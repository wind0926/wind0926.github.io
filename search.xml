<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>7种实现web实时消息推送的方案</title>
    <url>/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="7种实现web实时消息推送的方案"><a href="#7种实现web实时消息推送的方案" class="headerlink" title="7种实现web实时消息推送的方案"></a>7种实现web实时消息推送的方案</h1><p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/1.png" alt="图片"></p>
<h3 id="什么是消息推送（push）"><a href="#什么是消息推送（push）" class="headerlink" title="什么是消息推送（push）"></a><strong>什么是消息推送（push）</strong></h3><p>推送的场景比较多，比如有人关注我的公众号，这时我就会收到一条推送消息，以此来吸引我点击打开应用。</p>
<p>消息推送(push)通常是指网站的运营工作等人员，通过某种工具对用户当前网页或移动设备APP进行的主动消息推送。</p>
<p>消息推送一般又分为web端消息推送和移动端消息推送。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/2.png" alt="图片"></p>
<p>上边的这种属于移动端消息推送，web端消息推送常见的诸如站内信、未读邮件数量、监控报警数量等，应用的也非常广泛。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/3.png" alt="图片"></p>
<p>在具体实现之前，咱们再来分析一下前边的需求，其实功能很简单，只要触发某个事件（主动分享了资源或者后台主动推送消息），web页面的通知小红点就会实时的+1就可以了。</p>
<p>通常在服务端会有若干张消息推送表，用来记录用户触发不同事件所推送不同类型的消息，前端主动查询（拉）或者被动接收（推）用户所有未读的消息数。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/4.png" alt="图片"></p>
<p>消息推送无非是推（push）和拉（pull）两种形式，下边我们逐个了解下。</p>
<h3 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询"></a><strong>短轮询</strong></h3><hr>
<p>轮询(polling)应该是实现消息推送方案中最简单的一种，这里我们暂且将轮询分为短轮询和长轮询。</p>
<p>短轮询很好理解，指定的时间间隔，由浏览器向服务器发出HTTP请求，服务器实时返回未读消息数据给客户端，浏览器再做渲染显示。</p>
<p>一个简单的JS定时器就可以搞定，每秒钟请求一次未读消息数接口，返回的数据展示即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setInterval(() =&gt; &#123;</span><br><span class="line">  // 方法请求</span><br><span class="line">  messageCount().then((res) =&gt; &#123;</span><br><span class="line">      if (res.code === 200) &#123;</span><br><span class="line">          this.messageCount = res.data</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>



<p>效果还是可以的，短轮询实现固然简单，缺点也是显而易见，由于推送数据并不会频繁变更，无论后端此时是否有新的消息产生，客户端都会进行请求，势必会对服务端造成很大压力，浪费带宽和服务器资源。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/5.jpg" alt="图片"></p>
<h3 id><a href="#" class="headerlink" title></a></h3><h3 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a><strong>长轮询</strong></h3><hr>
<p>长轮询是对上边短轮询的一种改进版本，在尽可能减少对服务器资源浪费的同时，保证消息的相对实时性。长轮询在中间件中应用的很广泛，比如Nacos和apollo配置中心，消息队列kafka、RocketMQ中都有用到长轮询。</p>
<p>Nacos配置中心交互模型是push还是pull？一文中我详细介绍过Nacos长轮询的实现原理，感兴趣的小伙伴可以瞅瞅。</p>
<p>文章链接：<a href="https://mp.weixin.qq.com/s/94ftESkDoZI9gAGflLiGwg">https://mp.weixin.qq.com/s/94ftESkDoZI9gAGflLiGwg</a></p>
<p>这次我使用apollo配置中心实现长轮询的方式，应用了一个类DeferredResult，它是在servelet3.0后经过Spring封装提供的一种异步请求机制，直意就是延迟结果。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/6.png" alt="图片"></p>
<p>DeferredResult可以允许容器线程快速释放占用的资源，不阻塞请求线程，以此接受更多的请求提升系统的吞吐量，然后启动异步工作线程处理真正的业务逻辑，处理完成调用DeferredResult.setResult(200)提交响应结果。</p>
<p>下边我们用长轮询来实现消息推送。</p>
<p>因为一个ID可能会被多个长轮询请求监听，所以我采用了guava包提供的Multimap结构存放长轮询，一个key可以对应多个value。一旦监听到key发生变化，对应的所有长轮询都会响应。前端得到非请求超时的状态码，知晓数据变更，主动查询未读消息数接口，更新页面数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/polling&quot;)</span><br><span class="line">public class PollingController &#123;</span><br><span class="line"></span><br><span class="line">    // 存放监听某个Id的长轮询集合</span><br><span class="line">    // 线程同步结构</span><br><span class="line">    public static Multimap&lt;String, DeferredResult&lt;String&gt;&gt; watchRequests = Multimaps.synchronizedMultimap(HashMultimap.create());</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 公众号：程序员小富</span><br><span class="line">     * 设置监听</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(path = &quot;watch/&#123;id&#125;&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public DeferredResult&lt;String&gt; watch(@PathVariable String id) &#123;</span><br><span class="line">        // 延迟对象设置超时时间</span><br><span class="line">        DeferredResult&lt;String&gt; deferredResult = new DeferredResult&lt;&gt;(TIME_OUT);</span><br><span class="line">        // 异步请求完成时移除 key，防止内存溢出</span><br><span class="line">        deferredResult.onCompletion(() -&gt; &#123;</span><br><span class="line">            watchRequests.remove(id, deferredResult);</span><br><span class="line">        &#125;);</span><br><span class="line">        // 注册长轮询请求</span><br><span class="line">        watchRequests.put(id, deferredResult);</span><br><span class="line">        return deferredResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 公众号：程序员小富</span><br><span class="line">     * 变更数据</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(path = &quot;publish/&#123;id&#125;&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String publish(@PathVariable String id) &#123;</span><br><span class="line">        // 数据变更 取出监听ID的所有长轮询请求，并一一响应处理</span><br><span class="line">        if (watchRequests.containsKey(id)) &#123;</span><br><span class="line">            Collection&lt;DeferredResult&lt;String&gt;&gt; deferredResults = watchRequests.get(id);</span><br><span class="line">            for (DeferredResult&lt;String&gt; deferredResult : deferredResults) &#123;</span><br><span class="line">                deferredResult.setResult(&quot;我更新了&quot; + new Date());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>当请求超过设置的超时时间，会抛出AsyncRequestTimeoutException异常，这里直接用@ControllerAdvice全局捕获统一返回即可，前端获取约定好的状态码后再次发起长轮询请求，如此往复调用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ControllerAdvice</span><br><span class="line">public class AsyncRequestTimeoutHandler &#123;</span><br><span class="line"></span><br><span class="line">    @ResponseStatus(HttpStatus.NOT_MODIFIED)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    @ExceptionHandler(AsyncRequestTimeoutException.class)</span><br><span class="line">    public String asyncRequestTimeoutHandler(AsyncRequestTimeoutException e) &#123;</span><br><span class="line">        System.out.println(&quot;异步请求超时&quot;);</span><br><span class="line">        return &quot;304&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们来测试一下，首先页面发起长轮询请求&#x2F;polling&#x2F;watch&#x2F;10086监听消息更变，请求被挂起，不变更数据直至超时，再次发起了长轮询请求；紧接着手动变更数据&#x2F;polling&#x2F;publish&#x2F;10086，长轮询得到响应，前端处理业务逻辑完成后再次发起请求，如此循环往复。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/7.jpg" alt="图片"></p>
<p>长轮询相比于短轮询在性能上提升了很多，但依然会产生较多的请求，这是它的一点不完美的地方。</p>
<h3 id="iframe流"><a href="#iframe流" class="headerlink" title="iframe流"></a><strong>iframe流</strong></h3><hr>
<p>iframe流就是在页面中插入一个隐藏的<iframe>标签，通过在src中请求消息数量API接口，由此在服务端和客户端之间创建一条长连接，服务端持续向iframe传输数据。</iframe></p>
<p>传输的数据通常是HTML、或是内嵌的javascript脚本，来达到实时更新页面的效果。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/8.png" alt="图片"></p>
<p>这种方式实现简单，前端只要一个<iframe>标签搞定了。</iframe></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe src=&quot;/iframe/message&quot; style=&quot;display:none&quot;&gt;&lt;/iframe&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>服务端直接组装html、js脚本数据向response写入就行了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/iframe&quot;)</span><br><span class="line">public class IframeController &#123;</span><br><span class="line">    @GetMapping(path = &quot;message&quot;)</span><br><span class="line">    public void message(HttpServletResponse response) throws IOException, InterruptedException &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);</span><br><span class="line">            response.setDateHeader(&quot;Expires&quot;, 0);</span><br><span class="line">            response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache,no-store&quot;);</span><br><span class="line">            response.setStatus(HttpServletResponse.SC_OK);</span><br><span class="line">            response.getWriter().print(&quot; &lt;script type=\&quot;text/javascript\&quot;&gt;\n&quot; +</span><br><span class="line">                    &quot;parent.document.getElementById(&#x27;clock&#x27;).innerHTML = \&quot;&quot; + count.get() + &quot;\&quot;;&quot; +</span><br><span class="line">                    &quot;parent.document.getElementById(&#x27;count&#x27;).innerHTML = \&quot;&quot; + count.get() + &quot;\&quot;;&quot; +</span><br><span class="line">                    &quot;&lt;/script&gt;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>但我个人不推荐，因为它在浏览器上会显示请求未加载完，图标会不停旋转，简直是强迫症杀手。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/9.jpg" alt="图片"></p>
<h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><h3 id="SSE-我的方式"><a href="#SSE-我的方式" class="headerlink" title="SSE (我的方式)"></a><strong>SSE (我的方式)</strong></h3><hr>
<p>很多人可能不知道，服务端向客户端推送消息，其实除了可以用WebSocket这种耳熟能详的机制外，还有一种服务器发送事件(Server-sent events)，简称SSE。</p>
<p>SSE它是基于HTTP协议的，我们知道一般意义上的HTTP协议是无法做到服务端主动向客户端推送消息的，但SSE是个例外，它变换了一种思路。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/10.png" alt="图片"></p>
<p>SSE在服务器和客户端之间打开一个单向通道，服务端响应的不再是一次性的数据包而是text&#x2F;event-stream类型的数据流信息，在有数据变更时从服务器流式传输到客户端。</p>
<p>整体的实现思路有点类似于在线视频播放，视频流会连续不断的推送到浏览器，你也可以理解成，客户端在完成一次用时很长（网络不畅）的下载。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/11.png" alt="图片"></p>
<p>SSE与WebSocket作用相似，都可以建立服务端与浏览器之间的通信，实现服务端向客户端推送消息，但还是有些许不同：</p>
<ul>
<li>SSE 是基于HTTP协议的，它们不需要特殊的协议或服务器实现即可工作；WebSocket需单独服务器来处理协议。</li>
<li>SSE 单向通信，只能由服务端向客户端单向通信；webSocket全双工通信，即通信的双方可以同时发送和接受信息。</li>
<li>SSE 实现简单开发成本低，无需引入其他组件；WebSocket传输数据需做二次解析，开发门槛高一些。</li>
<li>SSE 默认支持断线重连；WebSocket则需要自己实现。</li>
<li>SSE 只能传送文本消息，二进制数据需要经过编码后传送；WebSocket默认支持传送二进制数据。</li>
</ul>
<p><strong>SSE 与 WebSocket 该如何选择？</strong></p>
<p>技术并没有好坏之分，只有哪个更合适。</p>
<p>SSE好像一直不被大家所熟知，一部分原因是出现了WebSockets，这个提供了更丰富的协议来执行双向、全双工通信。对于游戏、即时通信以及需要双向近乎实时更新的场景，拥有双向通道更具吸引力。</p>
<p>但是，在某些情况下，不需要从客户端发送数据。而你只需要一些服务器操作的更新。比如：站内信、未读消息数、状态更新、股票行情、监控数量等场景，SEE不管是从实现的难易和成本上都更加有优势。此外，SSE 具有WebSockets在设计上缺乏的多种功能，例如：自动重新连接、事件ID和发送任意事件的能力。</p>
<p>前端只需进行一次HTTP请求，带上唯一ID，打开事件流，监听服务端推送的事件就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    let source = null;</span><br><span class="line">    let userId = 7777</span><br><span class="line">    if (window.EventSource) &#123;</span><br><span class="line">        // 建立连接</span><br><span class="line">        source = new EventSource(&#x27;http://localhost:7777/sse/sub/&#x27;+userId);</span><br><span class="line">        setMessageInnerHTML(&quot;连接用户=&quot; + userId);</span><br><span class="line">        /**</span><br><span class="line">         * 连接一旦建立，就会触发open事件</span><br><span class="line">         * 另一种写法：source.onopen = function (event) &#123;&#125;</span><br><span class="line">         */</span><br><span class="line">        source.addEventListener(&#x27;open&#x27;, function (e) &#123;</span><br><span class="line">            setMessageInnerHTML(&quot;建立连接。。。&quot;);</span><br><span class="line">        &#125;, false);</span><br><span class="line">        /**</span><br><span class="line">         * 客户端收到服务器发来的数据</span><br><span class="line">         * 另一种写法：source.onmessage = function (event) &#123;&#125;</span><br><span class="line">         */</span><br><span class="line">        source.addEventListener(&#x27;message&#x27;, function (e) &#123;</span><br><span class="line">            setMessageInnerHTML(e.data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        setMessageInnerHTML(&quot;你的浏览器不支持SSE&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p>服务端的实现更简单，创建一个SseEmitter对象放入sseEmitterMap进行管理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static Map&lt;String, SseEmitter&gt; sseEmitterMap = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 创建连接</span><br><span class="line"> *</span><br><span class="line"> * @date: 2022/7/12 14:51</span><br><span class="line"> * @auther: 公众号：程序员小富</span><br><span class="line"> */</span><br><span class="line">public static SseEmitter connect(String userId) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 设置超时时间，0表示不过期。默认30秒</span><br><span class="line">        SseEmitter sseEmitter = new SseEmitter(0L);</span><br><span class="line">        // 注册回调</span><br><span class="line">        sseEmitter.onCompletion(completionCallBack(userId));</span><br><span class="line">        sseEmitter.onError(errorCallBack(userId));</span><br><span class="line">        sseEmitter.onTimeout(timeoutCallBack(userId));</span><br><span class="line">        sseEmitterMap.put(userId, sseEmitter);</span><br><span class="line">        count.getAndIncrement();</span><br><span class="line">        return sseEmitter;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        log.info(&quot;创建新的sse连接异常，当前用户：&#123;&#125;&quot;, userId);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 给指定用户发送消息</span><br><span class="line"> *</span><br><span class="line"> * @date: 2022/7/12 14:51</span><br><span class="line"> * @auther: 公众号：程序员小富</span><br><span class="line"> */</span><br><span class="line">public static void sendMessage(String userId, String message) &#123;</span><br><span class="line"></span><br><span class="line">    if (sseEmitterMap.containsKey(userId)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            sseEmitterMap.get(userId).send(message);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            log.error(&quot;用户[&#123;&#125;]推送异常:&#123;&#125;&quot;, userId, e.getMessage());</span><br><span class="line">            removeUser(userId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们模拟服务端推送消息，看下客户端收到了消息，和我们预期的效果一致。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/12.jpg" alt="图片"></p>
<p>注意： SSE不支持IE浏览器，对其他主流浏览器兼容性做的还不错。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/13.png" alt="图片"></p>
<h3 id="-2"><a href="#-2" class="headerlink" title></a></h3><h3 id="MQTT"><a href="#MQTT" class="headerlink" title="MQTT"></a><strong>MQTT</strong></h3><hr>
<p>什么是 MQTT协议？</p>
<p>MQTT 全称(Message Queue Telemetry Transport)：一种基于发布&#x2F;订阅（publish&#x2F;subscribe）模式的轻量级通讯协议，通过订阅相应的主题来获取消息，是物联网（Internet of Thing）中的一个标准传输协议。</p>
<p>该协议将消息的发布者（publisher）与订阅者（subscriber）进行分离，因此可以在不可靠的网络环境中，为远程连接的设备提供可靠的消息服务，使用方式与传统的MQ有点类似。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/14.png" alt="图片"></p>
<p>TCP协议位于传输层，MQTT 协议位于应用层，MQTT 协议构建于TCP&#x2F;IP协议上，也就是说只要支持TCP&#x2F;IP协议栈的地方，都可以使用MQTT协议。</p>
<p><strong>为什么要用 MQTT协议？</strong></p>
<p>MQTT协议为什么在物联网（IOT）中如此受偏爱？而不是其它协议，比如我们更为熟悉的 HTTP协议呢？</p>
<ul>
<li>首先HTTP协议它是一种同步协议，客户端请求后需要等待服务器的响应。而在物联网（IOT）环境中，设备会很受制于环境的影响，比如带宽低、网络延迟高、网络通信不稳定等，显然异步消息协议更为适合IOT应用程序。</li>
<li>HTTP是单向的，如果要获取消息客户端必须发起连接，而在物联网（IOT）应用程序中，设备或传感器往往都是客户端，这意味着它们无法被动地接收来自网络的命令。</li>
<li>通常需要将一条命令或者消息，发送到网络上的所有设备上。HTTP要实现这样的功能不但很困难，而且成本极高。</li>
</ul>
<p>具体的MQTT协议介绍和实践，这里我就不再赘述了，大家可以参考我之前的两篇文章，里边写的也都很详细了。</p>
<p>MQTT协议的介绍：<a href="https://mp.weixin.qq.com/s/udFE6k9pPetIWsa6KeErrA">https://mp.weixin.qq.com/s/udFE6k9pPetIWsa6KeErrA</a></p>
<p>MQTT实现消息推送：<a href="https://mp.weixin.qq.com/s/U-fUGr9i1MVa4PoVyiDFCg">https://mp.weixin.qq.com/s/U-fUGr9i1MVa4PoVyiDFCg</a></p>
<h3 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a><strong>Websocket</strong></h3><hr>
<p>websocket应该是大家都比较熟悉的一种实现消息推送的方式，上边我们在讲SSE的时候也和websocket进行过比较。</p>
<p>WebSocket是一种在TCP连接上进行全双工通信的协议，建立客户端和服务器之间的通信渠道。浏览器和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/15.png" alt="图片"></p>
<p>springboot整合websocket，先引入websocket相关的工具包，和SSE相比额外的开发成本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 引入websocket --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>





<p>服务端使用@ServerEndpoint注解标注当前类为一个websocket服务器，客户端可以通过ws:&#x2F;&#x2F;localhost:7777&#x2F;webSocket&#x2F;10086来连接到WebSocket服务器端。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">@ServerEndpoint(&quot;/websocket/&#123;userId&#125;&quot;)</span><br><span class="line">public class WebSocketServer &#123;</span><br><span class="line">    //与某个客户端的连接会话，需要通过它来给客户端发送数据</span><br><span class="line">    private Session session;</span><br><span class="line">    private static final CopyOnWriteArraySet&lt;WebSocketServer&gt; webSockets = new CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line">    // 用来存在线连接数</span><br><span class="line">    private static final Map&lt;String, Session&gt; sessionPool = new HashMap&lt;String, Session&gt;();</span><br><span class="line">    /**</span><br><span class="line">     * 公众号：程序员小富</span><br><span class="line">     * 链接成功调用的方法</span><br><span class="line">     */</span><br><span class="line">    @OnOpen</span><br><span class="line">    public void onOpen(Session session, @PathParam(value = &quot;userId&quot;) String userId) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.session = session;</span><br><span class="line">            webSockets.add(this);</span><br><span class="line">            sessionPool.put(userId, session);</span><br><span class="line">            log.info(&quot;websocket消息: 有新的连接，总数为:&quot; + webSockets.size());</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 公众号：程序员小富</span><br><span class="line">     * 收到客户端消息后调用的方法</span><br><span class="line">     */</span><br><span class="line">    @OnMessage</span><br><span class="line">    public void onMessage(String message) &#123;</span><br><span class="line">        log.info(&quot;websocket消息: 收到客户端消息:&quot; + message);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 公众号：程序员小富</span><br><span class="line">     * 此为单点消息</span><br><span class="line">     */</span><br><span class="line">    public void sendOneMessage(String userId, String message) &#123;</span><br><span class="line">        Session session = sessionPool.get(userId);</span><br><span class="line">        if (session != null &amp;&amp; session.isOpen()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                log.info(&quot;websocket消: 单点消息:&quot; + message);</span><br><span class="line">                session.getAsyncRemote().sendText(message);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>前端初始化打开WebSocket连接，并监听连接状态，接收服务端数据或向服务端发送数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var ws = new WebSocket(&#x27;ws://localhost:7777/webSocket/10086&#x27;);</span><br><span class="line">    // 获取连接状态</span><br><span class="line">    console.log(&#x27;ws连接状态：&#x27; + ws.readyState);</span><br><span class="line">    //监听是否连接成功</span><br><span class="line">    ws.onopen = function () &#123;</span><br><span class="line">        console.log(&#x27;ws连接状态：&#x27; + ws.readyState);</span><br><span class="line">        //连接成功则发送一个数据</span><br><span class="line">        ws.send(&#x27;test1&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 接听服务器发回的信息并处理展示</span><br><span class="line">    ws.onmessage = function (data) &#123;</span><br><span class="line">        console.log(&#x27;接收到来自服务器的消息：&#x27;);</span><br><span class="line">        console.log(data);</span><br><span class="line">        //完成通信后关闭WebSocket连接</span><br><span class="line">        ws.close();</span><br><span class="line">    &#125;</span><br><span class="line">    // 监听连接关闭事件</span><br><span class="line">    ws.onclose = function () &#123;</span><br><span class="line">        // 监听整个过程中websocket的状态</span><br><span class="line">        console.log(&#x27;ws连接状态：&#x27; + ws.readyState);</span><br><span class="line">    &#125;</span><br><span class="line">    // 监听并处理error事件</span><br><span class="line">    ws.onerror = function (error) &#123;</span><br><span class="line">        console.log(error);</span><br><span class="line">    &#125;</span><br><span class="line">    function sendMessage() &#123;</span><br><span class="line">        var content = $(&quot;#message&quot;).val();</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: &#x27;/socket/publish?userId=10086&amp;message=&#x27; + content,</span><br><span class="line">            type: &#x27;GET&#x27;,</span><br><span class="line">            data: &#123; &quot;id&quot;: &quot;7777&quot;, &quot;content&quot;: content &#125;,</span><br><span class="line">            success: function (data) &#123;</span><br><span class="line">                console.log(data)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>





<p>页面初始化建立websocket连接，之后就可以进行双向通信了，效果还不错。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/20.png" alt="图片"></p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/16.jpg" alt="图片"></p>
<h3 id="-3"><a href="#-3" class="headerlink" title></a></h3><h3 id="自定义推送"><a href="#自定义推送" class="headerlink" title="自定义推送"></a><strong>自定义推送</strong></h3><hr>
<p>上边我们给我出了6种方案的原理和代码实现，但在实际业务开发过程中，不能盲目的直接拿过来用，还是要结合自身系统业务的特点和实际场景来选择合适的方案。</p>
<p>推送最直接的方式就是使用第三推送平台，毕竟钱能解决的需求都不是问题，无需复杂的开发运维，直接可以使用，省时、省力、省心，像goEasy、极光推送都是很不错的三方服务商。</p>
<p>一般大型公司都有自研的消息推送平台，像我们本次实现的web站内信只是平台上的一个触点而已，短信、邮件、微信公众号、小程序凡是可以触达到用户的渠道都可以接入进来。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/17.png" alt="图片"></p>
<p>消息推送系统内部是相当复杂的，诸如消息内容的维护审核、圈定推送人群、触达过滤拦截（推送的规则频次、时段、数量、黑白名单、关键词等等）、推送失败补偿非常多的模块，技术上涉及到大数据量、高并发的场景也很多。所以我们今天的实现方式在这个庞大的系统面前只是小打小闹。</p>
<h3 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a><strong>Github地址</strong></h3><hr>
<p>文中所提到的案例我都一一的做了实现，整理放在了Github上，觉得有用就 Star 一下吧！</p>
<p>传送门：<a href="https://github.com/chengxy-nds/Springboot-Notebook/tree/master/springboot-realtime-data">https://github.com/chengxy-nds/Springboot-Notebook/tree/master/springboot-realtime-data</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>DDD-如何避免写流水账代码</title>
    <url>/2022/10/24/DDD-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%99%E6%B5%81%E6%B0%B4%E8%B4%A6%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h1 id="1-案例简介"><a href="#1-案例简介" class="headerlink" title="1. 案例简介"></a>1. 案例简介</h1><p>这里举一个简单的常见案例：下单链路。假设我们在做一个checkout接口，需要做各种校验、查询商品信息、调用库存服务扣库存、然后生成订单：</p>
<p><img src="/2022/10/24/DDD-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%99%E6%B5%81%E6%B0%B4%E8%B4%A6%E4%BB%A3%E7%A0%81/1.png" alt="image.png"></p>
<p>一个比较典型的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckoutController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ItemService itemService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> InventoryService inventoryService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OrderRepository orderRepository;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;checkout&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;OrderDO&gt; <span class="title function_">checkout</span><span class="params">(Long itemId, Integer quantity)</span> &#123;</span><br><span class="line">        <span class="comment">// 1) Session管理</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> SessionUtils.getLoggedInUserId();</span><br><span class="line">        <span class="keyword">if</span> (userId &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;Not Logged In&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="comment">// 2）参数校验</span></span><br><span class="line">        <span class="keyword">if</span> (itemId &lt;= <span class="number">0</span> || quantity &lt;= <span class="number">0</span> || quantity &gt;= <span class="number">1000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;Invalid Args&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3）外部数据补全</span></span><br><span class="line">        <span class="type">ItemDO</span> <span class="variable">item</span> <span class="operator">=</span> itemService.getItem(itemId);</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;Item Not Found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4）调用外部服务</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">withholdSuccess</span> <span class="operator">=</span> inventoryService.withhold(itemId, quantity);</span><br><span class="line">        <span class="keyword">if</span> (!withholdSuccess) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;Inventory not enough&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 5）领域计算</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">cost</span> <span class="operator">=</span> item.getPriceInCents() * quantity;</span><br><span class="line">        <span class="comment">// 6）领域对象操作</span></span><br><span class="line">        <span class="type">OrderDO</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderDO</span>();</span><br><span class="line">        order.setItemId(itemId);</span><br><span class="line">        order.setBuyerId(userId);</span><br><span class="line">        order.setSellerId(item.getSellerId());</span><br><span class="line">        order.setCount(quantity);</span><br><span class="line">        order.setTotalCost(cost);</span><br><span class="line">        <span class="comment">// 7）数据持久化</span></span><br><span class="line">        orderRepository.createOrder(order);</span><br><span class="line">        <span class="comment">// 8）返回</span></span><br><span class="line">        <span class="keyword">return</span> Result.success(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么这种典型的流水账代码在实际应用中会有问题呢？其本质问题是违背了SRP（Single Responsbility Principle）单一职责原则。这段代码里混杂了业务计算、校验逻辑、基础设施、和通信协议等，在未来无论哪一部分的逻辑变更都会直接影响到这段代码，长期当后人不断的在上面叠加新的逻辑时，会造成代码复杂度增加、逻辑分支越来越多，最终造成bug或者没人敢重构的历史包袱。</p>
<p>所以我们才需要用DDD的分层思想去重构一下以上的代码，通过不同的代码分层和规范，拆分出逻辑清晰，职责明确的分层和模块，也便于一些通用能力的沉淀。</p>
<p>主要的几个步骤分为：</p>
<ol>
<li>分离出独立的Interface接口层，负责处理网络协议相关的逻辑</li>
<li>从真实业务场景中，找出具体用例（Use Cases），然后将具体用例通过专用的Command指令、Query查询、和Event事件对象来承接</li>
<li>分离出独立的Application应用层，负责业务流程的编排，响应Command、Query和Event。每个应用层的方法应该代表整个业务流程中的一个节点</li>
<li>处理一些跨层的横切关注点，如鉴权、异常处理、校验、缓存、日志等</li>
</ol>
<p>下面会针对每个点做详细的解释。</p>
<h1 id="2-Interface接口层"><a href="#2-Interface接口层" class="headerlink" title="2. Interface接口层"></a>2. Interface接口层</h1><p>随着REST和MVC架构的普及，经常能看到开发同学直接在Controller中写业务逻辑，如上面的典型案例，但实际上MVC Controller不是唯一的重灾区。以下的几种常见的代码写法通常都可能包含了同样的问题：</p>
<ul>
<li>HTTP 框架：如Spring MVC框架，Spring Cloud等</li>
<li>RPC 框架：如Dubbo、HSF、gRPC等</li>
<li>消息队列MQ的“消费者”：比如JMS的 onMessage，RocketMQ的MessageListener等</li>
<li>Socket通信：Socket通信的receive、WebSocket的onMessage等</li>
<li>文件系统：WatcherService等</li>
<li>分布式任务调度：SchedulerX等</li>
</ul>
<p>这些的方法都有一个共同的点就是都有自己的网络协议，而如果我们的业务代码和网络协议混杂在一起，则会直接导致代码跟网络协议绑定，无法被复用。</p>
<p>所以，在DDD的分层架构中，我们单独会抽取出来Interface接口层，作为所有对外的门户，将网络协议和业务逻辑解耦。</p>
<h2 id="2-1-接口层的组成"><a href="#2-1-接口层的组成" class="headerlink" title="2.1 接口层的组成"></a>2.1 接口层的组成</h2><p>接口层主要由以下几个功能组成：</p>
<ol>
<li>网络协议的转化：通常这个已经由各种框架给封装掉了，我们需要构建的类要么是被注解的bean，要么是继承了某个接口的bean。</li>
<li>统一鉴权：比如在一些需要AppKey+Secret的场景，需要针对某个租户做鉴权的，包括一些加密串的校验</li>
<li>Session管理：一般在面向用户的接口或者有登陆态的，通过Session或者RPC上下文可以拿到当前调用的用户，以便传递给下游服务。</li>
<li>限流配置：对接口做限流避免大流量打到下游服务</li>
<li>前置缓存：针对变更不是很频繁的只读场景，可以前置结果缓存到接口层</li>
<li>异常处理：通常在接口层要避免将异常直接暴露给调用端，所以需要在接口层做统一的异常捕获，转化为调用端可以理解的数据格式</li>
<li>日志：在接口层打调用日志，用来做统计和debug等。一般微服务框架可能都直接包含了这些功能。</li>
</ol>
<p>当然，如果有一个独立的网关设施&#x2F;应用，则可以抽离出鉴权、Session、限流、日志等逻辑，但是目前来看API网关也只能解决一部分的功能，即使在有API网关的场景下，应用里独立的接口层还是有必要的。</p>
<p>在interface层，鉴权、Session、限流、缓存、日志等都比较直接，只有一个异常处理的点需要重点说下。</p>
<h2 id="2-2-返回值和异常处理规范，Result-vs-Exception"><a href="#2-2-返回值和异常处理规范，Result-vs-Exception" class="headerlink" title="2.2 返回值和异常处理规范，Result vs Exception"></a>2.2 返回值和异常处理规范，Result vs Exception</h2><p><em>注：这部分主要还是面向REST和RPC接口，其他的协议需要根据协议的规范产生返回值。</em></p>
<p>在我见过的一些代码里，接口的返回值比较多样化，有些直接返回DTO甚至DO，另一些返回Result。</p>
<p>接口层的核心价值是对外，所以如果只是返回DTO或DO会不可避免的面临异常和错误栈泄漏到使用方的情况，包括错误栈被序列化反序列化的消耗。所以，这里提出一个规范：</p>
<blockquote>
<p>规范：Interface层的HTTP和RPC接口，返回值为Result，捕捉所有异常</p>
<p>规范：Application层的所有接口返回值为DTO，不负责处理异常</p>
</blockquote>
<p>Application层的具体规范等下再讲，在这里先展示Interface层的逻辑。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;checkout&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;OrderDTO&gt; <span class="title function_">checkout</span><span class="params">(Long itemId, Integer quantity)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="type">CheckoutCommand</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CheckoutCommand</span>();</span><br><span class="line">                <span class="type">OrderDTO</span> <span class="variable">orderDTO</span> <span class="operator">=</span> checkoutService.checkout(cmd);    </span><br><span class="line">                <span class="keyword">return</span> Result.success(orderDTO);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ConstraintViolationException cve) &#123;</span><br><span class="line">        <span class="comment">// 捕捉一些特殊异常，比如Validation异常</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(cve.getMessage());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 兜底异常捕获</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，每个接口都要写异常处理逻辑会比较烦，所以可以用AOP做个注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ResultHandler &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResultAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(ResultHandler)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">logExecutionTime</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            proceed = joinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ConstraintViolationException cve) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(cve.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后最终代码则简化为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;checkout&quot;)</span></span><br><span class="line"><span class="meta">@ResultHandler</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;OrderDTO&gt; <span class="title function_">checkout</span><span class="params">(Long itemId, Integer quantity)</span> &#123;</span><br><span class="line">    <span class="type">CheckoutCommand</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CheckoutCommand</span>();</span><br><span class="line">    <span class="type">OrderDTO</span> <span class="variable">orderDTO</span> <span class="operator">=</span> checkoutService.checkout(cmd);</span><br><span class="line">    <span class="keyword">return</span> Result.success(orderDTO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-接口层的接口的数量和业务间的隔离"><a href="#2-3-接口层的接口的数量和业务间的隔离" class="headerlink" title="2.3 接口层的接口的数量和业务间的隔离"></a>2.3 接口层的接口的数量和业务间的隔离</h2><p>在传统REST和RPC的接口规范中，通常一个领域的接口，无论是REST的Resource资源的GET&#x2F;POST&#x2F;DELETE，还是RPC的方法，是<strong>追求相对固定的，统一的</strong>，而且会追求统一个领域的方法放在一个领域的服务或Controller中。</p>
<p>但是我发现在实际做业务的过程中，特别是当支撑的上游业务比较多时，刻意去追求接口的统一通常会导致方法中的参数膨胀，或者导致方法的膨胀。举个例子：假设有一个宠物卡和一个亲子卡的业务公用一个开卡服务，但是宠物需要传入宠物类型，亲子的需要传入宝宝年龄。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以是RPC Provider 或者 Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CardService</span> &#123;</span><br><span class="line">    <span class="comment">// 1）统一接口，参数膨胀</span></span><br><span class="line">    Result <span class="title function_">openCard</span><span class="params">(<span class="type">int</span> petType, <span class="type">int</span> babyAge)</span>;</span><br><span class="line">    <span class="comment">// 2）统一泛化接口，参数语意丢失</span></span><br><span class="line">    Result <span class="title function_">openCardV2</span><span class="params">(Map&lt;String, Object&gt; params)</span>;</span><br><span class="line">    <span class="comment">// 3）不泛化，同一个类里的接口膨胀</span></span><br><span class="line">    Result <span class="title function_">openPetCard</span><span class="params">(<span class="type">int</span> petType)</span>;</span><br><span class="line">    Result <span class="title function_">openBabyCard</span><span class="params">(<span class="type">int</span> babyAge)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出来，无论是怎么操作，都有可能导致CardService这个服务未来越来越难以维护，方法越来越多，一个业务的变更有可能会导致整个服务&#x2F;Controller的变更，最终变得无法维护。我曾经参与过的一个服务，提供了几十个方法，上万行代码，可想而知无论是使用方对接口的理解成本还是对代码的维护成本都是极高的。</p>
<p>所以，这里提出另一个规范：</p>
<blockquote>
<p>规范：一个Interface层的类应该是“小而美”的，应该是面向“一个单一的业务”或“一类同样需求的业务”，需要尽量避免用同一个类承接不同类型业务的需求。</p>
</blockquote>
<p>基于上面的这个规范，可以发现宠物卡和亲子卡虽然看起来像是类似的需求，但并非是“同样需求”的，可以预见到在未来的某个时刻，这两个业务的需求和需要提供的接口会越走越远，所以需要将这两个接口类拆分开：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PetCardService</span> &#123;</span><br><span class="line">    Result <span class="title function_">openPetCard</span><span class="params">(<span class="type">int</span> petType)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BabyCardService</span> &#123;</span><br><span class="line">    Result <span class="title function_">openBabyCard</span><span class="params">(<span class="type">int</span> babyAge)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个的好处是符合了Single Responsibility Principle单一职责原则，也就是说一个接口类仅仅会因为一个（或一类）业务的变化而变化。<strong>一个建议是当一个现有的接口类过度膨胀时，可以考虑对接口类做拆分，拆分原则和SRP一致。</strong></p>
<p>也许会有人问，如果按照这种做法，会不会产生大量的接口类，导致代码逻辑重复？答案是不会，因为在DDD分层架构里，接口类的核心作用仅仅是协议层，每类业务的协议可以是不同的，而真实的业务逻辑会沉淀到应用层。也就是说Interface和Application的关系是多对多的：</p>
<p><img src="/2022/10/24/DDD-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%99%E6%B5%81%E6%B0%B4%E8%B4%A6%E4%BB%A3%E7%A0%81/2.png" alt="image.png"></p>
<p>因为业务需求是快速变化的，所以接口层也要跟着快速变化，通过独立的接口层可以避免业务间相互影响，但我们希望相对稳定的是Application层的逻辑。所以我们接下来看一下Application层的一些规范。</p>
<h1 id="3-Application层"><a href="#3-Application层" class="headerlink" title="3. Application层"></a>3. Application层</h1><h2 id="3-1-Application层的组成部分"><a href="#3-1-Application层的组成部分" class="headerlink" title="3.1 Application层的组成部分"></a>3.1 Application层的组成部分</h2><p>Application层的几个核心类：</p>
<ul>
<li>ApplicationService应用服务：最核心的类，负责业务流程的编排，但本身不负责任何业务逻辑</li>
<li>DTO Assembler：负责将内部领域模型转化为可对外的DTO</li>
<li>Command、Query、Event对象：作为ApplicationService的入参</li>
<li>返回的DTO：作为ApplicationService的出参</li>
</ul>
<p>Application层最核心的对象是ApplicationService，它的核心功能是承接“业务流程“。但是在讲ApplicationService的规范之前，必须要先重点的讲几个特殊类型的对象，即Command、Query和Event。</p>
<h2 id="3-2-Command、Query、Event对象"><a href="#3-2-Command、Query、Event对象" class="headerlink" title="3.2 Command、Query、Event对象"></a>3.2 Command、Query、Event对象</h2><p>从本质上来看，这几种对象都是Value Object，但是从语义上来看有比较大的差异：</p>
<ul>
<li>Command指令：指调用方明确想让系统操作的指令，其预期是对一个系统有影响，也就是写操作。通常来讲指令需要有一个明确的返回值（如同步的操作结果，或异步的指令已经被接受）。</li>
<li>Query查询：指调用方明确想查询的东西，包括查询参数、过滤、分页等条件，其预期是对一个系统的数据完全不影响的，也就是只读操作。</li>
<li>Event事件：指一件已经发生过的既有事实，需要系统根据这个事实作出改变或者响应的，通常事件处理都会有一定的写操作。事件处理器不会有返回值。这里需要注意一下的是，Application层的Event概念和Domain层的DomainEvent是类似的概念，但不一定是同一回事，这里的Event更多是外部一种通知机制而已。</li>
</ul>
<p>简单总结下：</p>
<table>
<thead>
<tr>
<th></th>
<th>Command</th>
<th>Query</th>
<th>Event</th>
</tr>
</thead>
<tbody><tr>
<td>语意</td>
<td>”希望“能触发的操作</td>
<td>各种条件的查询</td>
<td>已经发生过的事情</td>
</tr>
<tr>
<td>读&#x2F;写</td>
<td>写</td>
<td>只读</td>
<td>通常是写</td>
</tr>
<tr>
<td>返回值</td>
<td>DTO 或 Boolean</td>
<td>DTO 或 Collection</td>
<td>Void</td>
</tr>
</tbody></table>
<p><strong>为什么要用CQE对象？</strong></p>
<p>通常在很多代码里，能看到接口上有多个参数，比如上文中的案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Result&lt;OrderDO&gt; <span class="title function_">checkout</span><span class="params">(Long itemId, Integer quantity)</span>;</span><br></pre></td></tr></table></figure>

<p>如果需要在接口上增加参数，考虑到向前兼容，则需要增加一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Result&lt;OrderDO&gt; <span class="title function_">checkout</span><span class="params">(Long itemId, Integer quantity)</span>;</span><br><span class="line">Result&lt;OrderDO&gt; <span class="title function_">checkout</span><span class="params">(Long itemId, Integer quantity, Integer channel)</span>;</span><br></pre></td></tr></table></figure>

<p>或者常见的查询方法，由于条件的不同导致多个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;OrderDO&gt; <span class="title function_">queryByItemId</span><span class="params">(Long itemId)</span>;</span><br><span class="line">List&lt;OrderDO&gt; <span class="title function_">queryBySellerId</span><span class="params">(Long sellerId)</span>;</span><br><span class="line">List&lt;OrderDO&gt; <span class="title function_">queryBySellerIdWithPage</span><span class="params">(Long sellerId, <span class="type">int</span> currentPage, <span class="type">int</span> pageSize)</span>;</span><br></pre></td></tr></table></figure>



<p>可以看出来，传统的接口写法有几个问题：</p>
<ol>
<li>接口膨胀：一个查询条件一个方法</li>
<li>难以扩展：每新增一个参数都有可能需要调用方升级</li>
<li>难以测试：接口一多，职责随之变得繁杂，业务场景各异，测试用例难以维护</li>
</ol>
<p>但是另外一个最重要的问题是：这种类型的参数罗列，本身没有任何业务上的”语意“，只是一堆参数而已，无法明确的表达出来意图。</p>
<p><strong>CQE的规范：</strong></p>
<p>所以在Application层的接口里，强力建议的一个规范是：</p>
<blockquote>
<p>规范：ApplicationService的接口入参只能是一个Command、Query或Event对象，CQE对象需要能代表当前方法的语意。唯一可以的例外是根据单一ID查询的情况，可以省略掉一个Query对象的创建</p>
</blockquote>
<p>按照上面的规范，实现案例是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CheckoutService</span> &#123;</span><br><span class="line">    OrderDTO <span class="title function_">checkout</span><span class="params">(<span class="meta">@Valid</span> CheckoutCommand cmd)</span>;</span><br><span class="line">    List&lt;OrderDTO&gt; <span class="title function_">query</span><span class="params">(OrderQuery query)</span>;</span><br><span class="line">    OrderDTO <span class="title function_">getOrder</span><span class="params">(Long orderId)</span>; <span class="comment">// 注意单一ID查询可以不用Query</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckoutCommand</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line">    <span class="keyword">private</span> Long itemId;</span><br><span class="line">    <span class="keyword">private</span> Integer quantity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderQuery</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long sellerId;</span><br><span class="line">    <span class="keyword">private</span> Long itemId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> currentPage;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> pageSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个规范的好处是：提升了接口的稳定性、降低低级的重复，并且让接口入参更加语意化。</p>
<p><strong>CQE vs DTO</strong></p>
<p>从上面的代码能看出来，ApplicationService的入参是CQE对象，但是出参却是一个DTO，从代码格式上来看都是简单的POJO对象，那么他们之间有什么区别呢？</p>
<ul>
<li>CQE：CQE对象是ApplicationService的输入，是有明确的”意图“的，所以这个对象必须保证其”正确性“。</li>
<li>DTO：DTO对象只是数据容器，只是为了和外部交互，所以本身不包含任何逻辑，只是贫血对象。</li>
</ul>
<p>但可能最重要的一点：因为CQE是”意图“，所以CQE对象在理论上可以有”无限“个，每个代表不同的意图；但是DTO作为模型数据容器，和模型一一对应，所以是有限的。</p>
<p><strong>CQE的校验</strong></p>
<p>CQE作为ApplicationService的输入，必须保证其正确性，那么这个校验是放在哪里呢？</p>
<p>在最早的代码里，曾经有这样的校验逻辑，当时写在了服务里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (itemId &lt;= <span class="number">0</span> || quantity &lt;= <span class="number">0</span> || quantity &gt;= <span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;Invalid Args&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种代码在日常非常常见，但其最大的问题就是大量的非业务代码混杂在业务代码中，很明显的违背了单一职责原则。但因为当时入参仅仅是简单的int，所以这个逻辑只能出现在服务里。现在当入参改为了CQE之后，我们可以利用java标准JSR303或JSR380的Bean Validation来前置这个校验逻辑。</p>
<blockquote>
<p>规范：CQE对象的校验应该前置，避免在ApplicationService里做参数的校验。可以通过JSR303&#x2F;380和Spring Validation来实现</p>
</blockquote>
<p>前面的例子可以改造为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Validated</span> <span class="comment">// Spring的注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckoutServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">CheckoutService</span> &#123;</span><br><span class="line">    OrderDTO <span class="title function_">checkout</span><span class="params">(<span class="meta">@Valid</span> CheckoutCommand cmd)</span> &#123; <span class="comment">// 这里@Valid是JSR-303/380的注解</span></span><br><span class="line">        <span class="comment">// 如果校验失败会抛异常，在interface层被捕捉</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckoutCommand</span> &#123;</span><br><span class="line">    <span class="meta">@NotNull(message = &quot;用户未登陆&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Positive(message = &quot;需要是合法的itemId&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long itemId;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Min(value = 1, message = &quot;最少1件&quot;)</span></span><br><span class="line">    <span class="meta">@Max(value = 1000, message = &quot;最多不能超过1000件&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer quantity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种做法的好处是，让ApplicationService更加清爽，同时各种错误信息可以通过Bean Validation的API做各种个性化定制。</p>
<p><strong>避免复用CQE</strong></p>
<p>因为CQE是有“意图”和“语意”的，我们需要尽量避免CQE对象的复用，哪怕所有的参数都一样，只要他们的语意不同，尽量还是要用不同的对象。</p>
<blockquote>
<p>规范：针对于不同语意的指令，要避免CQE对象的复用</p>
</blockquote>
<p>❌ 反例：一个常见的场景是“Create创建”和“Update更新”，一般来说这两种类型的对象唯一的区别是一个ID，创建没有ID，而更新则有。所以经常能看见有的同学用同一个对象来作为两个方法的入参，唯一区别是ID是否赋值。这个是错误的用法，因为这两个操作的语意完全不一样，他们的校验条件可能也完全不一样，所以不应该复用同一个对象。正确的做法是产出两个对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CheckoutService</span> &#123;</span><br><span class="line">    OrderDTO <span class="title function_">checkout</span><span class="params">(<span class="meta">@Valid</span> CheckoutCommand cmd)</span>;</span><br><span class="line">    OrderDTO <span class="title function_">updateOrder</span><span class="params">(<span class="meta">@Valid</span> UpdateOrderCommand cmd)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UpdateOrderCommand</span> &#123;</span><br><span class="line">    <span class="meta">@NotNull(message = &quot;用户未登陆&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line">    <span class="meta">@NotNull(message = &quot;必须要有OrderID&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long orderId;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Positive(message = &quot;需要是合法的itemId&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long itemId;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Min(value = 1, message = &quot;最少1件&quot;)</span></span><br><span class="line">    <span class="meta">@Max(value = 1000, message = &quot;最多不能超过1000件&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer quantity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-ApplicationService"><a href="#3-3-ApplicationService" class="headerlink" title="3.3 ApplicationService"></a>3.3 ApplicationService</h2><p>ApplicationService负责了业务流程的编排，是将原有业务流水账代码剥离了校验逻辑、领域计算、持久化等逻辑之后剩余的流程，是“胶水层”代码。</p>
<p>参考一个简易的交易流程：</p>
<p><img src="/2022/10/24/DDD-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%99%E6%B5%81%E6%B0%B4%E8%B4%A6%E4%BB%A3%E7%A0%81/3.png" alt="image.png"></p>
<p>在这个案例里可以看出来，交易这个领域一共有5个用例：下单、支付成功、支付失败关单、物流信息更新、关闭订单。这5个用例可以用5个Command&#x2F;Event对象代替，也就是对应了5个方法。</p>
<p>我见过3种ApplicationService的组织形态：</p>
<ol>
<li>一个ApplicationService类是一个完整的业务流程，其中每个方法负责处理一个Use Case。这种的好处是可以完整的收敛整个业务逻辑，从接口类即可对业务逻辑有一定的掌握，适合相对简单的业务流程。坏处就是对于复杂的业务流程会导致一个类的方法过多，有可能代码量过大。这种类型的具体案例如：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CheckoutService</span> &#123;</span><br><span class="line">    <span class="comment">// 下单</span></span><br><span class="line">    OrderDTO <span class="title function_">checkout</span><span class="params">(<span class="meta">@Valid</span> CheckoutCommand cmd)</span>;</span><br><span class="line">    <span class="comment">// 支付成功</span></span><br><span class="line">    OrderDTO <span class="title function_">payReceived</span><span class="params">(<span class="meta">@Valid</span> PaymentReceivedEvent event)</span>;</span><br><span class="line">    <span class="comment">// 支付取消</span></span><br><span class="line">    OrderDTO <span class="title function_">payCanceled</span><span class="params">(<span class="meta">@Valid</span> PaymentCanceledEvent event)</span>;</span><br><span class="line">    <span class="comment">// 发货</span></span><br><span class="line">    OrderDTO <span class="title function_">packageSent</span><span class="params">(<span class="meta">@Valid</span> PackageSentEvent event)</span>;</span><br><span class="line">    <span class="comment">// 收货</span></span><br><span class="line">    OrderDTO <span class="title function_">delivered</span><span class="params">(<span class="meta">@Valid</span> DeliveredEvent event)</span>;</span><br><span class="line">    <span class="comment">// 批量查询</span></span><br><span class="line">    List&lt;OrderDTO&gt; <span class="title function_">query</span><span class="params">(OrderQuery query)</span>;</span><br><span class="line">    <span class="comment">// 单个查询</span></span><br><span class="line">    OrderDTO <span class="title function_">getOrder</span><span class="params">(Long orderId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>针对于比较复杂的业务流程，可以通过增加独立的CommandHandler、EventHandler来降低一个类中的代码量：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckoutCommandHandler</span> <span class="keyword">implements</span> <span class="title class_">CommandHandler</span>&lt;CheckoutCommand, OrderDTO&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> OrderDTO <span class="title function_">handle</span><span class="params">(CheckoutCommand cmd)</span> &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckoutServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">CheckoutService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">        <span class="keyword">private</span> CheckoutCommandHandler checkoutCommandHandler;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> OrderDTO <span class="title function_">checkout</span><span class="params">(<span class="meta">@Valid</span> CheckoutCommand cmd)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> checkoutCommandHandler.handle(cmd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>比较激进一点，通过CommandBus、EventBus，直接将指令或事件抛给对应的Handler，EventBus比较常见。具体案例代码如下，通过消息队列收到MQ消息后，生成Event，然后由EventBus做路由到对应的Handler：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Application层</span></span><br><span class="line"><span class="comment">// 在这里框架通常可以根据接口识别到这个负责处理PaymentReceivedEvent</span></span><br><span class="line"><span class="comment">// 也可以通过增加注解识别</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentReceivedHandler</span> <span class="keyword">implements</span> <span class="title class_">EventHandler</span>&lt;PaymentReceivedEvent&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(PaymentReceivedEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Interface层，这个是RocketMQ的Listener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderMessageListener</span> <span class="keyword">implements</span> <span class="title class_">MessageListenerOrderly</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> EventBus eventBus;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ConsumeOrderlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">PaymentReceivedEvent</span> <span class="variable">event</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PaymentReceivedEvent</span>();</span><br><span class="line">        eventBus.dispatch(event); <span class="comment">// 不需要指定消费者</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>⚠️ 不建议：这种做法可以实现Interface层和某个具体的ApplicationService或Handler的完全静态解藕，在运行时动态dispatch，做的比较好的框架如AxonFramework。虽然看起来很便利，但是根据我们自己业务的实践和踩坑发现，当代码中的CQE对象越来越多，handler越来越复杂时，运行时的dispatch缺乏了静态代码间的关联关系，导致代码很难读懂，特别是当你需要trace一个复杂调用链路时，因为dispatch是运行时的，很难摸清楚具体调用到的对象。所以我们虽然曾经有过这种尝试，但现在已经不建议这么做了。</p>
<p><strong>Application Service 是业务流程的封装，不处理业务逻辑</strong></p>
<p>虽然之前曾经无数次重复ApplicationService只负责业务流程串联，不负责业务逻辑，但如何判断一段代码到底是业务流程还是逻辑呢？</p>
<p>举个之前的例子，最初的代码重构后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckoutServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">CheckoutService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">OrderDtoAssembler</span> <span class="variable">orderDtoAssembler</span> <span class="operator">=</span> OrderDtoAssembler.INSTANCE;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ItemService itemService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> InventoryService inventoryService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OrderRepository orderRepository;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> OrderDTO <span class="title function_">checkout</span><span class="params">(<span class="meta">@Valid</span> CheckoutCommand cmd)</span> &#123;</span><br><span class="line">        <span class="type">ItemDO</span> <span class="variable">item</span> <span class="operator">=</span> itemService.getItem(cmd.getItemId());</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Item not found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">withholdSuccess</span> <span class="operator">=</span> inventoryService.withhold(cmd.getItemId(), cmd.getQuantity());</span><br><span class="line">        <span class="keyword">if</span> (!withholdSuccess) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Inventory not enough&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        order.setBuyerId(cmd.getUserId());</span><br><span class="line">        order.setSellerId(item.getSellerId());</span><br><span class="line">        order.setItemId(item.getItemId());</span><br><span class="line">        order.setItemTitle(item.getTitle());</span><br><span class="line">        order.setItemUnitPrice(item.getPriceInCents());</span><br><span class="line">        order.setCount(cmd.getQuantity());</span><br><span class="line">        <span class="type">Order</span> <span class="variable">savedOrder</span> <span class="operator">=</span> orderRepository.save(order);</span><br><span class="line">        <span class="keyword">return</span> orderDtoAssembler.orderToDTO(savedOrder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>判断是否业务流程的几个点：</strong></p>
<p>1、不要有if&#x2F;else分支逻辑：也就是说代码的Cyclomatic Complexity（循环复杂度）应该尽量等于1</p>
<p>通常有分支逻辑的，都代表一些业务判断，应该将逻辑封装到DomainService或者Entity里。但这不代表完全不能有if逻辑，比如，在这段代码里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">withholdSuccess</span> <span class="operator">=</span> inventoryService.withhold(cmd.getItemId(), cmd.getQuantity());</span><br><span class="line"><span class="keyword">if</span> (!withholdSuccess) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Inventory not enough&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>虽然CC &gt; 1，但是仅仅代表了中断条件，具体的业务逻辑处理并没有受影响。可以把它看作为Precondition。</p>
<p>2、不要有任何计算：</p>
<p>在最早的代码里有这个计算：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 5）领域计算</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">cost</span> <span class="operator">=</span> item.getPriceInCents() * quantity;</span><br><span class="line">order.setTotalCost(cost);</span><br></pre></td></tr></table></figure>



<p>通过将这个计算逻辑封装到实体里，避免在ApplicationService里做计算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long itemUnitPrice;</span><br><span class="line">    <span class="keyword">private</span> Integer count;</span><br><span class="line">    <span class="comment">// 把原来一个在ApplicationService的计算迁移到Entity里</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getTotalCost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> itemUnitPrice * count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">order.setItemUnitPrice(item.getPriceInCents());</span><br><span class="line">order.setCount(cmd.getQuantity());</span><br></pre></td></tr></table></figure>



<p>3、一些数据的转化可以交给其他对象来做：</p>
<p>比如DTO Assembler，将对象间转化的逻辑沉淀在单独的类中，降低ApplicationService的复杂度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">OrderDTO</span> <span class="variable">dto</span> <span class="operator">=</span> orderDtoAssembler.orderToDTO(savedOrder);</span><br></pre></td></tr></table></figure>



<p><strong>常用的ApplicationService“套路”</strong></p>
<p>我们可以看出来，ApplicationService的代码通常有类似的结构：AppService通常不做任何决策（Precondition除外），仅仅是把所有决策交给DomainService或Entity，把跟外部交互的交给Infrastructure接口，如Repository或防腐层。</p>
<p>一般的“套路”如下：</p>
<ul>
<li>准备数据：包括从外部服务或持久化源取出相对应的Entity、VO以及外部服务返回的DTO。</li>
<li>执行操作：包括新对象的创建、赋值，以及调用领域对象的方法对其进行操作。需要注意的是这个时候通常都是纯内存操作，非持久化。</li>
<li>持久化：将操作结果持久化，或操作外部系统产生相应的影响，包括发消息等异步操作。</li>
</ul>
<p>如果涉及到对多个外部系统（包括自身的DB）都有变更的情况，这个时候通常处在“分布式事务”的场景里，无论是用分布式TX、TCC、还是Saga模式，取决于具体场景的设计，在此处暂时略过。</p>
<h2 id="3-4-DTO-Assembler"><a href="#3-4-DTO-Assembler" class="headerlink" title="3.4 DTO Assembler"></a>3.4 DTO Assembler</h2><p>一个经常被忽视的问题是 ApplicationService应该返回 Entity 还是 DTO？这里提出一个规范，在DDD分层架构中：</p>
<blockquote>
<p>ApplicationService应该永远返回DTO而不是Entity</p>
</blockquote>
<p>为什么呢？</p>
<ol>
<li>构建领域边界：ApplicationService的入参是CQE对象，出参是DTO，这些基本上都属于简单的POJO，来确保Application层的内外互相不影响。</li>
<li>降低规则依赖：Entity里面通常会包含业务规则，如果ApplicationService返回Entity，则会导致调用方直接依赖业务规则。如果内部规则变更可能直接影响到外部。</li>
<li>通过DTO组合降低成本：Entity是有限的，DTO可以是多个Entity、VO的自由组合，一次性封装成复杂DTO，或者有选择的抽取部分参数封装成DTO可以降低对外的成本。</li>
</ol>
<p>因为我们操作的对象是Entity，但是输出的对象是DTO，这里就需要一个专属类型的对象叫<strong>DTO Assembler</strong>。DTO Assembler的唯一职责是将一个或多个Entity&#x2F;VO，转化为DTO。注意：DTO Assembler通常不建议有反操作，也就是不会从DTO到Entity，因为通常一个DTO转化为Entity时是无法保证Entity的准确性的。</p>
<p>通常，Entity转DTO是有成本的，无论是代码量还是运行时的操作。手写转换代码容易出错，为了节省代码量用Reflection会造成极大的性能损耗。所以这里我还是不遗余力的推荐MapStruct这个库。MapStruct通过静态编译时代码生成，通过写接口和配置注解就可以生成对应的代码，且因为生成的代码是直接赋值，其性能损耗基本可以忽略不计。</p>
<p>通过MapStruct，代码即可简化为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.mapstruct.Mapper;</span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderDtoAssembler</span> &#123;</span><br><span class="line">    <span class="type">OrderDtoAssembler</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> Mappers.getMapper(OrderDtoAssembler.class);</span><br><span class="line">    OrderDTO <span class="title function_">orderToDTO</span><span class="params">(Order order)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckoutServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">CheckoutService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">OrderDtoAssembler</span> <span class="variable">orderDtoAssembler</span> <span class="operator">=</span> OrderDtoAssembler.INSTANCE;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> OrderDTO <span class="title function_">checkout</span><span class="params">(<span class="meta">@Valid</span> CheckoutCommand cmd)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">          <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();    </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">savedOrder</span> <span class="operator">=</span> orderRepository.save(order);</span><br><span class="line">        <span class="keyword">return</span> orderDtoAssembler.orderToDTO(savedOrder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合之前的Data Mapper，DTO、Entity和DataObject之间的关系如下图：</p>
<p><img src="/2022/10/24/DDD-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%99%E6%B5%81%E6%B0%B4%E8%B4%A6%E4%BB%A3%E7%A0%81/4.png" alt="image.png"></p>
<h2 id="3-5-Result-vs-Exception"><a href="#3-5-Result-vs-Exception" class="headerlink" title="3.5 Result vs Exception"></a>3.5 Result vs Exception</h2><p>最后，上文曾经提及在Interface层应该返回Result，在Application层应该返回DTO，在这里再次重复提出规范：</p>
<p>Application层只返回DTO，可以直接抛异常，不用统一处理。所有调用到的服务也都可以直接抛异常，除非需要特殊处理，否则不需要刻意捕捉异常</p>
<p>异常的好处是能明确的知道错误的来源，堆栈等，在Interface层统一捕捉异常是为了避免异常堆栈信息泄漏到API之外，但是在Application层，异常机制仍然是信息量最大，代码结构最清晰的方法，避免了Result的一些常见且繁杂的Result.isSuccess判断。所以在Application层、Domain层，以及Infrastructure层，遇到错误直接抛异常是最合理的方法。</p>
<h2 id="3-6-简单讲一下Anti-Corruption-Layer防腐层"><a href="#3-6-简单讲一下Anti-Corruption-Layer防腐层" class="headerlink" title="3.6 简单讲一下Anti-Corruption Layer防腐层"></a>3.6 简单讲一下Anti-Corruption Layer防腐层</h2><p><em>本文仅仅简单描述一下ACL的原理和作用，具体的实施规范可能要等到另外一篇文章。</em></p>
<p>在ApplicationService中，经常会依赖外部服务，从代码层面对外部系统产生了依赖。比如上文中的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ItemDO</span> <span class="variable">item</span> <span class="operator">=</span> itemService.getItem(cmd.getItemId());</span><br><span class="line"><span class="type">boolean</span> <span class="variable">withholdSuccess</span> <span class="operator">=</span> inventoryService.withhold(cmd.getItemId(), cmd.getQuantity());</span><br></pre></td></tr></table></figure>

<p>会发现我们的ApplicationService会强依赖ItemService、InventoryService以及ItemDO这个对象。如果任何一个服务的方法变更，或者ItemDO字段变更，都会有可能影响到ApplicationService的代码。也就是说，我们自己的代码会因为强依赖了外部系统的变化而变更，这个在复杂系统中应该是尽量避免的。那么如何做到对外部系统的隔离呢？需要加入ACL防腐层。</p>
<p>ACL防腐层的简单原理如下：</p>
<ul>
<li>对于依赖的外部对象，我们抽取出所需要的字段，生成一个内部所需的VO或DTO类</li>
<li>构建一个新的Facade，在Facade中封装调用链路，将外部类转化为内部类</li>
<li>针对外部系统调用，同样的用Facade方法封装外部调用链路</li>
</ul>
<p>无防腐层的情况：</p>
<p><img src="/2022/10/24/DDD-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%99%E6%B5%81%E6%B0%B4%E8%B4%A6%E4%BB%A3%E7%A0%81/5.png" alt="image.png"></p>
<p>有防腐层的情况：</p>
<p><img src="/2022/10/24/DDD-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%99%E6%B5%81%E6%B0%B4%E8%B4%A6%E4%BB%A3%E7%A0%81/6.png" alt="image.png"></p>
<p>具体简单实现，假设所有外部依赖都命名为ExternalXXXService：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义的内部值类</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemDTO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long itemId;</span><br><span class="line">    <span class="keyword">private</span> Long sellerId;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> Long priceInCents;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 商品Facade接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ItemFacade</span> &#123;</span><br><span class="line">    ItemDTO <span class="title function_">getItem</span><span class="params">(Long itemId)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 商品facade实现</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemFacadeImpl</span> <span class="keyword">implements</span> <span class="title class_">ItemFacade</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ExternalItemService externalItemService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ItemDTO <span class="title function_">getItem</span><span class="params">(Long itemId)</span> &#123;</span><br><span class="line">        <span class="type">ItemDO</span> <span class="variable">itemDO</span> <span class="operator">=</span> externalItemService.getItem(itemId);</span><br><span class="line">        <span class="keyword">if</span> (itemDO != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ItemDTO</span> <span class="variable">dto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ItemDTO</span>();</span><br><span class="line">            dto.setItemId(itemDO.getItemId());</span><br><span class="line">            dto.setTitle(itemDO.getTitle());</span><br><span class="line">            dto.setPriceInCents(itemDO.getPriceInCents());</span><br><span class="line">            dto.setSellerId(itemDO.getSellerId());</span><br><span class="line">            <span class="keyword">return</span> dto;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 库存Facade</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InventoryFacade</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">withhold</span><span class="params">(Long itemId, Integer quantity)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InventoryFacadeImpl</span> <span class="keyword">implements</span> <span class="title class_">InventoryFacade</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ExternalInventoryService externalInventoryService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">withhold</span><span class="params">(Long itemId, Integer quantity)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> externalInventoryService.withhold(itemId, quantity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>通过ACL改造之后，我们ApplicationService的代码改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckoutServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">CheckoutService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ItemFacade itemFacade;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> InventoryFacade inventoryFacade;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> OrderDTO <span class="title function_">checkout</span><span class="params">(<span class="meta">@Valid</span> CheckoutCommand cmd)</span> &#123;</span><br><span class="line">        <span class="type">ItemDTO</span> <span class="variable">item</span> <span class="operator">=</span> itemFacade.getItem(cmd.getItemId());</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Item not found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">withholdSuccess</span> <span class="operator">=</span> inventoryFacade.withhold(cmd.getItemId(), cmd.getQuantity());</span><br><span class="line">        <span class="keyword">if</span> (!withholdSuccess) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Inventory not enough&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>很显然，这么做的好处是ApplicationService的代码已经完全不再直接依赖外部的类和方法，而是依赖了我们自己内部定义的值类和接口。如果未来外部服务有任何的变更，需要修改的是Facade类和数据转化逻辑，而不需要修改ApplicationService的逻辑。</p>
<p>Repository可以认为是一种特殊的ACL，屏蔽了具体数据操作的细节，即使底层数据库结构变更，数据库类型变更，或者加入其他的持久化方式，Repository的接口保持稳定，ApplicationService就能保持不变。</p>
<p>在一些理论框架里ACL Facade也被叫做Gateway，含义是一样的。</p>
<h1 id="4-Orchestration-vs-Choreography"><a href="#4-Orchestration-vs-Choreography" class="headerlink" title="4. Orchestration vs Choreography"></a>4. Orchestration vs Choreography</h1><p>在本文最后想聊一下复杂业务流程的设计规范。在复杂的业务流程里，我们通常面临两种模式：Orchestration 和 Choreography。很无奈，这两个英文单词的百度翻译&#x2F;谷歌翻译，都是“编排”，但实际上这两种模式是完全不一样的设计模式。Orchestration的编排（比如SOA&#x2F;微服务的服务编排Service Orchestration）是我们通常熟悉的用法，Choreography是最近出现了事件驱动架构EDA才慢慢流行起来。网上可能会有其他的翻译，比如编制、编舞、协作等，但感觉都没有真正的把英文单词的意思表达出来，所以为了避免误解，在下文我尽量还是用英文原词。如果谁有更好的翻译方法欢迎联系我。</p>
<h2 id="4-1-模式简介"><a href="#4-1-模式简介" class="headerlink" title="4.1 模式简介"></a>4.1 模式简介</h2><p>Orchestration：通常出现在脑海里的是一个交响乐团（Orchestra，注意这两个词的相似性），如下图。交响乐团的核心是一个唯一的指挥家Conductor，在一个交响乐中，所有的音乐家必须听从Conductor的指挥做操作，不可以独自发挥。所以在Orchestration模式中，所有的流程都是由一个节点或服务触发的。我们常见的业务流程代码，包括调用外部服务，就是Orchestration，由我们的服务统一触发。</p>
<p><img src="/2022/10/24/DDD-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%99%E6%B5%81%E6%B0%B4%E8%B4%A6%E4%BB%A3%E7%A0%81/7.png" alt="image.png"></p>
<p>图片来源：<a href="https://insights-images.thoughtworks.com/orchestrator20music_d80f70dfd1857ae9778fee2f8fa9a01d.png%E3%80%82">https://insights-images.thoughtworks.com/orchestrator20music_d80f70dfd1857ae9778fee2f8fa9a01d.png</a></p>
<p>Choreography：通常会出现在脑海的场景是一个舞剧（来自于希腊文的舞蹈，Choros），如下图。其中每个不同的舞蹈家都在做自己的事，但是没有一个中心化的指挥。通过协作配合，每个人做好自己的事，整个舞蹈可以展现出一个完整的、和谐的画面。所以在Choreography模式中，每个服务都是独立的个体，可能会响应外部的一些事件，但整个系统是一个整体。</p>
<p><img src="/2022/10/24/DDD-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%99%E6%B5%81%E6%B0%B4%E8%B4%A6%E4%BB%A3%E7%A0%81/8.png" alt="image.png"></p>
<p>图片来源：<a href="https://i.ytimg.com/vi/uQaQrO4hKPQ/maxresdefault.jpg%E3%80%82">https://i.ytimg.com/vi/uQaQrO4hKPQ/maxresdefault.jpg</a></p>
<h2 id="4-2-案例"><a href="#4-2-案例" class="headerlink" title="4.2 案例"></a>4.2 案例</h2><p>用一个常见的例子：下单后支付并发货</p>
<p>如果这个案例是Orchestration，则业务逻辑为：下单时从一个预存的账户里扣取资金，并且生成物流单发货，从图上看是这样的：</p>
<p><img src="/2022/10/24/DDD-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%99%E6%B5%81%E6%B0%B4%E8%B4%A6%E4%BB%A3%E7%A0%81/9.png" alt="image.png"></p>
<p>如果这个案例是Choreography，则业务逻辑为：下单，然后等支付成功事件，然后再发货，类似这样：</p>
<p><img src="/2022/10/24/DDD-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%99%E6%B5%81%E6%B0%B4%E8%B4%A6%E4%BB%A3%E7%A0%81/10.png" alt="image.png"></p>
<h2 id="4-3-模式的区别和选择"><a href="#4-3-模式的区别和选择" class="headerlink" title="4.3 模式的区别和选择"></a>4.3 模式的区别和选择</h2><p>虽然看起来这两种模式都能达到一样的业务目的，但是在实际开发中他们有巨大的差异：</p>
<p>从代码依赖关系来看：</p>
<ul>
<li>Orchestration：涉及到一个服务调用到另外的服务，对于调用方来说，是强依赖的服务提供方。</li>
<li>Choreography：每一个服务只是做好自己的事，然后通过事件触发其他的服务，服务之间没有直接调用上的依赖。但要注意的是下游还是会依赖上游的代码（比如事件类），所以可以认为是下游对上游有依赖。</li>
</ul>
<p>从代码灵活性来看：</p>
<ul>
<li>Orchestration：因为服务间的依赖关系是写死的，增加新的业务流程必然需要修改代码。</li>
<li>Choreography：因为服务间没有直接调用关系，可以增加或替换服务，而不需要改上游代码。</li>
</ul>
<p>从调用链路来看：</p>
<ul>
<li>Orchestration：是从一个服务主动调用另一个服务，所以是Command-Driven指令驱动的。</li>
<li>Choreography：是每个服务被动的被外部事件触发，所以是Event-Driven事件驱动的。</li>
</ul>
<p>从业务职责来看：</p>
<ul>
<li>Orchestration：有主动的调用方（比如：下单服务）。无论下游的依赖是谁，主动的调用方都需要为整个业务流程和结果负责。</li>
<li>Choreography：没有主动调用方，每个服务只关心自己的触发条件和结果，没有任何一个服务会为整个业务链路负责</li>
</ul>
<p>总结下来一个比较：</p>
<table>
<thead>
<tr>
<th></th>
<th>Orchestration</th>
<th>Choreography</th>
</tr>
</thead>
<tbody><tr>
<td>驱动力</td>
<td>指令驱动Command-Driven</td>
<td>事件驱动Event-Driven</td>
</tr>
<tr>
<td>调用依赖</td>
<td>上游强依赖下游</td>
<td>无直接调用依赖但是有代码依赖可以认为是下游依赖上游</td>
</tr>
<tr>
<td>灵活性</td>
<td>较差</td>
<td>较高</td>
</tr>
<tr>
<td>业务职责</td>
<td>上游为业务负责</td>
<td>无全局责任人</td>
</tr>
</tbody></table>
<p>另外需要重点明确的：“指令驱动”和“事件驱动”的区别不是“同步”和“异步”。指令可以是同步调用，也可以是异步消息触发（但异步指令不是事件）；反过来事件可以是异步消息，但也完全可以是进程内的同步调用。所以指令驱动和事件驱动差异的本质不在于调用方式，而是一件事情是否“已经”发生。</p>
<p><strong>所以在日常业务中当你碰到一个需求时，该如何选择是用Orchestration还是Choreography？</strong></p>
<p>这里给出两个判断方法：</p>
<ol>
<li>明确依赖的方向：</li>
</ol>
<p><img src="/2022/10/24/DDD-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%99%E6%B5%81%E6%B0%B4%E8%B4%A6%E4%BB%A3%E7%A0%81/11.png" alt="image.png"></p>
<p>在代码中的依赖是比较明确的：如果你是下游，上游对你无感知，则只能走事件驱动；如果上游必须要对你有感知，则可以走指令驱动。反过来，如果你是上游，需要对下游强依赖，则是指令驱动；如果下游是谁无所谓，则可以走事件驱动。</p>
<ol start="2">
<li>找出业务中的“负责人”：</li>
</ol>
<p><img src="/2022/10/24/DDD-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%99%E6%B5%81%E6%B0%B4%E8%B4%A6%E4%BB%A3%E7%A0%81/12.png" alt="image.png"></p>
<p>第二种方法是根据业务场景找出其中的“负责人”。比如，如果业务需要通知卖家，下单系统的单一职责不应该为消息通知负责，但订单管理系统需要根据订单状态的推进主动触发消息，所以是这个功能的负责人。</p>
<p>在一个复杂业务流程里，通常两个模式都要有，但也很容易设计错误。如果出现依赖关系很奇怪，或者代码里调用链路&#x2F;负责人梳理不清楚的情况，可以尝试转换一下模式，可能会好很多。</p>
<p><strong>哪个模式更好？</strong></p>
<p>很显然，没有最好的模式，只有最合适自己业务场景的模式。</p>
<p>❌ 反例：最近几年比较流行的Event-Driven Architecture（EDA）事件驱动架构，以及Reactive-Programming响应式编程（比如RxJava），虽然有很多创新，但在一定程度上是“当你有把锤子，所有问题都是钉子”的典型案例。他们对一些基于事件的、流处理的问题有奇效，但如果拿这些框架硬套指令驱动的业务，就会感到代码极其“不协调”，认知成本提高。所以在日常选型中，还是要先根据业务场景梳理出来是哪些流程中的部分是Orchestration，哪些是Choreography，然后再选择相对应的框架。</p>
<h2 id="4-4-跟DDD分层架构的关系"><a href="#4-4-跟DDD分层架构的关系" class="headerlink" title="4.4 跟DDD分层架构的关系"></a>4.4 跟DDD分层架构的关系</h2><p>最后，讲了这么多O vs C，跟DDD有啥关系？很简单：</p>
<ul>
<li>O&amp;C其实是Interface层的关注点，Orchestration &#x3D; 对外的API，而Choreography &#x3D; 消息或事件。当你决策了O还是C之后，需要在interface层承接这些“驱动力”。</li>
<li>无论O&amp;C如何设计，Application层都“无感知”，因为ApplicationService天生就可以处理Command、Query和Event，至于这些对象怎么来，是Interface层的决策。</li>
</ul>
<p>所以，虽然Orchestration 和 Choreography是两种完全不同的业务设计模式，但最终落到Application层的代码应该是一致的，这也是为什么Application层是“用例”而不是“接口”，是相对稳定的存在。</p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>只要是做业务的，一定会需要写业务流程和服务编排，但不代表这种代码一定质量差。通过DDD的分层架构里的Interface层和Application层的合理拆分，代码可以变得优雅、灵活，能更快的响应业务但同时又能更好的沉淀。本文主要介绍了一些代码的设计规范，帮助大家掌握一定的技巧。</p>
<p>Interface层：</p>
<ul>
<li>职责：主要负责承接网络协议的转化、Session管理等</li>
<li>接口数量：避免所谓的统一API，不必人为限制接口类的数量，每个&#x2F;每类业务对应一套接口即可，接口参数应该符合业务需求，避免大而全的入参</li>
<li>接口出参：统一返回Result</li>
<li>异常处理：应该捕捉所有异常，避免异常信息的泄漏。可以通过AOP统一处理，避免代码里有大量重复代码。</li>
</ul>
<p>Application层：</p>
<ul>
<li>入参：具像化Command、Query、Event对象作为ApplicationService的入参，唯一可以的例外是单ID查询的场景。</li>
<li>CQE的语意化：CQE对象有语意，不同用例之间语意不同，即使参数一样也要避免复用。</li>
<li>入参校验：基础校验通过Bean Validation api解决。Spring Validation自带Validation的AOP，也可以自己写AOP。</li>
<li>出参：统一返回DTO，而不是Entity或DO。</li>
<li>DTO转化：用DTO Assembler负责Entity&#x2F;VO到DTO的转化。</li>
<li>异常处理：不统一捕捉异常，可以随意抛异常。</li>
</ul>
<p>部分Infra层：</p>
<ul>
<li>用ACL防腐层将外部依赖转化为内部代码，隔离外部的影响</li>
</ul>
<p>业务流程设计模式：</p>
<ul>
<li>没有最好的模式，取决于业务场景、依赖关系、以及是否有业务“负责人”。避免拿着锤子找钉子。</li>
</ul>
]]></content>
      <categories>
        <category>DDD领域驱动设计</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>DDD领域驱动设计</title>
    <url>/2022/10/24/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="从遇到问题开始"><a href="#从遇到问题开始" class="headerlink" title="从遇到问题开始"></a>从遇到问题开始</h2><p>当人们要做一个软件系统时，一般总是因为遇到了什么问题，然后希望通过一个软件系统来解决。</p>
<p>比如，我是一家企业，然后我觉得我现在线下销售自己的产品还不够，我希望能够在线上也能销售自己的产品。所以，自然而然就想到要做一个普通电商系统，用于实现在线销售自己企业产品的目的。</p>
<p>再比如，我是一家互联网公司，公司有很多系统对外提供服务，面向很多客户端设备。但是最近由于各种原因，导致服务经常出故障。所以，我们希望通过各种措施提高服务的质量和稳定性。其中的一个措施就是希望能做一个灰度发布的平台，这个平台可以提供灰度发布的服务。然后，当某个业务系统做了一些修改并需要发布时，可以使用我们的灰度发布平台来非常方便的实现灰度发布的功能。比如在灰度发布平台上方便的定制允许哪些特定的客户端才会访问新服务，哪些客户端继续使用老服务。灰度发布平台可以提供各种灰度的策略。有了这样的灰度发布机制，那即便系统的新逻辑有什么问题，受影响的面也不会很大，在可控范围内。所以，如果公司里的所有对外提供服务的系统都接入了灰度平台，那这些系统的发布环节就可以更加有保障了。</p>
<p>总之，我们做任何一个软件系统，都是有原因的，否则就没必要做这个系统，而这个原因就是我们遇到的问题。所以，通过问题，我们就知道了我们需要一个什么样的系统，这个系统解决什么样的问题。最后，我们就很自然的得出了一个目标，即知道了自己要什么。比如我要做一个论坛、一个博客系统、一个电商平台、一个灰度发布系统、一个IDE、一个分布式消息队列、一个通信框架，等等。</p>
<h2 id="DDD切入点1-理解概念"><a href="#DDD切入点1-理解概念" class="headerlink" title="DDD切入点1 - 理解概念"></a>DDD切入点1 - 理解概念</h2><p>DDD的全称为Domain-driven Design，即领域驱动设计。下面我从领域、问题域、领域模型、设计、驱动这几个词语的含义和联系的角度去阐述DDD是如何融入到我们平时的软件开发初期阶段的。要理解什么是领域驱动设计，首先要理解什么是领域，什么是设计，还有驱动是什么意思，什么驱动什么。</p>
<h2 id="什么是领域（Domain）？"><a href="#什么是领域（Domain）？" class="headerlink" title="什么是领域（Domain）？"></a>什么是领域（Domain）？</h2><p>前面我们已经清楚的知道我们现在要做一个什么样的系统，这个系统需要解决什么问题。我认为任何一个系统都会属于某个特定的领域，比如论坛是一个领域，只要你想做一个论坛，那这个论坛的核心业务是确定的，比如都有用户发帖、回帖等核心基本功能。比如电商平台、普通电商系统，这种都属于网上电商领域，只要是这个领域的系统，那都有商品浏览、购物车、下单、减库存、付款交易等核心环节。所以，同一个领域的系统都具有相同的核心业务，因为他们要解决的问题的本质是类似的。</p>
<p>因此，我们可以推断出，一个领域本质上可以理解为就是一个问题域，只要是同一个领域，那问题域就相同。所以，只要我们确定了系统所属的领域，那这个系统的核心业务，即要解决的关键问题、问题的范围边界就基本确定了。通常我们说，要成为一个领域的专家，必须要在这个领域深入研究很多年才行。因为只有你研究了很多年，你才会遇到非常多的该领域的问题，同时你解决这个领域中的问题的经验也非常丰富。很多时候，领域专家比技术专家更加吃香，比如金融领域的专家。</p>
<h2 id="什么是设计（Design）？"><a href="#什么是设计（Design）？" class="headerlink" title="什么是设计（Design）？"></a>什么是设计（Design）？</h2><p>DDD中的设计主要指领域模型的设计。为什么是领域模型的设计而不是架构设计或其他的什么设计呢？因为DDD是一种基于模型驱动开发的软件开发思想，强调领域模型是整个系统的核心，领域模型也是整个系统的核心价值所在。每一个领域，都有一个对应的领域模型，领域模型能够很好的帮我们解决复杂的业务问题。</p>
<p>从领域和代码实现的角度来理解，领域模型绑定了领域和代码实现，确保了最终的代码实现就一定是解决了领域中的核心问题的。因为：1）领域驱动领域模型设计；2）领域模型驱动代码实现。我们只要保证领域模型的设计是正确的，就能确定领域模型可以解决领域中的核心问题；同理，我们只要保证代码实现是严格按照领域模型的意图来落地的，那就能保证最后出来的代码能够解决领域的核心问题的。这个思路，和传统的分析、设计、编码这几个阶段被割裂（并且每个阶段的产物也不同）的软件开发方法学形成鲜明的对比。</p>
<h2 id="什么是驱动（Driven）？"><a href="#什么是驱动（Driven）？" class="headerlink" title="什么是驱动（Driven）？"></a>什么是驱动（Driven）？</h2><p>上面其实已经提到了，就是：1）领域驱动领域模型设计；2）领域模型驱动代码实现。这个就和我们传统的数据库驱动开发的思路形成对比了。DDD中，我们总是以领域为边界，分析领域中的核心问题（核心关注点），然后设计对应的领域模型，再通过领域模型驱动代码实现。而像数据库设计、持久化技术等这些都不是DDD的核心，而是外围的东西。</p>
<p>领域驱动设计（DDD）告诉我们的最大价值我觉得是：当我们要开发一个系统时，应该尽量先把领域模型想清楚，然后再开始动手编码，这样的系统后期才会很好维护。但是，很多项目（尤其是互联网项目，为了赶工）都是一开始模型没想清楚，一上来就开始建表写代码，代码写的非常冗余，完全是过程是的思考方式，最后导致系统非常难以维护。而且更糟糕的是，出来混总是要还的，前期的领域模型设计的不好，不够抽象，如果你的系统会长期需要维护和适应业务变化，那后面你一定会遇到各种问题维护上的困难，比如数据结构设计不合理，代码到处冗余，改BUG到处引入新的BUG，新人对这种代码上手困难，等。而那时如果你再想重构模型，那要付出的代价会比一开始重新开发还要大，因为你还要考虑兼容历史的数据，数据迁移，如何平滑发布等各种头疼的问题。所以，就导致我们最后天天加班。</p>
<p>虽然，我们都知道这个道理，但是我也明白，人的习惯很难改变的，大部分人都很难从面向过程式的想到哪里写到哪里的思想转变为基于系统化的模型驱动的思维。我想，这或许是DDD很难在中国或国外流行起来的原因吧。但是，我想这不应该成为我们放弃学习DDD的原因，对吧！</p>
<h2 id="概念总结："><a href="#概念总结：" class="headerlink" title="概念总结："></a>概念总结：</h2><p>领域就是问题域，有边界，领域中有很多问题；<br>任何一个系统要解决的那个大问题都对应一个领域；<br>通过建立领域模型来解决领域中的核心问题，模型驱动的思想；<br>领域建模的目标针对我们在领域中所关心的问题，即只针对核心关注点，而不是整个领域中的所有问题；<br>领域模型在设计时应考虑一定的抽象性、通用性，以及复用价值；<br>通过领域模型驱动代码的实现，确保代码让领域模型落地，代码最终能解决问题；<br>领域模型是系统的核心，是领域内的业务的直接沉淀，具有非常大的业务价值；<br>技术架构设计或数据存储等是在领域模型的外围，帮助领域模型进行落地；</p>
<h2 id="DDD切入点2-理解领域、拆分领域、细化领域"><a href="#DDD切入点2-理解领域、拆分领域、细化领域" class="headerlink" title="DDD切入点2 - 理解领域、拆分领域、细化领域"></a>DDD切入点2 - 理解领域、拆分领域、细化领域</h2><h3 id="理解领域知识是基础"><a href="#理解领域知识是基础" class="headerlink" title="理解领域知识是基础"></a>理解领域知识是基础</h3><p>上面我们通过第一步，虽然我们明确了要做一个什么样的系统，该系统主要解决什么问题，但是就这样我们还无法开始进行实际的需求分析和模型设计，我们还必须将我们的问题进行拆分，需求进行细化。有些时候，需求方，即提出问题的人，很可能自己不清楚具体想要什么。他只知道一个概念，一个大的目标。比如他只知道要做一个股票交易系统，一个灰度发布系统，一个电商平台，一个开发工具，等。但是他不清楚这些系统应该具体做成什么样子。这个时候，我认为领域专家就非常重要了，DDD也非常强调领域专家的重要性。因为领域专家对这个领域非常了解，对领域内的各种业务场景和各种业务规则也非常清楚，总之，对这个领域内的一切业务相关的知识都非常了解。所以，他们自然就有能力表达出系统该做成什么样子。所以，要知道一个系统到底该做成什么样子，到底哪些是核心业务关注点，只能靠沉淀领域内的各种知识，别无他法。因此，假设你现在打算做一个电商平台，但是你对这个领域没什么了解，那你一定得先去了解下该领域内主流的电商平台，比如淘宝、天猫、京东、亚马逊等。这个了解的过程就是你沉淀领域知识的过程。如果你不了解，就算你领域建模的能力再强，各种技术架构能力再强也是使不上力。领域专家不是某个固定的角色，而是某一类人，这类人对这个领域非常了解。比如，一个开发人员也可以是一个领域专家。假设你在一个公司开发和维护一个系统已经好几年了，但是这个系统的产品经理（PD）可能已经换过好几任了，这种情况下，我相信这几任产品经理都没有比你更熟悉这个领域。</p>
<h3 id="拆分领域"><a href="#拆分领域" class="headerlink" title="拆分领域"></a>拆分领域</h3><p>上面我们明白了，领域建模的基础是要先理解领域，让自己成为领域专家。如果做到了这点，我们就打好了坚实的基础了。但是，有时一个领域往往太复杂，涉及到的领域概念、业务规则、交互流程太多，导致我们没办法直接针对这个大的领域进行领域建模。所以，我们需要将领域进行拆分，本质上就是把大问题拆分为小问题，然后各个击破的思路。然后既然把一个大的领域划分为了多个小的领域（子域），那最关键的就是要理清每个子域的边界；然后要搞清楚哪些子域是核心子域，哪些是非核心子域，哪些是公共支撑子域；然后，还要思考子域之间的联系是什么。那么，我们该如何划分子域呢？我的个人看法是从业务相关性的角度去思考，也就是我们平时说的按业务功能为出发点进行划分。还是拿经典的电商系统来分析，通常一个电商系统都会包含好几个大块，比如：</p>
<p>会员中心：负责用户账号登录、用户信息的管理；<br>商品中心：负责商品的展示、导航、维护；<br>订单中心：负责订单的生成和生命周期管理；<br>交易中心：负责交易相关的业务；<br>库存中心：负责维护商品的库存；<br>促销中心：负责各种促销活动的支持；<br>上面这些中心看起来很自然，因为大家对电子商务的这个领域都已经非常熟悉了，所以都没什么疑问，好像很自然的样子。所以，领域划分是不是就是没什么挑战了呢？显然不是。之所以我们觉得子域划分很简单，是因为我们对整个大领域非常了解了。如果我们遇到一个冷门的领域，就没办法这么容易的去划分子域了。这就需要我们先去努力理解领域内的知识。所以，我个人从来不相信什么子域划分的技巧什么的东西，因为我觉得这个工作没有任何诀窍可以使用。当我们不了解一个东西的时候，如何去拆解它？当我们对整个领域有一定的熟悉了，了解了领域内的相关业务的本质和关系，我们就自然而然的能划分出合理的子域了。不过并不是所有的系统都需要划分子域的，有些系统只是解决一个小问题，这个问题不复杂，可能只有一两个核心概念。所以，这种系统完全不需要再划分子域。但不是绝对的，当一个领域，我们的关注点越来越多，每个关注点我们关注的信息越来越多的时候，我们会不由自主的去进一步的划分子域。比如，也许我们一开始将商品和商品的库存都放在商品中心里，但是后来由于库存的维护越来越复杂，导致揉在一起对我们的系统维护带来一定的困难时，我们就会考虑将两者进行拆分，这个就是所谓的业务垂直分割。</p>
<h3 id="细化子域"><a href="#细化子域" class="headerlink" title="细化子域"></a>细化子域</h3><p>通过上面的两步，我们了解了领域里的知识，也对领域进行了子域划分。但这样还不够，凭这些我们还无法进行后续的领域模型设计。我们还必须再进一步细化每个子域，进一步明确每个子域的核心关注点，即需求细化。我觉得我们需要细化的方面有以下几点：</p>
<p>梳理领域概念：梳理出领域内我们关注的概念、概念的关系，并统一交流词汇，形成统一语言；<br>梳理业务规则：梳理出领域内我们关注的各种业务规则，DDD中叫不变性（invariants），比如唯一性规则，余额不能小于零等；<br>梳理业务场景：梳理出领域内的核心业务场景，比如电商平台中的加入购物车、提交订单、发起付款等核心业务场景；<br>梳理业务流程：梳理出领域内的关键业务流程，比如订单处理流程，退款流程等；<br>从上面这4个方面，我们从领域概念、业务规则、交互场景、业务流程等维度梳理了我们到底要什么，整理了整个系统应该具备的功能。这个工作我觉得是一个非常具有创造性和有难度的工作。我们一方面会主观的定义我们想要什么；另一方面，我们还会思考我们要的东西的合理性。我认为这个就是产品经理的工作，产品经理必须要负起职责，把他的产品充分设计好，从各个方面去考虑，如何设计一个产品，才能更好的解决用户的核心诉求，即领域内的核心问题。如果对领域不够了解，如果想不清楚用户到底要什么，如果思考问题不够全面，谈何设计出一个合理的产品呢？</p>
<p>关于领域概念的梳理，我觉得可以采用四色原型分析法，这个分析法通过系统的方法，将概念划分为不同的种类，为不同种类的概念标注不同的颜色。然后将这些概念有机的组合起来，从而让我们可以清晰的分析出概念和概念之间的关系。有兴趣的同学可以在网上搜索下<a href="https://www.cnblogs.com/netfocus/archive/2011/03/05/1971899.html">四色原型</a>。</p>
<p><strong>注意：上面我说的这四点，重点是梳理出我们要什么功能，而不是思考如何实现这些功能，如何实现是软件设计人员的职责。</strong></p>
<h2 id="DDD切入点3-领域模型设计"><a href="#DDD切入点3-领域模型设计" class="headerlink" title="DDD切入点3 - 领域模型设计"></a>DDD切入点3 - 领域模型设计</h2><p>这部分内容，我想学习DDD的人都很熟悉了。DDD原著中提出了很多实用的建模工具：聚合、实体、值对象、工厂、仓储、领域服务、领域事件。我们可以使用这些工具，来设计每一个子域的领域模型。最终通过领域模型图将设计沉淀下来。要使用这些工具，首先就要理解每个工具的含义和使用场景。不要以为很简单哦，比如聚合的划分就是一个非常具有艺术的活。同一个系统，不同的人设计出来的聚合是完全不同的。而且很有可能高手之间的最后设计出来的差别反而更大，实际上我认为是世界观的相互碰撞，呵呵。所以，要领域建模，我觉得每个人都应该去学学哲学知识，这有助于我们更好的认识世界，更好的理解事物的本质。</p>
<p>关于这些建模工具的概念和如何运用我就不多展开了，我博客里也有很多这方面的介绍。下面我再讲一下我认为比较重要的东西，比如到底该如何领域建模？步骤应该是怎么样的？</p>
<h3 id="领域建模的方法"><a href="#领域建模的方法" class="headerlink" title="领域建模的方法"></a>领域建模的方法</h3><p>通过上面我介绍的细化子域的内容，现在再来谈该如何领域建模，我觉得就方便很多了。我的主要方法是：</p>
<p>划分好边界上下文，通常每个子域（sub domain）对应一个边界上下文（bounded context），同一个边界上下文中的概念是明确的，没有任何歧义；<br>在每个边界上下文中设计领域模型，具体的领域模型设计方法有很多种，如以场景为出发点的<a href="https://www.cnblogs.com/netfocus/archive/2011/03/05/1971899.html">四色原型</a>分析法，或者我早期写的这篇<a href="https://www.cnblogs.com/netfocus/archive/2011/09/18/2180656.html">文章</a>；这个步骤最核心的就是找出聚合根，并找出每个聚合根包含的信息；关于如何设计聚合，可以看一下我写的<a href="https://www.cnblogs.com/netfocus/p/3307971.html">这篇文章</a>；<br>画出领域模型图，圈出每个模型中的聚合边界；<br>设计领域模型时，要考虑该领域模型是否满足业务规则，同时还要综合考虑技术实现等问题，比如并发问题；领域模型不是概念模型，概念模型不关注技术实现，领域模型关心；所以领域模型才能直接指导编码实现；<br>思考领域模型是如何在业务场景中发挥作用的，以及是如何参与到业务流程的每个环节的；<br>场景走查，确认领域模型是否能满足领域中的业务场景和业务流程；<br>模型持续重构、完善、精炼；</p>
<h3 id="领域模型的核心作用："><a href="#领域模型的核心作用：" class="headerlink" title="领域模型的核心作用："></a>领域模型的核心作用：</h3><p>1.抽象了领域内的核心概念，并建立概念之间的关系；<br>2.领域模型承担了领域内的状态的维护；<br>3.领域模型维护了领域内的数据之间的业务规则，数据一致性；<br>下图是我最近做个一个普通电商系统的商品中心的领域模型图，给大家参考：<br><img src="https://img-blog.csdnimg.cn/20210427163137281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="领域模型设计只是软件设计中的一小部分"><a href="#领域模型设计只是软件设计中的一小部分" class="headerlink" title="领域模型设计只是软件设计中的一小部分"></a>领域模型设计只是软件设计中的一小部分</h3><p>需要特别注意的是，领域模型设计只是整个软件设计中的很小一部分。除了领域模型设计之外，要落地一个系统，我们还有非常多的其他设计要做，比如：</p>
<p>容量规划<br>架构设计<br>数据库设计<br>缓存设计<br>框架选型<br>发布方案<br>数据迁移、同步方案<br>分库分表方案<br>回滚方案<br>高并发解决方案<br>一致性选型<br>性能压测方案<br>监控报警方案<br>等等。上面这些都需要我们平时的大量学习和积累。作为一个合格的开发人员或架构师，我觉得除了要会DDD领域驱动设计，还要会上面这么多的技术能力，确实是非常不容易的。所以，千万不要以为会DDD了就以为自己很牛逼，实际上你会的只是软件设计中的冰山一角而已。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文的重点是基于我个人对DDD的一些理解，希望能整理出一些自己总结出来的一些感悟和经验，并分享给大家。我相信很多人已经看过太多DDD书上的东西，我总是感觉书上的东西看似都太”正规“，很多时候我们读了之后很难消化，就算理解了书里的内容，当我们想要运用到实践中时，总是感觉无从下手。本文希望通过通俗易懂的文字，介绍了一部分我对DDD的学习感悟和实践心得，希望能给大家一些启发和帮助。</p>
]]></content>
      <categories>
        <category>DDD领域驱动设计</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>ES知识点</title>
    <url>/2022/10/24/ES%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>Elasticsearch基础知识点总结</p>
<div class="pdf-container" data-target="./1-尚硅谷项目课程系列之Elasticsearch.pdf" data-height="1000px"></div>

]]></content>
      <categories>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>DDD-应用架构</title>
    <url>/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p><strong>简介：</strong> 应用架构，指软件系统中固定不变的代码结构、设计模式、规范和组件间的通信方式。在应用开发中架构之所以是最重要的第一步，因为一个好的架构能让系统安全、稳定、快速迭代。但是今天我们在做业务研发时，更多会关注一些宏观的架构，而忽略了应用内部的架构设计，希望能通过案例分析和重构，推演出一套高质量的DDD架构。</p>
<p>架构这个词源于英文里的“Architecture“，源头是土木工程里的“建筑”和“结构”，而架构里的”架“同时又包含了”架子“（scaffolding）的含义，意指能快速搭建起来的固定结构。而今天的应用架构，意指软件系统中固定不变的代码结构、设计模式、规范和组件间的通信方式。在应用开发中架构之所以是最重要的第一步，因为一个好的架构能让系统安全、稳定、快速迭代。在一个团队内通过规定一个固定的架构设计，可以让团队内能力参差不齐的同学们都能有一个统一的开发规范，降低沟通成本，提升效率和代码质量。</p>
<p>在做架构设计时，一个好的架构应该需要实现以下几个目标：</p>
<ul>
<li><strong>独立于框架：</strong>架构不应该依赖某个外部的库或框架，不应该被框架的结构所束缚。</li>
<li><strong>独立于UI：</strong>前台展示的样式可能会随时发生变化（今天可能是网页、明天可能变成console、后天是独立app），但是底层架构不应该随之而变化。</li>
<li><strong>独立于底层数据源：</strong>无论今天你用MySQL、Oracle还是MongoDB、CouchDB，甚至使用文件系统，软件架构不应该因为不同的底层数据储存方式而产生巨大改变。</li>
<li><strong>独立于外部依赖：</strong>无论外部依赖如何变更、升级，业务的核心逻辑不应该随之而大幅变化。</li>
<li><strong>可测试：</strong>无论外部依赖了什么数据库、硬件、UI或者服务，业务的逻辑应该都能够快速被验证正确性。</li>
</ul>
<p>这就好像是建筑中的楼宇，一个好的楼宇，无论内部承载了什么人、有什么样的活动、还是外部有什么风雨，一栋楼都应该屹立不倒，而且可以确保它不会倒。但是今天我们在做业务研发时，更多的会去关注一些宏观的架构，比如SOA架构、微服务架构，而忽略了应用内部的架构设计，很容易导致代码逻辑混乱，很难维护，容易产生bug而且很难发现。今天，我希望能够通过案例的分析和重构，来推演出一套高质量的DDD架构。</p>
<h1 id="1、案例分析"><a href="#1、案例分析" class="headerlink" title="1、案例分析"></a>1、案例分析</h1><p>我们先看一个简单的案例需求如下：</p>
<p>用户可以通过银行网页转账给另一个账号，支持跨币种转账。</p>
<p>同时因为监管和对账需求，需要记录本次转账活动。</p>
<p>拿到这个需求之后，一个开发可能会经历一些技术选型，最终可能拆解需求如下：</p>
<p>1、从MySql数据库中找到转出和转入的账户，选择用 MyBatis 的 mapper 实现 DAO；2、从 Yahoo（或其他渠道）提供的汇率服务获取转账的汇率信息（底层是 http 开放接口）；</p>
<p>3、计算需要转出的金额，确保账户有足够余额，并且没超出每日转账上限；</p>
<p>4、实现转入和转出操作，扣除手续费，保存数据库；</p>
<p>5、发送 Kafka 审计消息，以便审计和对账用；</p>
<p>而一个简单的代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransferController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TransferService transferService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Boolean&gt; <span class="title function_">transfer</span><span class="params">(String targetAccountNumber, BigDecimal amount, HttpSession session)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> (Long) session.getAttribute(<span class="string">&quot;userId&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> transferService.transfer(userId, targetAccountNumber, amount, <span class="string">&quot;CNY&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransferServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">TransferService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TOPIC_AUDIT_LOG</span> <span class="operator">=</span> <span class="string">&quot;TOPIC_AUDIT_LOG&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountDAO;</span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line">    <span class="keyword">private</span> YahooForexService yahooForex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Boolean&gt; <span class="title function_">transfer</span><span class="params">(Long sourceUserId, String targetAccountNumber, BigDecimal targetAmount, String targetCurrency)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 从数据库读取数据，忽略所有校验逻辑如账号是否存在等</span></span><br><span class="line">        <span class="type">AccountDO</span> <span class="variable">sourceAccountDO</span> <span class="operator">=</span> accountDAO.selectByUserId(sourceUserId);</span><br><span class="line">        <span class="type">AccountDO</span> <span class="variable">targetAccountDO</span> <span class="operator">=</span> accountDAO.selectByAccountNumber(targetAccountNumber);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 业务参数校验</span></span><br><span class="line">        <span class="keyword">if</span> (!targetAccountDO.getCurrency().equals(targetCurrency)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidCurrencyException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 获取外部数据，并且包含一定的业务逻辑</span></span><br><span class="line">        <span class="comment">// exchange rate = 1 source currency = X target currency</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">exchangeRate</span> <span class="operator">=</span> BigDecimal.ONE;</span><br><span class="line">        <span class="keyword">if</span> (sourceAccountDO.getCurrency().equals(targetCurrency)) &#123;</span><br><span class="line">            exchangeRate = yahooForex.getExchangeRate(sourceAccountDO.getCurrency(), targetCurrency);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">sourceAmount</span> <span class="operator">=</span> targetAmount.divide(exchangeRate, RoundingMode.DOWN);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 业务参数校验</span></span><br><span class="line">        <span class="keyword">if</span> (sourceAccountDO.getAvailable().compareTo(sourceAmount) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InsufficientFundsException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sourceAccountDO.getDailyLimit().compareTo(sourceAmount) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DailyLimitExceededException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 计算新值，并且更新字段</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">newSource</span> <span class="operator">=</span> sourceAccountDO.getAvailable().subtract(sourceAmount);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">newTarget</span> <span class="operator">=</span> targetAccountDO.getAvailable().add(targetAmount);</span><br><span class="line">        sourceAccountDO.setAvailable(newSource);</span><br><span class="line">        targetAccountDO.setAvailable(newTarget);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 更新到数据库</span></span><br><span class="line">        accountDAO.update(sourceAccountDO);</span><br><span class="line">        accountDAO.update(targetAccountDO);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 发送审计消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> sourceUserId + <span class="string">&quot;,&quot;</span> + targetAccountNumber + <span class="string">&quot;,&quot;</span> + targetAmount + <span class="string">&quot;,&quot;</span> + targetCurrency;</span><br><span class="line">        kafkaTemplate.send(TOPIC_AUDIT_LOG, message);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，一段业务代码里经常包含了参数校验、数据读取存储、业务计算、调用外部服务、发送消息等多种逻辑。在这个案例里虽然是写在了同一个方法里，在真实代码中经常会被拆分成多个子方法，但实际效果是一样的，而在我们日常的工作中，绝大部分代码都或多或少的接近于此类结构。在Martin Fowler的 P of EAA书中，这种很常见的代码样式被叫做Transaction Script（事务脚本）。虽然这种类似于脚本的写法在功能上没有什么问题，但是长久来看，他有以下几个很大的问题：可维护性差、可扩展性差、可测试性差。</p>
<p><strong>问题1-可维护性能差</strong></p>
<p>一个应用最大的成本一般都不是来自于开发阶段，而是应用整个生命周期的总维护成本，所以代码的可维护性代表了最终成本。</p>
<p><strong>可维护性 &#x3D; 当依赖变化时，有多少代码需要随之改变</strong><br>参考以上的案例代码，事务脚本类的代码很难维护因为以下几点：</p>
<ul>
<li><strong>数据结构的不稳定性：</strong>AccountDO类是一个纯数据结构，映射了数据库中的一个表。这里的问题是数据库的表结构和设计是应用的外部依赖，长远来看都有可能会改变，比如数据库要做Sharding，或者换一个表设计，或者改变字段名。</li>
<li><strong>依赖库的升级：</strong>AccountMapper依赖MyBatis的实现，如果MyBatis未来升级版本，可能会造成用法的不同（可以参考iBatis升级到基于注解的MyBatis的迁移成本）。同样的，如果未来换一个ORM体系，迁移成本也是巨大的。</li>
<li><strong>第三方服务依赖的不确定性</strong>：第三方服务，比如Yahoo的汇率服务未来很有可能会有变化：轻则API签名变化，重则服务不可用需要寻找其他可替代的服务。在这些情况下改造和迁移成本都是巨大的。同时，外部依赖的兜底、限流、熔断等方案都需要随之改变。</li>
<li><strong>第三方服务API的接口变化：</strong>YahooForexService.getExchangeRate返回的结果是小数点还是百分比？入参是（source, target）还是（target, source）？谁能保证未来接口不会改变？如果改变了，核心的金额计算逻辑必须跟着改，否则会造成资损。</li>
<li><strong>中间件更换：</strong>今天我们用Kafka发消息，明天如果要上阿里云用RocketMQ该怎么办？后天如果消息的序列化方式从String改为Binary该怎么办？如果需要消息分片该怎么改？</li>
</ul>
<p>我们发现案例里的代码对于任何外部依赖的改变都会有比较大的影响。如果你的应用里有大量的此类代码，你每一天的时间基本上会被各种库升级、依赖服务升级、中间件升级、jar包冲突占满，最终这个应用变成了一个不敢升级、不敢部署、不敢写新功能、并且随时会爆发的炸弹，终有一天会给你带来惊喜。</p>
<p><strong>问题2-可拓展性差</strong></p>
<p>事务脚本式代码的第二大缺陷是：虽然写单个用例的代码非常高效简单，但是当用例多起来时，其扩展性会变得越来越差。</p>
<p><strong>可扩展性 &#x3D; 做新需求或改逻辑时，需要新增&#x2F;修改多少代码</strong></p>
<p>参考以上的代码，如果今天需要增加一个跨行转账的能力，你会发现基本上需要重新开发，基本上没有任何的可复用性：</p>
<ul>
<li><strong>数据来源被固定、数据格式不兼容：</strong>原有的AccountDO是从本地获取的，而跨行转账的数据可能需要从一个第三方服务获取，而服务之间数据格式不太可能是兼容的，导致从数据校验、数据读写、到异常处理、金额计算等逻辑都要重写。</li>
<li><strong>业务逻辑无法复用：</strong>数据格式不兼容的问题会导致核心业务逻辑无法复用。每个用例都是特殊逻辑的后果是最终会造成大量的if-else语句，而这种分支多的逻辑会让分析代码非常困难，容易错过边界情况，造成bug。</li>
<li><strong>逻辑和数据存储的相互依赖：</strong>当业务逻辑增加变得越来越复杂时，新加入的逻辑很有可能需要对数据库schema或消息格式做变更。而变更了数据格式后会导致原有的其他逻辑需要一起跟着动。在最极端的场景下，一个新功能的增加会导致所有原有功能的重构，成本巨大。</li>
</ul>
<p>在事务脚本式的架构下，一般做第一个需求都非常的快，但是做第N个需求时需要的时间很有可能是呈指数级上升的，绝大部分时间花费在老功能的重构和兼容上，最终你的创新速度会跌为0，促使老应用被推翻重构。</p>
<p><strong>问题3-可测试性能差</strong></p>
<p>除了部分工具类、框架类和中间件类的代码有比较高的测试覆盖之外，我们在日常工作中很难看到业务代码有比较好的测试覆盖，而绝大部分的上线前的测试属于人肉的“集成测试”。低测试率导致我们对代码质量很难有把控，容易错过边界条件，异常case只有线上爆发了才被动发现。而低测试覆盖率的主要原因是业务代码的可测试性比较差。</p>
<p><strong>可测试性 &#x3D; 运行每个测试用例所花费的时间 * 每个需求所需要增加的测试用例数量</strong></p>
<p>参考以上的一段代码，这种代码有极低的可测试性：</p>
<ul>
<li>设施搭建困难：当代码中强依赖了数据库、第三方服务、中间件等外部依赖之后，想要完整跑通一个测试用例需要确保所有依赖都能跑起来，这个在项目早期是及其困难的。在项目后期也会由于各种系统的不稳定性而导致测试无法通过。</li>
<li>运行耗时长：大多数的外部依赖调用都是I&#x2F;O密集型，如跨网络调用、磁盘调用等，而这种I&#x2F;O调用在测试时需要耗时很久。另一个经常依赖的是笨重的框架如Spring，启动Spring容器通常需要很久。当一个测试用例需要花超过10秒钟才能跑通时，绝大部分开发都不会很频繁的测试。</li>
<li>耦合度高：假如一段脚本中有A、B、C三个子步骤，而每个步骤有N个可能的状态，当多个子步骤耦合度高时，为了完整覆盖所有用例，最多需要有N <em>N</em> N个测试用例。当耦合的子步骤越多时，需要的测试用例呈指数级增长。</li>
</ul>
<p>在事务脚本模式下，当测试用例复杂度远大于真实代码复杂度，当运行测试用例的耗时超出人肉测试时，绝大部分人会选择不写完整的测试覆盖，而这种情况通常就是bug很难被早点发现的原因。</p>
<p><strong>总结分析</strong></p>
<p>我们重新来分析一下为什么以上的问题会出现？因为以上的代码违背了至少以下几个软件设计的原则：</p>
<ul>
<li><strong>单一性原则（Single Responsibility Principle）：</strong>单一性原则要求一个对象&#x2F;类应该只有一个变更的原因。但是在这个案例里，代码可能会因为任意一个外部依赖或计算逻辑的改变而改变。</li>
<li><strong>依赖反转原则（Dependency Inversion Principle）：</strong>依赖反转原则要求在代码中依赖抽象，而不是具体的实现。在这个案例里外部依赖都是具体的实现，比如YahooForexService虽然是一个接口类，但是它对应的是依赖了Yahoo提供的具体服务，所以也算是依赖了实现。同样的KafkaTemplate、MyBatis的DAO实现都属于具体实现。</li>
<li><strong>开放封闭原则（Open Closed Principle）：</strong>开放封闭原则指开放扩展，但是封闭修改。在这个案例里的金额计算属于可能会被修改的代码，这个时候该逻辑应该需要被包装成为不可修改的计算类，新功能通过计算类的拓展实现。</li>
</ul>
<p>我们需要对代码重构才能解决这些问题。</p>
<h1 id="2、重构方案"><a href="#2、重构方案" class="headerlink" title="2、重构方案"></a>2、重构方案</h1><p>在重构之前，我们先画一张流程图，描述当前代码在做的每个步骤：</p>
<p><img src="/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/1.png" alt="image.png"></p>
<p>这是一个传统的三层分层结构：UI层、业务层、和基础设施层。上层对于下层有直接的依赖关系，导致耦合度过高。在业务层中对于下层的基础设施有强依赖，耦合度高。我们需要对这张图上的每个节点做抽象和整理，来降低对外部依赖的耦合度。</p>
<p><strong>2.1 - 抽象数据存储层</strong></p>
<p>第一步常见的操作是将Data Access层做抽象，降低系统对数据库的直接依赖。具体的方法如下：</p>
<ul>
<li>新建Account实体对象：一个实体（Entity）是拥有ID的域对象，除了拥有数据之外，同时拥有行为。Entity和数据库储存格式无关，在设计中要以该领域的通用严谨语言（Ubiquitous Language）为依据。</li>
<li>新建对象储存接口类AccountRepository：Repository只负责Entity对象的存储和读取，而Repository的实现类完成数据库存储的细节。通过加入Repository接口，底层的数据库连接可以通过不同的实现类而替换。</li>
</ul>
<p>具体的简单代码实现如下：</p>
<p>Account实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AccountId id;</span><br><span class="line">    <span class="keyword">private</span> AccountNumber accountNumber;</span><br><span class="line">    <span class="keyword">private</span> UserId userId;</span><br><span class="line">    <span class="keyword">private</span> Money available;</span><br><span class="line">    <span class="keyword">private</span> Money dailyLimit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Money money)</span> &#123;</span><br><span class="line">        <span class="comment">// 转出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(Money money)</span> &#123;</span><br><span class="line">        <span class="comment">// 转入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和AccountRepository及MyBatis实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountRepository</span> &#123;</span><br><span class="line">    Account <span class="title function_">find</span><span class="params">(AccountId id)</span>;</span><br><span class="line">    Account <span class="title function_">find</span><span class="params">(AccountNumber accountNumber)</span>;</span><br><span class="line">    Account <span class="title function_">find</span><span class="params">(UserId userId)</span>;</span><br><span class="line">    Account <span class="title function_">save</span><span class="params">(Account account)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountRepositoryImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountRepository</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountDAO;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountBuilder accountBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">find</span><span class="params">(AccountId id)</span> &#123;</span><br><span class="line">        <span class="type">AccountDO</span> <span class="variable">accountDO</span> <span class="operator">=</span> accountDAO.selectById(id.getValue());</span><br><span class="line">        <span class="keyword">return</span> accountBuilder.toAccount(accountDO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">find</span><span class="params">(AccountNumber accountNumber)</span> &#123;</span><br><span class="line">        <span class="type">AccountDO</span> <span class="variable">accountDO</span> <span class="operator">=</span> accountDAO.selectByAccountNumber(accountNumber.getValue());</span><br><span class="line">        <span class="keyword">return</span> accountBuilder.toAccount(accountDO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">find</span><span class="params">(UserId userId)</span> &#123;</span><br><span class="line">        <span class="type">AccountDO</span> <span class="variable">accountDO</span> <span class="operator">=</span> accountDAO.selectByUserId(userId.getId());</span><br><span class="line">        <span class="keyword">return</span> accountBuilder.toAccount(accountDO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">save</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">        <span class="type">AccountDO</span> <span class="variable">accountDO</span> <span class="operator">=</span> accountBuilder.fromAccount(account);</span><br><span class="line">        <span class="keyword">if</span> (accountDO.getId() == <span class="literal">null</span>) &#123;</span><br><span class="line">            accountDAO.insert(accountDO);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            accountDAO.update(accountDO);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> accountBuilder.toAccount(accountDO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Account实体类和AccountDO数据类的对比如下：</p>
<ul>
<li><strong>Data Object数据类：</strong>AccountDO是单纯的和数据库表的映射关系，每个字段对应数据库表的一个column，这种对象叫Data Object。DO只有数据，没有行为。AccountDO的作用是对数据库做快速映射，避免直接在代码里写SQL。无论你用的是MyBatis还是Hibernate这种ORM，从数据库来的都应该先直接映射到DO上，但是代码里应该完全避免直接操作 DO。</li>
<li><strong>Entity实体类：</strong>Account 是基于领域逻辑的实体类，它的字段和数据库储存不需要有必然的联系。Entity包含数据，同时也应该包含行为。在 Account 里，字段也不仅仅是String等基础类型，而应该尽可能用上一讲的 Domain Primitive 代替，可以避免大量的校验代码。</li>
</ul>
<p>DAO 和 Repository 类的对比如下：</p>
<ul>
<li>DAO对应的是一个特定的数据库类型的操作，相当于SQL的封装。所有操作的对象都是DO类，所有接口都可以根据数据库实现的不同而改变。比如，insert 和 update 属于数据库专属的操作。</li>
<li>Repository对应的是Entity对象读取储存的抽象，在接口层面做统一，不关注底层实现。比如，通过 save 保存一个Entity对象，但至于具体是 insert 还是 update 并不关心。Repository的具体实现类通过调用DAO来实现各种操作，通过Builder&#x2F;Factory对象实现AccountDO 到 Account之间的转化</li>
</ul>
<p><em>2.1.1 Repository和Entity</em></p>
<ul>
<li>通过Account对象，避免了其他业务逻辑代码和数据库的直接耦合，避免了当数据库字段变化时，大量业务逻辑也跟着变的问题。</li>
<li>通过Repository，改变业务代码的思维方式，让业务逻辑不再面向数据库编程，而是面向领域模型编程。</li>
<li>Account属于一个完整的内存中对象，可以比较容易的做完整的测试覆盖，包含其行为。</li>
<li>Repository作为一个接口类，可以比较容易的实现Mock或Stub，可以很容易测试。</li>
<li>AccountRepositoryImpl实现类，由于其职责被单一出来，只需要关注Account到AccountDO的映射关系和Repository方法到DAO方法之间的映射关系，相对于来说更容易测试。</li>
</ul>
<p><img src="/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/2.png" alt="image.png"></p>
<p><strong>2.2 - 抽象第三方服务</strong></p>
<p>类似对于数据库的抽象，所有第三方服务也需要通过抽象解决第三方服务不可控，入参出参强耦合的问题。在这个例子里我们抽象出 ExchangeRateService 的服务，和一个ExchangeRate的Domain Primitive类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ExchangeRateService</span> &#123;</span><br><span class="line">    ExchangeRate <span class="title function_">getExchangeRate</span><span class="params">(Currency source, Currency target)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExchangeRateServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">ExchangeRateService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> YahooForexService yahooForexService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ExchangeRate <span class="title function_">getExchangeRate</span><span class="params">(Currency source, Currency target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (source.equals(target)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExchangeRate</span>(BigDecimal.ONE, source, target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">forex</span> <span class="operator">=</span> yahooForexService.getExchangeRate(source.getValue(), target.getValue());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExchangeRate</span>(forex, source, target);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><em>2.2.1 防腐层（ACL）</em></p>
<p>这种常见的设计模式叫做Anti-Corruption Layer（防腐层或ACL）。很多时候我们的系统会去依赖其他的系统，而被依赖的系统可能包含不合理的数据结构、API、协议或技术实现，如果对外部系统强依赖，会导致我们的系统被”腐蚀“。这个时候，通过在系统间加入一个防腐层，能够有效的隔离外部依赖和内部逻辑，无论外部如何变更，内部代码可以尽可能的保持不变。</p>
<p><img src="/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/3.png" alt="image.png"></p>
<p>ACL 不仅仅只是多了一层调用，在实际开发中ACL能够提供更多强大的功能：</p>
<ul>
<li><strong>适配器：</strong>很多时候外部依赖的数据、接口和协议并不符合内部规范，通过适配器模式，可以将数据转化逻辑封装到ACL内部，降低对业务代码的侵入。在这个案例里，我们通过封装了ExchangeRate和Currency对象，转化了对方的入参和出参，让入参出参更符合我们的标准。</li>
<li><strong>缓存：</strong>对于频繁调用且数据变更不频繁的外部依赖，通过在ACL里嵌入缓存逻辑，能够有效的降低对于外部依赖的请求压力。同时，很多时候缓存逻辑是写在业务代码里的，通过将缓存逻辑嵌入ACL，能够降低业务代码的复杂度。</li>
<li><strong>兜底：</strong>如果外部依赖的稳定性较差，一个能够有效提升我们系统稳定性的策略是通过ACL起到兜底的作用，比如当外部依赖出问题后，返回最近一次成功的缓存或业务兜底数据。这种兜底逻辑一般都比较复杂，如果散落在核心业务代码中会很难维护，通过集中在ACL中，更加容易被测试和修改。</li>
<li><strong>易于测试：</strong>类似于之前的Repository，ACL的接口类能够很容易的实现Mock或Stub，以便于单元测试。</li>
<li><strong>功能开关：</strong>有些时候我们希望能在某些场景下开放或关闭某个接口的功能，或者让某个接口返回一个特定的值，我们可以在ACL配置功能开关来实现，而不会对真实业务代码造成影响。同时，使用功能开关也能让我们容易的实现Monkey测试，而不需要真正物理性的关闭外部依赖。</li>
</ul>
<p><img src="/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/4.png" alt="image.png"></p>
<p><strong>2.3 - 抽象中间件</strong></p>
<p>类似于2.2的第三方服务的抽象，对各种中间件的抽象的目的是让业务代码不再依赖中间件的实现逻辑。因为中间件通常需要有通用型，中间件的接口通常是String或Byte[] 类型的，导致序列化&#x2F;反序列化逻辑通常和业务逻辑混杂在一起，造成胶水代码。通过中间件的ACL抽象，减少重复胶水代码。</p>
<p>在这个案例里，我们通过封装一个抽象的AuditMessageProducer和AuditMessage DP对象，实现对底层kafka实现的隔离：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuditMessage</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserId userId;</span><br><span class="line">    <span class="keyword">private</span> AccountNumber source;</span><br><span class="line">    <span class="keyword">private</span> AccountNumber target;</span><br><span class="line">    <span class="keyword">private</span> Money money;</span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userId + <span class="string">&quot;,&quot;</span> + source + <span class="string">&quot;,&quot;</span> + target + <span class="string">&quot;,&quot;</span> + money + <span class="string">&quot;,&quot;</span> + date;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AuditMessage <span class="title function_">deserialize</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuditMessageProducer</span> &#123;</span><br><span class="line">    SendResult <span class="title function_">send</span><span class="params">(AuditMessage message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuditMessageProducerImpl</span> <span class="keyword">implements</span> <span class="title class_">AuditMessageProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TOPIC_AUDIT_LOG</span> <span class="operator">=</span> <span class="string">&quot;TOPIC_AUDIT_LOG&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> SendResult <span class="title function_">send</span><span class="params">(AuditMessage message)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">messageBody</span> <span class="operator">=</span> message.serialize();</span><br><span class="line">        kafkaTemplate.send(TOPIC_AUDIT_LOG, messageBody);</span><br><span class="line">        <span class="keyword">return</span> SendResult.success();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的分析和2.2类似，在此略过。</p>
<p><img src="/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/5.png" alt="image.png"></p>
<p><strong>2.4 - 封装业务逻辑</strong></p>
<p>在这个案例里，有很多业务逻辑是跟外部依赖的代码混合的，包括金额计算、账户余额的校验、转账限制、金额增减等。这种逻辑混淆导致了核心计算逻辑无法被有效的测试和复用。在这里，我们的解法是通过Entity、Domain Primitive和Domain Service封装所有的业务逻辑：</p>
<p><em>2.4.1 - 用Domain Primitive封装跟实体无关的无状态计算逻辑</em></p>
<p>在这个案例里使用ExchangeRate来封装汇率计算逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">exchangeRate</span> <span class="operator">=</span> BigDecimal.ONE;</span><br><span class="line"><span class="keyword">if</span> (sourceAccountDO.getCurrency().equals(targetCurrency)) &#123;</span><br><span class="line">    exchangeRate = yahooForex.getExchangeRate(sourceAccountDO.getCurrency(), targetCurrency);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">sourceAmount</span> <span class="operator">=</span> targetAmount.divide(exchangeRate, RoundingMode.DOWN);</span><br></pre></td></tr></table></figure>

<p>变为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExchangeRate</span> <span class="variable">exchangeRate</span> <span class="operator">=</span> exchangeRateService.getExchangeRate(sourceAccount.getCurrency(), targetMoney.getCurrency());</span><br><span class="line"><span class="type">Money</span> <span class="variable">sourceMoney</span> <span class="operator">=</span> exchangeRate.exchangeTo(targetMoney);</span><br></pre></td></tr></table></figure>

<p><em>2.4.2 - 用Entity封装单对象的有状态的行为，包括业务校验</em></p>
<p>用Account实体类封装所有Account的行为，包括业务校验如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AccountId id;</span><br><span class="line">    <span class="keyword">private</span> AccountNumber accountNumber;</span><br><span class="line">    <span class="keyword">private</span> UserId userId;</span><br><span class="line">    <span class="keyword">private</span> Money available;</span><br><span class="line">    <span class="keyword">private</span> Money dailyLimit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Currency <span class="title function_">getCurrency</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.available.getCurrency();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(Money money)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.getCurrency().equals(money.getCurrency())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidCurrencyException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.available = <span class="built_in">this</span>.available.add(money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Money money)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.available.compareTo(money) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InsufficientFundsException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.dailyLimit.compareTo(money) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DailyLimitExceededException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.available = <span class="built_in">this</span>.available.subtract(money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原有的业务代码则可以简化为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sourceAccount.deposit(sourceMoney);</span><br><span class="line">targetAccount.withdraw(targetMoney);</span><br></pre></td></tr></table></figure>

<p><strong>2.4.3 - 用Domain Service封装多对象逻辑</strong></p>
<p>在这个案例里，我们发现这两个账号的转出和转入实际上是一体的，也就是说这种行为应该被封装到一个对象中去。特别是考虑到未来这个逻辑可能会产生变化：比如增加一个扣手续费的逻辑。这个时候在原有的TransferService中做并不合适，在任何一个Entity或者Domain Primitive里也不合适，需要有一个新的类去包含跨域对象的行为。这种对象叫做Domain Service。</p>
<p>我们创建一个AccountTransferService的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountTransferService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account sourceAccount, Account targetAccount, Money targetMoney, ExchangeRate exchangeRate)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountTransferServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountTransferService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ExchangeRateService exchangeRateService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account sourceAccount, Account targetAccount, Money targetMoney, ExchangeRate exchangeRate)</span> &#123;</span><br><span class="line">        <span class="type">Money</span> <span class="variable">sourceMoney</span> <span class="operator">=</span> exchangeRate.exchangeTo(targetMoney);</span><br><span class="line">        sourceAccount.deposit(sourceMoney);</span><br><span class="line">        targetAccount.withdraw(targetMoney);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而原始代码则简化为一行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">accountTransferService.transfer(sourceAccount, targetAccount, targetMoney, exchangeRate);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/6.png" alt="image.png"></p>
<p><strong>2.5 - 重构后结果分析</strong></p>
<p>这个案例重构后的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransferServiceImplNew</span> <span class="keyword">implements</span> <span class="title class_">TransferService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AccountRepository accountRepository;</span><br><span class="line">    <span class="keyword">private</span> AuditMessageProducer auditMessageProducer;</span><br><span class="line">    <span class="keyword">private</span> ExchangeRateService exchangeRateService;</span><br><span class="line">    <span class="keyword">private</span> AccountTransferService accountTransferService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Boolean&gt; <span class="title function_">transfer</span><span class="params">(Long sourceUserId, String targetAccountNumber, BigDecimal targetAmount, String targetCurrency)</span> &#123;</span><br><span class="line">        <span class="comment">// 参数校验</span></span><br><span class="line">        <span class="type">Money</span> <span class="variable">targetMoney</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Money</span>(targetAmount, <span class="keyword">new</span> <span class="title class_">Currency</span>(targetCurrency));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读数据</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">sourceAccount</span> <span class="operator">=</span> accountRepository.find(<span class="keyword">new</span> <span class="title class_">UserId</span>(sourceUserId));</span><br><span class="line">        <span class="type">Account</span> <span class="variable">targetAccount</span> <span class="operator">=</span> accountRepository.find(<span class="keyword">new</span> <span class="title class_">AccountNumber</span>(targetAccountNumber));</span><br><span class="line">        <span class="type">ExchangeRate</span> <span class="variable">exchangeRate</span> <span class="operator">=</span> exchangeRateService.getExchangeRate(sourceAccount.getCurrency(), targetMoney.getCurrency());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">        accountTransferService.transfer(sourceAccount, targetAccount, targetMoney, exchangeRate);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存数据</span></span><br><span class="line">        accountRepository.save(sourceAccount);</span><br><span class="line">        accountRepository.save(targetAccount);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送审计消息</span></span><br><span class="line">        <span class="type">AuditMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuditMessage</span>(sourceAccount, targetAccount, targetMoney);</span><br><span class="line">        auditMessageProducer.send(message);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出来，经过重构后的代码有以下几个特征：</p>
<ul>
<li>业务逻辑清晰，数据存储和业务逻辑完全分隔。</li>
<li>Entity、Domain Primitive、Domain Service都是独立的对象，没有任何外部依赖，但是却包含了所有核心业务逻辑，可以单独完整测试。</li>
<li>原有的TransferService不再包括任何计算逻辑，仅仅作为组件编排，所有逻辑均delegate到其他组件。这种仅包含Orchestration（编排）的服务叫做Application Service（应用服务）。</li>
</ul>
<p>我们可以根据新的结构重新画一张图：</p>
<p><img src="/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/7.png" alt="image.png"></p>
<p>然后通过重新编排后该图变为：</p>
<p><img src="/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/8.png" alt="image.png"></p>
<p>我们可以发现，通过对外部依赖的抽象和内部逻辑的封装重构，应用整体的依赖关系变了：</p>
<ul>
<li>最底层不再是数据库，而是Entity、Domain Primitive和Domain Service。这些对象不依赖任何外部服务和框架，而是纯内存中的数据和操作。这些对象我们打包为Domain Layer（领域层）。领域层没有任何外部依赖关系。</li>
<li>再其次的是负责组件编排的Application Service，但是这些服务仅仅依赖了一些抽象出来的ACL类和Repository类，而其具体实现类是通过依赖注入注进来的。Application Service、Repository、ACL等我们统称为Application Layer（应用层）。应用层 依赖 领域层，但不依赖具体实现。</li>
<li>最后是ACL，Repository等的具体实现，这些实现通常依赖外部具体的技术实现和框架，所以统称为Infrastructure Layer（基础设施层）。Web框架里的对象如Controller之类的通常也属于基础设施层。</li>
</ul>
<p>如果今天能够重新写这段代码，考虑到最终的依赖关系，我们可能先写Domain层的业务逻辑，然后再写Application层的组件编排，最后才写每个外部依赖的具体实现。这种架构思路和代码组织结构就叫做Domain-Driven Design（领域驱动设计，或DDD）。所以DDD不是一个特殊的架构设计，而是所有Transction Script代码经过合理重构后一定会抵达的终点。</p>
<h1 id="3、DDD的六边形架构"><a href="#3、DDD的六边形架构" class="headerlink" title="3、DDD的六边形架构"></a>3、DDD的六边形架构</h1><p>在我们传统的代码里，我们一般都很注重每个外部依赖的实现细节和规范，但是今天我们需要敢于抛弃掉原有的理念，重新审视代码结构。在上面重构的代码里，如果抛弃掉所有Repository、ACL、Producer等的具体实现细节，我们会发现每一个对外部的抽象类其实就是输入或输出，类似于计算机系统中的I&#x2F;O节点。这个观点在CQRS架构中也同样适用，将所有接口分为Command（输入）和Query（输出）两种。除了I&#x2F;O之外其他的内部逻辑，就是应用业务的核心逻辑。基于这个基础，Alistair Cockburn在2005年提出了Hexagonal Architecture（六边形架构），又被称之为Ports and Adapters（端口和适配器架构）。</p>
<p><img src="/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/9.png" alt="image.png"></p>
<p>在这张图中：</p>
<ul>
<li>I&#x2F;O的具体实现在模型的最外层</li>
<li>每个I&#x2F;O的适配器在灰色地带</li>
<li>每个Hex的边是一个端口</li>
<li>Hex的中央是应用的核心领域模型</li>
</ul>
<p>在Hex中，架构的组织关系第一次变成了一个二维的内外关系，而不是传统一维的上下关系。同时在Hex架构中我们第一次发现UI层、DB层、和各种中间件层实际上是没有本质上区别的，都只是数据的输入和输出，而不是在传统架构中的最上层和最下层。</p>
<p>除了2005年的Hex架构，2008年 Jeffery Palermo的Onion Architecture（洋葱架构）和2017年 Robert Martin的Clean Architecture（干净架构），都是极为类似的思想。除了命名不一样、切入点不一样之外，其他的整体架构都是基于一个二维的内外关系。这也说明了基于DDD的架构最终的形态都是类似的。Herberto Graca有一个很全面的图包含了绝大部分现实中的端口类，值得借鉴。</p>
<p><img src="/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/10.png" alt="image.png"></p>
<p><strong>3.1 - 代码组织结构</strong></p>
<p>为了有效的组织代码结构，避免下层代码依赖到上层实现的情况，在Java中我们可以通过POM Module和POM依赖来处理相互的关系。通过Spring&#x2F;SpringBoot的容器来解决运行时动态注入具体实现的依赖的问题。一个简单的依赖关系图如下：</p>
<p><img src="/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/11.png" alt="image.png"><br><img src="/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/12.png" alt="image.png"></p>
<p><em>3.1.1 - Types 模块</em></p>
<p>Types模块是保存可以对外暴露的Domain Primitives的地方。Domain Primitives因为是无状态的逻辑，可以对外暴露，所以经常被包含在对外的API接口中，需要单独成为模块。Types模块不依赖任何类库，纯 POJO 。</p>
<p><img src="/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/13.png" alt="image.png"></p>
<p><em>3.1.2 - Domain 模块</em></p>
<p>Domain 模块是核心业务逻辑的集中地，包含有状态的Entity、领域服务Domain Service、以及各种外部依赖的接口类（如Repository、ACL、中间件等。Domain模块仅依赖Types模块，也是纯 POJO 。</p>
<p><img src="/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/14.png" alt="image.png"></p>
<p><em>3.1.3 - Application模块</em></p>
<p>Application模块主要包含Application Service和一些相关的类。Application模块依赖Domain模块。还是不依赖任何框架，纯POJO。</p>
<p><img src="/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/15.png" alt="image.png"></p>
<p><em>3.1.4 - Infrastructure模块</em></p>
<p>Infrastructure模块包含了Persistence、Messaging、External等模块。比如：Persistence模块包含数据库DAO的实现，包含Data Object、ORM Mapper、Entity到DO的转化类等。Persistence模块要依赖具体的ORM类库，比如MyBatis。如果需要用Spring-Mybatis提供的注解方案，则需要依赖Spring。</p>
<p><img src="/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/16.png" alt="image.png"></p>
<p><em>3.1.5 - Web模块</em></p>
<p>Web模块包含Controller等相关代码。如果用SpringMVC则需要依赖Spring。</p>
<p><img src="/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/17.png" alt="image.png"></p>
<p><em>3.1.6 - Start模块</em></p>
<p>Start模块是SpringBoot的启动类。</p>
<p><strong>3.2 - 测试</strong></p>
<ul>
<li>Types，Domain模块都属于无外部依赖的纯POJO，基本上都可以100%的被单元测试覆盖。</li>
<li>Application模块的代码依赖外部抽象类，需要通过测试框架去Mock所有外部依赖，但仍然可以100%被单元测试。</li>
<li>Infrastructure的每个模块的代码相对独立，接口数量比较少，相对比较容易写单测。但是由于依赖了外部I&#x2F;O，速度上不可能很快，但好在模块的变动不会很频繁，属于一劳永逸。</li>
<li>Web模块有两种测试方法：通过Spring的MockMVC测试，或者通过HttpClient调用接口测试。但是在测试时最好把Controller依赖的服务类都Mock掉。一般来说当你把Controller的逻辑都后置到Application Service中时，Controller的逻辑变得极为简单，很容易100%覆盖。</li>
<li>Start模块：通常应用的集成测试写在start里。当其他模块的单元测试都能100%覆盖后，集成测试用来验证整体链路的真实性。</li>
</ul>
<p><strong>3.3 - 代码的演进&#x2F;变化速度</strong></p>
<p>在传统架构中，代码从上到下的变化速度基本上是一致的，改个需求需要从接口、到业务逻辑、到数据库全量变更，而第三方变更可能会导致整个代码的重写。但是在DDD中不同模块的代码的演进速度是不一样的：</p>
<ul>
<li>Domain层属于核心业务逻辑，属于经常被修改的地方。比如：原来不需要扣手续费，现在需要了之类的。通过Entity能够解决基于单个对象的逻辑变更，通过Domain Service解决多个对象间的业务逻辑变更。</li>
<li>Application层属于Use Case（业务用例）。业务用例一般都是描述比较大方向的需求，接口相对稳定，特别是对外的接口一般不会频繁变更。添加业务用例可以通过新增Application Service或者新增接口实现功能的扩展。</li>
<li>Infrastructure层属于最低频变更的。一般这个层的模块只有在外部依赖变更了之后才会跟着升级，而外部依赖的变更频率一般远低于业务逻辑的变更频率。</li>
</ul>
<p>所以在DDD架构中，能明显看出越外层的代码越稳定，越内层的代码演进越快，真正体现了领域“驱动”的核心思想。</p>
<h1 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h1><p>DDD不是一个什么特殊的架构，而是任何传统代码经过合理的重构之后最终一定会抵达的终点。DDD的架构能够有效的解决传统架构中的问题：</p>
<ul>
<li><strong>高可维护性：</strong>当外部依赖变更时，内部代码只用变更跟外部对接的模块，其他业务逻辑不变。</li>
<li><strong>高可扩展性：</strong>做新功能时，绝大部分的代码都能复用，仅需要增加核心业务逻辑即可。</li>
<li><strong>高可测试性：</strong>每个拆分出来的模块都符合单一性原则，绝大部分不依赖框架，可以快速的单元测试，做到100%覆盖。</li>
<li><strong>代码结构清晰：</strong>通过POM module可以解决模块间的依赖关系， 所有外接模块都可以单独独立成Jar包被复用。当团队形成规范后，可以快速的定位到相关代码。</li>
</ul>
]]></content>
      <categories>
        <category>DDD领域驱动设计</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>Gossip协议</title>
    <url>/2022/10/24/Gossip%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>我是一个小病毒，其他病毒都叫我小 B，我长得就是下图这个样子了。</p>
<p><img src="/2022/10/24/Gossip%E5%8D%8F%E8%AE%AE/1.png" alt="图片">冠状病毒</p>
<p>我现在已经有 100 nm 大小了，我还有很多触角，人类把我的触角称为<code>冠</code>，所以给我起了个学术名：<code>冠状病毒</code>。对于这个学术名，我一直不满意，怎么能用外貌来取名呢，这是<code>以貌取毒</code>。</p>
<p>我出生在一个蝙蝠身上，每到晚上，这只动物就到处觅食，它最喜欢的就是在森林中觅食，但最近森林的范围急剧减少，它不得不到人类居住的城市来觅食，看着五颜六色的灯光，我如痴如醉。</p>
<p><img src="/2022/10/24/Gossip%E5%8D%8F%E8%AE%AE/2.png" alt="图片">出生在一只蝙蝠身上</p>
<p>这只蝙蝠携带了 100 多种病毒，比如<code>埃博拉</code>病毒、<code>MERS</code> 病毒，我每天和这些病毒一起嬉戏游玩。<code>SARS 病毒</code>是我的近亲，2002 年的时候，它还造成了一次不小的传染病疫情，轰动了整个病毒界，人类称它为<code>非典</code>。</p>
<p><img src="/2022/10/24/Gossip%E5%8D%8F%E8%AE%AE/3.png" alt="图片">蝙蝠携带的病毒</p>
<h2 id="二、意外"><a href="#二、意外" class="headerlink" title="二、意外"></a>二、意外</h2><p>这天晚上，乌云密布，空气混浊，蝙蝠飞到了密林深处，突然浑身被一股电流击中，猝然倒地，一只大网将其捕获，随之而来的是穿着一袭黑色大衣的人类把蝙蝠关进了笼子里面。</p>
<p><img src="/2022/10/24/Gossip%E5%8D%8F%E8%AE%AE/4.png" alt="图片">被抓住了（图片来源于网络）</p>
<p>随后的几天，蝙蝠一直被关在笼子里面，直到有一天，蝙蝠被带到了一个随处可见野生动物的地方，但这些动物要么是被粗绳绑起来了，要么是被关在铁笼里。一个肥头大耳的人类走进了蝙蝠，他将手里攒着的一大叠<code>钞票</code>给了黑衣人后，带走了蝙蝠。</p>
<p>蝙蝠可能与肥头大耳的人类走得太近，我被传到了人类的的<code>手</code>上，随后又通过他接触的<code>食物</code>进入到了他的<code>口</code>中，进而进入到了他的体内。</p>
<h2 id="三、种子节点"><a href="#三、种子节点" class="headerlink" title="三、种子节点"></a>三、种子节点</h2><p>进入到人体中后，我欺骗了人类的<code>免疫系统</code>，顺利进入到人体细胞中，释放自己的 <code>RNA</code>，通过正常细胞的 <code>RNA 聚合酶</code>来复制自己的 RNA，从而<code>复制</code>出更多的病毒，进而<code>攻击</code>人体肺部器官。</p>
<p>过了几天后，这名人类出现了<code>发烧</code>现象，同时伴有<code>咳嗽</code>症状，而我的同伴也通过<code>喷嚏</code>传到了其他人体中，同样开始<code>大量复制</code>自己。</p>
<p><strong>一传十，十传百，这个地级市已有数千名人类被病毒感染</strong>。而我就被称作<code>种子节点</code>，而那名人类被称作<code>零号病人</code>。</p>
<h2 id="四、Gossip-协议"><a href="#四、Gossip-协议" class="headerlink" title="四、Gossip 协议"></a>四、Gossip 协议</h2><p>人体内的正常细胞对我的传染性非常感兴趣。</p>
<blockquote>
<p>“</p>
<p><strong>正常细胞</strong>：“冠状大哥，你是怎么这么快进行传播的啊？”</p>
<p><strong>我</strong>：“其实我是利用了 <code>Gossip</code> 协议。”</p>
<p><strong>我</strong>：Gossip 主要有三大功能，直接邮寄、反熵、谣言传播。</p>
<p>”</p>
</blockquote>
<p>Gossip 的中文意思就是<code>流言蜚语</code>，该协议就像流言蜚语一样，利用一种<code>随机</code>、带有<code>传染性</code>的方式，将信息传播到整个网络中，并在一定时间内，使得系统内的<code>所有节点数据一致</code>。这个就是实现了<code>最终一致性</code>的协议。</p>
<h3 id="4-1-直接邮寄"><a href="#4-1-直接邮寄" class="headerlink" title="4.1  直接邮寄"></a>4.1  直接邮寄</h3><p>直接发送需要更新的数据到其他节点，当数据<code>发送失败</code>时，将数据<code>缓存</code>下来，然后<code>重传</code>。如下图所示，人类 A 直接将病毒传染给了 C 和 E，而 B 和 D 没有被感染到，需要重新传染。</p>
<p><img src="/2022/10/24/Gossip%E5%8D%8F%E8%AE%AE/5.png" alt="图片">直接邮寄</p>
<p><strong>优点</strong>：实现容易，数据同步及时。</p>
<p><strong>缺点</strong>：可能会因为重试的缓存队列满了而丢数据。无法实现最终一致性。</p>
<p>那如何实现最终一致性呢？那就要用到第二种功能了：<code>反熵</code>。</p>
<h3 id="4-2-反熵"><a href="#4-2-反熵" class="headerlink" title="4.2 反熵"></a>4.2 反熵</h3><p><code>反熵</code>这个名词怎么理解呢？</p>
<p><code>熵</code>指混乱程度，<code>反熵</code>就是<code>消除</code>不同节点间数据的<code>差异</code>，<code>提升</code>节点间数据的<code>相似度</code>。</p>
<p>反熵的过程：</p>
<ul>
<li>（1）集群中的节点，每隔段时间就随机选择某个其他节点。</li>
<li>（2）互相交换自己的所有数据来消除两者之间的差异。</li>
<li>（3）实现数据的最终一致性。</li>
</ul>
<p>下面举个病毒传染的例子来说明反熵。</p>
<p>首先人类 A 被感染了两种病毒，分别是病毒 T 和病毒 R，如下图所示：</p>
<p><img src="/2022/10/24/Gossip%E5%8D%8F%E8%AE%AE/6.png" alt="图片">人类 A 感染了两种病毒</p>
<p>人类  E 被感染了三种病毒，分别是病毒 T、病毒 S、病毒 Y，如下图所示：</p>
<p><img src="/2022/10/24/Gossip%E5%8D%8F%E8%AE%AE/7.png" alt="图片">人类 E 被感染了四种病毒</p>
<p>人类 A 将携带的病毒 T 和 R 传染给了人类 E，而 E 本来就携带了病毒 T，所以最后会被传染四种病毒：T、S、Y、R。也就是说通过反熵的方式，修复了人类 E 中缺失的病毒 R。如下图所示：</p>
<p><img src="/2022/10/24/Gossip%E5%8D%8F%E8%AE%AE/8.png" alt="图片">人类 E 被感染了四种病毒</p>
<p>其实，反熵主要有三种方式：<code>推、拉、推和拉</code>。</p>
<h4 id="4-2-1-推"><a href="#4-2-1-推" class="headerlink" title="4.2.1 推"></a>4.2.1 推</h4><p><strong>推</strong>：将自己的副本数据推给对象，修复对方副本中的熵。</p>
<p>如下图所示，人类 A 将病毒 R 传染（<code>推</code>）给了人类 E，E 中就包含所有 A 的病毒了。</p>
<p><img src="/2022/10/24/Gossip%E5%8D%8F%E8%AE%AE/9.png" alt="图片">推</p>
<h4 id="4-2-2-拉"><a href="#4-2-2-拉" class="headerlink" title="4.2.2 拉"></a>4.2.2 拉</h4><p><strong>拉</strong>：拉取对方中的所有副本数据，修复自己副本中的熵。</p>
<p>如下图所示：人类 A 只有病毒 T 和 R，经过主动<code>拉</code>方式后，将人类 E 的病毒 S 和 病毒 Y 同步到人类 A 身上了，最后，人类 A 携带四种病毒：T、R、S、Y。</p>
<p><img src="/2022/10/24/Gossip%E5%8D%8F%E8%AE%AE/10.png" alt="图片">拉方式</p>
<h4 id="4-2-3-推拉"><a href="#4-2-3-推拉" class="headerlink" title="4.2.3 推拉"></a>4.2.3 推拉</h4><p><strong>推拉</strong>：同时修复自己副本和对象副本中的熵。</p>
<p>如下图所示：人类 A 和 人类 E 通过推拉的方式最后都被感染了相同的四种病毒：T、R、S、Y。</p>
<p><img src="/2022/10/24/Gossip%E5%8D%8F%E8%AE%AE/11.png" alt="图片">推拉</p>
<h4 id="4-2-4-反熵的缺点"><a href="#4-2-4-反熵的缺点" class="headerlink" title="4.2.4 反熵的缺点"></a>4.2.4 反熵的缺点</h4><p>（1）通过上面推、拉、推拉的方式，我们可以主要到，反熵是需要节点两两交换和比对自己所有的数据，这样来看的话，通讯成本是很高的，所以不建议实际场景中频繁地执行反熵。</p>
<p><strong>那有没有办法来减少反熵的次数呢？</strong></p>
<p>答案是有的，我们可以通过引入校验和等机制来降低需要对比的数据量和通讯信息。</p>
<p>（2）执行反熵时，相关节点都是已知的，且节点数量不能太多。如果节点动态变化或节点数过多，反熵就不合适。</p>
<p><strong>那有没有办法来解决动态、多节点的最终一致性呢？</strong></p>
<p>答案是有的，那就要用到 Gossip 协议的第三种传播功能了，谣言传播或者叫流行病传播。</p>
<h3 id="4-3-流行病传播"><a href="#4-3-流行病传播" class="headerlink" title="4.3 流行病传播"></a>4.3 流行病传播</h3><h4 id="4-3-1-过程"><a href="#4-3-1-过程" class="headerlink" title="4.3.1 过程"></a>4.3.1 过程</h4><p>Gossip 协议的第三种传播功能，流行病传播，也就是广泛地散播病毒。</p>
<p>如下图所示：A 传染给了 B 和 E，B 传染给了 C 和 D，D 传染给了 F 和 G。最后 ABCDEFG 都被感染了。</p>
<p><img src="/2022/10/24/Gossip%E5%8D%8F%E8%AE%AE/12.png" alt="图片">流行病传播过程</p>
<p>在分布式系统中，当一个节点有了新数据后，这个节点变成活跃状态，并周期性地联系其他节点向其发送新数据，直到所有节点都存储了该数据，可以理解为之前讲的反熵中的<code>推</code>的方式。如下图所示：</p>
<p><img src="/2022/10/24/Gossip%E5%8D%8F%E8%AE%AE/13.png" alt="图片">流行病传播方式&amp;图片来源于网络</p>
<h4 id="4-3-2-缺点"><a href="#4-3-2-缺点" class="headerlink" title="4.3.2 缺点"></a>4.3.2 缺点</h4><p>流行病传播的方式有如下缺点：</p>
<ul>
<li><strong>时间随机</strong>：所有节点达到一致性是一个随机性的概率。可以改进反熵的流程：使用闭环修复。</li>
<li><strong>消息冗余</strong>：同一节点会多次接收同一消息，增加消息处理的压力，每一次通信都会对网络带宽、CPU 资源造成负载，进而影响达到最终一致性的时间。</li>
<li><strong>拜占庭问题</strong>：如果有恶意节点出现，那么其他节点也会出问题。所以需要先修复故障节点。</li>
</ul>
<h4 id="4-3-3-优点"><a href="#4-3-3-优点" class="headerlink" title="4.3.3 优点"></a>4.3.3 优点</h4><ul>
<li><strong>支持动态、多节点</strong>：允许动态增加或减少节点，支持非常多的节点。</li>
<li><strong>大多数节点</strong>：不需要大多数节点正常运行也能达到最终一致性</li>
<li><strong>容错</strong>：任何节点重启或宕机都不会影响 Gossip 协议的运行，天然的分布式系统容错特性。</li>
<li><strong>去中心化</strong>：节点都是对等的，没有特殊节点。任何节点出现问题都不会阻止其他节点继续执行反熵。</li>
<li><strong>速度快</strong>：因为每个节点都可以进行传播，所以速度是指数级的，就像现在的新冠病毒一样。</li>
</ul>
<p>因为 Gossip 协议是一个带冗余的容错算法，为了保证最终一致性的算法。虽然所有节点达到一致的时间点不明确，但也可以通过改进反熵的执行过程来达到可预测，比如闭环反熵（不在本文展开论述）。</p>
<h3 id><a href="#" class="headerlink" title></a></h3><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本文通过一个携带冠状病毒的蝙蝠传染人类的故事来讲解了 Gossip 协议。</p>
<ul>
<li>Gossip 协议是一种<code>异步修复</code>、实现<code>最终一致性</code>的协议。优先考虑反熵。</li>
<li>反熵在<code>存储组件</code>中用得比较多。比如 Cassandra、InfluxDB。</li>
<li>谣言传播（流行病传播）具有传染性，节点之间<code>相互传染</code>。适合<code>动态变化</code>的<code>分布式系统</code>。比如 Cassandra 动态管理集群的节点状态。</li>
<li>实际场景，<code>直接邮寄</code>一定要实现，性能损耗最低。通过发送更新数据或缓存重传就能修复数据的不一致。</li>
<li>在存储组件中，节点已知，采用<code>反熵</code>修复数据副本的不一致。</li>
<li>集群节点变化时，或节点较多时，采用<code>谣言传播</code>方式，来同步更新多节点的数据，来实现最终一致性。</li>
<li>Gossip 的三种功能其实都是为了实现反熵，第一种用消息队列，第二种用推拉消息，第三种用散播谣言。</li>
<li>如果节点出现<code>故障</code>，需要先修复故障节点。</li>
</ul>
]]></content>
      <categories>
        <category>分布式一致性协议</category>
      </categories>
      <tags>
        <tag>分布式一致性协议</tag>
        <tag>Gossip协议</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM内部锁升级过程</title>
    <url>/2022/10/24/JVM%E5%86%85%E9%83%A8%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="谈谈JVM内部锁升级过程"><a href="#谈谈JVM内部锁升级过程" class="headerlink" title="谈谈JVM内部锁升级过程"></a>谈谈JVM内部锁升级过程</h2><p><strong>一 为什么讲这个？</strong></p>
<p>总结AQS之后，对这方面顺带的复习一下。本文从以下几个高频问题出发：</p>
<ul>
<li>对象在内存中的内存布局是什么样的？</li>
<li>描述synchronized和ReentrantLock的底层实现和重入的底层原理。</li>
<li>谈谈AQS，为什么AQS底层是CAS+volatile？</li>
<li>描述下锁的四种状态和锁升级过程？</li>
<li>Object  o &#x3D; new Object() 在内存中占用多少字节？</li>
<li>自旋锁是不是一定比重量级锁效率高？</li>
<li>打开偏向锁是否效率一定会提升？</li>
<li>重量级锁到底重在哪里？</li>
<li>重量级锁什么时候比轻量级锁效率高，同样反之呢？</li>
</ul>
<p><strong>二 加锁发生了什么？</strong></p>
<p>无意识中用到锁的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//System.out.println都加了锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(String x)</span> &#123;  </span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;    </span><br><span class="line">	print(x);    </span><br><span class="line">	newLine();  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>简单加锁发生了什么？</p>
<p>要弄清楚加锁之后到底发生了什么需要看一下对象创建之后再内存中的布局是个什么样的？</p>
<p>一个对象在new出来之后在内存中主要分为4个部分：</p>
<ul>
<li><p>markword这部分其实就是加锁的核心，同时还包含的对象的一些生命信息，例如是否GC、经过了几次Young GC还存活。</p>
</li>
<li><p>klass pointer记录了指向对象的class文件指针。</p>
</li>
<li><p>instance data记录了对象里面的变量数据。</p>
</li>
<li><p>padding作为对齐使用，对象在64位服务器版本中，规定对象内存必须要能被8字节整除，如果不能整除，那么就靠对齐来补。举个例子：new出了一个对象，内存只占用18字节，但是规定要能被8整除，所以padding&#x3D;6。</p>
</li>
</ul>
<p><img src="/2022/10/24/JVM%E5%86%85%E9%83%A8%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B/1.png" alt="图片"></p>
<p>知道了这4个部分之后，我们来验证一下底层。借助于第三方包 JOL  &#x3D; Java Object Layout java内存布局去看看。很简单的几行代码就可以看到内存布局的样式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JOLDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object  o;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>将结果打印出来：</p>
<p><img src="/2022/10/24/JVM%E5%86%85%E9%83%A8%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B/2.png" alt="图片"></p>
<p>从输出结果看：</p>
<p>1）对象头包含了12个字节分为3行，其中前2行其实就是markword，第三行就是klass指针。值得注意的是在加锁前后输出从001变成了000。Markword用处：8字节(64bit)的头记录一些信息，锁就是修改了markword的内容8字节(64bit)的头记录一些信息，锁就是修改了markword的内容字节(64bit)的头记录一些信息。从001无锁状态，变成了00轻量级锁状态。</p>
<p><img src="/2022/10/24/JVM%E5%86%85%E9%83%A8%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B/3.png" alt="图片"></p>
<p>2）New出一个object对象，占用16个字节。对象头占用12字节，由于Object中没有额外的变量，所以instance &#x3D; 0，考虑要对象内存大小要被8字节整除，那么padding&#x3D;4，最后new Object() 内存大小为16字节。</p>
<p>拓展：什么样的对象会进入老年代？很多场景例如对象太大了可以直接进入，但是这里想探讨的是为什么从Young GC的对象最多经历15次Young GC还存活就会进入Old区（年龄是可以调的，默认是15）。上图中hotspots的markword的图中，用了4个bit去表示分代年龄，那么能表示的最大范围就是0-15。所以这也就是为什么设置新生代的年龄不能超过15，工作中可以通过-XX:MaxTenuringThreshold去调整，但是一般我们不会动。</p>
<p><img src="/2022/10/24/JVM%E5%86%85%E9%83%A8%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B/4.png" alt="图片"></p>
<p><strong>三 锁的升级过程</strong></p>
<p>1 锁的升级验证</p>
<p>探讨锁的升级之前，先做个实验。两份代码，不同之处在于一个中途让它睡了5秒，一个没睡。看看是否有区别。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JOLDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object  o;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JOLDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object  o;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">5000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这两份代码会不会有什么区别？运行之后看看结果：</p>
<p><img src="/2022/10/24/JVM%E5%86%85%E9%83%A8%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B/5.png" alt="图片"></p>
<p><img src="/2022/10/24/JVM%E5%86%85%E9%83%A8%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B/6.png" alt="图片"></p>
<p>有点意思的是，让主线程睡了5s之后输出的内存布局跟没睡的输出结果居然不一样。</p>
<p>Syn锁升级之后，jdk1.8版本的一个底层默认设置4s之后偏向锁开启。也就是说在4s内是没有开启偏向锁的，加了锁就直接升级为轻量级锁了。</p>
<p>那么这里就有几个问题了？</p>
<ul>
<li><p>为什么要进行锁升级，以前不是默认syn就是重量级锁么？要么不用要么就用别的不行么？</p>
</li>
<li><p>既然4s内如果加了锁就直接到轻量级，那么能不能不要偏向锁，为什么要有偏向锁？</p>
</li>
<li><p>为什么要设置4s之后开始偏向锁？</p>
</li>
</ul>
<p><strong>问题1：为什么要进行锁升级？锁了就锁了，不就要加锁么？</strong></p>
<p>首先明确早起jdk1.2效率非常低。那时候syn就是重量级锁，申请锁必须要经过操作系统老大kernel进行系统调用，入队进行排序操作，操作完之后再返回给用户态。</p>
<p>内核态：用户态如果要做一些比较危险的操作直接访问硬件，很容易把硬件搞死（格式化，访问网卡，访问内存干掉、）操作系统为了系统安全分成两层，用户态和内核态 。申请锁资源的时候用户态要向操作系统老大内核态申请。Jdk1.2的时候用户需要跟内核态申请锁，然后内核态还会给用户态。这个过程是非常消耗时间的，导致早期效率特别低。有些jvm就可以处理的为什么还交给操作系统做去呢？能不能把jvm就可以完成的锁操作拉取出来提升效率，所以也就有了锁优化。</p>
<p><strong>问题2：为什么要有偏向锁？</strong></p>
<p>其实这本质上归根于一个概率问题，统计表示，在我们日常用的syn锁过程中70%-80%的情况下，一般都只有一个线程去拿锁，例如我们常使用的System.out.println、StringBuffer，虽然底层加了syn锁，但是基本没有多线程竞争的情况。那么这种情况下，没有必要升级到轻量级锁级别了。偏向的意义在于：第一个线程拿到锁，将自己的线程信息标记在锁上，下次进来就不需要在拿去拿锁验证了。如果超过1个线程去抢锁，那么偏向锁就会撤销，升级为轻量级锁，其实我认为严格意义上来讲偏向锁并不算一把真正的锁，因为只有一个线程去访问共享资源的时候才会有偏向锁这个情况。</p>
<p>无意使用到锁的场景：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***StringBuffer内部同步***/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println 无意识的使用锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(String x)</span> &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">     print(x);</span><br><span class="line">     newLine();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p><strong>问题3：为什么jdk8要在4s后开启偏向锁？</strong></p>
<p>其实这是一个妥协，明确知道在刚开始执行代码时，一定有好多线程来抢锁，如果开了偏向锁效率反而降低，所以上面程序在睡了5s之后偏向锁才开放。为什么加偏向锁效率会降低，因为中途多了几个额外的过程，上了偏向锁之后多个线程争抢共享资源的时候要进行锁升级到轻量级锁，这个过程还的把偏向锁进行撤销在进行升级，所以导致效率会降低。为什么是4s？这是一个统计的时间值。</p>
<p>当然我们是可以禁止偏向锁的，通过配置参数-XX:-UseBiasedLocking &#x3D; false来禁用偏向锁。jdk15之后默认已经禁用了偏向锁。本文是在jdk8的环境下做的锁升级验证。</p>
<p>2 锁的升级流程</p>
<p>上面已经验证了对象从创建出来之后进内存从无锁状态-&gt;偏向锁（如果开启了）-&gt;轻量级锁的过程。对于锁升级的流程继续往下，轻量级锁之后就会变成重量级锁。首先我们先理解什么叫做轻量级锁，从一个线程抢占资源（偏向锁）到多线程抢占资源升级为轻量级锁，线程如果没那么多的话，其实这里就可以理解为CAS，也就是我们说的Compare and Swap，比较并交换值。在并发编程中最简单的一个例子就是并发包下面的原子操作类AtomicInteger。在进行类似++操作的时候，底层其实就是CAS锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">   <span class="type">int</span> var5;</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">       var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">   &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>问题4：什么情况下轻量级锁要升级为重量级锁呢？</strong></p>
<p>首先我们可以思考的是多个线程的时候先开启轻量级锁，如果它carry不了的情况下才会升级为重量级。那么什么情况下轻量级锁会carry不住。1、如果线程数太多，比如上来就是10000个，那么这里CAS要转多久才可能交换值，同时CPU光在这10000个活着的线程中来回切换中就耗费了巨大的资源，这种情况下自然就升级为重量级锁，直接叫给操作系统入队管理，那么就算10000个线程那也是处理休眠的情况等待排队唤醒。2、CAS如果自旋10次依然没有获取到锁，那么也会升级为重量级。</p>
<p>总的来说2种情况会从轻量级升级为重量级，10次自旋或等待cpu调度的线程数超过cpu核数的一半，自动升级为重量级锁。看服务器CPU的核数怎么看，输入top指令，然后按1就可以看到。</p>
<p><strong>问题5：都说syn为重量级锁，那么到底重在哪里？</strong></p>
<p>JVM偷懒把任何跟线程有关的操作全部交给操作系统去做，例如调度锁的同步直接交给操作系统去执行，而在操作系统中要执行先要入队，另外操作系统启动一个线程时需要消耗很多资源，消耗资源比较重，重就重在这里。</p>
<p>整个锁升级过程如图所示：</p>
<p><img src="/2022/10/24/JVM%E5%86%85%E9%83%A8%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B/7.png" alt="图片"></p>
<p><strong>四 synchronized的底层实现</strong></p>
<p>上面我们对对象的内存布局有了一些了解之后，知道锁的状态主要存放在markword里面。这里我们看看底层实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RnEnterLockDemo</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对这段简单代码进行反解析看看什么情况。javap -c RnEnterLockDemo.class</p>
<p><img src="/2022/10/24/JVM%E5%86%85%E9%83%A8%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B/8.png" alt="图片"></p>
<p>首先我们能确定的是syn肯定是还有加锁的操作，看到的信息中出现了monitorenter和monitorexit，主观上就可以猜到这是跟加锁和解锁相关的指令。有意思的是1个monitorenter和2个monitorexit。为什么呢？正常来说应该就是一个加锁和一个释放锁啊。其实这里也体现了syn和lock的区别。syn是JVM层面的锁，如果异常了不用自己释放，jvm会自动帮助释放，这一步就取决于多出来的那个monitorexit。而lock异常需要我们手动补获并释放的。</p>
<p>关于这两条指令的作用，我们直接参考JVM规范中描述：</p>
<blockquote>
<p>monitorenter ：</p>
<p>Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows: • If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor. • If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count. • If another thread already owns the monitor associated with objectref, the thread blocks until the monitor’s entry count is zero, then tries again to gain ownership</p>
</blockquote>
<p>翻译一下：</p>
<p>每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</p>
<ul>
<li><p>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</p>
</li>
<li><p>如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1。</p>
</li>
<li><p>如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</p>
</li>
</ul>
<blockquote>
<p>monitorexit：　</p>
<p>The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref. The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.</p>
</blockquote>
<p>翻译一下：</p>
<p>执行monitorexit的线程必须是objectref所对应的monitor的所有者。指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor的所有权。 </p>
<p>通过这段话的描述，很清楚的看出Synchronized的实现原理，Synchronized底层通过一个monitor的对象来完成，wait&#x2F;notify等方法其实也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait&#x2F;notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常。</p>
<p>每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针。</p>
<p>当执行monitorenter时，如果目标对象的计数器为零，那么说明它没有被其他线程所持有，Java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加i。在目标锁对象的计数器不为零的情况下，如果锁对象的持有线程是当前线程，那么Java虚拟机可以将其计数器加1，否则需要等待，直至持有线程释放该锁。当执行monitorexit时，Java虚拟机则需将锁对象的计数器减1。计数器为零代表锁已被释放。</p>
<p><strong>总结</strong></p>
<p>以往的经验中，只要用到synchronized就以为它已经成为了重量级锁。在jdk1.2之前确实如此，后来发现太重了，消耗了太多操作系统资源，所以对synchronized进行了优化。以后可以直接用，至于锁的力度如何，JVM底层已经做好了我们直接用就行。</p>
<p>最后再看看开头的几个问题，是不是都理解了呢。带着问题去研究，往往会更加清晰。希望对大家有所帮助。</p>
]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>Java并发编程</tag>
        <tag>synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK/Dubbo/Spring 三种 SPI 机制，谁更好？</title>
    <url>/2022/10/21/JDKDubboSpring%20%E4%B8%89%E7%A7%8D%20SPI%20%E6%9C%BA%E5%88%B6%EF%BC%8C%E8%B0%81%E6%9B%B4%E5%A5%BD/</url>
    <content><![CDATA[<h1 id="JDK-x2F-Dubbo-x2F-Spring-三种-SPI-机制，谁更好？"><a href="#JDK-x2F-Dubbo-x2F-Spring-三种-SPI-机制，谁更好？" class="headerlink" title="JDK&#x2F;Dubbo&#x2F;Spring 三种 SPI 机制，谁更好？"></a>JDK&#x2F;Dubbo&#x2F;Spring 三种 SPI 机制，谁更好？</h1><blockquote>
<p>SPI 全称为 Service Provider Interface，是一种服务发现机制。SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。正因此特性，我们可以很容易的通过 SPI 机制为我们的程序提供拓展功能。</p>
</blockquote>
<p>本文主要是特性 &amp; 用法介绍，不涉及源码解析（源码都很简单，相信你一定一看就懂）</p>
<h2 id="SPI-有什么用？"><a href="#SPI-有什么用？" class="headerlink" title="SPI 有什么用？"></a>SPI 有什么用？</h2><p>举个栗子，现在我们设计了一款全新的日志框架：<strong>super-logger</strong>。默认以XML文件作为我们这款日志的配置文件，并设计了一个配置文件解析的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.kongwu.spisamples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SuperLoggerConfiguration</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(String configFile)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后来一个默认的XML实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.kongwu.spisamples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XMLConfiguration</span> <span class="keyword">implements</span> <span class="title class_">SuperLoggerConfiguration</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(String configFile)</span>&#123;</span><br><span class="line">    	......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么我们在初始化，解析配置时，只需要调用这个XMLConfiguration来解析XML配置文件即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.kongwu.spisamples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">SuperLoggerConfiguration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLConfiguration</span>();</span><br><span class="line">		configuration.configure(configFile);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">getLogger</span><span class="params">(Class clazz)</span>&#123;</span><br><span class="line">    	......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样就完成了一个基础的模型，看起来也没什么问题。不过扩展性不太好，因为如果想定制&#x2F;扩展&#x2F;重写解析功能的话，我还得重新定义入口的代码，LoggerFactory 也得重写，不够灵活，侵入性太强了。</p>
<p>比如现在用户&#x2F;使用方想增加一个 yml 文件的方式，作为日志配置文件，那么只需要新建一个YAMLConfiguration，实现 SuperLoggerConfiguration 就可以。但是……怎么注入呢，怎么让 LoggerFactory中使用新建的这个 YAMLConfiguration ？难不成连 LoggerFactory 也重写了？</p>
<p>如果借助SPI机制的话，这个事情就很简单了，可以很方便的完成这个入口的扩展功能。</p>
<p>下面就先来看看，利用JDK 的 SPI 机制怎么解决上面的扩展性问题。</p>
<h2 id="JDK-SPI"><a href="#JDK-SPI" class="headerlink" title="JDK SPI"></a>JDK SPI</h2><p>JDK 中 提供了一个 SPI 的功能，核心类是 java.util.ServiceLoader。其作用就是，可以通过类名获取在”META-INF&#x2F;services&#x2F;“下的多个配置实现文件。</p>
<p>为了解决上面的扩展问题，现在我们在<code>META-INF/services/</code>下创建一个<code>com.github.kongwu.spisamples.SuperLoggerConfiguration</code>文件（没有后缀）。文件中只有一行代码，那就是我们默认的<code>com.github.kongwu.spisamples.XMLConfiguration</code>（注意，一个文件里也可以写多个实现，回车分隔）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">META-INF/services/com.github.kongwu.spisamples.SuperLoggerConfiguration:</span><br><span class="line"></span><br><span class="line">com.github.kongwu.spisamples.XMLConfiguration</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后通过 ServiceLoader 获取我们的 SPI 机制配置的实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServiceLoader&lt;SuperLoggerConfiguration&gt; serviceLoader = ServiceLoader.load(SuperLoggerConfiguration.class);</span><br><span class="line">Iterator&lt;SuperLoggerConfiguration&gt; iterator = serviceLoader.iterator();</span><br><span class="line">SuperLoggerConfiguration configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">    <span class="comment">//加载并初始化实现类</span></span><br><span class="line">	configuration = iterator.next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对最后一个configuration类调用configure方法</span></span><br><span class="line">configuration.configure(configFile);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后在调整LoggerFactory中初始化配置的方式为现在的SPI方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.kongwu.spisamples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">        ServiceLoader&lt;SuperLoggerConfiguration&gt; serviceLoader = ServiceLoader.load(SuperLoggerConfiguration.class);</span><br><span class="line">        Iterator&lt;SuperLoggerConfiguration&gt; iterator = serviceLoader.iterator();</span><br><span class="line">        SuperLoggerConfiguration configuration;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">            configuration = iterator.next();<span class="comment">//加载并初始化实现类</span></span><br><span class="line">        &#125;</span><br><span class="line">        configuration.configure(configFile);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">getLogger</span><span class="params">(Class clazz)</span>&#123;</span><br><span class="line">    	......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>等等，这里为什么是用 iterator ? 而不是get之类的只获取一个实例的方法？</strong></p>
<p>试想一下，如果是一个固定的get方法，那么get到的是一个固定的实例，SPI 还有什么意义呢？</p>
<p>SPI 的目的，就是增强扩展性。将固定的配置提取出来，通过 SPI 机制来配置。那既然如此，一般都会有一个默认的配置，然后通过 SPI 的文件配置不同的实现，这样就会存在一个接口多个实现的问题。要是找到多个实现的话，用哪个实现作为最后的实例呢？</p>
<p>所以这里使用iterator来获取所有的实现类配置。刚才已经在我们这个 <strong>super-logger</strong> 包里增加了默认的SuperLoggerConfiguration 实现。</p>
<p>为了支持 YAML 配置，现在在使用方&#x2F;用户的代码里，增加一个YAMLConfiguration的 SPI 配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">META-INF/services/com.github.kongwu.spisamples.SuperLoggerConfiguration:</span><br><span class="line"></span><br><span class="line">com.github.kongwu.spisamples.ext.YAMLConfiguration</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>此时通过iterator方法，就会获取到默认的XMLConfiguration和我们扩展的这个YAMLConfiguration两个配置实现类了。</p>
<p>在上面那段加载的代码里，我们遍历iterator，遍历到最后，我们使用最后一个实现配置作为最终的实例。</p>
<p><strong>再等等？最后一个？怎么算最后一个？</strong></p>
<p>使用方&#x2F;用户自定义的的这个 YAMLConfiguration 一定是最后一个吗？</p>
<p>这个真的不一定，取决于我们运行时的 ClassPath 配置，在前面加载的jar自然在前，最后的jar里的自然当然也在后面。所以<strong>如果用户的包在ClassPath中的顺序比super-logger的包更靠后，才会处于最后一个位置；如果用户的包位置在前，那么所谓的最后一个仍然是默认的XMLConfiguration。</strong></p>
<p>举个栗子，如果我们程序的启动脚本为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -<span class="built_in">cp</span> super-logger.jar:a.jar:b.jar:main.jar example.Main</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>默认的XMLConfiguration SPI配置在<code>super-logger.jar</code>，扩展的YAMLConfiguration SPI配置文件在<code>main.jar</code>，那么iterator获取的最后一个元素一定为YAMLConfiguration。</p>
<p>但这个classpath顺序如果反了呢？main.jar 在前，super-logger.jar 在后</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -<span class="built_in">cp</span> main.jar:super-logger.jar:a.jar:b.jar example.Main</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>这样一来，iterator 获取的最后一个元素又变成了默认的XMLConfiguration，我们使用 JDK SPI 没啥意义了，获取的又是第一个，还是默认的XMLConfiguration。</p>
<p>由于这个加载顺序（classpath）是由用户指定的，所以无论我们加载第一个还是最后一个，都有可能会导致加载不到用户自定义的那个配置。</p>
<p><strong>所以这也是JDK SPI机制的一个劣势，无法确认具体加载哪一个实现，也无法加载某个指定的实现，仅靠ClassPath的顺序是一个非常不严谨的方式</strong></p>
<h2 id="Dubbo-SPI"><a href="#Dubbo-SPI" class="headerlink" title="Dubbo SPI"></a>Dubbo SPI</h2><blockquote>
<p>Dubbo 就是通过 SPI 机制加载所有的组件。不过，Dubbo 并未使用 Java 原生的 SPI 机制，而是对其进行了增强，使其能够更好的满足需求。在 Dubbo 中，SPI 是一个非常重要的模块。基于 SPI，我们可以很容易的对 Dubbo 进行拓展。如果大家想要学习 Dubbo 的源码，SPI 机制务必弄懂。接下来，我们先来了解一下 Java SPI 与 Dubbo SPI 的用法，然后再来分析 Dubbo SPI 的源码。</p>
</blockquote>
<p>Dubbo 中实现了一套新的 SPI 机制，功能更强大，也更复杂一些。相关逻辑被封装在了 ExtensionLoader 类中，通过 ExtensionLoader，我们可以加载指定的实现类。Dubbo SPI 所需的配置文件需放置在 META-INF&#x2F;dubbo 路径下，配置内容如下（以下demo来自dubbo官方文档）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">optimusPrime = org.apache.spi.OptimusPrime</span><br><span class="line">bumblebee = org.apache.spi.Bumblebee</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>与 Java SPI 实现类配置不同，Dubbo SPI 是通过键值对的方式进行配置，这样我们可以按需加载指定的实现类。另外在使用时还需要在接口上标注 @SPI 注解。下面来演示 Dubbo SPI 的用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Robot</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptimusPrime</span> <span class="keyword">implements</span> <span class="title class_">Robot</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I am Optimus Prime.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bumblebee</span> <span class="keyword">implements</span> <span class="title class_">Robot</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I am Bumblebee.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DubboSPITest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ExtensionLoader&lt;Robot&gt; extensionLoader = </span><br><span class="line">            ExtensionLoader.getExtensionLoader(Robot.class);</span><br><span class="line">        <span class="type">Robot</span> <span class="variable">optimusPrime</span> <span class="operator">=</span> extensionLoader.getExtension(<span class="string">&quot;optimusPrime&quot;</span>);</span><br><span class="line">        optimusPrime.sayHello();</span><br><span class="line">        <span class="type">Robot</span> <span class="variable">bumblebee</span> <span class="operator">=</span> extensionLoader.getExtension(<span class="string">&quot;bumblebee&quot;</span>);</span><br><span class="line">        bumblebee.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p><strong>Dubbo SPI 和 JDK SPI 最大的区别就在于支持“别名”</strong>，可以通过某个扩展点的别名来获取固定的扩展点。就像上面的例子中，我可以获取 Robot 多个 SPI 实现中别名为“optimusPrime”的实现，也可以获取别名为“bumblebee”的实现，这个功能非常有用！</p>
<p>通过 @SPI 注解的 value 属性，还可以默认一个“别名”的实现。比如在Dubbo 中，默认的是Dubbo 私有协议：<strong>dubbo protocol - dubbo:&#x2F;&#x2F;</strong> ** 来看看Dubbo中协议的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;dubbo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Protocol</span> &#123;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>在 Protocol 接口上，增加了一个 @SPI 注解，而注解的 value 值为 Dubbo ，通过 SPI 获取实现时就会获取 Protocol SPI 配置中别名为dubbo的那个实现，<code>com.alibaba.dubbo.rpc.Protocol</code>文件如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">filter=com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper</span><br><span class="line">listener=com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper</span><br><span class="line">mock=com.alibaba.dubbo.rpc.support.MockProtocol</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">injvm=com.alibaba.dubbo.rpc.protocol.injvm.InjvmProtocol</span><br><span class="line">rmi=com.alibaba.dubbo.rpc.protocol.rmi.RmiProtocol</span><br><span class="line">hessian=com.alibaba.dubbo.rpc.protocol.hessian.HessianProtocol</span><br><span class="line">com.alibaba.dubbo.rpc.protocol.http.HttpProtocol</span><br><span class="line">com.alibaba.dubbo.rpc.protocol.webservice.WebServiceProtocol</span><br><span class="line">thrift=com.alibaba.dubbo.rpc.protocol.thrift.ThriftProtocol</span><br><span class="line">memcached=com.alibaba.dubbo.rpc.protocol.memcached.MemcachedProtocol</span><br><span class="line">redis=com.alibaba.dubbo.rpc.protocol.redis.RedisProtocol</span><br><span class="line">rest=com.alibaba.dubbo.rpc.protocol.rest.RestProtocol</span><br><span class="line">registry=com.alibaba.dubbo.registry.integration.RegistryProtocol</span><br><span class="line">qos=com.alibaba.dubbo.qos.protocol.QosProtocolWrapper</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>然后只需要通过getDefaultExtension，就可以获取到 @SPI 注解上value对应的那个扩展实现了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Protocol</span> <span class="variable">protocol</span> <span class="operator">=</span> ExtensionLoader.getExtensionLoader(Protocol.class).getDefaultExtension();</span><br><span class="line"><span class="comment">//protocol: DubboProtocol</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>还有一个 Adaptive 的机制，虽然非常灵活，但……用法并不是很“优雅”，这里就不介绍了</p>
<p>Dubbo 的 SPI 中还有一个“加载优先级”，优先加载内置（internal）的，然后加载外部的（external），按优先级顺序加载，<strong>如果遇到重复就跳过不会加载</strong>了。</p>
<p>所以如果想靠classpath加载顺序去覆盖内置的扩展，也是个不太理智的做法，原因同上 - 加载顺序不严谨</p>
<h2 id="Spring-SPI"><a href="#Spring-SPI" class="headerlink" title="Spring SPI"></a>Spring SPI</h2><p>Spring 的 SPI 配置文件是一个固定的文件 - <code>META-INF/spring.factories</code>，功能上和 JDK 的类似，每个接口可以有多个扩展实现，使用起来非常简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取所有factories文件中配置的LoggingSystemFactory</span></span><br><span class="line">List&lt;LoggingSystemFactory&gt;&gt; factories = </span><br><span class="line">    SpringFactoriesLoader.loadFactories(LoggingSystemFactory.class, classLoader);</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>下面是一段 Spring Boot 中 spring.factories 的配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Logging Systems</span><br><span class="line">org.springframework.boot.logging.LoggingSystemFactory=\</span><br><span class="line">org.springframework.boot.logging.logback.LogbackLoggingSystem.Factory,\</span><br><span class="line">org.springframework.boot.logging.log4j2.Log4J2LoggingSystem.Factory,\</span><br><span class="line">org.springframework.boot.logging.java.JavaLoggingSystem.Factory</span><br><span class="line"></span><br><span class="line"># PropertySource Loaders</span><br><span class="line">org.springframework.boot.env.PropertySourceLoader=\</span><br><span class="line">org.springframework.boot.env.PropertiesPropertySourceLoader,\</span><br><span class="line">org.springframework.boot.env.YamlPropertySourceLoader</span><br><span class="line"></span><br><span class="line"># ConfigData Location Resolvers</span><br><span class="line">org.springframework.boot.context.config.ConfigDataLocationResolver=\</span><br><span class="line">org.springframework.boot.context.config.ConfigTreeConfigDataLocationResolver,\</span><br><span class="line">org.springframework.boot.context.config.StandardConfigDataLocationResolver</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>Spring SPI 中，将所有的配置放到一个固定的文件中，省去了配置一大堆文件的麻烦。至于多个接口的扩展配置，是用一个文件好，还是每个单独一个文件好这个，这个问题就见仁见智了（个人喜欢 Spring 这种，干净利落）。</p>
<p>Spring的SPI 虽然属于spring-framework(core)，但是目前主要用在spring boot中……</p>
<p>和前面两种 SPI 机制一样，Spring 也是支持 ClassPath 中存在多个 spring.factories 文件的，加载时会按照 classpath 的顺序依次加载这些 spring.factories 文件，添加到一个 ArrayList 中。由于没有别名，所以也没有去重的概念，有多少就添加多少。</p>
<p>但由于 Spring 的 SPI 主要用在 Spring Boot 中，而 Spring Boot 中的 ClassLoader 会优先加载项目中的文件，而不是依赖包中的文件。所以如果在你的项目中定义个spring.factories文件，那么你项目中的文件会被第一个加载，得到的Factories中，项目中spring.factories里配置的那个实现类也会排在第一个</p>
<p>如果我们要扩展某个接口的话，只需要在你的项目（spring boot）里新建一个<code>META-INF/spring.factories</code>文件，<strong>只添加你要的那个配置，不要完整的复制一遍 Spring Boot 的 spring.factories 文件然后修改</strong> 比如我只想添加一个新的 LoggingSystemFactory 实现，那么我只需要新建一个<code>META-INF/spring.factories</code>文件，而不是完整的复制+修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.logging.LoggingSystemFactory=\</span><br><span class="line">com.example.log4j2demo.Log4J2LoggingSystem.Factory</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><table>
<thead>
<tr>
<th></th>
<th>JDK SPI</th>
<th>DUBBO SPI</th>
<th>Spring SPI</th>
</tr>
</thead>
<tbody><tr>
<td>文件方式</td>
<td>每个扩展点单独一个文件</td>
<td>每个扩展点单独一个文件</td>
<td>所有的扩展点在一个文件</td>
</tr>
<tr>
<td>获取某个固定的实现</td>
<td>不支持，只能按顺序获取所有实现</td>
<td>有“别名”的概念，可以通过名称获取扩展点的某个固定实现，配合Dubbo SPI的注解很方便</td>
<td>不支持，只能按顺序获取所有实现。但由于Spring Boot ClassLoader会优先加载用户代码中的文件，所以可以保证用户自定义的spring.factoires文件在第一个，通过获取第一个factory的方式就可以固定获取自定义的扩展</td>
</tr>
<tr>
<td>其他</td>
<td>无</td>
<td>支持Dubbo内部的依赖注入，通过目录来区分Dubbo 内置SPI和外部SPI，优先加载内部，保证内部的优先级最高</td>
<td>无</td>
</tr>
<tr>
<td>文档完整度</td>
<td>文章 &amp; 三方资料足够丰富</td>
<td>文档 &amp; 三方资料足够丰富</td>
<td>文档不够丰富，但由于功能少，使用非常简单</td>
</tr>
<tr>
<td>IDE支持</td>
<td>无</td>
<td>无</td>
<td>IDEA 完美支持，有语法提示</td>
</tr>
</tbody></table>
<p>三种 SPI 机制对比之下，JDK 内置的机制是最弱鸡的，但是由于是 JDK 内置，所以还是有一定应用场景，毕竟不用额外的依赖；Dubbo 的功能最丰富，但机制有点复杂了，而且只能配合 Dubbo 使用，不能完全算是一个独立的模块；Spring 的功能和JDK的相差无几，最大的区别是所有扩展点写在一个 spring.factories 文件中，也算是一个改进，并且 IDEA 完美支持语法提示。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>日常生活</tag>
        <tag>杂文</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM知识点总结</title>
    <url>/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="java-程序编译和运行过程详解"><a href="#java-程序编译和运行过程详解" class="headerlink" title="java 程序编译和运行过程详解"></a>java 程序编译和运行过程详解</h2><p>java整个编译以及运行的过程相当繁琐，这里有个简单的例子。</p>
<h4 id="Java程序从源文件创建到程序运行要经过两大步骤："><a href="#Java程序从源文件创建到程序运行要经过两大步骤：" class="headerlink" title="Java程序从源文件创建到程序运行要经过两大步骤："></a>Java程序从源文件创建到程序运行要经过两大步骤：</h4><p>1、源文件由编译器编译成字节码（ByteCode）；<br>2、字节码由java虚拟机解释运行。因为java程序既要编译同时也要经过JVM的解释运行，所以说Java被称为半解释语言(“semi-interpreted” language)。</p>
<p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/1.png" alt="在这里插入图片描述"></p>
<h3 id="Java-程序运行过程"><a href="#Java-程序运行过程" class="headerlink" title="Java 程序运行过程"></a><strong>Java 程序运行过程</strong></h3><h3 id="第一步-编译过程"><a href="#第一步-编译过程" class="headerlink" title="第一步(编译过程)"></a>第一步(编译过程)</h3><p>创建完源文件之后，程序先要被JVM中的java编译器进行编译为.class文件。<br>1、java编译一个类时，如果这个类所依赖的类还没有被编译，编译器会自动的先编译这个所依赖的类，然后引用。<br>2、如果java编译器在指定的目录下找不到该类所依赖的类的 .class文件或者 .java源文件，就会报<br>        “Cant found sysbol”的异常错误。<br>3、编译后的字节码文件格式主要分为两部分：常量池和方法字节码。<br>常量池记录的是代码出现过的（常量、类名、成员变量等）以及符号引用（类引用、方法引用，成员变量引用等）；<br>方法字节码中放的是各个方法的字节码。</p>
<p>下面通过以下这个java程序，来说明java程序从编译到最后运行的整个流程。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java代码</span><br><span class="line"></span><br><span class="line"><span class="comment">//MainApp.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApp</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;Puppy&quot;</span>);</span><br><span class="line"></span><br><span class="line">animal.printName();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Animal.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printName</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Animal [&quot;</span>+name+<span class="string">&quot;]&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一步(编译): 创建完源文件之后，程序会先被编译为.class文件。Java编译一个类时，如果这个类所依赖的类还没有被编译，编译器就会先编译这个被依赖的类，然后引用，否则直接引用，这个有点象make。如果java编译器在指定目录下找不到该类所其依赖的类的.class文件或者.java源文件的话，编译器话报“cant find symbol”的错误。</p>
<p>编译后的字节码文件格式主要分为两部分：<strong>常量池和方法字节码</strong>。常量池记录的是代码出现过的所有token(类名，成员变量名等等)以及符号引用(方法引用，成员变量引用等等)；方法字节码放的是类中各个方法的字节码。下面是MainApp.class通过反汇编的结果，我们可以清楚看到.class文件的结构：</p>
<p> MainApp类常量池<br><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/2.png" alt="在这里插入图片描述"></p>
<p>MainApp类方法字节码<br><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/3.png" alt="在这里插入图片描述"></p>
<h3 id="第二步（运行阶段）"><a href="#第二步（运行阶段）" class="headerlink" title="第二步（运行阶段）"></a>第二步（运行阶段）</h3><p>JVM程序在第一次运行时主动使用类的时候，才会立即去加载。换言之，JVM并不是在运行时就会把所有使用到的类都加载到内存中，而是用到的时候，才加载进来，而且只加载一次！<br>java类运行的过程大概分为两个步骤：<br>（1）类的加载<br>（2）类的执行。<br>根据上面的程序，详解该程序运行的详细步骤：</p>
<h4 id="1、类的加载"><a href="#1、类的加载" class="headerlink" title="1、类的加载"></a>1、类的加载</h4><p>在类路径下找到编译好的 java 程序中；得到 Test.class 字节码文件后，在命令行上敲 java Test，系统就会启动一个 JVM 进程，JVM进程从classpath路径下找到一个名为Test.class的二进制文件，将Test.class文件中的类信息加载到运行时数据区的方法区中，这一过程叫做类的加载。（只有类信息在方法区中，才能创建对象，使用类中的成员变量）</p>
<h4 id="2、JVM-找到main方法的主函数入口"><a href="#2、JVM-找到main方法的主函数入口" class="headerlink" title="2、JVM 找到main方法的主函数入口"></a>2、JVM 找到main方法的主函数入口</h4><p>在主函数入口持有一个指向当前类(Test)常量池的指针，并且常量池中的第一项是发现是一个对Animal对象的符号引用。<br>并且main方法中第一条指令是Animal animal &#x3D; new Animal(“super_yc”)，就是让JVM创建一个Animal对象。<br>但是方法区中还没有Animal类的类信息，于是JVM就要马上的加载Animal类，将Animal类信息放入到方法区中。<br>于是JVM 以一个直接指向方法区 Animal类的指针替换了常量池中第一项的符号引用。(直接引用)</p>
<h4 id="3、实例化对象"><a href="#3、实例化对象" class="headerlink" title="3、实例化对象"></a>3、实例化对象</h4><p>加载完Animal类的信息以后，JVM虚拟机就会在堆内存中为一个Animal类实例分配内存，然后调用其构造函数初始化Animal实例，<br>这个实例持有指向方法区的Animal类的类型信息（其中包含有方法表，java动态绑定的底层实现）的引用。（animal指向了Animal对象的引用会自动的放在栈中，字符串常量”super_yc”会自动的放在方法区的常量池中，对象会自动的放入堆区）。</p>
<h4 id="4、程序运行"><a href="#4、程序运行" class="headerlink" title="4、程序运行"></a>4、程序运行</h4><p>当使用animal.printName()的时候，JVM根据栈中animal引用找到Animal对象，然后根据Animal对象持有的引用定位到方法区中Animal类的类型信息方法表，获得printName()函数的字节码地址，然后开始运行函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Animal animal = new Animal(&quot;super_yc&quot;);</span><br><span class="line">		animal.printName();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Animal&#123;</span><br><span class="line">	private String name;</span><br><span class="line">	public Animal(String name) &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void printName()&#123;</span><br><span class="line">		System.out.println(&quot;Animal = &quot; + this.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/4.png" alt="在这里插入图片描述"></p>
<h4 id="java-进程运行过程详解"><a href="#java-进程运行过程详解" class="headerlink" title="java 进程运行过程详解"></a>java 进程运行过程详解</h4><p>JVM常量池主要分为<strong>Class文件常量池、运行时常量池，全局字符串常量池，以及基本类型包装类对象常量池</strong>。</p>
<p><strong>0、Class文件常量池</strong></p>
<p>class文件是一组以字节为单位的二进制数据流，在java代码的编译期间，我们编写的java文件就被编译为.class文件格式的二进制数据存放在磁盘中，其中就包括class文件常量池。 class文件中存在常量池（非运行时常量池），其在编译阶段就已经确定，jvm规范对class文件结构有着严格的规范，必须符合此规范的class文件才能被jvm认识和装载。为了方便说明，我们写个简单的类</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">JavaBean</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> <span class="keyword">value</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> final <span class="keyword">static</span> <span class="built_in">int</span> f = <span class="number">0x101</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span>(<span class="params"><span class="built_in">int</span> v</span>)</span>&#123;</span><br><span class="line">        final <span class="built_in">int</span> temp = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">value</span> = temp + v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">getValue</span>()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过javac命令编译之后，用javap -v 命令查看编译后的文件:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">class JavaBasicKnowledge.JavaBean</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">1 = Methodref          <span class="comment">#6.#29         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">2 = Fieldref           <span class="comment">#5.#30         // JavaBasicKnowledge/JavaBean.valuI</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">3 = String             <span class="comment">#31            // abc</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">4 = Fieldref           <span class="comment">#5.#32         // JavaBasicKnowledge/JavaBean.s:Ljava/lang/String;</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">5 = Class              <span class="comment">#33            // JavaBasicKnowledge/JavaBean</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">6 = Class              <span class="comment">#34            // java/lang/Object</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">7 = Utf8               value</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">8 = Utf8               I</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">9 = Utf8               s</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">10 = Utf8               Ljava/lang/String;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">11 = Utf8               f</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">12 = Utf8               ConstantValue</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">13 = Integer            257</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">14 = Utf8               &lt;init&gt;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">15 = Utf8               ()V</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">16 = Utf8               Code</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">17 = Utf8               LineNumberTable</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">18 = Utf8               LocalVariableTable</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">19 = Utf8               this</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">20 = Utf8               LJavaBasicKnowledge/JavaBean;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">21 = Utf8               setValue</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">22 = Utf8               (I)V</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">23 = Utf8               v</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">24 = Utf8               temp</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">25 = Utf8               getValue</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">26 = Utf8               ()I</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">27 = Utf8               SourceFile</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">28 = Utf8               StringConstantPool.java</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">29 = NameAndType        <span class="comment">#14:#15        // &quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">30 = NameAndType        <span class="comment">#7:#8          // valuI</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">31 = Utf8               abc</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">32 = NameAndType        <span class="comment">#9:#10         // s:Ljava/lang/String;</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">33 = Utf8               JavaBasicKnowledge/JavaBean</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">34 = Utf8               java/lang/Object</span></span><br></pre></td></tr></table></figure>

<p>可以看到这个命令之后我们得到了该class文件的版本号、常量池、已经编译后的字节码（这里未列出）。既然是常量池，那么其中存放的肯定是常量，那么什么是“常量”呢？ class文件常量池主要存放两大常量：<strong>字面量和符号引用</strong>。</p>
<ol>
<li>字面量： 字面量接近java语言层面的常量概念，主要包括：</li>
</ol>
<ul>
<li><strong>文本字符串</strong>，也就是我们经常申明的： public String s &#x3D; “abc”;中的”abc”</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">9 = Utf8               s</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3 = String             <span class="comment">#31            // abc</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">31 = Utf8              abc</span></span><br></pre></td></tr></table></figure>

<ul>
<li>用final修饰的成员变量，包括静态变量、实例变量和局部变量</li>
</ul>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment">#11 = Utf8               f</span></span><br><span class="line"> <span class="comment">#12 = Utf8               ConstantValue</span></span><br><span class="line"> <span class="comment">#13 = Integer            257</span></span><br></pre></td></tr></table></figure>

<p>这里需要说明的一点，上面说的存在于常量池的字面量，指的是数据的值，也就是abc和0x101(257),通过上面对常量池的观察可知这两个字面量是确实存在于常量池的。</p>
<p><strong>而对于基本类型数据(甚至是方法中的局部变量)，也就是上面的private int value &#x3D; 1;常量池中只保留了他的的字段描述符I和字段的名称value，他们的字面量不会存在于常量池。</strong></p>
<p>**2) 符号引用</p>
<p>**符号引用主要设涉及编译原理方面的概念，包括下面三类常量:</p>
<ul>
<li>类和接口的全限定名，也就是java&#x2F;lang&#x2F;String;这样，将类名中原来的”.”替换为”&#x2F;“得到的，主要用于在运行时解析得到类的直接引用，像上面</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">5 = Class              <span class="comment">#33            // JavaBasicKnowledge/JavaBean</span></span></span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">33 = Utf8               JavaBasicKnowledge/JavaBean</span></span><br></pre></td></tr></table></figure>

<ul>
<li>字段的名称和描述符，字段也就是类或者接口中声明的变量，包括类级别变量和实例级的变量</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4 = Fieldref           <span class="comment">#5.#32         // JavaBasicKnowledge/JavaBean.valuI</span></span></span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">5 = Class              <span class="comment">#33            // JavaBasicKnowledge/JavaBean</span></span></span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">32 = NameAndType       <span class="comment">#7:#8          // valuI</span></span></span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">7 = Utf8               value</span></span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">8 = Utf8               I</span></span><br><span class="line"> //这两个是局部变量，只保留字段名称</span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">23 = Utf8               v</span></span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">24 = Utf8               temp</span></span><br></pre></td></tr></table></figure>

<p>可以看到，对于方法中的局部变量名，class文件的常量池仅仅保存字段名。</p>
<ul>
<li>方法中的名称和描述符，也即参数类型+返回值</li>
</ul>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment">#21 = Utf8               setValue</span></span><br><span class="line"> <span class="comment">#22 = Utf8               (I)V</span></span><br><span class="line"> <span class="comment">#25 = Utf8               getValue</span></span><br><span class="line"> <span class="comment">#26 = Utf8               ()I</span></span><br></pre></td></tr></table></figure>

<p><strong>1、运行时常量池</strong></p>
<p>运行时常量池是方法区的一部分，所以也是全局贡献的，我们知道，jvm在执行某个类的时候，必须经过<strong>加载、链接（验证、准备、解析）、初始化</strong>，在第一步加载的时候需要完成：</p>
<ul>
<li>通过一个类的全限定名来获取此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个类对象，代表加载的这个类，这个对象是java.lang.Class，它作为方法区这个类的各种数据访问的入口。</li>
</ul>
<p>类对象和普通对象是不同的，类对象是在类加载的时候完成的，是jvm创建的并且是单例的，作为这个类和外界交互的入口， 而普通的对象一般是在调用new之后创建。</p>
<p>上面的第二条，将class字节流代表的静态存储结构转化为方法区的运行时数据结构，其中就包含了class文件常量池进入运行时常量池的过程，这里需要强调一下<strong>不同的类共用一个运行时常量池</strong>，同时在进入运行时常量池的过程中，多个class文件中常量池相同的字符串，多个class文件中常量池中相同的字符串只会存在一份在运行时常量池，这也是一种优化。</p>
<p>运行时常量池的作用是存储java class文件常量池中的符号信息，运行时常量池中保存着一些class文件中描述的符号引用，同时在类的解析阶段还会将这些符号引用翻译出直接引用（直接指向实例对象的指针，内存地址），翻译出来的直接引用也是存储在运行时常量池中。</p>
<p>运行时常量池相对于class常量池一大特征就是具有动态性，java规范并不要求常量只能在运行时才产生，也就是说运行时常量池的内容并不全部来自class常量池，在运行时可以通过代码生成常量并将其放入运行时常量池中，这种特性被用的最多的就是String.intern()。</p>
<p><strong>2、全局字符串常量池</strong></p>
<p><strong>1）Java中创建字符串对象的两种方式</strong></p>
<p>一般有如下两种：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">String</span> s0 = <span class="string">&quot;hellow&quot;</span>;</span><br><span class="line"><span class="title class_">String</span> s1 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hellow&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>第一种方式声明的字面量hellow是在编译期就已经确定的，它会直接进入class文件常量池中；当运行期间在全局字符串常量池中会保存它的一个引用.实际上最终还是要在堆上创建一个”hellow”对象，这个后面会讲。</p>
<p>第二种方式方式使用了new String()，也就是调用了String类的构造函数，我们知道new指令是创建一个类的实例对象并完成加载初始化的，因此这个字符串对象是在运行期才能确定的，创建的字符串对象是在堆内存上。</p>
<p>因此此时调用System.out.println(s0 &#x3D;&#x3D; s1);返回的肯定是flase,因此&#x3D;&#x3D;符号比较的是两边元素的地址，s1和s0都存在于堆上，但是地址肯定不相同。</p>
<p>我们来看几个常见的题目：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">String</span> s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="title class_">String</span> s2 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="title class_">String</span> s3 = <span class="string">&quot;Hel&quot;</span> + <span class="string">&quot;lo&quot;</span>;</span><br><span class="line"><span class="title class_">String</span> s4 = <span class="string">&quot;Hel&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line"><span class="title class_">String</span> s5 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="title class_">String</span> s7 = <span class="string">&quot;H&quot;</span>;</span><br><span class="line"><span class="title class_">String</span> s8 = <span class="string">&quot;ello&quot;</span>;</span><br><span class="line"><span class="title class_">String</span> s9 = s7 + s8;</span><br><span class="line"><span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(s1 == s2);  <span class="comment">// true</span></span><br><span class="line"><span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(s1 == s3);  <span class="comment">// true</span></span><br><span class="line"><span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(s1 == s4);  <span class="comment">// false</span></span><br><span class="line"><span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(s1 == s9);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="String-s1-x3D-“Hello”，到底有没有在堆中创建对象？"><a href="#String-s1-x3D-“Hello”，到底有没有在堆中创建对象？" class="headerlink" title="String s1 &#x3D; “Hello”，到底有没有在堆中创建对象？"></a>String s1 &#x3D; “Hello”，到底有没有在堆中创建对象？</h4><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/5.png" alt="在这里插入图片描述"></p>
<p>这张图是我们理解的jvm运行时数据区的结构，但是还有不完整的地方，<br><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/6.png" alt="在这里插入图片描述"></p>
<p>这张图中，可以看到，方法区实际上是在一块叫“非堆”的区域包含——可以简单粗略的理解为非堆中包含了永生代，而永生代中又包含了方法区和字符串常量池。<br><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/7.png" alt="在这里插入图片描述"></p>
<p>其中的Interned String就是全局共享的“字符串常量池（String Pool）”，和运行时常量池不是一个概念。但我们在代码中申明String s1 &#x3D; “Hello”;这句代码后，在类加载的过程中，类的class文件的信息会被解析到内存的方法区里。</p>
<p>class文件里常量池里大部分数据会被加载到“运行时常量池”，包括String的字面量；但同时“Hello”字符串的一个引用会被存到同样在“非堆”区域的“字符串常量池”中，而”Hello”本体还是和所有对象一样，创建在Java堆中。</p>
<p>当主线程开始创建s1时，虚拟机会先去字符串池中找是否有equals(“Hello”)的String，如果相等就把在字符串池中“Hello”的引用复制给s1；如果找不到相等的字符串，就会在堆中新建一个对象，同时把引用驻留在字符串池，再把引用赋给str。</p>
<p>当用字面量赋值的方法创建字符串时，无论创建多少次，只要字符串的值相同，它们所指向的都是堆中的同一个对象。<br><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/8.png" alt="在这里插入图片描述"></p>
<p>区别：<code>String str1 = &quot;abc&quot;</code>直接str1存储的是常量池中的地址值<br><code>String str2 = new String(&quot;abc&quot;)</code> <code>str2</code>存储的是在堆中的 <code>new String()</code>的地址值<br><code>new String()</code>存放的是跟<code>str1</code>相同指向的常量池的地址值。</p>
<p><strong>2）字符串常量池的本质</strong></p>
<p>字符串常量池是JVM所维护的一个字符串实例的引用表，在HotSpot VM中，它是一个叫做StringTable的全局表。在字符串常量池中维护的是字符串实例的引用，底层C++实现就是一个Hashtable。这些被维护的引用所指的字符串实例，被称作”被驻留的字符串”或”interned string”或通常所说的”进入了字符串常量池的字符串”。  </p>
<p>强调一下：<strong>运行时常量池在方法区(Non-heap)，而JDK1.7后，字符串常量池被移到了heap区，因此两者根本就不是一个概念。</strong></p>
<h5 id="String”字面量”-是何时进入字符串常量池的"><a href="#String”字面量”-是何时进入字符串常量池的" class="headerlink" title="String”字面量” 是何时进入字符串常量池的?"></a>String”字面量” 是何时进入字符串常量池的?</h5><p>先说结论： 在执行ldc指令时，该指令表示int、float或String型常量从常量池推送至栈顶。</p>
<p>JVM规范里Class文件的常量池项的类型，有两种东西：</p>
<ul>
<li>CONSTANT_Utf8_info</li>
<li>CONSTANT_String_info</li>
</ul>
<p>在HotSpot VM中，运行时常量池里，CONSTANT_Utf8_info可以表示Class文件的方法、字段等等，其结构如下：</p>
<p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/9.png" alt="在这里插入图片描述"></p>
<p>首先是1个字节的tag,表示这是一个CONSTANT_Utf8_info结构的常量，然后是两个字节的length，表示要储存字节的长度，之后是一个字节的byte数组，表示真正的储存的length个长度的字符串。这里需要注意的是，一个字节只是代表这里有一个byte类型的数组，而这个数组的长度当然可以远远大于一个字节。当然，由于CONSTANT_Utf8_info结构只能用u2即两个字节来表示长度，因此长度的最大值为2byte，也就是65535。</p>
<p>CONSTANT_String_info是String常量的类型，但它并不直接持有String常量的内容，而是只持有一个index，这个index所指定的另一个常量池项必须是一个CONSTANT_Utf8类型的常量，这里才真正持有字符串的内容</p>
<p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/10.png" alt="在这里插入图片描述"></p>
<p>CONSTANT_Utf8会在类加载的过程中就全部创建出来，而CONSTANT_String则是lazy resolve的，在第一次引用该项的ldc指令被第一次执行到的时候才会resolve。在尚未resolve的时候，HotSpot VM把它的类型叫做JVM_CONSTANT_UnresolvedString，内容跟Class文件里一样只是一个index；等到resolve过后这个项的常量类型就会变成最终的JVM_CONSTANT_String。</p>
<p>也就是说，就HotSpot VM的实现来说，加载类的时候，那些字符串字面量会进入到当前类的运行时常量池，不会进入全局的字符串常量池（即在StringTable中并没有相应的引用，在堆中也没有对应的对象产生），在执行ldc指令时，触发lazy resolution这个动作。</p>
<p>ldc字节码在这里的执行语义是：到当前类的运行时常量池（runtime constant pool，HotSpot VM里是ConstantPool + ConstantPoolCache）去查找该index对应的项，如果该项尚未resolve则resolve之，并返回resolve后的内容。</p>
<p>在遇到String类型常量时，resolve的过程如果发现StringTable已经有了内容匹配的java.lang.String的引用，则直接返回这个引用，反之，如果StringTable里尚未有内容匹配的String实例的引用，则会在Java堆里创建一个对应内容的String对象，然后在StringTable记录下这个引用，并返回这个引用出去。</p>
<p>可见，ldc指令是否需要创建新的String实例，全看在第一次执行这一条ldc指令时，StringTable是否已经记录了一个对应内容的String的引用。</p>
<p><strong>3）String.intern()的用法</strong></p>
<p>String.intern()官方给的定义：</p>
<p>When the intern method is invoked, if the pool already contains a string equal to this String object as determined by the equals(Object) method, then the string from the pool is returned. Otherwise, this String object is added to the pool and a reference to this String object is returned.</p>
<p>实际上，就是去拿String的内容去Stringtable里查表，如果存在，则返回引用，不存在，就把该对象的”引用”存在Stringtable表里。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">         String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;计算机&quot;</span>).append(<span class="string">&quot;软件&quot;</span>).toString();</span><br><span class="line">         System.<span class="keyword">out</span>.println(str1.intern() == str1);</span><br><span class="line"></span><br><span class="line">         String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;ja&quot;</span>).append(<span class="string">&quot;va&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">         System.<span class="keyword">out</span>.println(str2.intern() == str2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码，在 JDK6 下执行结果为 false、false，在 JDK7 以上执行结果为 true、false。</p>
<p>首先我们调用StringBuilder创建了一个”计算机软件”String对象，因为调用了new关键字，因此是在运行时创建，之前JVM中是没有这个字符串的。</p>
<p>在 JDK6 下，intern()会把首次遇到的字符串实例复制到永久代中，返回的也是这个永久代中字符串实例的引用；而在JDK1.7开始，intern()方法不再复制字符串实例，String 的 intern 方法首先将尝试在常量池中查找该对象的引用，如果找到则直接返回该对象在常量池中的引用地址。</p>
<p>因此在1.7中，“计算机软件”这个字符串实例只存在一份，存在于java堆中！通过3中的分析，我们知道当String str1 &#x3D; new StringBuilder(“计算机”).append(“软件”).toString();这句代码执行完之后，已经在堆中创建了一个字符串对象，并且在全局字符串常量池中保留了这个字符串的引用，那么str1.intern()直接返回这个引用，这当然满足str1.intern() &#x3D;&#x3D; str1——都是他自己嘛；对于引用str2，因为JVM中已经有“java”这个字符串了，因此new StringBuilder(“ja”).append(“va”).toString()会重新创建一个新的“java”字符串对象，而intern()会返回首次遇到的常量的实例引用，因此他返回的是系统中的那个”java”字符串对象引用(首次)，因此会返回false。</p>
<p>在 JDK6 下 str1、str2 指向的是新创建的对象，该对象将在 Java Heap 中创建，所以 str1、str2 指向的是 Java Heap 中的内存地址；调用 intern 方法后将尝试在常量池中查找该对象，没找到后将其放入常量池并返回，所以此时 str1&#x2F;str2.intern() 指向的是常量池中的地址，JDK6常量池在永久代，与堆隔离，所以 s1.intern()和s1 的地址当然不同了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 首先设置 持久代最大和最小内存占用(限定为10M)</span></span><br><span class="line"><span class="comment">         * VM args: -XX:PermSize=10M -XX:MaxPremSize=10M</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        List&lt;String&gt; list  = <span class="keyword">new</span> <span class="built_in">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 无限循环 使用 list 对其引用保证 不被GC  intern 方法保证其加入到常量池中</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 此处永久执行，最多就是将整个 int 范围转化成字符串并放入常量池</span></span><br><span class="line">            list.<span class="built_in">add</span>(String.<span class="built_in">valueOf</span>(i++).<span class="built_in">intern</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码在 JDK6 下会出现 Perm 内存溢出，JDK7 or high 则没问题。</p>
<p>JDK6 常量池存在持久代，设置了持久代大小后，不断while循环必将撑满 Perm 导致内存溢出；JDK7 常量池被移动到 Native Heap(Java Heap,HotSpot VM中不区分native堆和Java堆)，所以即使设置了持久代大小，也不会对常量池产生影响；不断while循环在当前的代码中，所有int的字符串相加还不至于撑满 Heap 区，所以不会出现异常。</p>
<p><strong>3、JAVA 基本类型的封装类及对应常量池</strong></p>
<p>java中基本类型的包装类的大部分都实现了常量池技术，这些类是Byte,Short,Integer,Long,Character,Boolean,另外两种浮点数类型的包装类则没有实现。另外上面这5种整型的包装类也只是在对应值小于等于127时才可使用对象池，也即对象不负责创建和管理大于127的这些类的对象。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringConstantPool</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> static void main(String[] args)&#123;</span><br><span class="line">        <span class="comment">//5种整形的包装类Byte,Short,Integer,Long,Character的对象，</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//在值小于127时可以使用常量池</span></span><br><span class="line">        Integer i1=<span class="number">127</span>;</span><br><span class="line">        Integer i2=<span class="number">127</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.println(i1==i2);<span class="comment">//输出true</span></span><br><span class="line">        <span class="comment">//值大于127时，不会从常量池中取对象</span></span><br><span class="line">        Integer i3=<span class="number">128</span>;</span><br><span class="line">        Integer i4=<span class="number">128</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.println(i3==i4);<span class="comment">//输出false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Boolean类也实现了常量池技术</span></span><br><span class="line">        <span class="built_in">Boolean</span> bool1=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Boolean</span> bool2=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        System.<span class="keyword">out</span>.println(bool1==bool2);<span class="comment">//输出true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//浮点类型的包装类没有实现常量池技术</span></span><br><span class="line">        <span class="built_in">Double</span> d1=<span class="number">1.0</span>;</span><br><span class="line">        <span class="built_in">Double</span> d2=<span class="number">1.0</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.println(d1==d2); <span class="comment">//输出false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在JDK5.0之前是不允许直接将基本数据类型的数据直接赋值给其对应地包装类的，如：Integer i &#x3D; 5; 但是在JDK5.0中支持这种写法，因为编译器会自动将上面的代码转换成如下代码：Integer i&#x3D;Integer.valueOf(5);这就是Java的装箱.JDK5.0也提供了自动拆箱：Integer i &#x3D;5; int j &#x3D; i;</p>
<h1 id="一、运行时数据区域"><a href="#一、运行时数据区域" class="headerlink" title="一、运行时数据区域"></a>一、运行时数据区域</h1><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/11.png" alt="在这里插入图片描述"></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。</p>
<h2 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h2><p>每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p>
<p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/12.png" alt="在这里插入图片描述"></p>
<p>可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K，而在 JDK 1.5+ 默认为 1M：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -Xss2M HackTheJava</span><br></pre></td></tr></table></figure>

<p>该区域可能抛出以下异常：</p>
<ul>
<li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；</li>
<li>栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。</li>
</ul>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。</p>
<p>本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。</p>
<p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/13.png" alt="在这里插入图片描述"></p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>所有对象都在这里分配内存，是垃圾收集的主要区域（”GC 堆”）。</p>
<p>现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：</p>
<ul>
<li>新生代（Young Generation）</li>
<li>老年代（Old Generation）</li>
</ul>
<p>堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。</p>
<p>可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -Xms1M -Xmx2M HackTheJava</span><br></pre></td></tr></table></figure>

<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。</p>
<p>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。</p>
<p>HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。</p>
<p>方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和字符串常量池等放入堆中。<br><img src="https://img-blog.csdnimg.cn/20210411053700275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池是方法区的一部分。</p>
<p>Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。</p>
<p>除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。</p>
<p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/14.png" alt="在这里插入图片描述"></p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。</p>
<h1 id="二、垃圾收集"><a href="#二、垃圾收集" class="headerlink" title="二、垃圾收集"></a>二、垃圾收集</h1><p>垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。</p>
<h2 id="判断一个对象是否可被回收"><a href="#判断一个对象是否可被回收" class="headerlink" title="判断一个对象是否可被回收"></a>判断一个对象是否可被回收</h2><h3 id="1-引用计数算法"><a href="#1-引用计数算法" class="headerlink" title="1. 引用计数算法"></a>1. 引用计数算法</h3><p>为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</p>
<p>在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="type">Test</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        a.instance = b;</span><br><span class="line">        b.instance = a;</span><br><span class="line">        a = <span class="literal">null</span>;</span><br><span class="line">        b = <span class="literal">null</span>;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，a 与 b 引用的对象实例互相持有了对象的引用，因此当我们把对 a 对象与 b 对象的引用去除之后，由于两个对象还存在互相之间的引用，导致两个 Test 对象无法被回收。</p>
<h3 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2. 可达性分析算法"></a>2. 可达性分析算法</h3><p>以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。</p>
<p>Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：</p>
<ul>
<li>虚拟机栈中局部变量表中引用的对象</li>
<li>本地方法栈中 JNI 中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
</ul>
<p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/15.png" alt="在这里插入图片描述"></p>
<h3 id="3-方法区的回收"><a href="#3-方法区的回收" class="headerlink" title="3. 方法区的回收"></a>3. 方法区的回收</h3><p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。</p>
<p>主要是对常量池的回收和对类的卸载。</p>
<p>为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。</p>
<p>类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：</p>
<ul>
<li>该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li>
</ul>
<h3 id="4-finalize"><a href="#4-finalize" class="headerlink" title="4. finalize()"></a>4. finalize()</h3><p>类似 C++ 的析构函数，用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。</p>
<p>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。</p>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p>
<p>Java 提供了四种强度不同的引用类型。</p>
<h3 id="1-强引用"><a href="#1-强引用" class="headerlink" title="1. 强引用"></a>1. 强引用</h3><p>被强引用关联的对象不会被回收。</p>
<p>使用 new 一个新对象的方式来创建强引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<h3 id="2-软引用"><a href="#2-软引用" class="headerlink" title="2. 软引用"></a>2. 软引用</h3><p>被软引用关联的对象只有在内存不够的情况下才会被回收。</p>
<p>使用 SoftReference 类来创建软引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;  <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure>

<h3 id="3-弱引用"><a href="#3-弱引用" class="headerlink" title="3. 弱引用"></a>3. 弱引用</h3><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</p>
<p>使用 WeakReference 类来创建弱引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4-虚引用"><a href="#4-虚引用" class="headerlink" title="4. 虚引用"></a>4. 虚引用</h3><p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。</p>
<p>为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。</p>
<p>使用 PhantomReference 来创建虚引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;Object&gt;(obj, <span class="literal">null</span>);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="1-标记-清除"><a href="#1-标记-清除" class="headerlink" title="1. 标记 - 清除"></a>1. 标记 - 清除</h3><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/16.png" alt="在这里插入图片描述"></p>
<p>在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。</p>
<p>在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。</p>
<p>在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。</p>
<p>不足：</p>
<ul>
<li>标记和清除过程效率都不高；</li>
<li>会产生大量不连续的内存碎片，导致无法给大对象分配内存。</li>
</ul>
<h3 id="2-标记-整理"><a href="#2-标记-整理" class="headerlink" title="2. 标记 - 整理"></a>2. 标记 - 整理</h3><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/17.png" alt="在这里插入图片描述"></p>
<p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<p>优点:</p>
<ul>
<li>不会产生内存碎片</li>
</ul>
<p>不足:</p>
<ul>
<li>需要移动大量对象，处理效率比较低。</li>
</ul>
<h3 id="3-复制"><a href="#3-复制" class="headerlink" title="3. 复制"></a>3. 复制</h3><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/18.png" alt="在这里插入图片描述"></p>
<p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p>
<p>主要不足是只使用了内存的一半。</p>
<p>现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。</p>
<p>HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。</p>
<h3 id="4-分代收集"><a href="#4-分代收集" class="headerlink" title="4. 分代收集"></a>4. 分代收集</h3><p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p>
<p>一般将堆分为新生代和老年代。</p>
<ul>
<li>新生代使用：复制算法</li>
<li>老年代使用：标记 - 清除 或者 标记 - 整理 算法</li>
</ul>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/19.png" alt="在这里插入图片描述"></p>
<p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p>
<ul>
<li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；</li>
<li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li>
</ul>
<h3 id="1-Serial-收集器"><a href="#1-Serial-收集器" class="headerlink" title="1. Serial 收集器"></a>1. Serial 收集器</h3><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/20.png" alt="在这里插入图片描述"></p>
<p>Serial 翻译为串行，也就是说它以串行的方式执行。</p>
<p>它是单线程的收集器，只会使用一个线程进行垃圾收集工作。</p>
<p>它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p>
<p>它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。</p>
<h3 id="2-ParNew-收集器"><a href="#2-ParNew-收集器" class="headerlink" title="2. ParNew 收集器"></a>2. ParNew 收集器</h3><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/21.png" alt="在这里插入图片描述"></p>
<p>它是 Serial 收集器的多线程版本。</p>
<p>它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。</p>
<h3 id="3-Parallel-Scavenge-收集器"><a href="#3-Parallel-Scavenge-收集器" class="headerlink" title="3. Parallel Scavenge 收集器"></a>3. Parallel Scavenge 收集器</h3><p>与 ParNew 一样是多线程收集器。</p>
<p>其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。</p>
<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。</p>
<p>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p>
<p>可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p>
<h3 id="4-Serial-Old-收集器"><a href="#4-Serial-Old-收集器" class="headerlink" title="4. Serial Old 收集器"></a>4. Serial Old 收集器</h3><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/22.png" alt="在这里插入图片描述"></p>
<p>是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：</p>
<ul>
<li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li>
<li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li>
</ul>
<h3 id="5-Parallel-Old-收集器"><a href="#5-Parallel-Old-收集器" class="headerlink" title="5. Parallel Old 收集器"></a>5. Parallel Old 收集器</h3><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/23.png" alt="在这里插入图片描述"></p>
<p>是 Parallel Scavenge 收集器的老年代版本。</p>
<p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p>
<h3 id="6-CMS-收集器"><a href="#6-CMS-收集器" class="headerlink" title="6. CMS 收集器"></a>6. CMS 收集器</h3><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/24.png" alt="在这里插入图片描述"></p>
<p>CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。</p>
<p>分为以下四个流程：</p>
<ul>
<li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li>
<li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li>
<li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li>
<li>并发清除：不需要停顿。</li>
</ul>
<p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p>
<p>具有以下缺点：</p>
<ul>
<li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li>
<li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li>
<li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li>
</ul>
<h3 id="7-G1-收集器"><a href="#7-G1-收集器" class="headerlink" title="7. G1 收集器"></a>7. G1 收集器</h3><p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p>
<p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</p>
<p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/25.png" alt="在这里插入图片描述"></p>
<p>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。</p>
<p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/26.png" alt="在这里插入图片描述"></p>
<p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p>
<p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p>
<p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/27.png" alt="在这里插入图片描述"></p>
<p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li>
<li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li>
</ul>
<p>具备如下特点：</p>
<ul>
<li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li>
<li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li>
</ul>
<p>JDK1.8中默认使用的是Parallel Scavenge和Parallel Old收集器组合。</p>
<h1 id="三、内存分配与回收策略"><a href="#三、内存分配与回收策略" class="headerlink" title="三、内存分配与回收策略"></a>三、内存分配与回收策略</h1><h2 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h2><ul>
<li><p>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</p>
</li>
<li><p>Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</p>
</li>
</ul>
<h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><h3 id="1-对象优先在-Eden-分配"><a href="#1-对象优先在-Eden-分配" class="headerlink" title="1. 对象优先在 Eden 分配"></a>1. 对象优先在 Eden 分配</h3><p>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。</p>
<h3 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2. 大对象直接进入老年代"></a>2. 大对象直接进入老年代</h3><p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p>
<p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p>
<p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</p>
<h3 id="3-长期存活的对象进入老年代"><a href="#3-长期存活的对象进入老年代" class="headerlink" title="3. 长期存活的对象进入老年代"></a>3. 长期存活的对象进入老年代</h3><p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p>
<p>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</p>
<h3 id="4-动态对象年龄判定"><a href="#4-动态对象年龄判定" class="headerlink" title="4. 动态对象年龄判定"></a>4. 动态对象年龄判定</h3><p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p>
<h3 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5. 空间分配担保"></a>5. 空间分配担保</h3><p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</p>
<p>如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。</p>
<h2 id="Full-GC-的触发条件"><a href="#Full-GC-的触发条件" class="headerlink" title="Full GC 的触发条件"></a>Full GC 的触发条件</h2><p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：</p>
<h3 id="1-调用-System-gc"><a href="#1-调用-System-gc" class="headerlink" title="1. 调用 System.gc()"></a>1. 调用 System.gc()</h3><p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p>
<h3 id="2-老年代空间不足"><a href="#2-老年代空间不足" class="headerlink" title="2. 老年代空间不足"></a>2. 老年代空间不足</h3><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p>
<p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p>
<h3 id="3-空间分配担保失败"><a href="#3-空间分配担保失败" class="headerlink" title="3. 空间分配担保失败"></a>3. 空间分配担保失败</h3><p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第 5 小节。</p>
<h3 id="4-JDK-1-7-及以前的永久代空间不足"><a href="#4-JDK-1-7-及以前的永久代空间不足" class="headerlink" title="4. JDK 1.7 及以前的永久代空间不足"></a>4. JDK 1.7 及以前的永久代空间不足</h3><p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</p>
<p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p>
<p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p>
<h3 id="5-Concurrent-Mode-Failure"><a href="#5-Concurrent-Mode-Failure" class="headerlink" title="5. Concurrent Mode Failure"></a>5. Concurrent Mode Failure</h3><p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p>
<h1 id="四、类加载机制"><a href="#四、类加载机制" class="headerlink" title="四、类加载机制"></a>四、类加载机制</h1><p>类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。</p>
<h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/28.png" alt="在这里插入图片描述"></p>
<p>包括以下 7 个阶段：</p>
<ul>
<li><strong>加载（Loading）</strong>  </li>
<li><strong>验证（Verification）</strong>  </li>
<li><strong>准备（Preparation）</strong>  </li>
<li><strong>解析（Resolution）</strong>  </li>
<li><strong>初始化（Initialization）</strong>  </li>
<li>使用（Using）</li>
<li>卸载（Unloading）</li>
</ul>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>包含了加载、验证、准备、解析和初始化这 5 个阶段。</p>
<h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h3><p>加载是类加载的一个阶段，注意不要混淆。</p>
<p>加载过程完成以下三件事：</p>
<ul>
<li>通过类的完全限定名称获取定义该类的二进制字节流。</li>
<li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构。</li>
<li>在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。</li>
</ul>
<p>其中二进制字节流可以从以下方式中获取：</p>
<ul>
<li>从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。</li>
<li>从网络中获取，最典型的应用是 Applet。</li>
<li>运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。</li>
<li>由其他文件生成，例如由 JSP 文件生成对应的 Class 类。</li>
</ul>
<h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h3><p>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h3><p>类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。</p>
<p>实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。</p>
<p>初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4. 解析"></a>4. 解析</h3><p>将常量池的符号引用替换为直接引用的过程。</p>
<p>其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</p>
<div data="补充为什么可以支持动态绑定 --> <--"></div>

<h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5. 初始化"></a>5. 初始化</h3><div data="modify -->"></div>

<p>初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 &lt;clinit&gt;() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。</p>
<p>&lt;clinit&gt;() 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;                <span class="comment">// 给变量赋值可以正常编译通过</span></span><br><span class="line">        System.out.print(i);  <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于父类的 &lt;clinit&gt;() 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">A</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        A = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">B</span> <span class="operator">=</span> A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     System.out.println(Sub.B);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 &lt;clinit&gt;() 方法。但接口与类不同的是，执行接口的 &lt;clinit&gt;() 方法不需要先执行父接口的 &lt;clinit&gt;() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 &lt;clinit&gt;() 方法。</p>
<p>虚拟机会保证一个类的 &lt;clinit&gt;() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 &lt;clinit&gt;() 方法，其它线程都会阻塞等待，直到活动线程执行 &lt;clinit&gt;() 方法完毕。如果在一个类的 &lt;clinit&gt;() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。</p>
<h2 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h2><h3 id="1-主动引用"><a href="#1-主动引用" class="headerlink" title="1. 主动引用"></a>1. 主动引用</h3><p>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）：</p>
<ul>
<li><p>遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。</p>
</li>
<li><p>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。</p>
</li>
<li><p>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p>
</li>
<li><p>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；</p>
</li>
<li><p>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；</p>
</li>
</ul>
<h3 id="2-被动引用"><a href="#2-被动引用" class="headerlink" title="2. 被动引用"></a>2. 被动引用</h3><p>以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：</p>
<ul>
<li>通过子类引用父类的静态字段，不会导致子类初始化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(SubClass.value);  <span class="comment">// value 字段在 SuperClass 中定义</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SuperClass[] sca = <span class="keyword">new</span> <span class="title class_">SuperClass</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(ConstClass.HELLOWORLD);</span><br></pre></td></tr></table></figure>

<h2 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h2><p>两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。</p>
<p>这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。</p>
<h2 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h2><p>从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：</p>
<ul>
<li><p>启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分；</p>
</li>
<li><p>所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。</p>
</li>
</ul>
<p>从 Java 开发人员的角度看，类加载器可以划分得更细致一些：</p>
<ul>
<li><p>启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 &lt;JRE_HOME&gt;\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。</p>
</li>
<li><p>扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 &lt;JAVA_HOME&gt;&#x2F;lib&#x2F;ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。</p>
</li>
<li><p>应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
</li>
</ul>
<div data="modify <--"></div>

<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。</p>
<p>下图展示了类加载器之间的层次关系，称为双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。</p>
<p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/29.png" alt="在这里插入图片描述"></p>
<h3 id="1-工作过程"><a href="#1-工作过程" class="headerlink" title="1. 工作过程"></a>1. 工作过程</h3><p>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。</p>
<h3 id="2-好处"><a href="#2-好处" class="headerlink" title="2. 好处"></a>2. 好处</h3><p>使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。</p>
<p>例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。</p>
<h3 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h3><p>以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="comment">// The parent class loader for delegation</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义类加载器实现"><a href="#自定义类加载器实现" class="headerlink" title="自定义类加载器实现"></a>自定义类加载器实现</h2><p>以下代码中的 FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。</p>
<p>java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileSystemClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileSystemClassLoader</span><span class="params">(String rootDir)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rootDir = rootDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">byte</span>[] classData = getClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] getClassData(String className) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> classNameToPath(className);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path);</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">bufferSize</span> <span class="operator">=</span> <span class="number">4096</span>;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[bufferSize];</span><br><span class="line">            <span class="type">int</span> bytesNumRead;</span><br><span class="line">            <span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, bytesNumRead);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">classNameToPath</span><span class="params">(String className)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rootDir + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">&#x27;.&#x27;</span>, File.separatorChar) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、JVM常见的启动参数"><a href="#五、JVM常见的启动参数" class="headerlink" title="五、JVM常见的启动参数"></a>五、JVM常见的启动参数</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xms：初始大小内存，默认为物理内存1/64，等价于-XX:InitialHeapSize</span><br><span class="line">-Xmx：最大分配内存，默认为物理内存1/4，等价于-XX:MaxHeapSize</span><br><span class="line">-Xss：设置单个线程的大小，一般默认为512K~1024K，等价于-XX:ThreadStackSize</span><br><span class="line">-Xmn：设置年轻代大小</span><br><span class="line">-XX:MetaspaceSize：设置元空间大小，-Xms10m -Xmx10m -XX:MetaspaceSize=1024m -			XX:+PrintFlagsFinal</span><br><span class="line">-XX:+PrintGCDetails：输出详细GC收集日志信息</span><br></pre></td></tr></table></figure>

<h5 id="GC"><a href="#GC" class="headerlink" title="GC:"></a>GC:</h5><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/30.png" alt="在这里插入图片描述"></p>
<h5 id="FullGC"><a href="#FullGC" class="headerlink" title="FullGC:"></a>FullGC:</h5><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/31.png" alt="在这里插入图片描述"></p>
<h5 id="XX-SurvivoRatio"><a href="#XX-SurvivoRatio" class="headerlink" title="-XX:SurvivoRatio"></a>-XX:SurvivoRatio</h5><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/32.png" alt="在这里插入图片描述"></p>
<p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/33.png" alt="在这里插入图片描述"></p>
<h5 id="XX-NewRatio"><a href="#XX-NewRatio" class="headerlink" title="-XX:NewRatio"></a>-XX:NewRatio</h5><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/34.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:MaxTenuringThreshold：设置垃圾最大年龄</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/45.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -XX:+PrintFlagsInitial   查看初始默认值</span><br><span class="line">java -XX:+PrintCommandLineFlags -version 查看GC是哪个收集器</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如何查看一个正在运行中的java程序，它的某个JVM参数手否开启，具体值是多少？</span><br><span class="line">1.命令jps -l 在idea下的terminal窗口下得到类的进程号 ID；</span><br><span class="line">2.jinfo -flag PrintGCDetails ID //查看某一个正在运行的java程序是否开启打印GC收集细节</span><br></pre></td></tr></table></figure>



<h4 id="几种常用的内存调试工具"><a href="#几种常用的内存调试工具" class="headerlink" title="几种常用的内存调试工具"></a>几种常用的内存调试工具</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jps:查看虚拟机进程的状况，如进程ID；</span><br><span class="line">jmap: 用于生成堆转储快照文件(某一时刻的)。</span><br><span class="line">jhat: 对生成的堆转储快照文件进行分析。</span><br><span class="line">jstack: 用来生成线程快照(某一时刻的)。生成线程快照的主要目的是定位线程长时停顿的原因(如死锁,死循环,等待 			I/O 等), 通过查看各个线程的调用堆栈,就可以知道没有响应的线程在后台做了什么或者等待什么资源。 </span><br><span class="line">jstat: 虚拟机统计信息监视工具。如显示垃圾收集的情况,内存使用的情况。</span><br><span class="line">Jconsol 主要是内存监控和线程监控。内存监控:可以显示内存的使用情况。线程监控:遇到线程停顿时,可以使用这个			功能。</span><br></pre></td></tr></table></figure>

<h1 id="六、请谈谈你对ooM的认识"><a href="#六、请谈谈你对ooM的认识" class="headerlink" title="六、请谈谈你对ooM的认识"></a>六、请谈谈你对ooM的认识</h1><h5 id="1、Java-lang-StackOverflowError"><a href="#1、Java-lang-StackOverflowError" class="headerlink" title="1、Java.lang.StackOverflowError"></a>1、Java.lang.StackOverflowError</h5><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/36.png" alt="在这里插入图片描述"></p>
<h5 id="2-Java-lang-OutOfMemoryError-Java-heap-space"><a href="#2-Java-lang-OutOfMemoryError-Java-heap-space" class="headerlink" title="2.Java.lang.OutOfMemoryError:Java heap space"></a>2.Java.lang.OutOfMemoryError:Java heap space</h5><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/37.png" alt="在这里插入图片描述"></p>
<h5 id="3、Java-lang-OutOfMemeoryError-GC-overhead-limit-exceeded"><a href="#3、Java-lang-OutOfMemeoryError-GC-overhead-limit-exceeded" class="headerlink" title="3、Java.lang.OutOfMemeoryError:GC overhead limit exceeded"></a>3、Java.lang.OutOfMemeoryError:GC overhead limit exceeded</h5><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/38.png" alt="在这里插入图片描述"></p>
<h5 id="4、Java-lang-OutOfMemeoryError-Direct-buffer-memory"><a href="#4、Java-lang-OutOfMemeoryError-Direct-buffer-memory" class="headerlink" title="4、Java.lang.OutOfMemeoryError:Direct buffer memory"></a>4、Java.lang.OutOfMemeoryError:Direct buffer memory</h5><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/39.png" alt="在这里插入图片描述"></p>
<h5 id="5、Java-lang-OutOfMemeoryError-unable-to-create-new-native-thread"><a href="#5、Java-lang-OutOfMemeoryError-unable-to-create-new-native-thread" class="headerlink" title="5、Java.lang.OutOfMemeoryError:unable to create new native thread"></a>5、Java.lang.OutOfMemeoryError:unable to create new native thread</h5><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/41.png" alt="在这里插入图片描述"></p>
<h5 id="6、Java-lang-OutOfMemeoryError-Metaspace"><a href="#6、Java-lang-OutOfMemeoryError-Metaspace" class="headerlink" title="6、Java.lang.OutOfMemeoryError:Metaspace"></a>6、Java.lang.OutOfMemeoryError:Metaspace</h5><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/42.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用Java -XX:+PrintFlagsInitial命令查看本机的初始化参数，-XX:MetaspaceSize为21810376B(约20M)</span><br></pre></td></tr></table></figure>



<h1 id="七、假如生产环境出现CPU占用过高，请谈谈你的分析思路和定位"><a href="#七、假如生产环境出现CPU占用过高，请谈谈你的分析思路和定位" class="headerlink" title="七、假如生产环境出现CPU占用过高，请谈谈你的分析思路和定位"></a>七、假如生产环境出现CPU占用过高，请谈谈你的分析思路和定位</h1><p>下面我写一个死循环的代码，然后演示一遍如何去定位问题</p>
<ul>
<li>这个案例为了演示cpu很高时候 如何快速定位</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CpuTest</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           System.out.println(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1010101010</span>));</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第一步、用top命令找出占cpu占比最高的 记录下PID</strong></p>
<p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/51.png" alt="在这里插入图片描述"></p>
<p><strong>二、采用 jps 进一步定位找到当前正在运行的进程号</strong></p>
<p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/52.png" alt="在这里插入图片描述"></p>
<p><strong>三、定位到具体的线程或代码 ps -mp 进程 -o THREAD,tid,time   定位到了具体的线程</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-m 显示所有的线程</span><br><span class="line">-p pid进程使用cpu的时间</span><br><span class="line">-o 该参数后是用户自定义的格式</span><br></pre></td></tr></table></figure>

<p><strong>四、将需要的线程ID转换为16进制格式（英文小写格式）</strong><br><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/53.png" alt="在这里插入图片描述"></p>
<p><strong>五、jstack 进程号 | grep tid 线程号（16进制） -A60</strong><br><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/54.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>问题排查</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程池实现原理及业务实践</title>
    <url>/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="线程池讲解"><a href="#线程池讲解" class="headerlink" title="线程池讲解"></a>线程池讲解</h2><p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/1.png" alt="图片"></p>
<p>我们知道，线程需要的时候要进行创建，不需要的时候需要进行销毁，但是线程的创建和销毁都是一个开销比较大的操作。</p>
<blockquote>
<p>为什么开销大呢？</p>
</blockquote>
<p>虽然我们程序员创建一个线程很容易，直接使用 new Thread() 创建就可以了，但是操作系统做的工作会多很多，它需要发出 <code>系统调用</code>，陷入内核，调用内核 API 创建线程，为线程分配资源等，这一些操作有很大的开销。</p>
<p>所以，在高并发大流量的情况下，频繁的创建和销毁线程会大大拖慢响应速度，那么有什么能够提高响应速度的方式吗？方式有很多，尽量避免线程的创建和销毁是一种提升性能的方式，也就是把线程 <code>复用</code> 起来，因为性能是我们日常最关注的因素。</p>
<p>线程池解决的核心问题就是资源管理问题。在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来以下若干问题：</p>
<ol>
<li>频繁申请&#x2F;销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。</li>
<li>对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。</li>
<li>系统无法合理管理内部的资源分布，会降低系统的稳定性。</li>
</ol>
<p>为解决资源分配这个问题，线程池采用了“池化”（Pooling）思想。池化，顾名思义，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。</p>
<p>本篇文章我们先来通过认识一下 Executor 框架、然后通过描述线程池的基本概念入手、逐步认识线程池的核心类，然后慢慢进入线程池的原理中，带你一步一步理解线程池。</p>
<p>在 Java 中可以通过线程池来达到这样的效果。今天我们就来详细讲解一下 Java 的<code>线程池</code>。</p>
<p>使用线程池可以带来一系列好处：</p>
<ul>
<li><strong>降低资源消耗</strong>：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。</li>
<li><strong>提高响应速度</strong>：任务到达时，无需等待线程创建即可立即执行。</li>
<li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。</li>
<li><strong>提供更多更强大的功能</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</li>
</ul>
<h2 id="Executor-框架"><a href="#Executor-框架" class="headerlink" title="Executor 框架"></a>Executor 框架</h2><p>为什么要先说一下 Executor 呢？因为我认为 Executor 是线程池的一个驱动，我们平常创建并执行线程用的一般都是 new Thread().start() 这个方法，这个方法更多强调 <strong>创建一个线程并开始运行</strong>。而我们后面讲到创建线程池更多体现在<strong>驱动执行</strong>上。</p>
<p>Executor 的总体框架如下，我们下面会对 Executor 框架中的每个类进行介绍。</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/2.png" alt="图片"></p>
<p>我们首先来认识一下 Executor</p>
<h3 id="Executor-接口"><a href="#Executor-接口" class="headerlink" title="Executor 接口"></a>Executor 接口</h3><p>Executor 是 <code>java.util.concurrent</code> 的顶级接口，这个接口只有一个方法，那就是 <code>execute</code> 方法。我们平常创建并启动线程会使用 <code>new Thread().start()</code> ，而 Executor 中的 execute 方法替代了显示创建线程的方式。Executor 的设计初衷就是将任务提交和任务执行细节进行解藕。使用 Executor 框架，你可以使用如下的方式创建线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.xxx <span class="comment">// xxx 其实就是 Executor 的实现类，我们后面会说</span></span><br><span class="line">executor.execute(<span class="keyword">new</span> <span class="title class_">RunnableTask1</span>());</span><br><span class="line">executor.execute(<span class="keyword">new</span> <span class="title class_">RunnableTask2</span>());</span><br></pre></td></tr></table></figure>

<p>execute方法接收一个 <code>Runnable</code> 实例，它用来执行一个任务，而任务就是一个实现了 Runnable 接口的类，但是 execute 方法不能接收实现了 <code>Callable</code> 接口的类，也就是说，execute 方法不能接收具有返回值的任务。</p>
<p>execute 方法创建的线程是异步执行的，也就是说，你不用等待每个任务执行完毕后再执行下一个任务。</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/3.png" alt="图片"></p>
<p>比如下面就是一个简单的使用 Executor 创建并执行线程的示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor(); <span class="comment">// 你可能不太理解这是什么意思，我们后面会说。</span></span><br><span class="line">        executor.execute(<span class="keyword">new</span> <span class="title class_">RunnableTask</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Executor 就相当于是族长，大佬只发号令，族长让你异步执行你就得异步执行，族长说不用<code>汇报</code>任务你就不用回报，但是这个族长管的事情有点少，所以除了 Executor 之外，我们还需要认识其他管家，比如说管你这个线程啥时候终止，啥时候暂停，判断你这个线程当前的状态等，<code>ExecutorService</code> 就是一位大管家。</p>
<h3 id="ExecutorService-接口"><a href="#ExecutorService-接口" class="headerlink" title="ExecutorService 接口"></a>ExecutorService 接口</h3><p>ExecutorService 也是一个接口，它是 Executor 的拓展，提供了一些 Executor 中没有的方法，下面我们来介绍一下这些方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p><code>shutdown</code> 方法调用后，ExecutorService 会有序关闭正在执行的任务，但是不接受新任务。如果任务已经关闭，那么这个方法不会产生任何影响。</p>
<p>ExecutorService 还有一个和 shutdown 方法类似的方法是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p><code>shutdownNow</code> 会尝试停止关闭所有正在执行的任务，停止正在等待的任务，并返回正在等待执行的任务列表。</p>
<blockquote>
<p>既然 shutdown 和 shutdownNow 这么相似，那么二者有啥区别呢？</p>
<ul>
<li>shutdown 方法只是会将<code>线程池</code>的状态设置为 <code>SHUTWDOWN</code> ，正在执行的任务会继续执行下去，线程池会等待任务的执行完毕，而没有执行的线程则会中断。</li>
<li>shutdownNow 方法会将线程池的状态设置为 <code>STOP</code>，正在执行和等待的任务则被停止，返回等待执行的任务列表</li>
</ul>
</blockquote>
<p>ExecutorService 还有三个判断线程状态的方法，分别是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isShutdown</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isTerminated</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">awaitTermination</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>isShutdown</code> 方法表示执行器是否已经关闭，如果已经关闭，返回 true，否则返回 false。</li>
<li><code>isTerminated</code> 方法表示判断所有任务再关闭后是否已完成，如果完成返回 false，这个需要注意一点，除非首先调用 shutdown 或者 shutdownNow 方法，否则 isTerminated 方法永远不会为 true。</li>
<li><code>awaitTermination</code> 方法会阻塞，直到发出调用 shutdown 请求后所有的任务已经完成执行后才会解除。这个方法不是非常容易理解，下面通过一个小例子来看一下。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    executorService.submit(() -&gt; &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName());</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  executorService.shutdown();</span><br><span class="line">  System.out.println(<span class="string">&quot;Waiting...&quot;</span>);</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">isTermination</span> <span class="operator">=</span> executorService.awaitTermination(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">  System.out.println(<span class="string">&quot;Waiting...Done&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(isTermination)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;All Thread Done&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在调用 executorService.shutdown() 之后，所有线程完成任务，isTermination 返回 true，程序才会打印出 All Thread Done ，如果注释掉 executorService.shutdown() 或者在任务没有完成后 awaitTermination 就超时了，那么 isTermination 就会返回 false。</p>
<p>ExecutorService 当大管家还有一个原因是因为它不仅能够包容 Runnable 对象，还能够接纳 <code>Callable</code> 对象。在 ExecutorService 中，<code>submit</code> 方法扮演了这个角色。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span>;</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>

<p>submit 方法会返回一个 <code>Future</code>对象，<code>&lt;T&gt;</code> 表示范型，它是对 Callable 产生的返回值来说的，submit 方法提交的任务中的 call 方法如果返回 Integer，那么 submit 方法就返回 <code>Future&lt;Integer&gt;</code>，依此类推。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                                  <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>

<p><code>invokeAll</code> 方法用于执行给定的任务结合，执行完成后会返回一个任务列表，任务列表每一项是一个任务，每个任务会包括任务状态和执行结果，同样 invokeAll 方法也会返回 Future 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">&lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                    <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br></pre></td></tr></table></figure>

<p>invokeAny 会获得最先完成任务的结果，即<code>Callable&lt;T&gt;</code> 接口中的 call 的返回值，<strong>在获得结果时，会中断其他正在执行的任务</strong>，具有<code>阻塞性</code>。</p>
<p>大管家的职责相对于组长来说标准更多，管的事情也比较宽，但是大管家毕竟也是家族的中流砥柱，他不会做具体的活，他的下面有各个干将，干将是一个家族的核心，他负责完成大管家的工作。</p>
<h3 id="AbstractExecutorService-抽象类"><a href="#AbstractExecutorService-抽象类" class="headerlink" title="AbstractExecutorService 抽象类"></a>AbstractExecutorService 抽象类</h3><p>AbstractExecutorService 是一个抽象类，它实现了 ExecutorService 中的部分方法，它相当一个干将，会分析大管家有哪些要做的工作，然后针对大管家的要求做一些具体的规划，然后找他的得力助手 <code>ThreadPoolExecutor</code> 来完成目标。</p>
<p>AbstractExecutorService 这个抽象类主要实现了 <code>invokeAll</code> 和 <code>invokeAny</code> 方法，关于这两个方法的源码分析我们会在后面进行解释。</p>
<h3 id="ScheduledExecutorService-接口"><a href="#ScheduledExecutorService-接口" class="headerlink" title="ScheduledExecutorService 接口"></a>ScheduledExecutorService 接口</h3><p>ScheduledExecutorService 也是一个接口，它扩展了 ExecutorService 接口，提供了 ExecutorService 接口所没有的功能，ScheduledExecutorService 顾名思义就是一个<code>定时执行器</code>，定时执行器可以安排命令在一定延迟时间后运行或者定期执行。</p>
<p>它主要有三个接口方法，一个重载方法。下面我们先来看一下这两个重载方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class="line">                                       <span class="type">long</span> delay, TimeUnit unit);</span><br><span class="line"><span class="keyword">public</span> &lt;V&gt; ScheduledFuture&lt;V&gt; <span class="title function_">schedule</span><span class="params">(Callable&lt;V&gt; callable,</span></span><br><span class="line"><span class="params">                                           <span class="type">long</span> delay, TimeUnit unit)</span>;</span><br></pre></td></tr></table></figure>

<p><code>schedule</code> 方法能够延迟一定时间后执行任务，并且只能执行一次。可以看到，schedule 方法也返回了一个 <code>ScheduledFuture</code> 对象，ScheduledFuture 对象扩展了 Future 和 Delayed 接口，它表示异步延迟计算的结果。schedule 方法支持零延迟和负延迟，这两类值都被视为立即执行任务。</p>
<p>还有一点需要说明的是，schedule 方法能够接收相对的时间和周期作为参数，而不是固定的日期，你可以使用 <strong>date.getTime - System.currentTimeMillis()</strong> 来得到相对的时间间隔。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                                  <span class="type">long</span> initialDelay,</span><br><span class="line">                                                  <span class="type">long</span> period,</span><br><span class="line">                                                  TimeUnit unit);</span><br></pre></td></tr></table></figure>

<p>scheduleAtFixedRate 表示任务会根据固定的速率在时间 <code>initialDelay</code> 后不断地执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                     <span class="type">long</span> initialDelay,</span><br><span class="line">                                                     <span class="type">long</span> delay,</span><br><span class="line">                                                     TimeUnit unit);</span><br></pre></td></tr></table></figure>

<p>这个方法和上面的方法很类似，它表示的是以固定延迟时间的方式来执行任务。</p>
<blockquote>
<p>scheduleAtFixedRate 和 scheduleWithFixedDelay 这两个方法容易混淆，下面我们通过一个示例来说明一下这两个方法的区别。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">command</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">&quot;current timestamp = &quot;</span> + startTime);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">100</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;time spend = &quot;</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledExecutorService</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(command,<span class="number">100</span>,<span class="number">1000</span>,TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果大致如下</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/4.png" alt="图片"></p>
<p>可以看到，每次打印出来 current timestamp 的时间间隔大约等于 1000 毫秒，所以可以断定 <code>scheduleAtFixedRate</code> 是以恒定的速率来执行任务的。</p>
<p>然后我们再看一下 <code>scheduleWithFixedDelay</code> 方法，和上面测试类一样，只不过我们把 scheduleAtFixedRate 换为了 scheduleWithFixedDelay 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">scheduledExecutorService.scheduleWithFixedDelay(command,<span class="number">10</span>,<span class="number">1000</span>,TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>

<p>然后观察一下输出结果</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/5.png" alt="图片"></p>
<p>可以看到，两个 current timestamp 之间的间隔大约等于 1000(固定时间) + delay(time spend) 的总和，由此可以确定 <code>scheduleWithFixedDelay</code> 是以固定时延来执行的。</p>
<h2 id="线程池的描述"><a href="#线程池的描述" class="headerlink" title="线程池的描述"></a>线程池的描述</h2><p>下面我们先来认识一下什么是线程池，线程池从概念上来看就是一个<code>池子</code>，什么池子呢？是指管理同一组工作线程的池子，也就是说，线程池会统一管理内部的工作线程。</p>
<p>wiki 上说，线程池其实就是一种软件设计模式，这种设计模式用于实现计算机程序中的并发。</p>
<p>比如下面就是一个简单的线程池概念图。</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/6.png" alt="图片"></p>
<blockquote>
<p>注意：这个图只是一个概念模型，不是真正的线程池实现，希望读者不要混淆。</p>
</blockquote>
<p>可以看到，这种其实也相当于是<strong>生产者-消费者</strong>模型，任务队列中的线程会进入到线程池中，由线程池进行管理，线程池中的一个个线程就是工作线程，工作线程执行完毕后会放入完成队列中，代表已经完成的任务。</p>
<p>上图有个缺点，那就是队列中的线程执行完毕后就会销毁，销毁就会产生性能损耗，降低响应速度，而我们使用线程池的目的往往是需要把线程重用起来，提高程序性能。</p>
<p>所以我们应该把执行完成后的工作线程重新利用起来，等待下一次使用。</p>
<h3 id="线程池创建"><a href="#线程池创建" class="headerlink" title="线程池创建"></a>线程池创建</h3><p>我们上面大概聊了一下什么线程池的基本执行机制，你知道了线程是如何复用的，那么任何事物不可能是凭空出现的，线程也一样，那么它是如何创建出来的呢？下面就不得不提一个工具类，那就是 <code>Executors</code>。</p>
<p>Executors 也是<code>java.util.concurrent</code> 包下的成员，它是一个创建线程池的工厂，可以使用静态工厂方法来创建线程池，下面就是 Executors 所能够创建线程池的具体类型。</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/7.png" alt="图片"></p>
<ul>
<li><code>newFixedThreadPool</code>：newFixedThreadPool 将会创建固定数量的线程池，这个数量可以由程序员通过创建 <code>Executors.newFixedThreadPool(int nThreads)</code>时手动指定，每次提交一个任务就会创建一个线程，在任何时候，nThreads 的值是最多允许活动的线程。如果在所有线程都处于活跃状态时有额外的任务被创建，这些新创建的线程会进入等待队列等待线程调度。如果有任何线程由于执行期间出现意外导致<code>线程终止</code>，那么在执行后续任务时会使用等待队列中的线程进行替代。</li>
<li><code>newWorkStealingPool</code>：newWorkStealingPool 是 JDK1.8 新增加的线程池，它是基于 <code>fork-join</code> 机制的一种线程池实现，使用了 <code>Work-Stealing</code> 算法。newWorkStealingPool 会创建足够的线程来支持并行度，会使用多个队列来减少竞争。work-stealing pool 线程池不会保证提交任务的执行顺序。</li>
<li><code>newSingleThreadExecutor</code>：newSingleThreadExecutor 是一个单线程的执行器，它只会创建<code>单个</code>线程来执行任务，如果这个线程异常结束，则会创建另外一个线程来替代。newSingleThreadExecutor 会确保任务在任务队列中的执行次序，也就是说，任务的执行是 <code>有序的</code>。</li>
<li><code>newCachedThreadPool</code>：newCachedThreadPool 会根据实际需要创建一个可缓存的线程池。如果线程池的线程数量超过实际需要处理的任务，那么 newCachedThreadPool 将会回收多余的线程。如果实际需要处理的线程不能满足任务的数量，则回你添加新的线程到线程池中，线程池中线程的数量不存在任何限制。</li>
<li><code>newSingleThreadScheduledExecutor</code>：newSingleThreadScheduledExecutor 和 newSingleThreadExecutor 很类似，只不过带有 scheduled 的这个执行器哥们能够在一定延迟后执行或者定期执行任务。</li>
<li><code>newScheduledThreadPool</code>：这个线程池和上面的 scheduled 执行器类似，只不过 newSingleThreadScheduledExecutor 比 newScheduledThreadPool 多加了一个 <code>DelegatedScheduledExecutorService</code> 代理，这其实包装器设计模式的体现。</li>
</ul>
<p>上面这些线程池的底层实现都是由 ThreadPoolExecutor 来提供支持的，所以要理解这些线程池的工作原理，你就需要先把 ThreadPoolExecutor 搞明白，下面我们就来聊一聊 ThreadPoolExecutor。</p>
<h2 id="ThreadPoolExecutor-类"><a href="#ThreadPoolExecutor-类" class="headerlink" title="ThreadPoolExecutor 类"></a>ThreadPoolExecutor 类</h2><p><code>ThreadPoolExecutor</code> 位于 <code>java.util.concurrent</code> 工具类下，可以说它是线程池中最核心的一个类了。如果你要想把线程池理解透彻的话，就要首先了解一下这个类。</p>
<p>如果我们再拿上面家族举例子的话，ThreadPoolExecutor 就是一个家族的骨干人才，家族顶梁柱。ThreadPoolExecutor 做的工作真是太多太多了。</p>
<p>首先，ThreadPoolExecutor 提供了四个构造方法，然而前三个构造方法最终都会调用最后一个构造方法进行初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title class_">AbstractExecutorService</span> &#123;</span><br><span class="line">    .....</span><br><span class="line">      <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,<span class="type">int</span> maximumPoolSize,<span class="type">long</span> keepAliveTime,TimeUnit unit,</span></span><br><span class="line"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue)</span>;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,<span class="type">int</span> maximumPoolSize,<span class="type">long</span> keepAliveTime,TimeUnit unit,</span></span><br><span class="line"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory)</span>;</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,<span class="type">int</span> maximumPoolSize,<span class="type">long</span> keepAliveTime,TimeUnit unit,</span></span><br><span class="line"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler)</span>;</span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,<span class="type">int</span> maximumPoolSize,<span class="type">long</span> keepAliveTime,TimeUnit unit,</span></span><br><span class="line"><span class="params">        BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们直接就来看一波最后这个线程池，看看参数都有啥，如果我没数错的话，应该是有 7 个参数(小学数学水平。。。。。。)</p>
<ul>
<li>首先，一个非常重要的参数就是 <code>corePoolSize</code>，核心线程池的容量&#x2F;大小，你叫啥我觉得都没毛病。只不过你得理解这个参数的意义，<strong>它和线程池的实现原理有非常密切的关系</strong>。你刚开始创建了一个线程池，此时是没有任何线程的，这个很好理解，因为我现在没有任务可以执行啊，创建线程干啥啊？而且创建线程还有开销啊，所以等到任务过来时再创建线程也不晚。但是！我要说但是了，如果调用了 prestartAllCoreThreads 或者 prestartCoreThread 方法，就会在没有任务到来时创建线程，前者是创建 corePoolSize 个线程，后者是只创建一个线程。Lea 爷爷本来想让我们程序员当个<code>懒汉</code>，等任务来了再干；可是你非要当个<code>饿汉</code>，提前完成任务。如果我们想当个懒汉的话，在创建了线程池后，线程池中的线程数为 0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到 corePoolSize 后，就会把到达的任务放到<code>缓存队列</code>当中。</li>
</ul>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/8.png" alt="图片"></p>
<ul>
<li><code>maximumPoolSize</code> ：又来一个线程池的容量，只不过这个是线程池的最大容量，也就是线程池所能容纳最大的线程，而上面的 corePoolSize 只是核心线程容量。</li>
</ul>
<blockquote>
<p>我知道你此时会有疑问，那就是不知道如何核心线程的容量和线程最大容量的区别是吧？我们后面会解释这点。</p>
</blockquote>
<ul>
<li><p><code>keepAliveTime</code>：这个参数是线程池的<code>保活机制</code>，表示线程在没有任务执行的情况下保持多久会终止。在默认情况下，这个参数只在线程数量大于 corePoolSize 时才会生效。当线程数量大于 corePoolSize 时，如果任意一个空闲的线程的等待时间 &gt; keepAliveTime 后，那么这个线程会被剔除，直到线程数量等于 corePoolSize 为止。如果调用了 allowCoreThreadTimeOut 方法，线程数量在 corePoolSize 范围内也会生效，直到线程减为 0。</p>
</li>
<li><p><code>unit</code> ：这个参数好说，它就是一个 <code>TimeUnit</code> 的变量，unit 表示的是 keepAliveTime 的时间单位。unit 的类型有下面这几种</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TimeUnit.DAYS;               <span class="comment">//天</span></span><br><span class="line">TimeUnit.HOURS;             <span class="comment">//小时</span></span><br><span class="line">TimeUnit.MINUTES;           <span class="comment">//分钟</span></span><br><span class="line">TimeUnit.SECONDS;           <span class="comment">//秒</span></span><br><span class="line">TimeUnit.MILLISECONDS;      <span class="comment">//毫秒</span></span><br><span class="line">TimeUnit.MICROSECONDS;      <span class="comment">//微妙</span></span><br><span class="line">TimeUnit.NANOSECONDS;       <span class="comment">//纳秒</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>workQueue</code>：这个参数表示的概念就是等待队列，我们上面说过，如果核心线程 &gt; corePoolSize 的话，就会把任务放入等待队列，这个等待队列的选择也是一门学问。Lea 爷爷给我们展示了三种等待队列的选择</p>
</li>
<li><ul>
<li><code>SynchronousQueue</code>: 基于<code>阻塞队列(BlockingQueue)</code>的实现，它会直接将任务交给消费者，必须等队列中的添加元素被消费后才能继续添加新的元素。使用 SynchronousQueue 阻塞队列一般要求maximumPoolSizes 为无界，也就是 Integer.MAX_VALUE，避免线程拒绝执行操作。</li>
<li><code>LinkedBlockingQueue</code>：LinkedBlockingQueue 是一个无界缓存等待队列。当前执行的线程数量达到 corePoolSize 的数量时，剩余的元素会在阻塞队列里等待。</li>
<li><code>ArrayBlockingQueue</code>：ArrayBlockingQueue 是一个有界缓存等待队列，可以指定缓存队列的大小，当正在执行的线程数等于 corePoolSize 时，多余的元素缓存在 ArrayBlockingQueue 队列中等待有空闲的线程时继续执行，当 ArrayBlockingQueue 已满时，加入 ArrayBlockingQueue 失败，会开启新的线程去执行，当线程数已经达到最大的 maximumPoolSizes 时，再有新的元素尝试加入 ArrayBlockingQueue时会报错</li>
</ul>
</li>
<li><p><code>threadFactory</code>：线程工厂，这个参数主要用来创建线程；</p>
</li>
<li><p><code>handler</code> ：拒绝策略，拒绝策略主要有以下取值</p>
</li>
<li><ul>
<li><code>AbortPolicy</code>：丢弃任务并抛出 RejectedExecutionException 异常。</li>
<li><code>DiscardPolicy</code>: 直接丢弃任务，但是不抛出异常。</li>
<li><code>DiscardOldestPolicy</code>：直接丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）。</li>
<li><code>CallerRunsPolicy</code>：由调用线程处理该任务。</li>
</ul>
</li>
</ul>
<h2 id="深入理解线程池"><a href="#深入理解线程池" class="headerlink" title="深入理解线程池"></a>深入理解线程池</h2><p>上面我和你简单聊了一下线程池的基本构造，线程池有几个非常重要的参数可以细细品味，但是哥们醒醒，接下来才是刺激的地方。</p>
<h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><p>首先我们先来聊聊线程池状态，线程池状态是一个非常有趣的设计点，ThreadPoolExecutor 使用 <code>ctl</code> 来存储线程池状态，这些状态也叫做线程池的<code>生命周期</code>。想想也是，线程池作为一个存储管理线程的资源池，它自己也要有这些状态，以及状态之间的变更才能更好的满足我们的需求。ctl 其实就是一个 <code>AtomicInteger</code> 类型的变量，保证<code>原子性</code>。</p>
<p>ctl 除了存储线程池状态之外，它还存储 <code>workerCount</code> 这个概念，workerCount 指示的是有效线程数，workerCount 表示的是已经被允许启动但不允许停止的工作线程数量。workerCount 的值与实际活动线程的数量不同。</p>
<p><strong>ctl 高低位来判断是线程池状态还是工作线程数量，线程池状态位于高位</strong>。</p>
<blockquote>
<p>这里有个设计点，为什么使用 AtomicInteger 而不是存储上线更大的 AtomicLong 之类的呢？</p>
</blockquote>
<p>Lea 并非没有考虑过这个问题，为了表示 int 值，目前 workerCount 的大小是<strong>（2 ^ 29）-1（约 5 亿个线程），而不是（2 ^ 31）-1（20亿个）可表示的线程</strong>。如果将来有问题，可以将该变量更改为 AtomicLong。但是在需要之前，使用 int 可以使此代码更快，更简单，int 存储占用存储空间更小。</p>
<p>runState 具有如下几种状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>

<p>我们先上状态轮转图，然后根据状态轮转图做详细的解释。</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/9.png" alt="图片"></p>
<p>这几种状态的解释如下</p>
<ul>
<li><code>RUNNING</code>: 如果线程池处于 RUNNING 状态下的话，能够接收新任务，也能处理正在运行的任务。可以从 ctl 的初始化得知，线程池一旦创建出来就会处于 RUNNING 状态，并且线程池中的有效线程数为 0。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li><code>SHUTDOWN</code>: 在调用 shutdown 方法后，线程池的状态会由 RUNNING -&gt; SHUTDOWN 状态，位于 SHUTDOWN 状态的线程池能够处理正在运行的任务，但是不能接受新的任务，这和我们上面说的对于 shutdown 的描述一致。</li>
<li><code>STOP</code>: 和 shutdown 方法类似，在调用 shutdownNow 方法时，程序会从 RUNNING&#x2F;SHUTDOWN -&gt; STOP 状态，处于 STOP 状态的线程池，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。</li>
<li><code>TIDYING</code>：TIDYING 状态有个前置条件，分为两种：一种是是当线程池位于 SHUTDOWN 状态下，阻塞队列和线程池中的线程数量为空时，会由 SHUTDOWN -&gt; TIDYING；另一种是当线程池位于 STOP 状态下时，线程池中的数量为空时，会由 STOP -&gt; TIDYING 状态。转换为 TIDYING 的线程池会调用 <code>terminated</code>这个钩子方法，terminated 在 ThreadPoolExecutor 类中是空实现，若用户想在线程池变为 TIDYING 时，进行相应的处理，可以通过重载 terminated 函数来实现。</li>
<li><code>TERMINATED</code>：TERMINATED 状态是线程池的最后一个状态，线程池处在 TIDYING 状态时，执行完terminated 方法之后，就会由 TIDYING -&gt; TERMINATED 状态。此时表示线程池的彻底终止。</li>
</ul>
<h3 id="重要变量"><a href="#重要变量" class="headerlink" title="重要变量"></a>重要变量</h3><p>下面我们一起来了解一下线程池中的重要变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br></pre></td></tr></table></figure>

<p>阻塞队列，这个和我们上面说的阻塞队列的参数是一个意思，因为在构造 ThreadPoolExecutor 时，会把参数的值赋给 this.workQueue。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); </span><br></pre></td></tr></table></figure>

<p>线程池的主要<code>状态锁</code>，对线程池的状态(比如线程池大小、运行状态)的改变都需要使用到这个锁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();</span><br></pre></td></tr></table></figure>

<p>workers 持有线程池中所有线程的集合，只有持有上面 <code>mainLock</code> 的锁才能够访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">termination</span> <span class="operator">=</span> mainLock.newCondition();</span><br></pre></td></tr></table></figure>

<p>等待条件，用来支持 awaitTermination 方法。Condition 和 Lock 一起使用可以实现通知&#x2F;等待机制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> largestPoolSize;</span><br></pre></td></tr></table></figure>

<p>largestPoolSize 表示线程池中最大池的大小，只有持有 mainLock 才能访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> completedTaskCount;</span><br></pre></td></tr></table></figure>

<p>completedTaskCount 表示任务完成的计数，它仅仅在任务终止时更新，需要持有 mainLock 才能访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br></pre></td></tr></table></figure>

<p>threadFactory 是创建线程的工厂，所有的线程都会使用这个工厂，调用 <code>addWorker</code>方法创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br></pre></td></tr></table></figure>

<p>handler 表示拒绝策略，handler 会在线程饱和或者将要关闭的时候调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> keepAliveTime;</span><br></pre></td></tr></table></figure>

<p>保活时间，它指的是空闲线程等待工作的超时时间，当存在多个 corePoolSize 或 allowCoreThreadTimeOut 时，线程将使用这个超时时间。</p>
<p>下面是一些其他变量，这些变量比较简单，我就直接给出注释了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> allowCoreThreadTimeOut;   <span class="comment">//是否允许为核心线程设置存活时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span>   corePoolSize;     <span class="comment">//核心池的大小（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span>   maximumPoolSize;   <span class="comment">//线程池最大能容忍的线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RejectedExecutionHandler</span> <span class="variable">defaultHandler</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AbortPolicy</span>(); <span class="comment">// 默认的拒绝策略</span></span><br></pre></td></tr></table></figure>

<h3 id="任务提交"><a href="#任务提交" class="headerlink" title="任务提交"></a>任务提交</h3><p>现在我们知道了 ThreadPoolExecutor 创建出来就会处于运行状态，此时线程数量为 0 ，等任务到来时，线程池就会创建线程来执行任务，而下面我们的关注点就会放在<strong>任务提交</strong>这个过程上。</p>
<p>通常情况下，我们会使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">executor.execute() </span><br></pre></td></tr></table></figure>

<p>来执行任务，我在很多书和博客教程上都看到过这个执行过程，下面是一些书和博客教程所画的 ThreadPoolExecutor 的执行示意图和执行流程图</p>
<p>执行示意图</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/10.png" alt="图片"></p>
<p>处理流程图</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/11.png" alt="图片"></p>
<p>ThreadPoolExecutor 的执行 execute 的方法分为下面四种情况</p>
<ol>
<li>如果当前运行的工作线程少于 corePoolSize 的话，那么会创建新线程来执行任务 ，这一步需要获取 mainLock <code>全局锁</code>。</li>
<li>如果运行线程不小于 corePoolSize，则将任务加入 BlockingQueue 阻塞队列。</li>
<li>如果无法将任务加入 BlockingQueue 中，此时的现象就是队列已满，此时需要创建新的线程来处理任务，这一步同样需要获取 mainLock 全局锁。</li>
<li>如果创建新线程会使当前运行的线程超过 <code>maximumPoolSize</code> 的话，任务将被拒绝，并且使用 <code>RejectedExecutionHandler.rejectEExecution()</code> 方法拒绝新的任务。</li>
</ol>
<p>ThreadPoolExecutor 采取上面的整体设计思路，是为了在执行 execute 方法时，避免获取全局锁，因为频繁获取全局锁会是一个严重的<code>可伸缩瓶颈</code>，所以，几乎所有的 execute 方法调用都是通过执行步骤2。</p>
<p>上面指出了 execute 的运行过程，整体上来说这个执行过程把非常重要的点讲解出来了，但是不够细致，我查阅 ThreadPoolExecute 和部分源码分析文章后，发现这事其实没这么简单，先来看一下 execute 的源码，我已经给出了中文注释,Execute是提交任务的方法入口方法，根据核心线程池的数量、线程池的状态，任务队列大小、最大数量、分成不同情况，创建不同线程，存储到不同位置，或执行拒绝策略。</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/12.png" alt="图片"></p>
<p>下面是我根据源码画出的执行流程图</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/13.png" alt="图片"></p>
<p>下面我们针对 execute 流程进行分析，可能有点啰嗦，因为几个核心流程上面已经提过了，不过为了流程的完整性，我们再在这里重新提一下。</p>
<ol>
<li>如果线程池的核心数量少于 <code>corePoolSize</code>，那么就会使用 addWorker 创建新线程，addworker 的流程我们会在下面进行分析。如果创建成功，那么 execute 方法会直接返回。如果没创建成功，可能是由于线程池已经 shutdown，可能是由于并发情况下 workerCountOf(c) &lt; corePoolSize ，别的线程先创建了 worker 线程，导致 workerCoun t&gt;&#x3D; corePoolSize。</li>
<li>如果线程池还在 Running 状态，会将 task 加入阻塞队列，加入成功后会进行 <code>double-check</code> 双重校验，继续下面的步骤，如果加入失败，可能是由于队列线程已满，此时会判断是否能够加入线程池中，如果线程池也满了的话，就会直接执行拒绝策略，如果线程池能加入，execute 方法结束。</li>
<li>步骤 2 中的 double-check 主要是为了判断进入 workQueue 中的 task 是否能被执行：如果线程池已经不是 Running 状态，则应该拒绝添加任务，从 workQueue 队列中删除任务。如果线程池是 Running，但是从 workQueue 中删除失败了，此时的原因可能是由于其他线程执行了这个任务，此时会直接执行拒绝策略。</li>
<li>如果线程是 Running 状态，并且不能把任务从队列中移除，进而判断工作线程是否为 0 ，如果不为 0 ，execute 执行完毕，如果工作线程是 0 ，则会使用 addWorker 增加工作线程，execute 执行完毕。</li>
</ol>
<h3 id="添加-worker-线程"><a href="#添加-worker-线程" class="headerlink" title="添加 worker 线程"></a>添加 worker 线程</h3><p>增加线程是通过线程池中的addWorker方法，该方法的功能就是增加一个线程，该方法不考虑线程池是在哪个阶段增加的该线程，这个分配线程的策略是在上个步骤完成的，该步骤仅仅完成增加线程，并使它运行，最后返回是否成功这个结果。addWorker方法有两个参数：firstTask、core。firstTask参数用于指定新增的线程执行的第一个任务，该参数可以为空；core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">  <span class="comment">// retry 的用法相当于 goto</span></span><br><span class="line">  retry:</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">    <span class="comment">// 仅在必要时检查队列是否为空。</span></span><br><span class="line">    <span class="comment">// 线程池状态有五种，state 越小越是运行状态</span></span><br><span class="line">    <span class="comment">// rs &gt;= SHUTDOWN，表示此时线程池状态可能是 SHUTDOWN、STOP、TIDYING、TERMINATED</span></span><br><span class="line">    <span class="comment">// 默认 rs &gt;= SHUTDOWN，如果 rs = SHUTDOWN，直接返回 false</span></span><br><span class="line">    <span class="comment">// 默认 rs &lt; SHUTDOWN，是 RUNNING，如果任务不是空，返回 false</span></span><br><span class="line">    <span class="comment">// 默认 RUNNING，任务是空，如果工作队列为空，返回 false</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">        ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">           firstTask == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">           ! workQueue.isEmpty()))</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">// 统计工作线程数量</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">      <span class="comment">// 如果 worker 数量&gt;线程池最大上限 CAPACITY（即使用int低29位可以容纳的最大值）</span></span><br><span class="line">      <span class="comment">// 或者 worker数量 &gt; corePoolSize 或 worker数量&gt;maximumPoolSize )，即已经超过了给定的边界</span></span><br><span class="line">      <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">          wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 使用 CAS 增加 worker 数量，增加成功，跳出循环。</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">        <span class="keyword">break</span> retry;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检查 ctl</span></span><br><span class="line">      c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">      <span class="comment">// 如果状态不等于之前获取的 state，跳出内层循环，继续去外层循环判断</span></span><br><span class="line">      <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">        <span class="keyword">continue</span> retry;</span><br><span class="line">      <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">          worker数量+1成功的后续操作</span></span><br><span class="line"><span class="comment">        * 添加到 workers Set 集合，并启动 worker 线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">  <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 包装 Runnable 对象</span></span><br><span class="line">    <span class="comment">// 设置 firstTask 的值为 -1</span></span><br><span class="line">    <span class="comment">// 赋值给当前任务</span></span><br><span class="line">    <span class="comment">// 使用 worker 自身这个 runnable，调用 ThreadFactory 创建一个线程，并设置给worker的成员变量thread</span></span><br><span class="line">    w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">    	<span class="comment">//全局锁</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">      <span class="comment">//加独占锁，为了works同步，因为可能多个现场调用了线程池的execute方法。</span></span><br><span class="line">      mainLock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 重新检查持有锁的状态，为了避免获取锁前调用了shutdown接口</span></span><br><span class="line">        <span class="comment">// 如果 ThreadFactory 失败或在获得锁之前关闭，请回退。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果线程池处于运行状态，或者线程池关闭且任务线程为空</span></span><br><span class="line">        <span class="comment">// （可能是 workQueue 中仍有未执行完成的任务，创建没有初始任务的 worker 线程执行）</span></span><br><span class="line">        <span class="comment">//worker 数量 -1 的操作在 addWorkerFailed()</span></span><br><span class="line">        <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">            (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">          <span class="comment">//线程处于活跃状态，切线程已经开始执行或者还未死亡，正确的是线程在这里应该还未开始执行的</span></span><br><span class="line">          <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 添加任务，workers 就是一个 HashSet 集合</span></span><br><span class="line">          workers.add(w);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 设置最大的池大小 largestPoolSize，workerAdded 设置为true</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">          <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">            largestPoolSize = s;</span><br><span class="line">          workerAdded = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//添加成功则启动任务</span></span><br><span class="line">      <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">        t.start();</span><br><span class="line">        workerStarted = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果启动线程失败</span></span><br><span class="line">    <span class="comment">// worker 数量 -1</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">      addWorkerFailed(w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的执行流程图如下</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/14.png" alt="图片"></p>
<p>这里我们就不再文字描述了，但是上面流程图中有一个对象引起了我的注意，那就是 <code>worker</code> 对象，这个对象就代表了线程池中的工作线程，那么这个 worker 对象到底是啥呢？</p>
<h3 id="worker-对象"><a href="#worker-对象" class="headerlink" title="worker 对象"></a>worker 对象</h3><p>Worker 位于 <code>ThreadPoolExecutor</code> 内部，它继承了 AQS 类并且实现了 Runnable 接口。Worker 类主要维护了线程运行过程中的中断控制状态。它提供了锁的获取和释放操作。在 worker 的实现中，我们使用了非重入的互斥锁而不是使用重复锁，因为 Lea 觉得我们不应该在调用诸如 setCorePoolSize 之类的控制方法时能够重新获取锁。</p>
<p>worker 对象的源码比较简单和标准，这里我们只说一下 worker 对象的构造方法，也就是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">  setState(-<span class="number">1</span>); </span><br><span class="line">  <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">  <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造一个 worker 对象需要做三步操作：</p>
<ul>
<li>初始 AQS 状态为 -1，此时不允许中断 interrupt()，只有在 worker 线程启动了，执行了 runWorker() 方法后，将 state 置为0，才能进行中断。</li>
<li>将 firstTask 赋值给为当前类的全局变量</li>
<li>通过 <code>ThreadFactory</code> 创建一个新的线程。</li>
</ul>
<h3 id="任务运行"><a href="#任务运行" class="headerlink" title="任务运行"></a>任务运行</h3><p>我们前面的流程主要分析了线程池的 execute 方法的执行过程，这个执行过程相当于是任务提交过程，而我们下面要说的是<strong>从队列中获取任务并运行</strong>的这个工作流程。</p>
<p>一般情况下，我们会从初始任务开始运行，所以我们不需要获取第一个任务。否则，只要线程池还处于 Running 状态，我们会调用 <code>getTask</code> 方法获取任务。getTask 方法可能会返回 null，此时可能是由于线程池状态改变或者是配置参数更改而导致的退出。还有一种情况可能是由于 <code>异常</code> 而引发的，这个我们后面会细说。</p>
<p>下面来看一下 <code>runWorker</code> 方法的源码：</p>
<p>runWorker真正执行任务的地方，先执行第一个任务，再源源不断从任务队列中取任务来执行；如果线程池调用了shutDownNow，这里也会收到影响。</p>
<p>在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的执行过程如下：</p>
<ol>
<li>while循环不断地通过getTask()方法获取任务。</li>
<li>getTask()方法从阻塞队列中取任务。</li>
<li>如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态。</li>
<li>执行任务。</li>
<li>如果getTask结果为null则跳出循环，执行processWorkerExit()方法，销毁线程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">  <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">  <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">  w.firstTask = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 允许打断</span></span><br><span class="line">  <span class="comment">//  new Worker() 是 state==-1，此处是调用 Worker 类的 tryRelease() 方法，</span></span><br><span class="line">  <span class="comment">//  将 state 置为0</span></span><br><span class="line">  w.unlock();</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Work在执行任务完成后，还会循环获取任务队列中的任务执行，复用线程</span></span><br><span class="line">    <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 获取全局锁</span></span><br><span class="line">      w.lock();</span><br><span class="line">      <span class="comment">// 确保只有在线程 STOPING 时，才会被设置中断标志，否则清除中断标志。</span></span><br><span class="line">      <span class="comment">// 如果一开始判断线程池状态 &lt; STOPING，但 Thread.interrupted() 为 true，</span></span><br><span class="line">      <span class="comment">// 即线程已经被中断，又清除了中断标示，再次判断线程池状态是否 &gt;= stop</span></span><br><span class="line">      <span class="comment">// 是，再次设置中断标示，wt.interrupt()</span></span><br><span class="line">      <span class="comment">// 否，不做操作，清除中断标示后进行后续步骤</span></span><br><span class="line">      <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">           (Thread.interrupted() &amp;&amp;</span><br><span class="line">            runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">          !wt.isInterrupted())</span><br><span class="line">        wt.interrupt();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行前需要调用的方法，交给程序员自己来实现</span></span><br><span class="line">        beforeExecute(wt, task);</span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          task.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">          thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">          thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">          thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// 执行后需要调用的方法，交给程序员自己来实现</span></span><br><span class="line">          afterExecute(task, thrown);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 把 task 置为 null，完成任务数 + 1，并进行解锁</span></span><br><span class="line">        task = <span class="literal">null</span>;</span><br><span class="line">        w.completedTasks++;</span><br><span class="line">        w.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 最后处理 worker 的退出</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    processWorkerExit(w, completedAbruptly);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是 runWorker 的执行流程图</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/15.png" alt="图片"></p>
<p>这里需要注意一下最后的 <code>processWorkerExit</code> 方法，这里面其实也做了很多事情，包括判断 <code>completedAbruptly</code> 的布尔值来表示是否完成任务，获取锁，尝试从队列中移除 worker，然后尝试中断，接下来会判断一下中断状态，在线程池当前状态小于 STOP 的情况下会创建一个新的 worker 来替换被销毁的 worker。</p>
<h3 id="任务获取"><a href="#任务获取" class="headerlink" title="任务获取"></a>任务获取</h3><p>从队列取任务的地方，默认情况下，根据工作线程数量与核心数量的关系判断使用队列的poll()还是take()方法，keepAliveTime参数也是在这里使用的。</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/16.png" alt="图片"></p>
<p>getTask 方法的执行流程图如下</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/17.png" alt="图片"></p>
<h3 id="工作线程退出"><a href="#工作线程退出" class="headerlink" title="工作线程退出"></a>工作线程退出</h3><p>工作线程退出是 runWorker 的最后一步，这一步会判断工作线程是否突然终止，并且会尝试终止线程，以及是否需要增加线程来替换原工作线程。线程池中线程的销毁依赖JVM自动的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。Worker被创建出来后，就会不断地进行轮询，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务。当Worker无法获取到任务，也就是获取的任务为空时，循环会结束，Worker会主动消除自身在线程池内的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//执行任务</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  processWorkerExit(w, completedAbruptly);<span class="comment">//获取不到任务时，主动回收自己</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程回收的工作是在processWorkerExit方法完成的。</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/18.png" alt="图片"></p>
<p>事实上，在这个方法中，将线程引用移出线程池就已经结束了线程销毁的部分。但由于引起线程销毁的可能性有很多，线程池还要判断是什么引发了这次销毁，是否要改变线程池的现阶段状态，是否要根据新状态，重新分配线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processWorkerExit</span><span class="params">(Worker w, <span class="type">boolean</span> completedAbruptly)</span> &#123;</span><br><span class="line">  <span class="comment">// worker数量 -1</span></span><br><span class="line">  <span class="comment">// completedAbruptly 是 true，突然终止，说明是 task 执行时异常情况导致，即run()方法执行时发生了异常，那么正在工作的 worker 线程数量需要-1</span></span><br><span class="line">  <span class="comment">// completedAbruptly 是 false 是突然终止，说明是 worker 线程没有 task 可执行了，不用-1，因为已经在 getTask() 方法中-1了</span></span><br><span class="line">  <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">    decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从 Workers Set 中移除 worker</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">  mainLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    completedTaskCount += w.completedTasks;</span><br><span class="line">    workers.remove(w);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    mainLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 尝试终止线程，</span></span><br><span class="line">  tryTerminate();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否需要增加 worker 线程</span></span><br><span class="line">  <span class="comment">// 线程池状态是 running 或 shutdown</span></span><br><span class="line">  <span class="comment">// 如果当前线程是突然终止的，addWorker()</span></span><br><span class="line">  <span class="comment">// 如果当前线程不是突然终止的，但当前线程数量 &lt; 要维护的线程数量，addWorker()</span></span><br><span class="line">  <span class="comment">// 故如果调用线程池 shutdown()，直到workQueue为空前，线程池都会维持 corePoolSize 个线程，</span></span><br><span class="line">  <span class="comment">// 然后再逐渐销毁这 corePoolSize 个线程</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">  <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">      <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">        min = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">    &#125;</span><br><span class="line">    addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码搞的有点头大了，可能一时半会无法理解上面这些源码，不过你可以先把注释粘过去，等有时间了需要反复刺激，加深印象！</p>
<h2 id="其他线程池"><a href="#其他线程池" class="headerlink" title="其他线程池"></a>其他线程池</h2><p>下面我们来了解一下其他线程池的构造原理，主要涉及 <strong>FixedThreadPool、SingleThreadExecutor、CachedThreadPool</strong>。</p>
<h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>newFixedThreadPool 被称为可重用<code>固定线程数</code>的线程池，下面是 newFixedThreadPool 的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，newFixedThreadPool 的 corePoolSize 和 maximumPoolSize 都被设置为创建 FixedThreadPool 时指定的参数 <code>nThreads</code>，也就是说，在 newFiexedThreadPool 中，核心线程数就是最大线程数。</p>
<p>下面是 newFixedThreadPool 的执行示意图</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/19.png" alt="图片"></p>
<p>newFixedThreadPool 的工作流程如下</p>
<ul>
<li>如果当前运行的线程数少于 corePoolSize，则会创建新线程 addworker 来执行任务</li>
<li>如果当前线程的线程数等于 corePoolSize，会将任务直接加入到 <code>LinkedBlockingQueue</code> 无界阻塞队列中，LinkedBlockingQueue 的上限如果没有制定，默认为 Integer.MAX_VALUE 大小。</li>
<li>等到线程池中的任务执行完毕后，newFixedThreadPool 会反复从 LinkedBlockingQueue 中获取任务来执行。</li>
</ul>
<p>相较于 ThreadPoolExecutor，newFixedThreadPool 主要做了以下改变</p>
<ul>
<li>核心线程数等于最大线程数，因此 newFixedThreadPool 只有两个最大容量，一个是线程池的线程容量，还有一个是 LinkedBlockingQueue 无界阻塞队列的线程容量。</li>
<li>这里可以看到还有一个变化是 0L，也就是 keepAliveTime &#x3D; 0L，keepAliveTime 就是到达工作线程最大容量后的线程等待时间，0L 就意味着当线程池中的线程数大于 corePoolsize 时，空余的线程会被立即终止。</li>
<li>由于使用无界队列，运行中的 newFixedThreadPool 不会拒绝任务，也就是不会调用 RejectedExecutionHandler.rejectedExecution 方法。</li>
</ul>
<h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p>newSingleThreadExecutor 中只有单个工作线程，也就是说它是一个只有单个 worker 的 Executor。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">    (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                            <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                            threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在 newSingleThreadExecutor 中，corePoolSize 和 maximumPoolSize 都被设置为 1，也不存在超时情况，同样使用了 LinkedBlockingQueue 无界阻塞队列，除了 corePoolSize 和 maximumPoolSize 外，其他几乎和 newFixedThreadPool 一模一样。</p>
<p>下面是 newSingleThreadExecutor  的执行示意图</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/20.png" alt="图片"></p>
<p>newSingleThreadExecutor 的执行过程和 newFixedThreadPool 相同，只是 newSingleThreadExecutor 的工作线程数为 1。</p>
<h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><p>newCachedThreadPool 是一个根据需要创建工作线程的线程池，newCachedThreadPool 线程池最大数量是 Integer.MAX_VALUE，保活时间是 <code>60</code>秒，使用的是<code>SynchronousQueue</code> 无缓冲阻塞队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的执行示意图如下</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/21.png" alt="图片"></p>
<ul>
<li>首先会先执行 SynchronousQueue.offer 方法，如果当前 maximumPool 中有空闲线程正在执行 <code>SynchronousQueue.poll</code> ，就会把任务交给空闲线程来执行，execute 方法执行完毕，否则的话，继续向下执行。</li>
<li>如果 maximumPool 中没有线程执行 SynchronousQueue.poll 方法，这种情况下 newCachedThreadPool 会创建一个新线程执行任务，execute 方法执行完成。</li>
<li>执行完成的线程将执行 poll 操作，这个 poll 操作会让空闲线程最多在 SynchronousQueue 中等待 60 秒钟。如果 60 秒钟内提交了一个新任务，那么空闲线程会执行这个新提交的任务，否则空闲线程将会终止。</li>
</ul>
<p>这里的关键点在于 SynchronousQueue 队列，它是一个没有容量的阻塞队列。<strong>每个插入操作必须等待另一个线程对应的移除操作</strong>。这其实就是一种任务传递，如下图所示</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/22.png" alt="图片"></p>
<p>其实还有一个线程池 <code>ScheduledThreadPoolExecutor</code> ，就先不在此篇文章做详细赘述了。</p>
<h2 id="线程池实践考量因素"><a href="#线程池实践考量因素" class="headerlink" title="线程池实践考量因素"></a>线程池实践考量因素</h2><p>下面介绍几种在实践过程中使用线程池需要考虑的几个点</p>
<ul>
<li><strong>避免任务堆积</strong>，比如我们上面提到的 newFixedThreadPool，它是创建指定数目的线程，但是工作队列是无界的，这就导致如果工作队列线程太少，导致处理速度跟不上入队速度，这种情况下很可能会导致 OOM，诊断时可以使用 <code>jmap</code> 检查是否有大量任务入队。</li>
<li>生产实践中很可能由于逻辑不严谨或者工作线程不能及时释放导致 <strong>线程泄漏</strong>，这个时候最好检查一下线程栈</li>
<li>避免死锁等同步问题</li>
<li>尽量避免在使用线程池时操作 <code>ThreadLocal</code>，因为工作线程的生命周期可能会超过任务的生命周期。</li>
</ul>
<h2 id="线程池大小的设置"><a href="#线程池大小的设置" class="headerlink" title="线程池大小的设置"></a>线程池大小的设置</h2><p>线程池大小的设置也是面试官经常会考到的一个点，一般需要根据<code>任务类型</code>来配置线程池大小</p>
<ul>
<li>如果是 CPU 密集型任务，那么就意味着 CPU 是稀缺资源，这个时候我们通常不能通过增加线程数来提高计算能力，因为线程数量太多，会导致频繁的上下文切换，一般这种情况下，建议合理的线程数值是 <code>N(CPU)数 + 1</code>。</li>
<li>如果是 I&#x2F;O 密集型任务，就说明需要较多的等待，这个时候可以参考 Brain Goetz 的推荐方法 **线程数 &#x3D; CPU核数 × (1 + 平均等待时间&#x2F;平均工作时间)**。参考值可以是 N(CPU) 核数 * 2。</li>
</ul>
<p>当然，这只是一个参考值，具体的设置还需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整。</p>
<h2 id="线程池在业务中的实践"><a href="#线程池在业务中的实践" class="headerlink" title="线程池在业务中的实践"></a>线程池在业务中的实践</h2><p><strong>1.业务背景</strong></p>
<p>在当今的互联网业界，为了最大程度利用CPU的多核性能，并行运算的能力是不可或缺的。通过线程池管理线程获取并发性是一个非常基础的操作，让我们来看两个典型的使用线程池获取并发性的场景。</p>
<p><strong>场景1：快速响应用户请求</strong></p>
<p><strong>描述</strong>：用户发起的实时请求，服务追求响应时间。比如说用户要查看一个商品的信息，那么我们需要将商品维度的一系列信息如商品的价格、优惠、库存、图片等等聚合起来，展示给用户。</p>
<p><strong>分析</strong>：从用户体验角度看，这个结果响应的越快越好，如果一个页面半天都刷不出，用户可能就放弃查看这个商品了。而面向用户的功能聚合通常非常复杂，伴随着调用与调用之间的级联、多级级联等情况，业务开发同学往往会选择使用线程池这种简单的方式，将调用封装成任务并行的执行，缩短总体响应时间。另外，使用线程池也是有考量的，这种场景最重要的就是获取最大的响应速度去满足用户，所以应该不设置队列去缓冲并发任务，调高corePoolSize和maxPoolSize去尽可能创造多的线程快速执行任务。</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/23.png" alt="图片">图12 并行执行任务提升任务响应速度</p>
<p><strong>场景2：快速处理批量任务</strong></p>
<p><strong>描述</strong>：离线的大量计算任务，需要快速执行。比如说，统计某个报表，需要计算出全国各个门店中有哪些商品有某种属性，用于后续营销策略的分析，那么我们需要查询全国所有门店中的所有商品，并且记录具有某属性的商品，然后快速生成报表。</p>
<p><strong>分析</strong>：这种场景需要执行大量的任务，我们也会希望任务执行的越快越好。这种情况下，也应该使用多线程策略，并行计算。但与响应速度优先的场景区别在于，这类场景任务量巨大，并不需要瞬时的完成，而是关注如何使用有限的资源，尽可能在单位时间内处理更多的任务，也就是吞吐量优先的问题。所以应该设置队列去缓冲并发任务，调整合适的corePoolSize去设置处理任务的线程数。在这里，设置的线程数过多可能还会引发线程上下文切换频繁的问题，也会降低处理任务的速度，降低吞吐量。</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/24.png" alt="图片"><strong>实际问题及方案思考</strong></p>
<p>线程池使用面临的核心的问题在于：<strong>线程池的参数并不好配置</strong>。一方面线程池的运行机制不是很好理解，配置合理需要强依赖开发人员的个人经验和知识；另一方面，线程池执行的情况和任务类型相关性较大，IO密集型和CPU密集型的任务运行起来的情况差异非常大，这导致业界并没有一些成熟的经验策略帮助开发人员参考。</p>
<p>关于线程池配置不合理引发的故障，公司内部有较多记录，下面举一些例子：</p>
<p><strong>Case1</strong>：2018年XX页面展示接口大量调用降级。</p>
<p><strong>事故描述</strong>：XX页面展示接口产生大量调用降级，数量级在几十到上百。</p>
<p><strong>事故原因</strong>：该服务展示接口内部逻辑使用线程池做并行计算，由于没有预估好调用的流量，导致最大核心数设置偏小，大量抛出RejectedExecutionException，触发接口降级条件，示意图如下：</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/25.png" alt="图片">图14 线程数核心设置过小引发RejectExecutionException</p>
<p><strong>Case2</strong>：2018年XX业务服务不可用S2级故障。</p>
<p><strong>事故描述</strong>：XX业务提供的服务执行时间过长，作为上游服务整体超时，大量下游服务调用失败。</p>
<p><strong>事故原因</strong>：该服务处理请求内部逻辑使用线程池做资源隔离，由于队列设置过长，最大线程数设置失效，导致请求数量增加时，大量任务堆积在队列中，任务执行时间过长，最终导致下游服务的大量调用超时失败。示意图如下：</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/26.png" alt="图片"></p>
<p> 线程池队列长度设置过长、corePoolSize设置过小导致任务执行速度低</p>
<p>业务中要使用线程池，而使用不当又会导致故障，那么我们怎样才能更好地使用线程池呢？针对这个问题，我们下面延展几个方向：</p>
<p><strong>1. 能否不用线程池?</strong></p>
<p>回到最初的问题，业务使用线程池是为了获取并发性，对于获取并发性，是否可以有什么其他的方案呢替代？我们尝试进行了一些其他方案的调研：</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/27.png" alt="图片"></p>
<p>综合考虑，这些新的方案都能在某种情况下提升并行任务的性能，然而本次重点解决的问题是如何更简易、更安全地获得的并发性。另外，Actor模型的应用实际上甚少，只在Scala中使用广泛，协程框架在Java中维护的也不成熟。这三者现阶段都不是足够的易用，也并不能解决业务上现阶段的问题。</p>
<p><strong>2. 追求参数设置合理性？</strong></p>
<p>有没有一种计算公式，能够让开发同学很简易地计算出某种场景中的线程池应该是什么参数呢？</p>
<p>带着这样的疑问，我们调研了业界的一些线程池参数配置方案：</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/28.png" alt="图片"></p>
<p>调研了以上业界方案后，我们并没有得出通用的线程池计算方式。并发任务的执行情况和任务类型相关，IO密集型和CPU密集型的任务运行起来的情况差异非常大，但这种占比是较难合理预估的，这导致很难有一个简单有效的通用公式帮我们直接计算出结果。</p>
<p><strong>3. 线程池参数动态化？</strong></p>
<p>尽管经过谨慎的评估，仍然不能够保证一次计算出来合适的参数，那么我们是否可以将修改线程池参数的成本降下来，这样至少可以发生故障的时候可以快速调整从而缩短故障恢复的时间呢？基于这个思考，我们是否可以将线程池的参数从代码中迁移到分布式配置中心上，实现线程池参数可动态配置和即时生效，线程池参数动态化前后的参数修改流程对比如下：</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/29.png" alt="图片"></p>
<p>基于以上三个方向对比，我们可以看出参数动态化方向简单有效。</p>
<p><strong>3.3 动态化线程池</strong></p>
<p><strong>3.3.1 整体设计</strong></p>
<p>动态化线程池的核心设计包括以下三个方面：</p>
<ol>
<li><strong>简化线程池配置</strong>：线程池构造参数有8个，但是最核心的是3个：corePoolSize、maximumPoolSize，workQueue，它们最大程度地决定了线程池的任务分配和线程分配策略。考虑到在实际应用中我们获取并发性的场景主要是两种：（1）并行执行子任务，提高响应速度。这种情况下，应该使用同步队列，没有什么任务应该被缓存下来，而是应该立即执行。（2）并行执行大批次任务，提升吞吐量。这种情况下，应该使用有界队列，使用队列去缓冲大批量的任务，队列容量必须声明，防止任务无限制堆积。所以线程池只需要提供这三个关键参数的配置，并且提供两种队列的选择，就可以满足绝大多数的业务需求，Less is More。</li>
<li><strong>参数可动态修改</strong>：为了解决参数不好配，修改参数成本高等问题。在Java线程池留有高扩展性的基础上，封装线程池，允许线程池监听同步外部的消息，根据消息进行修改配置。将线程池的配置放置在平台侧，允许开发同学简单的查看、修改线程池配置。</li>
<li><strong>增加线程池监控</strong>：对某事物缺乏状态的观测，就对其改进无从下手。在线程池执行任务的生命周期添加监控能力，帮助开发同学了解线程池状态。</li>
</ol>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/30.png" alt="图片">图17 动态化线程池整体设计</p>
<p><strong>3.3.2 功能架构</strong></p>
<p>动态化线程池提供如下功能：</p>
<ul>
<li><strong>动态调参</strong>：支持线程池参数动态调整、界面化操作；包括修改线程池核心大小、最大核心大小、队列长度等；参数修改后及时生效。</li>
<li><strong>任务监控</strong>：支持应用粒度、线程池粒度、任务粒度的Transaction监控；可以看到线程池的任务执行情况、最大任务执行时间、平均任务执行时间、95&#x2F;99线等。</li>
<li><strong>负载告警</strong>：线程池队列任务积压到一定值的时候会通过大象（美团内部通讯工具）告知应用开发负责人；当线程池负载数达到一定阈值的时候会通过大象告知应用开发负责人。</li>
<li><strong>操作监控</strong>：创建&#x2F;修改和删除线程池都会通知到应用的开发负责人。</li>
<li><strong>操作日志</strong>：可以查看线程池参数的修改记录，谁在什么时候修改了线程池参数、修改前的参数值是什么。</li>
<li><strong>权限校验</strong>：只有应用开发负责人才能够修改应用的线程池参数。</li>
</ul>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/31.png" alt="图片"> 动态化线程池功能架构</p>
<p><strong>参数动态化</strong></p>
<p>JDK原生线程池ThreadPoolExecutor提供了如下几个public的setter方法，如下图所示：</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/32.png" alt="图片"> JDK 线程池参数设置接口</p>
<p>JDK允许线程池使用方通过ThreadPoolExecutor的实例来动态设置线程池的核心策略，以setCorePoolSize为方法例，在运行期线程池使用方调用此方法设置corePoolSize之后，线程池会直接覆盖原来的corePoolSize值，并且基于当前值和原始值的比较结果采取不同的处理策略。对于当前值小于当前工作线程数的情况，说明有多余的worker线程，此时会向当前idle的worker线程发起中断请求以实现回收，多余的worker在下次idle的时候也会被回收；对于当前值大于原始值且当前队列中有待执行任务，则线程池会创建新的worker线程来执行队列任务，setCorePoolSize具体流程如下：</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/33.png" alt="图片"> setCorePoolSize方法执行流程</p>
<p>线程池内部会处理好当前状态做到平滑修改，其他几个方法限于篇幅，这里不一一介绍。重点是基于这几个public方法，我们只需要维护ThreadPoolExecutor的实例，并且在需要修改的时候拿到实例修改其参数即可。基于以上的思路，我们实现了线程池参数的动态化、线程池参数在管理平台可配置可修改，其效果图如下图所示：</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/34.png" alt="图片"> 可动态修改线程池参数</p>
<p>用户可以在管理平台上通过线程池的名字找到指定的线程池，然后对其参数进行修改，保存后会实时生效。目前支持的动态参数包括核心数、最大值、队列长度等。除此之外，在界面中，我们还能看到用户可以配置是否开启告警、队列等待任务告警阈值、活跃度告警等等。关于监控和告警，我们下面一节会对齐进行介绍。</p>
<p><strong>线程池监控</strong></p>
<p>除了参数动态化之外，为了更好地使用线程池，我们需要对线程池的运行状况有感知，比如当前线程池的负载是怎么样的？分配的资源够不够用？任务的执行情况是怎么样的？是长任务还是短任务？</p>
<p>基于对这些问题的思考，动态化线程池提供了多个维度的监控和告警能力，包括：线程池活跃度、任务的执行Transaction（频率、耗时）、Reject异常、线程池内部统计信息等等，既能帮助用户从多个维度分析线程池的使用情况，又能在出现问题第一时间通知到用户，从而避免故障或加速故障恢复。</p>
<p><strong>1. 负载监控和告警</strong></p>
<p>线程池负载关注的核心问题是：基于当前线程池参数分配的资源够不够。对于这个问题，我们可以从事前和事中两个角度来看。事前，线程池定义了“活跃度”这个概念，来让用户在发生Reject异常之前能够感知线程池负载问题，线程池活跃度计算公式为：线程池活跃度 &#x3D; activeCount&#x2F;maximumPoolSize。这个公式代表当活跃线程数趋向于maximumPoolSize的时候，代表线程负载趋高。</p>
<p>事中，也可以从两方面来看线程池的过载判定条件，一个是发生了Reject异常，一个是队列中有等待任务（支持定制阈值）。以上两种情况发生了都会触发告警，告警信息会通过大象推送给服务所关联的负责人。</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/35.png" alt="图片"></p>
<p> 大象告警通知</p>
<p><strong>2. 任务级精细化监控</strong></p>
<p>在传统的线程池应用场景中，线程池中的任务执行情况对于用户来说是透明的。比如在一个具体的业务场景中，业务开发申请了一个线程池同时用于执行两种任务，一个是发消息任务、一个是发短信任务，这两类任务实际执行的频率和时长对于用户来说没有一个直观的感受，很可能这两类任务不适合共享一个线程池，但是由于用户无法感知，因此也无从优化。动态化线程池内部实现了任务级别的埋点，且允许为不同的业务任务指定具有业务含义的名称，线程池内部基于这个名称做Transaction打点，基于这个功能，用户可以看到线程池内部任务级别的执行情况，且区分业务，任务监控示意图如下图所示：</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/36.png" alt="图片"> 线程池任务执行监控</p>
<p><strong>3. 运行时状态实时查看</strong></p>
<p>用户基于JDK原生线程池ThreadPoolExecutor提供的几个public的getter方法，可以读取到当前线程池的运行状态以及参数，如下图所示：</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/37.png" alt="图片"> 线程池实时运行情况</p>
<p>动态化线程池基于这几个接口封装了运行时状态实时查看的功能，用户基于这个功能可以了解线程池的实时状态，比如当前有多少个工作线程，执行了多少个任务，队列中等待的任务数等等。效果如下图所示：</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/38.png" alt="图片">图25 线程池实时运行情况</p>
<p><strong>3.4 实践总结</strong></p>
<p>面对业务中使用线程池遇到的实际问题，我们曾回到支持并发性问题本身来思考有没有取代线程池的方案，也曾尝试着去追求线程池参数设置的合理性，但面对业界方案具体落地的复杂性、可维护性以及真实运行环境的不确定性，我们在前两个方向上可谓“举步维艰”。</p>
<p>最终，我们回到线程池参数动态化方向上探索，得出一个且可以解决业务问题的方案，虽然本质上还是没有逃离使用线程池的范畴，但是在成本和收益之间，算是取得了一个很好的平衡。成本在于实现动态化以及监控成本不高，收益在于：在不颠覆原有线程池使用方式的基础之上，从降低线程池参数修改的成本以及多维度监控这两个方面降低了故障发生的概率。希望本文提供的动态化线程池思路能对大家有帮助。</p>
<p><strong>四、参考资料</strong></p>
<p>[1]JDK 1.8 源码</p>
<p>[2] <a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E6%B1%A0">维基百科-线程池</a></p>
<p>[3] <a href="https://my.oschina.net/andylucc/blog/648127">更好的使用Java线程池</a></p>
<p>[4] <a href="https://en.wikipedia.org/wiki/Pooling_(resource_management)">维基百科Pooling(Resource Management)</a></p>
<p>[5] <a href="http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/">深入理解Java线程池：ThreadPoolExecutor</a></p>
<p>[6]《Java并发编程实践》</p>
]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>线程池</tag>
        <tag>动态线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>Java语言基础</title>
    <url>/2022/10/24/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h1><p><strong>数据类型分类:</strong><br>Java的数据类型分为两大类：<br>基本数据类型：包括 整数 、 浮点数 、 字符 、 布尔 。<br>引用数据类型：包括 类 、 数组 、 接口 。</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>四类八种基本数据类型：<br><img src="/2022/10/24/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/1.png" alt="在这里插入图片描述"></p>
<p>boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。</p>
<p><strong>自动转换：</strong> 将取值范围小的类型自动提升为取值范围大的类型。<br><strong>转换规则</strong><br>范围小的类型向范围大的类型提升， byte、short、char 运算时直接提升为 int。<br>byte、short、char‐‐&gt;int‐‐&gt;long‐‐&gt;float‐‐&gt;double<br><strong>强制转换:</strong><br>int i &#x3D; (int)1.5; &#x2F;&#x2F; double类型数据强制转成int类型，直接去掉小数点.</p>
<h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">2</span>;     <span class="comment">// 装箱 调用了 Integer.valueOf(2)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x;         <span class="comment">// 拆箱 调用了 X.intValue()</span></span><br></pre></td></tr></table></figure>

<h2 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h2><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p>
<ul>
<li>new Integer(123) 每次都会新建一个对象；</li>
<li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">z</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">k</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// high value may be configured by property</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span></span><br><span class="line">        sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (integerCacheHighPropValue != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parseInt(integerCacheHighPropValue);</span><br><span class="line">            i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">            <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">            <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    high = h;</span><br><span class="line"></span><br><span class="line">    cache = <span class="keyword">new</span> <span class="title class_">Integer</span>[(high - low) + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">        cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">    <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">System.out.println(m == n); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>基本类型对应的缓冲池如下：</p>
<ul>
<li>boolean values true and false</li>
<li>all byte values</li>
<li>short values between -128 and 127</li>
<li>int values between -128 and 127</li>
<li>char in the range \u0000 to \u007F</li>
</ul>
<p>在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。</p>
<p>在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax&#x3D;<size> 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。</size></p>
<h1 id="二、String"><a href="#二、String" class="headerlink" title="二、String"></a>二、String</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承）</p>
<p>在 Java 8 中，String 内部使用 char 数组存储数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The identifier of the encoding used to encode the bytes in &#123;<span class="doctag">@code</span> value&#125;. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span> coder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p>
<h2 id="不可变的好处"><a href="#不可变的好处" class="headerlink" title="不可变的好处"></a>不可变的好处</h2><p><strong>1. 可以缓存 hash 值</strong>  </p>
<p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p>
<p><strong>2. String Pool 的需要</strong>  </p>
<p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。<br><img src="/2022/10/24/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/2.png" alt="在这里插入图片描述"></p>
<p><strong>3. 安全性</strong>  </p>
<p>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p>
<p><strong>4. 线程安全</strong>  </p>
<p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p>
<h2 id="String-StringBuffer-and-StringBuilder"><a href="#String-StringBuffer-and-StringBuilder" class="headerlink" title="String, StringBuffer and StringBuilder"></a>String, StringBuffer and StringBuilder</h2><p><strong>1. 可变性</strong>  </p>
<ul>
<li>String 不可变</li>
<li>StringBuffer 和 StringBuilder 可变</li>
</ul>
<p><strong>2. 线程安全</strong>  </p>
<ul>
<li>String 不可变，因此是线程安全的</li>
<li>StringBuilder 不是线程安全的</li>
<li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li>
</ul>
<p>StringBuffer是线程安全的，支持并发操作，支持多线程；<br>StringBuilder是线程不安全的，不支持并发操作，支持单线程。<br>StringBuffer继承抽象类AbstractStringBuilder，StringBuffer可以给指定对象的实体初始化容量字符串长度再另外加16个字符串，<br>super(str.length+16),这是自动扩容，还有就是扩容算法：使用append（）方法在字符串后面追加东西的时候，如果超过了字符串存储空间大小就需要进行扩容，<br>传入一个方法：ensureCapacityInternal进行是否扩容判断，需要扩容就调用<strong>expendCapacity</strong>方法进行扩容。  </p>
<p>StringBuffer类可以创建可修改的字符串序列。该类有StringBuffer(),StringBuffer(int size),StringBuffer(String s)三个改造方法。</p>
<p>1.StringBuffer()的初始容量可以容纳16个字符，当该对象的实体存放的字符的长度大于16时，实体容量就自动增加。StringBuffer对象可以通过length()方法获取实体中存放的字符序列长度，通过capacity()方法来获取当前实体的实际容量。</p>
<p>2.StringBuffer(int size)可以指定分配给该对象的实体的初始容量参数为参数size指定的字符个数。当该对象的实体存放的字符序列的长度大于size个字符时，实体的容量就自动的增加。以便存放所增加的字符。 </p>
<p>3.StringBuffer(String s)可以指定给对象的实体的初始容量为参数字符串s的长度额外再加16个字符。当该对象的实体存放的字符序列长度大于size个字符时，实体的容量自动的增加，以便存放所增加的字符。 </p>
<p>接下来介绍StringBuffer()怎样扩容： </p>
<p>首先我们需要知道StringBuffer和StringBuilder类都继承了抽象类AbstractStringBuilder类；<br>源码都调用父类来进行初始化：<br><img src="/2022/10/24/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/3.png" alt="在这里插入图片描述"></p>
<p>StringBuffer(String s)的初始化：<br><img src="/2022/10/24/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/4.png" alt="在这里插入图片描述"></p>
<p>扩容算法：<br>使用append()方法在字符串后面追加东西的时候，如果长度超过了该字符串存储空间大小了就需要进行扩容：构建新的存储空间更大的字符串，将旧的复制过去；</p>
<p>再进行字符串append添加的时候，会先计算添加后字符串大小，传入一个方法：ensureCapacityInternal 这个方法进行是否扩容的判断，需要扩容就调用expandCapacity方法进行扩容：<br><img src="/2022/10/24/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/5.png" alt="在这里插入图片描述"></p>
<p>尝试将新容量扩为大小变成2倍+2   if 判断一下 容量如果不够，直接扩充到需要的容量大小。</p>
<h2 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h2><p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。</p>
<p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p>
<p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得同一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2);           <span class="comment">// false</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1.intern();</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1.intern();</span><br><span class="line">System.out.println(s3 == s4);           <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">System.out.println(s5 == s6);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p>
<h2 id="new-String-“abc”"><a href="#new-String-“abc”" class="headerlink" title="new String(“abc”)"></a>new String(“abc”)</h2><p>使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。</p>
<ul>
<li>“abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量；</li>
<li>而使用 new 的方式会在堆中创建一个字符串对象。</li>
</ul>
<p>创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewStringTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 javap -verbose 进行反编译，得到以下内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">Constant pool:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">   #<span class="number">2</span> = Class              #<span class="number">18</span>            <span class="comment">// java/lang/String</span></span><br><span class="line">   #<span class="number">3</span> = String             #<span class="number">19</span>            <span class="comment">// abc</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  #<span class="number">18</span> = Utf8               java/lang/String</span><br><span class="line">  #<span class="number">19</span> = Utf8               abc</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class java/lang/String</span></span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         <span class="number">4</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String abc</span></span><br><span class="line">         <span class="number">6</span>: invokespecial #<span class="number">4</span>                  <span class="comment">// Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="number">9</span>: astore_1</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>在 Constant Pool 中，#19 存储这字符串字面量 “abc”，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。</p>
<p>以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(String original)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = original.value;</span><br><span class="line">    <span class="built_in">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、运算"><a href="#三、运算" class="headerlink" title="三、运算"></a>三、运算</h1><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>Java 的参数是以值传递的形式传入方法中，而不是引用传递。</p>
<p>java中只有值传递，没有引用传递<br> 1.方法内如果传基本类型，传的是复印件，原件不动<br> 2.方法内如果传引用类型，传递的是引用（地址）<br>main方法在Java栈中，先进入栈底  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String personName;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String personName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.personName = personName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPersonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> personName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPersonName</span><span class="params">(String personName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.personName = personName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTransferValue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeValue1</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">       age=<span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeValue2</span><span class="params">(Person person)</span>&#123;</span><br><span class="line">        person.setPersonName(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeValue3</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        str=<span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">TestTransferValue</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestTransferValue</span>();</span><br><span class="line">        <span class="type">int</span> age=<span class="number">20</span>;</span><br><span class="line">        test.changeValue1(age);</span><br><span class="line">        System.out.println(<span class="string">&quot;age-----&quot;</span>+age);<span class="comment">//20</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        test.changeValue2(person);</span><br><span class="line">        System.out.println(<span class="string">&quot;personName----&quot;</span>+person.getPersonName());<span class="comment">//xxx</span></span><br><span class="line"></span><br><span class="line">        String str=<span class="string">&quot;abc&quot;</span>;<span class="comment">//在字符串常量池</span></span><br><span class="line">        <span class="comment">//如果字符串常量池中有直接复用，如果没有，新建</span></span><br><span class="line">        test.changeValue3(str);</span><br><span class="line">        System.out.println(<span class="string">&quot;String-----&quot;</span>+str);<span class="comment">//abc</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="float-与-double"><a href="#float-与-double" class="headerlink" title="float 与 double"></a>float 与 double</h2><p>Java 不能隐式执行向下转型，因为这会使得精度降低。</p>
<p>1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// float f = 1.1;</span></span><br></pre></td></tr></table></figure>

<p>1.1f 字面量才是 float 类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">1.1f</span>;</span><br></pre></td></tr></table></figure>

<h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// s1 = s1 + 1;</span></span><br></pre></td></tr></table></figure>

<p>但是使用 +&#x3D; 或者 ++ 运算符会执行隐式类型转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s1 += <span class="number">1</span>;</span><br><span class="line">s1++;</span><br></pre></td></tr></table></figure>

<p>上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s1 = (<span class="type">short</span>) (s1 + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>


<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;b&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数几个值的类型进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</p>
<h1 id="四、关键字"><a href="#四、关键字" class="headerlink" title="四、关键字"></a>四、关键字</h1><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>1.当用final去修饰一个类的时候，表示这个类不能被继承。<br>2.被final修饰的方法不能被重写.<br>  <strong>注意：</strong><br>  a. 一个类的private方法会隐式的被指定为final方法。<br>  b. 如果父类中有final修饰的方法，那么子类不能去重写。<br>3.修饰成员变量<br>  <strong>注意：</strong><br>  a. 必须要赋初始值，而且是只能初始化一次。<br>  b. 被fianl修饰的成员变量赋值，有两种方式：1、直接赋值 2、全部在构造方法中赋初值。<br>  c. 如果修饰的成员变量是基本类型，则表示这个变量的值不能改变。<br>  d. 如果修饰的成员变量是一个引用类型，则是说这个引用的地址的值不能修改，但是这个引用所指向的对象里面的内容还是可以改变的。<br>。</p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p><strong>1. 静态变量</strong>  </p>
<ul>
<li>静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。</li>
<li>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;         <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> y;  <span class="comment">// 静态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// int x = A.x;  // Non-static field &#x27;x&#x27; cannot be referenced from a static context</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> a.x;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> A.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 静态方法</strong>  </p>
<p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// public abstract static void func2();  // Illegal combination of modifiers: &#x27;abstract&#x27; and &#x27;static&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因此这两个关键字与具体对象关联。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="comment">// int b = y;  // Non-static field &#x27;y&#x27; cannot be referenced from a static context</span></span><br><span class="line">        <span class="comment">// int b = this.y;     // &#x27;A.this&#x27; cannot be referenced from a static context</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 静态语句块</strong>  </p>
<p>静态语句块在类初始化时运行一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">A</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure>

<p><strong>4. 静态内部类</strong>  </p>
<p>非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// InnerClass innerClass = new InnerClass(); // &#x27;OuterClass.this&#x27; cannot be referenced from a static context</span></span><br><span class="line">        <span class="type">OuterClass</span> <span class="variable">outerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">        <span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> outerClass.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        <span class="type">StaticInnerClass</span> <span class="variable">staticInnerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticInnerClass</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态内部类不能访问外部类的非静态的变量和方法。</p>
<p><strong>5. 静态导包</strong>  </p>
<p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.xxx.ClassName.*</span><br></pre></td></tr></table></figure>

<p><strong>6. 初始化顺序</strong>  </p>
<p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">staticField</span> <span class="operator">=</span> <span class="string">&quot;静态变量&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;静态语句块&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">String</span> <span class="variable">field</span> <span class="operator">=</span> <span class="string">&quot;实例变量&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;普通语句块&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后才是构造函数的初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InitialOrderTest</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;构造函数&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在继承的情况下，初始化顺序为：</p>
<ul>
<li>父类（静态变量、静态语句块）</li>
<li>子类（静态变量、静态语句块）</li>
<li>父类（实例变量、普通语句块）</li>
<li>父类（构造函数）</li>
<li>子类（实例变量、普通语句块）</li>
<li>子类（构造函数）</li>
</ul>
<h1 id="五、Object-通用方法"><a href="#五、Object-通用方法" class="headerlink" title="五、Object 通用方法"></a>五、Object 通用方法</h1><h2 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br></pre></td></tr></table></figure>

<h2 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h2><p><strong>1. 等价关系</strong>  </p>
<p>两个对象具有等价关系，需要满足以下五个条件：</p>
<p>Ⅰ 自反性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>Ⅱ 对称性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.equals(y) == y.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>Ⅲ 传递性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x.equals(y) &amp;&amp; y.equals(z))</span><br><span class="line">    x.equals(z); <span class="comment">// true;</span></span><br></pre></td></tr></table></figure>

<p>Ⅳ 一致性</p>
<p>多次调用 equals() 方法结果不变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.equals(y) == x.equals(y); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>Ⅴ 与 null 的比较</p>
<p>对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.equals(<span class="literal">null</span>); <span class="comment">// false;</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 等价与相等</strong>  </p>
<ul>
<li>对于基本类型，&#x3D;&#x3D; 判断两个值是否相等，基本类型没有 equals() 方法。</li>
<li>对于引用类型，&#x3D;&#x3D; 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x == y);      <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 实现</strong>  </p>
<ul>
<li>检查是否为同一个对象的引用，如果是直接返回 true；</li>
<li>检查是否是同一个类型，如果不是，直接返回 false；</li>
<li>将 Object 对象进行转型；</li>
<li>判断每个关键域是否相等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EqualExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EqualExample</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">        <span class="built_in">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">EqualExample</span> <span class="variable">that</span> <span class="operator">=</span> (EqualExample) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x != that.x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (y != that.y) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> z == that.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h2><p>hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。</p>
<p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等。</p>
<p>HashSet  和 HashMap 等集合类使用了 hashCode()  方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode()  方法。</p>
<p>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象。但是 EqualExample 没有实现 hashCode() 方法，因此这两个对象的哈希值是不同的，最终导致集合添加了两个等价的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">EqualExample</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EqualExample</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">EqualExample</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EqualExample</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(e1.equals(e2)); <span class="comment">// true</span></span><br><span class="line">HashSet&lt;EqualExample&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">set.add(e1);</span><br><span class="line">set.add(e2);</span><br><span class="line">System.out.println(set.size());   <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上。这就要求了哈希函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。</p>
<p>R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位，最左边的位丢失。并且一个数与 31 相乘可以转换成移位和减法：<code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">17</span>;</span><br><span class="line">    result = <span class="number">31</span> * result + x;</span><br><span class="line">    result = <span class="number">31</span> * result + y;</span><br><span class="line">    result = <span class="number">31</span> * result + z;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h2><p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToStringExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ToStringExample</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ToStringExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ToStringExample</span>(<span class="number">123</span>);</span><br><span class="line">System.out.println(example.toString());</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">ToStringExample@4554617c</span><br></pre></td></tr></table></figure>

<h2 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h2><p><strong>1. cloneable</strong>  </p>
<p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CloneExample</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CloneExample</span>();</span><br><span class="line"><span class="comment">// CloneExample e2 = e1.clone(); // &#x27;clone()&#x27; has protected access in &#x27;java.lang.Object&#x27;</span></span><br></pre></td></tr></table></figure>

<p>重写 clone() 得到以下实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CloneExample <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (CloneExample)<span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CloneExample</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CloneExample</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">CloneExample</span> <span class="variable">e2</span> <span class="operator">=</span> e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">java.lang.CloneNotSupportedException: CloneExample</span><br></pre></td></tr></table></figure>

<p>以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。</p>
<p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneExample</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 浅拷贝</strong>  </p>
<p>拷贝对象和原始对象的引用类型引用同一个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShallowCloneExample</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ShallowCloneExample</span><span class="params">()</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> ShallowCloneExample <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (ShallowCloneExample) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ShallowCloneExample</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShallowCloneExample</span>();</span><br><span class="line"><span class="type">ShallowCloneExample</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 222</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 深拷贝</strong>  </p>
<p>拷贝对象和原始对象的引用类型引用不同对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeepCloneExample</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DeepCloneExample</span><span class="params">()</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> DeepCloneExample <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">DeepCloneExample</span> <span class="variable">result</span> <span class="operator">=</span> (DeepCloneExample) <span class="built_in">super</span>.clone();</span><br><span class="line">        result.arr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            result.arr[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DeepCloneExample</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeepCloneExample</span>();</span><br><span class="line"><span class="type">DeepCloneExample</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><strong>4. clone() 的替代方案</strong>  </p>
<p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneConstructorExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CloneConstructorExample</span><span class="params">()</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CloneConstructorExample</span><span class="params">(CloneConstructorExample original)</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[original.arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; original.arr.length; i++) &#123;</span><br><span class="line">            arr[i] = original.arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CloneConstructorExample</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CloneConstructorExample</span>();</span><br><span class="line"><span class="type">CloneConstructorExample</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CloneConstructorExample</span>(e1);</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h1 id="六、继承"><a href="#六、继承" class="headerlink" title="六、继承"></a>六、继承</h1><h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><p><img src="/2022/10/24/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/6.png" alt="在这里插入图片描述"></p>
<h2 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h2><p><strong>1. 抽象类</strong>  </p>
<p>抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。</p>
<p>抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClassExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractExtendClassExample</span> <span class="keyword">extends</span> <span class="title class_">AbstractClassExample</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractClassExample ac1 = new AbstractClassExample(); // &#x27;AbstractClassExample&#x27; is abstract; cannot be instantiated</span></span><br><span class="line"><span class="type">AbstractClassExample</span> <span class="variable">ac2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AbstractExtendClassExample</span>();</span><br><span class="line">ac2.func1();</span><br></pre></td></tr></table></figure>

<p><strong>2. 接口</strong>  </p>
<p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p>
<p>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。</p>
<p>接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。</p>
<p>接口的字段默认都是 static 和 final 的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">func2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">    <span class="comment">// int y;               // Variable &#x27;y&#x27; might not have been initialized</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">0</span>;       <span class="comment">// Modifier &#x27;public&#x27; is redundant for interface fields</span></span><br><span class="line">    <span class="comment">// private int k = 0;   // Modifier &#x27;private&#x27; not allowed here</span></span><br><span class="line">    <span class="comment">// protected int l = 0; // Modifier &#x27;protected&#x27; not allowed here</span></span><br><span class="line">    <span class="comment">// private void fun3(); // Modifier &#x27;private&#x27; not allowed here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceImplementExample</span> <span class="keyword">implements</span> <span class="title class_">InterfaceExample</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// InterfaceExample ie1 = new InterfaceExample(); // &#x27;InterfaceExample&#x27; is abstract; cannot be instantiated</span></span><br><span class="line"><span class="type">InterfaceExample</span> <span class="variable">ie2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterfaceImplementExample</span>();</span><br><span class="line">ie2.func1();</span><br><span class="line">System.out.println(InterfaceExample.x);</span><br></pre></td></tr></table></figure>

<p><strong>3. 比较</strong><br>1.抽象类可以没有抽象方法，但接口中的方法必须是抽象方法；<br>2.抽象类中可以存在普通属性，方法，静态属性和方法；<br>3.接口中的变量必须是static final类型的，必须被初始化，只有常亮没有变量；<br>4.抽象类只能单继承，接口可以继承多个父接口。</p>
<p><strong>4. 使用选择</strong>  </p>
<p>如果准备为不相关的类创建一些提供共有功能的东西，请使用接口。<br>抽象类允许你为子类提供默认功能。<br>当创建一个可以被随意更改的独立项目时，使用优先于抽象类的接口，因为它提供更多的设计灵活性。<br>使用接口来引入多态行为而无需子类化并模拟多重继承 - 允许特定类型支持多种行为。</p>
<p>在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</p>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><ul>
<li>访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super() 函数。</li>
<li>访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SuperExample</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperExample.func()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperExtendExample</span> <span class="keyword">extends</span> <span class="title class_">SuperExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SuperExtendExample</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(x, y);</span><br><span class="line">        <span class="built_in">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.func();</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperExtendExample.func()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SuperExample</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuperExtendExample</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">e.func();</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">SuperExample.func()</span><br><span class="line">SuperExtendExample.func()</span><br></pre></td></tr></table></figure>


<h2 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h2><p><strong>1. 重写（Override）</strong>  </p>
<p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。</p>
<p>为了满足里式替换原则，重写有以下三个限制：</p>
<ul>
<li>子类方法的访问权限必须大于等于父类方法；</li>
<li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li>
<li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。</li>
</ul>
<p>使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。</p>
<p>下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中：</p>
<ul>
<li>子类方法访问权限为 public，大于父类的 protected。</li>
<li>子类的返回类型为 ArrayList<Integer>，是父类返回类型 List<Integer> 的子类。</Integer></Integer></li>
<li>子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。</li>
<li>子类重写方法使用 @Override 注解，从而让编译器自动检查是否满足限制条件。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;Integer&gt; <span class="title function_">func</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">func</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：</p>
<ul>
<li>this.func(this)</li>
<li>super.func(this)</li>
<li>this.func(super)</li>
<li>super.func(super)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    A</span></span><br><span class="line"><span class="comment">    |</span></span><br><span class="line"><span class="comment">    B</span></span><br><span class="line"><span class="comment">    |</span></span><br><span class="line"><span class="comment">    C</span></span><br><span class="line"><span class="comment">    |</span></span><br><span class="line"><span class="comment">    D</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(A obj)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A.show(A)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(C obj)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A.show(C)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(A obj)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B.show(A)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">C</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">    <span class="type">D</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">D</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 A 中存在 show(A obj)，直接调用</span></span><br><span class="line">    a.show(a); <span class="comment">// A.show(A)</span></span><br><span class="line">    <span class="comment">// 在 A 中不存在 show(B obj)，将 B 转型成其父类 A</span></span><br><span class="line">    a.show(b); <span class="comment">// A.show(A)</span></span><br><span class="line">    <span class="comment">// 在 B 中存在从 A 继承来的 show(C obj)，直接调用</span></span><br><span class="line">    b.show(c); <span class="comment">// A.show(C)</span></span><br><span class="line">    <span class="comment">// 在 B 中不存在 show(D obj)，但是存在从 A 继承来的 show(C obj)，将 D 转型成其父类 C</span></span><br><span class="line">    b.show(d); <span class="comment">// A.show(C)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用的还是 B 对象，所以 ba 和 b 的调用结果一样</span></span><br><span class="line">    <span class="type">A</span> <span class="variable">ba</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    ba.show(c); <span class="comment">// A.show(C)</span></span><br><span class="line">    ba.show(d); <span class="comment">// A.show(C)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 重载（Overload）</strong>  </p>
<p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。</p>
<p>应该注意的是，返回值不同，其它都相同不算是重载。</p>
<h1 id="七、java程序-编译-运行-Java程序编译和运行的过程"><a href="#七、java程序-编译-运行-Java程序编译和运行的过程" class="headerlink" title="七、java程序 编译 运行_Java程序编译和运行的过程"></a>七、java程序 编译 运行_Java程序编译和运行的过程</h1><p> Java整个编译以及运行的过程相当繁琐，本文通过一个简单的程序来简单的说明整个流程。    </p>
<p>首先两张图，描述编译和执行的过程：</p>
<p>Java代码编译是由Java源码编译器来完成，流程图如下所示：<br><img src="/2022/10/24/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/7.png" alt="在这里插入图片描述"></p>
<p>Java字节码的执行是由JVM执行引擎来完成，流程图如下所示：<br><img src="https://img-blog.csdnimg.cn/20210410013410761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<pre><code> 如上图，Java程序从源文件创建到程序运行要经过两大步骤：1、源文件由编译器编译成字节码（ByteCode）  2、字节码由java虚拟机解释运行。因为java程序既要编译同时也要经过JVM的解释运行，所以说Java被称为半解释语言（ &quot;semi-interpreted&quot; language）。
</code></pre>
<p>图1   java程序编译运行过程</p>
<p>下面通过以下这个java程序，来说明java程序从编译到最后运行的整个流程。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java代码</span><br><span class="line"></span><br><span class="line"><span class="comment">//MainApp.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApp</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;Puppy&quot;</span>);</span><br><span class="line"></span><br><span class="line">animal.printName();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Animal.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printName</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Animal [&quot;</span>+name+<span class="string">&quot;]&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一步(编译): 创建完源文件之后，程序会先被编译为.class文件。Java编译一个类时，如果这个类所依赖的类还没有被编译，编译器就会先编译这个被依赖的类，然后引用，否则直接引用，这个有点象make。如果java编译器在指定目录下找不到该类所其依赖的类的.class文件或者.java源文件的话，编译器话报“cant find symbol”的错误。</p>
<p>编译后的字节码文件格式主要分为两部分：<strong>常量池和方法字节码</strong>。常量池记录的是代码出现过的所有token(类名，成员变量名等等)以及符号引用(方法引用，成员变量引用等等)；方法字节码放的是类中各个方法的字节码。下面是MainApp.class通过反汇编的结果，我们可以清楚看到.class文件的结构：</p>
<p> MainApp类常量池<br><img src="/2022/10/24/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/8.png" alt="在这里插入图片描述"></p>
<p>MainApp类方法字节码<br><img src="/2022/10/24/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/9.png" alt="在这里插入图片描述"></p>
<p>第二步(运行)：java类运行的过程大概可分为两个过程：<strong>1、类的加载  2、类的执行。</strong>需要说明的是：JVM主要在程序第一次主动使用类的时候，才会去加载该类。也就是说，JVM并不是在一开始就把一个程序就所有的类都加载到内存中，而是到不得不用的时候才把它加载进来，而且只加载一次。</p>
<p>下面是程序运行的详细步骤：</p>
<p>在编译好java程序得到MainApp.class文件后，在命令行上敲java AppMain。系统就会启动一个jvm进程，jvm进程从classpath路径中找到一个名为AppMain.class的二进制文件，将MainApp的类信息加载到运行时数据区的方法区内，这个过程叫做MainApp类的加载。</p>
<p>然后JVM找到AppMain的主函数入口，开始执行main函数。</p>
<p>main函数的第一条命令是Animal  animal &#x3D; new Animal(“Puppy”);就是让JVM创建一个Animal对象，但是这时候方法区中没有Animal类的信息，所以JVM马上加载Animal类，把Animal类的类型信息放到方法区中。</p>
<p>加载完Animal类之后，Java虚拟机做的第一件事情就是在堆区中为一个新的Animal实例分配内存, 然后调用构造函数初始化Animal实例，这个Animal实例持有着指向方法区的Animal类的类型信息(其中包含有方法表，java动态绑定的底层实现)的引用。</p>
<p>当使用animal.printName()的时候，JVM根据animal引用找到Animal对象，然后根据Animal对象持有的引用定位到方法区中Animal类的类型信息的方法表，获得printName()函数的字节码的地址。</p>
<p>开始运行printName()函数。</p>
<p>java程序运行过程<br><img src="/2022/10/24/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/10.png" alt="在这里插入图片描述"></p>
<p>Java类中所有public和protected的实例方法都采用动态绑定机制，所有私有方法、静态方法、构造器及初始化方法都是采用静态绑定机制。而使用动态绑定机制的时候会用到方法表，静态绑定时并不会用到。</p>
<p>Java初始化一个类的时候可以用new 操作符来初始化,也可通过Class.forName的方式来得到一个Class类型的实例,然后通过这个Class类型的实例的newInstance来初始化.我们把前者叫做JAVA的静态加载,把后者叫做动态加载.。</p>
<h2 id="八、反射"><a href="#八、反射" class="headerlink" title="八、反射"></a>八、反射</h2><p>每个类都有一个 <strong>Class</strong> 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p>
<p>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p>
<p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p>
<p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p>
<ul>
<li><strong>Field</strong> ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li>
<li><strong>Method</strong> ：可以使用 invoke() 方法调用与 Method 对象关联的方法；</li>
<li><strong>Constructor</strong> ：可以用 Constructor 的 newInstance() 创建新的对象。</li>
</ul>
<p><strong>反射的优点：</strong></p>
<ul>
<li><strong>可扩展性</strong> ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。</li>
<li><strong>类浏览器和可视化开发环境</strong> ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。</li>
<li><strong>调试器和测试工具</strong> ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。</li>
</ul>
<p><strong>反射的缺点：</strong></p>
<p>尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。</p>
<ul>
<li><strong>性能开销</strong> ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。</li>
<li><strong>安全限制</strong> ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。</li>
<li><strong>内部暴露</strong> ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。</li>
</ul>
<h1 id="九、异常"><a href="#九、异常" class="headerlink" title="九、异常"></a>九、异常</h1><p>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： <strong>Error</strong> 和 <strong>Exception</strong>。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：</p>
<ul>
<li><strong>受检异常</strong> ：需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复；</li>
<li><strong>非受检异常</strong> ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。<br><img src="/2022/10/24/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/11.png" alt="在这里插入图片描述"></li>
</ul>
<p><img src="/2022/10/24/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/12.png" alt="在这里插入图片描述"></p>
<h1 id="十、泛型"><a href="#十、泛型" class="headerlink" title="十、泛型"></a>十、泛型</h1><ol>
<li>Java中的泛型是什么 ? 使用泛型的好处是什么?</li>
</ol>
<p>　　这是在各种Java泛型面试中，<strong>参数化类型</strong>，一开场你就会被问到的问题中的一个，主要集中在初级和中级面试中。那些拥有Java1.4或更早版本的开发背景的人都知道，在集合中存储对象并在使用前进行类型转换是多么的不方便。泛型防止了那种情况的发生。它提供了编译期的类型安全，确保你只能把正确类型的对象放入集合中，避免了在运行时出现ClassCastException。</p>
<ol start="2">
<li>Java的泛型是如何工作的 ? 什么是类型擦除 ?</li>
</ol>
<p>　　这是一道更好的泛型面试题。泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如List<String>在运行时仅用一个List来表示。这样做的目的，是确保能和Java 5之前的版本开发二进制类库进行兼容。你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型。</String></p>
<ol start="3">
<li>什么是泛型中的限定通配符和非限定通配符 ?</li>
</ol>
<p>　　这是另一个非常流行的Java泛型面试题。限定通配符对类型进行了限制。有两种限定通配符，一种是<? extends T>它通过确保类型必须是T的子类来设定类型的上界，另一种是<? super T>它通过确保类型必须是T的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。另一方面<?>表示了非限定通配符，因为&lt;?&gt;可以用任意类型来替代；</p>
<ol start="4">
<li>List&lt;? extends T&gt;和List &lt;? super T&gt;之间有什么区别 ?</li>
</ol>
<p>　　这和上一个面试题有联系，有时面试官会用这个问题来评估你对泛型的理解，而不是直接问你什么是限定通配符和非限定通配符。这两个List的声明都是限定通配符的例子，List&lt;? extends T&gt;可以接受任何继承自T的类型的List，而List&lt;? super T&gt;可以接受任何T的父类构成的List。例如List&lt;? extends Number&gt;可以接受List<Integer>或List<Float>。</Float></Integer></p>
<h1 id="十一、Java-与-C-的区别"><a href="#十一、Java-与-C-的区别" class="headerlink" title="十一、Java 与 C++ 的区别"></a>十一、Java 与 C++ 的区别</h1><ul>
<li>Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。</li>
<li>Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。</li>
<li>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。</li>
<li>Java 支持自动垃圾回收，而 C++ 需要手动回收。</li>
<li>Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。</li>
<li>Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。</li>
<li>Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。</li>
</ul>
<h1 id="十二、JRE-or-JDK"><a href="#十二、JRE-or-JDK" class="headerlink" title="十二、JRE or JDK"></a>十二、JRE or JDK</h1><ul>
<li>JRE：Java Runtime Environment，java运行环境的简称，为java的运行提供了所需的环境。主要包括了JVM的标准实现和一些java基本类库。</li>
<li>JDK：Java Development Kit，java开发工具包，提供了java的开发及运行环境。JDK是java开发的核心，集成了JRE以及一些其他的工具，比如编译 java 源码的编译器 javac等。</li>
<li>因此可以这样认为：JDK&gt;JRE&gt;JVM，JRE支持了java程序的运行，而JDK则同时支持了java程序的开发。</li>
</ul>
<h1 id="十三、标识符"><a href="#十三、标识符" class="headerlink" title="十三、标识符"></a>十三、标识符</h1><p>标识符可以包含 英文字母26个(区分大小写) 、 0-9数字 、 $（美元符号） 和 _（下划线） 。<br>标识符不能以数字开头。<br>标识符不能是关键字。</p>
<h1 id="十三、编码"><a href="#十三、编码" class="headerlink" title="十三、编码"></a>十三、编码</h1><p><strong>Java中汉字占几个字节？</strong><br>可能占2、3、4个字节，看编码格式  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UtfTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 第二个字符为BMP之外的字符，csdn编辑器无法显示该字符，可以在运行结果截图中看到</span></span><br><span class="line">        String[] strArr = &#123;<span class="string">&quot;中&quot;</span>, <span class="string">&quot;鼍&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;aa&quot;</span>&#125;;</span><br><span class="line">        String[] charsetArr = &#123;<span class="string">&quot;gbk&quot;</span>, <span class="string">&quot;utf-8&quot;</span>, <span class="string">&quot;utf-16&quot;</span>, <span class="string">&quot;gb2312&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(String str : strArr) &#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">            <span class="keyword">for</span>(String charset : charsetArr) &#123;</span><br><span class="line">                byteTest(str, charset);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;============================&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">byteTest</span><span class="params">(String str, String charset)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;编码：&quot;</span> + charset</span><br><span class="line">                + <span class="string">&quot;\t所占字节数：&quot;</span> + str.getBytes(charset).length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 中</span></span><br><span class="line"><span class="comment">编码：gbk	所占字节数：2</span></span><br><span class="line"><span class="comment">编码：utf-8	所占字节数：3</span></span><br><span class="line"><span class="comment">编码：utf-16	所占字节数：4</span></span><br><span class="line"><span class="comment">编码：gb2312	所占字节数：2</span></span><br><span class="line"><span class="comment">============================</span></span><br><span class="line"><span class="comment">鼍</span></span><br><span class="line"><span class="comment">编码：gbk	所占字节数：2</span></span><br><span class="line"><span class="comment">编码：utf-8	所占字节数：3</span></span><br><span class="line"><span class="comment">编码：utf-16	所占字节数：4</span></span><br><span class="line"><span class="comment">编码：gb2312	所占字节数：2</span></span><br><span class="line"><span class="comment">============================</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">编码：gbk	所占字节数：1</span></span><br><span class="line"><span class="comment">编码：utf-8	所占字节数：1</span></span><br><span class="line"><span class="comment">编码：utf-16	所占字节数：4</span></span><br><span class="line"><span class="comment">编码：gb2312	所占字节数：1</span></span><br><span class="line"><span class="comment">============================</span></span><br><span class="line"><span class="comment">aa</span></span><br><span class="line"><span class="comment">编码：gbk	所占字节数：2</span></span><br><span class="line"><span class="comment">编码：utf-8	所占字节数：2</span></span><br><span class="line"><span class="comment">编码：utf-16	所占字节数：6</span></span><br><span class="line"><span class="comment">编码：gb2312	所占字节数：2</span></span><br><span class="line"><span class="comment">============================</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure>

<h1 id="十四、内部类"><a href="#十四、内部类" class="headerlink" title="十四、内部类"></a>十四、内部类</h1><p>1.为什么使用内部类?<br>使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。<br>1.1.使用内部类最大的优点就在于它能够非常好的解决多重继承的问题,使用内部类还能够为我们带来如下特性:<br>(1)内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。<br>(2)在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。<br>(3)创建内部类对象的时刻并不依赖于外围类对象的创建。<br>(4)内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。<br>(5)内部类提供了更好的封装，除了该外围类，其他类都不能访问。  </p>
<h3 id="2-内部类分类"><a href="#2-内部类分类" class="headerlink" title="2.内部类分类:"></a>2.内部类分类:</h3><p><strong>(一).成员内部类:</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">	<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Coco&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Jayden&quot;</span>;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(Outer.<span class="built_in">this</span>.name);</span><br><span class="line">		System.out.println(name);</span><br><span class="line">		System.out.println(age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Inner <span class="title function_">getInnerClass</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	<span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">	<span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> o.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">	in.show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.Inner 类定义在 Outer 类的内部，相当于 Outer 类的一个成员变量的位置，Inner 类可以使用任意访问	控制符，如 public 、 protected 、 private 等；<br>2.Inner 类中定义的 show() 方法可以直接访问 Outer 类中的数据，而不受访问控制符的影响，如直接访问 Outer 类中的私有属性age；<br>3.定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去 new 一个内部类对象，即：内部类 对象名 &#x3D; 外部类对象.new 内部类( );<br>4.编译上面的程序后，会发现产生了两个 .class 文件: Outer.class,Outer$Inner.class{}<br>5.成员内部类中不能存在任何 static 的变量和方法,可以定义常量:<br>   (1)因为非静态内部类是要依赖于外部类的实例,而静态变量和方法是不依赖于对象的,仅与类相关,<br>    简而言之:在加载静态域时,根本没有外部类,所在在非静态内部类中不能定义静态域或方法,编译不通过;<br>   非静态内部类的作用域是实例级别；<br>   (2)常量是在编译器就确定的,放到所谓的常量池了；<br><strong>★★友情提示:</strong><br>1.外部类是不能直接使用内部类的成员和方法的，可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法;<br>2.如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量,可以使用 this 关键字,如:Outer.this.name  </p>
<p><strong>(二).静态内部类: 是 static 修饰的内部类</strong><br>1.静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问;<br>2.如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员,如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员;<br>3.创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名 &#x3D; new 内部类();  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Coco&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Jayden&quot;</span>;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">			System.out.println(Outer.name);</span><br><span class="line">			System.out.println(name); </span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	<span class="type">Inner</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">	i.show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(三).方法内部类：</strong><br>其作用域仅限于方法内，方法外部无法访问该内部类<br>(1)局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的；<br>(2)只能访问方法中定义的 final 类型的局部变量,因为:<br>  当方法被调用运行完毕之后，局部变量就已消亡了。但内部类对象可能还存在,直到没有被引用时才会消亡。此时就会出现一种情况，就是内部类要访问一个不存在的局部变量;<br>&#x3D;&#x3D;&gt;使用final修饰符不仅会保持对象的引用不会改变,而且编译器还会持续维护这个对象在回调方法中的生命周期.<br>局部内部类并不是直接调用方法传进来的参数，而是内部类将传进来的参数通过自己的构造器备份到了自己的内部，自己内部的方法调用的实际是自己的属性而不是外部类方法的参数;<br>防止被篡改数据,而导致内部类得到的值不一致<br>   &#x2F;*<br>使用的形参为何要为 final???<br> 在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，也就是说在内部类中我对属性的改变并不会影响到外部的形参，而然这从程序员的角度来看这是不可行的， 毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定使用 final 来避免形参的不改变<br> *&#x2F;    </p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">25</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">13</span>;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;访问外部类:&quot;</span> + a);</span><br><span class="line">	System.out.println(<span class="string">&quot;访问内部类:&quot;</span> + c);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Inner</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">i.print();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">  <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">   o.show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>(3).注意:在JDK8版本之中,方法内部类中调用方法中的局部变量,可以不需要修饰为 final,匿名内部类也是一样的，主要是JDK8之后增加了 Effectively final 功能</p>
<p><a href="http://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html">http://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html</a>  </p>
<p>反编译jdk8编译之后的class文件,发现内部类引用外部的局部变量都是 final 修饰的  </p>
<p><strong>(四).匿名内部类:</strong> </p>
<p>(1).匿名内部类是直接使用 new 来生成一个对象的引用;<br>(2).对于匿名内部类的使用它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例,该类的定义会立即消失，所以匿名内部类是不能够被重复使用;<br>(3).使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口;<br>(4).匿名内部类中是不能定义构造函数的,匿名内部类中不能存在任何的静态成员变量和静态方法;<br>(5).匿名内部类中不能存在任何的静态成员变量和静态方法,匿名内部类不能是抽象的,它必须要实现继承的类或者实现的接口的所有抽象方法<br>(6).匿名内部类初始化:使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">          <span class="keyword">public</span> InnerClass <span class="title function_">getInnerClass</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span>   num,String str2)</span>&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InnerClass</span>()&#123;</span><br><span class="line">                  <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> num + <span class="number">3</span>;</span><br><span class="line">                  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span>&#123;</span><br><span class="line">                      <span class="keyword">return</span> number;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;;        <span class="comment">/* 注意：分号不能省 */</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">              <span class="type">OuterClass</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">              <span class="type">InnerClass</span> <span class="variable">inner</span> <span class="operator">=</span> out.getInnerClass(<span class="number">2</span>, <span class="string">&quot;chenssy&quot;</span>);</span><br><span class="line">              System.out.println(inner.getNumber());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">interface</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">          <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span>;</span><br><span class="line">      &#125;   </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="十五、Comparable和Comparator"><a href="#十五、Comparable和Comparator" class="headerlink" title="十五、Comparable和Comparator"></a>十五、Comparable和Comparator</h1><p>Comparable的代码如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T o)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Comparator的代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jdk1.8 后的方法</span></span><br><span class="line">    <span class="keyword">default</span> Comparator&lt;T&gt; <span class="title function_">reversed</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.reverseOrder(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Comparable和Comparator的主要区别在于：</p>
<p>　　(1).Comparator 和 Comparable都是Java中的内部比较器接口，都是用来实现对一个自定义的类进行排序</p>
<p>　　(2). 不同的是实现Comparable接口是定义在类的内部，比较代码需要嵌入类的内部结构中</p>
<p>　　(3).  Comparator 实现在类的外部，单独实现第一个比较器，不需要对原来的类进行结构上的变化，属于无侵入式的。<br>    (4).Comparator更加符合开闭原则，对修改关闭，对扩展开放</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Score</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Score&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> score;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTime</span><span class="params">(<span class="type">int</span> time)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.time = time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Score</span><span class="params">(<span class="type">int</span> score, <span class="type">int</span> time)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">        <span class="built_in">this</span>.time = time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Score o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.time&gt;o.time) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.time==o.time) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Score&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;score=&quot;</span> + score +</span><br><span class="line">                <span class="string">&quot;, time=&quot;</span> + time +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScoreComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Score&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Score o1, Score o2)</span> &#123;</span><br><span class="line">       <span class="comment">/* if(o1.time&gt;o2.time) return 1;</span></span><br><span class="line"><span class="comment">        else if(o1.time==o2.time) return 0;</span></span><br><span class="line"><span class="comment">        else return -1;*/</span></span><br><span class="line">       <span class="keyword">return</span> o1.score-o2.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScoreTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Score</span> <span class="variable">score</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Score</span>(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="type">Score</span> <span class="variable">score1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Score</span>(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">        <span class="type">Score</span> <span class="variable">score2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Score</span>(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">        <span class="type">Score</span> <span class="variable">score3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Score</span>(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="type">Score</span> <span class="variable">score4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Score</span>(<span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line">        Score[] help=<span class="keyword">new</span> <span class="title class_">Score</span>[]&#123;score,score1,score2,score3,score4&#125;;</span><br><span class="line">        Arrays.sort(help,<span class="keyword">new</span> <span class="title class_">ScoreComparator</span>());</span><br><span class="line">        System.out.println(Arrays.toString(help));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="十六、序列化和反序列化"><a href="#十六、序列化和反序列化" class="headerlink" title="十六、序列化和反序列化"></a>十六、序列化和反序列化</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User1</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User1&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializableDemo1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception, IOException &#123;</span><br><span class="line">        <span class="comment">//初始化对象</span></span><br><span class="line">        <span class="type">User1</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User1</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;tanglilei&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">23</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="comment">//序列化对象到文件中</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;template&quot;</span>));</span><br><span class="line">        oos.writeObject(user);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line"><span class="comment">//        File file = new File(&quot;template&quot;);</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;template&quot;</span>));</span><br><span class="line">        <span class="type">User1</span> <span class="variable">newUser</span> <span class="operator">=</span> (User1) ois.readObject();</span><br><span class="line">        System.out.println(newUser.toString());</span><br><span class="line"><span class="comment">/*        File file = new File(&quot;template&quot;);</span></span><br><span class="line"><span class="comment">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file));</span></span><br><span class="line"><span class="comment">        User1 newUser = (User1)ois.readObject();</span></span><br><span class="line"><span class="comment">        System.out.println(newUser.toString());*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合</title>
    <url>/2022/10/24/Java%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="一、概览"><a href="#一、概览" class="headerlink" title="一、概览"></a>一、概览</h1><table>
<thead>
<tr>
<th>Collection</th>
<th></th>
<th>是否有序</th>
<th>是否允许元素重复</th>
<th>是否允许null值</th>
<th>实现</th>
<th>优点</th>
<th>缺点</th>
<th>默认容量</th>
<th>扩容因子</th>
<th>扩容</th>
</tr>
</thead>
<tbody><tr>
<td>List</td>
<td>ArrayList</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>数组实现</td>
<td>无容量限制，查询快，轻量级</td>
<td>增删慢，线程不安全</td>
<td>10</td>
<td>1</td>
<td>1.5倍</td>
</tr>
<tr>
<td></td>
<td>LinkedList</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>链表实现</td>
<td>增删快</td>
<td>查询慢，双向链表，线程不安全</td>
<td>10</td>
<td>1</td>
<td>1.5倍</td>
</tr>
<tr>
<td></td>
<td>Vector</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>数组实现</td>
<td>线程安全，查询快</td>
<td>重量级，存在性能问题，增删慢</td>
<td>10</td>
<td>1</td>
<td>2倍</td>
</tr>
<tr>
<td>Set</td>
<td>HashSet</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>基于HashMap实现</td>
<td>效率高</td>
<td>非线程安全</td>
<td>16</td>
<td>0.75</td>
<td>2倍</td>
</tr>
<tr>
<td></td>
<td>TreeSet</td>
<td>是（用二叉树实现排序）</td>
<td>否</td>
<td>否</td>
<td>基于TreeMap实现</td>
<td>可以指定比较方法进行排序</td>
<td>非线程安全</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>LinkedHashSet</td>
<td>是（用二叉树实现排序）</td>
<td>否</td>
<td>是</td>
<td>继承HashSet，底层使用LinkedHashMap</td>
<td>链表保证元素有序，hash表保证元素唯一</td>
<td>双重链接列表</td>
<td>16</td>
<td>0.75</td>
<td>2倍</td>
</tr>
<tr>
<td>Map</td>
<td>HashMap</td>
<td>否</td>
<td>使用key-value来映射和存储数据，key必须唯一，value可以重复</td>
<td>最多只允许一条记录的key为null</td>
<td>根据key的hashCode值存储数据</td>
<td>使用hash算法去重效率高</td>
<td>非线程安全</td>
<td>16</td>
<td>0.75</td>
<td>2倍</td>
</tr>
<tr>
<td></td>
<td>TreeMap</td>
<td>是（用二叉树排序）</td>
<td>同上</td>
<td>否</td>
<td>基于红黑树实现，继承AbstractMap，并且实现了NavigableMap接口</td>
<td>可以用指定比较方法进行排序</td>
<td>非线程安全</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>LinkedHashMap</td>
<td>是</td>
<td>同上</td>
<td>是</td>
<td>在HashMap基础上采用了双向链表</td>
<td>元素迭代顺序和插入顺序一致</td>
<td>双重链接链表，非同步，遍历比HashMap慢</td>
<td>16</td>
<td>0.75</td>
<td>2倍</td>
</tr>
<tr>
<td></td>
<td>WeakHashMap</td>
<td>否</td>
<td>同上</td>
<td>是</td>
<td>KV对存储，“弱键”自动GC回收删除，继承AbstractMap</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>HashTable</td>
<td>否</td>
<td>同上</td>
<td>否</td>
<td>在HashMap基础上加synchronized</td>
<td>线程安全</td>
<td>效率低</td>
<td>11</td>
<td>0.75</td>
<td>2倍+1</td>
</tr>
</tbody></table>
<p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。<br><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/1.png" alt="在这里插入图片描述"></p>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/2.png" alt="在这里插入图片描述"></p>
<h3 id="1-Set"><a href="#1-Set" class="headerlink" title="1. Set"></a>1. Set</h3><ul>
<li><p>TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</p>
</li>
<li><p>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</p>
</li>
<li><p>LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。</p>
</li>
</ul>
<h3 id="2-List"><a href="#2-List" class="headerlink" title="2. List"></a>2. List</h3><ul>
<li><p>ArrayList：基于动态数组实现，支持随机访问。</p>
</li>
<li><p>Vector：和 ArrayList 类似，但它是线程安全的。</p>
</li>
<li><p>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</p>
</li>
</ul>
<h3 id="3-Queue"><a href="#3-Queue" class="headerlink" title="3. Queue"></a>3. Queue</h3><ul>
<li><p>LinkedList：可以用它来实现双向队列。</p>
</li>
<li><p>PriorityQueue：基于堆结构实现，可以用它来实现优先队列</p>
</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/3.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>TreeMap：基于红黑树实现。</p>
</li>
<li><p>HashMap：基于哈希表实现。</p>
</li>
<li><p>HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</p>
</li>
<li><p>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</p>
</li>
</ul>
<h1 id="二、容器中的设计模式"><a href="#二、容器中的设计模式" class="headerlink" title="二、容器中的设计模式"></a>二、容器中的设计模式</h1><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/4.png" alt="在这里插入图片描述"></p>
<p>Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。</p>
<p>从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>java.util.Arrays#asList() 可以把数组类型转换为 List 类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">asList</span><span class="params">(T... a)</span></span><br></pre></td></tr></table></figure>

<p>应该注意的是 asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Arrays.asList(arr);</span><br></pre></td></tr></table></figure>

<p>也可以使用以下方式调用 asList()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h1 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h1><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="1-概览"><a href="#1-概览" class="headerlink" title="1. 概览"></a>1. 概览</h3><p>因为 ArrayList 是基于数组实现的，所以支持快速随机访问。RandomAccess 接口标识着该类支持快速随机访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>

<p>数组的默认大小为 10。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>创建了一个大小为0的数组，在后面用到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>声明一个数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure>

<p>(1)ArrayList的无参构造方法，将前面声明创建的大小为0的数组赋给elementData数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2)这是ArrayList的有参构造方法，传入一个int类型的变量，相当于我们在使用arrayList的时候指定list的大小。如果传入的参数大于0，则新建一个initialCapacity大小的数组。传入值等于0的话，将这个空数组给elementData。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-扩容"><a href="#2-扩容" class="headerlink" title="2. 扩容"></a>2. 扩容</h3><p>添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，也就是旧容量的 1.5 倍。</p>
<p>扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-删除元素"><a href="#3-删除元素" class="headerlink" title="3. 删除元素"></a>3. 删除元素</h3><p>需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-序列化"><a href="#4-序列化" class="headerlink" title="4. 序列化"></a>4. 序列化</h3><p>ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。</p>
<p>保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br></pre></td></tr></table></figure>

<p>ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> java.io.IOException&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file));</span><br><span class="line">oos.writeObject(list);</span><br></pre></td></tr></table></figure>

<h3 id="5-Fail-Fast"><a href="#5-Fail-Fast" class="headerlink" title="5. Fail-Fast"></a>5. Fail-Fast</h3><p>modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。</p>
<p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。代码参考上节序列化中的 writeObject() 方法。</p>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><h3 id="1-同步"><a href="#1-同步" class="headerlink" title="1. 同步"></a>1. 同步</h3><p>它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-扩容-1"><a href="#2-扩容-1" class="headerlink" title="2. 扩容"></a>2. 扩容</h3><p>Vector 的构造函数可以传入 capacityIncrement 参数，它的作用是在扩容时使容量 capacity 增长 capacityIncrement。如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的两倍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">int</span> capacityIncrement)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    <span class="built_in">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用没有 capacityIncrement 的构造函数时，capacityIncrement 值被设置为 0，也就是说默认情况下 Vector 每次扩容时容量都会翻倍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-与-ArrayList-的比较"><a href="#3-与-ArrayList-的比较" class="headerlink" title="3. 与 ArrayList 的比较"></a>3. 与 ArrayList 的比较</h3><ul>
<li>Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；</li>
<li>Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍。</li>
</ul>
<h3 id="4-替代方案"><a href="#4-替代方案" class="headerlink" title="4. 替代方案"></a>4. 替代方案</h3><p>可以使用 <code>Collections.synchronizedList();</code> 得到一个线程安全的 ArrayList。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; synList = Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure>

<p>也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><h3 id="1-读写分离"><a href="#1-读写分离" class="headerlink" title="1. 读写分离"></a>1. 读写分离</h3><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p>
<p>写操作需要加锁，防止并发写入时导致写入数据丢失。</p>
<p>写操作结束之后需要把原始数组指向新的复制数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setArray</span><span class="params">(Object[] a)</span> &#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">get</span><span class="params">(Object[] a, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2. 适用场景"></a>2. 适用场景</h3><p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p>
<p>但是 CopyOnWriteArrayList 有其缺陷：</p>
<ul>
<li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li>
<li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li>
</ul>
<p>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。</p>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><h3 id="1-概览-1"><a href="#1-概览-1" class="headerlink" title="1. 概览"></a>1. 概览</h3><p>基于双向链表实现，使用 Node 存储链表节点信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个链表存储了 first 和 last 指针：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/5.png" alt="在这里插入图片描述"></p>
<h3 id="2-与-ArrayList-的比较"><a href="#2-与-ArrayList-的比较" class="headerlink" title="2. 与 ArrayList 的比较"></a>2. 与 ArrayList 的比较</h3><p>ArrayList 基于动态数组实现，LinkedList 基于双向链表实现。ArrayList 和 LinkedList 的区别可以归结为数组和链表的区别：</p>
<ul>
<li>数组支持随机访问，但插入删除的代价很高，需要移动大量元素；</li>
<li>链表不支持随机访问，但插入删除只需要改变指针。</li>
</ul>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="JDK1-7分析"><a href="#JDK1-7分析" class="headerlink" title="JDK1.7分析"></a>JDK1.7分析</h3><h3 id="1-存储结构"><a href="#1-存储结构" class="headerlink" title="1. 存储结构"></a>1. 存储结构</h3><p>内部包含了一个 Entry 类型的数组 table。Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 Entry。<br><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/6.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Entry[] table;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="type">int</span> hash;</span><br><span class="line"></span><br><span class="line">    Entry(<span class="type">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Map.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> (Map.Entry)o;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">k1</span> <span class="operator">=</span> getKey();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">k2</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">        <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="literal">null</span> &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">v1</span> <span class="operator">=</span> getValue();</span><br><span class="line">            <span class="type">Object</span> <span class="variable">v2</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="literal">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getKey() + <span class="string">&quot;=&quot;</span> + getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-拉链法的工作原理"><a href="#2-拉链法的工作原理" class="headerlink" title="2. 拉链法的工作原理"></a>2. 拉链法的工作原理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;K1&quot;</span>, <span class="string">&quot;V1&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;K2&quot;</span>, <span class="string">&quot;V2&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;K3&quot;</span>, <span class="string">&quot;V3&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>新建一个 HashMap，默认大小为 16；</li>
<li>插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16&#x3D;3。</li>
<li>插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16&#x3D;6。</li>
<li>插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16&#x3D;6，插在 &lt;K2,V2&gt; 前面。</li>
</ul>
<p>应该注意到链表的插入是以头插法方式进行的，例如上面的 &lt;K3,V3&gt; 不是插在 &lt;K2,V2&gt; 后面，而是插入在链表头部。</p>
<p>查找需要分成两步进行：</p>
<ul>
<li>计算键值对所在的桶；</li>
<li>在链表上顺序查找，时间复杂度显然和链表的长度成正比。<br><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/7.png" alt="在这里插入图片描述"></li>
</ul>
<h3 id="3-put-操作"><a href="#3-put-操作" class="headerlink" title="3. put 操作"></a>3. put 操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 键为 null 单独处理</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="comment">// 确定桶下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 插入新键值对</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> V <span class="title function_">putForNullKey</span><span class="params">(V value)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(<span class="number">0</span>, <span class="literal">null</span>, value, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">// 头插法，链表头部指向新的键值对</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Entry(<span class="type">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">    value = v;</span><br><span class="line">    next = n;</span><br><span class="line">    key = k;</span><br><span class="line">    hash = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-确定桶下标"><a href="#4-确定桶下标" class="headerlink" title="4. 确定桶下标"></a>4. 确定桶下标</h3><p>很多操作都需要先确定一个键值对所在的桶下标。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br></pre></td></tr></table></figure>

<p><strong>4.1 计算 hash 值</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.2 取模</strong>  </p>
<p>令 x &#x3D; 1&lt;&lt;4，即 x 为 2 的 4 次方，它具有以下性质：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x   : 00010000</span><br><span class="line">x-1 : 00001111</span><br></pre></td></tr></table></figure>

<p>令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y       : 10110010</span><br><span class="line">x-1     : 00001111</span><br><span class="line">y&amp;(x-1) : 00000010</span><br></pre></td></tr></table></figure>

<p>这个性质和 y 对 x 取模效果是一样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y   : 10110010</span><br><span class="line">x   : 00010000</span><br><span class="line">y%x : 00000010</span><br></pre></td></tr></table></figure>

<p>我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。</p>
<p>确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-扩容-基本原理"><a href="#5-扩容-基本原理" class="headerlink" title="5. 扩容-基本原理"></a>5. 扩容-基本原理</h3><p>设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N&#x2F;M，因此查找的复杂度为 O(N&#x2F;M)。</p>
<p>为了让查找的成本降低，应该使 N&#x2F;M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。</p>
<p>和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">capacity</td>
<td align="left">table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。</td>
</tr>
<tr>
<td align="center">size</td>
<td align="left">键值对数量。</td>
</tr>
<tr>
<td align="center">threshold</td>
<td align="left">size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。</td>
</tr>
<tr>
<td align="center">loadFactor</td>
<td align="left">装载因子，table 能够使用的比例，threshold &#x3D; (int)(capacity* loadFactor)。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br></pre></td></tr></table></figure>

<p>从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的两倍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">    <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];</span><br><span class="line">    transfer(newTable);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="type">int</span>)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable)</span> &#123;</span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-扩容-重新计算桶下标"><a href="#6-扩容-重新计算桶下标" class="headerlink" title="6. 扩容-重新计算桶下标"></a>6. 扩容-重新计算桶下标</h3><p>在进行扩容时，需要把键值对重新计算桶下标，从而放到对应的桶上。在前面提到，HashMap 使用 hash%capacity 来确定桶下标。HashMap capacity 为 2 的 n 次方这一特点能够极大降低重新计算桶下标操作的复杂度。</p>
<p>假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">capacity     : 00010000</span><br><span class="line">new capacity : 00100000</span><br></pre></td></tr></table></figure>

<p>对于一个 Key，它的哈希值 hash 在第 5 位：</p>
<ul>
<li>为 0，那么 hash%00010000 &#x3D; hash%00100000，桶位置和原来一致；</li>
<li>为 1，hash%00010000 &#x3D; hash%00100000 + 16，桶位置是原位置 + 16。</li>
</ul>
<h3 id="7-计算数组容量"><a href="#7-计算数组容量" class="headerlink" title="7. 计算数组容量"></a>7. 计算数组容量</h3><p>HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。</p>
<p>先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mask |= mask &gt;&gt; 1    11011000</span><br><span class="line">mask |= mask &gt;&gt; 2    11111110</span><br><span class="line">mask |= mask &gt;&gt; 4    11111111</span><br></pre></td></tr></table></figure>

<p>mask+1 是大于原始数字的最小的 2 的 n 次方。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">num     10010000</span><br><span class="line">mask+1 100000000</span><br></pre></td></tr></table></figure>

<p>以下是 HashMap 中计算数组容量的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-链表转红黑树"><a href="#8-链表转红黑树" class="headerlink" title="8. 链表转红黑树"></a>8. 链表转红黑树</h3><p>从 JDK 1.8 开始，一个桶存储的链表长度大于等于 8 时会将链表转换为红黑树。</p>
<h3 id="9-与-Hashtable-的比较"><a href="#9-与-Hashtable-的比较" class="headerlink" title="9. 与 Hashtable 的比较"></a>9. 与 Hashtable 的比较</h3><ul>
<li>Hashtable 使用 synchronized 来进行同步。</li>
<li>HashMap 可以插入键为 null 的 Entry。</li>
<li>HashMap 的迭代器是 fail-fast 迭代器。</li>
<li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。</li>
</ul>
<p>Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null。</p>
<p>因为Hashtable在我们put 空值的时候会直接抛空指针异常，但是HashMap却做了特殊处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">  <span class="type">int</span> h;</span><br><span class="line">  <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null？</p>
<p>这是因为Hashtable使用的是<strong>安全失败机制（fail-safe）</strong>，这种机制会使你此次读到的数据不一定是最新的数据。</p>
<p>如果你使用null值，就会使得其无法判断对应的key是不存在还是为空，因为你无法再调用一次contain(key）来对key是否存在进行判断，ConcurrentHashMap同理。</p>
<blockquote>
<p><strong>fail-fast是啥？</strong></p>
</blockquote>
<p><strong>快速失败（fail—fast）</strong>是java集合中的一种机制， 在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。</p>
<blockquote>
<p>他的原理是啥？</p>
</blockquote>
<p>迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。</p>
<p>集合在被遍历期间如果内容发生变化，就会改变modCount的值。</p>
<p>每当迭代器使用hashNext()&#x2F;next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p>
<p><strong>Tip</strong>：这里异常的抛出条件是检测到 modCount！&#x3D;expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。</p>
<p>因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。</p>
<blockquote>
<p>说说他的场景？</p>
</blockquote>
<p>java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）算是一种安全机制吧。</p>
<p><strong>Tip</strong>：<strong>安全失败（fail—safe）</strong>大家也可以了解下，java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p>
<h3 id="10-HashMap默认加载因子为什么选择0-75？"><a href="#10-HashMap默认加载因子为什么选择0-75？" class="headerlink" title="10.HashMap默认加载因子为什么选择0.75？"></a>10.HashMap默认加载因子为什么选择0.75？</h3><p><strong>Hashtable 初始容量是11 ，扩容 方式为2N+1;</strong></p>
<p><strong>HashMap 初始容量是16,扩容方式为2N;</strong>　　</p>
<p>阿里的人突然问我为啥扩容因子是0.75，回来总结了一下； <strong>提高空间利用率和 减少查询成本的折中，主要是泊松分布，0.75的话碰撞最小，</strong></p>
<p>HashMap有两个参数影响其性能：初始容量和加载因子。容量是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。加载因子是哈希表在其容量自动扩容之前可以达到多满的一种度量。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行扩容、rehash操作（即重建内部数据结构），扩容后的哈希表将具有两倍的原容量。</p>
<p>通常，加载因子需要在时间和空间成本上寻求一种折衷。</p>
<p>加载因子过高，例如为1，虽然减少了空间开销，提高了空间利用率，但同时也增加了查询时间成本；</p>
<p><strong>加载因子过低，例如0.5，虽然可以减少查询时间成本，但是空间利用率很低，同时提高了rehash操作的次数</strong>。</p>
<p><strong>在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少rehash操作次数，所以，一般在使用HashMap时建议根据预估值设置初始容量，减少扩容操作。</strong></p>
<p><strong>选择0.75作为默认的加载因子，完全是时间和空间成本上寻求的一种折衷选择，</strong> </p>
<h3 id="JDK1-8分析（以面试官的形式提问分析）"><a href="#JDK1-8分析（以面试官的形式提问分析）" class="headerlink" title="JDK1.8分析（以面试官的形式提问分析）"></a>JDK1.8分析（以面试官的形式提问分析）</h3><p>数组里面每个地方都存了Key-Value这样的实例，在Java7叫Entry在Java8中叫Node。<br><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/8.png" alt="在这里插入图片描述"></p>
<p>因为他本身所有的位置都为null，在put插入的时候会根据key的hash去计算一个index值。  </p>
<p>就比如我put（”帅丙“，520），我插入了为”帅丙“的元素，这个时候我们会通过哈希函数计算出插入的位置，计算出来index是2那结果如下。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hash（“帅丙”）= <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/9.png" alt="在这里插入图片描述"></p>
<p><strong>问：你提到了还有链表，为啥需要链表，链表又是怎么样子的呢？</strong><br>我们都知道数组长度是有限的，在有限的长度里面我们使用哈希，哈希本身就存在概率性，就是”帅丙“和”丙帅“我们都去hash有一定的概率会一样，就像上面的情况我再次哈希”丙帅“极端情况也会hash到一个值上，那就形成了链表。<br><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/10.png" alt="在这里插入图片描述"></p>
<p>每一个节点都会保存自身的hash、key、value、以及下个节点，我们看Node的源码。<br><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/11.png" alt="在这里插入图片描述"></p>
<p><strong>问：说到链表我想问一下，你知道新的Entry节点在插入链表的时候，是怎么插入的么？</strong>  </p>
<p>java8之前是头插法，就是说新来的值会取代原有的值，原有的值就顺推到链表中去，就像上面的例子一样，因为写这个代码的作者认为后来的值被查找的可能性更大一点，提升查找的效率。<br>但是，在java8之后，都是所用尾部插入了。  </p>
<p><strong>问：为啥改为尾部插入呢？</strong>  </p>
<p>首先我们看下HashMap的扩容机制：<br>数组容量是有限的，数据多次插入的，到达一定的数量就会进行扩容，也就是resize。  </p>
<p><strong>问：什么时候resize呢？</strong>   </p>
<p>有两个因素：  </p>
<p>Capacity：HashMap当前长度。  </p>
<p>LoadFactor：负载因子，默认值0.75f。<br><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/12.png" alt="在这里插入图片描述"></p>
<p>怎么理解呢，就比如当前的容量大小为100，当你存进第76个的时候，判断发现需要进行resize了，那就进行扩容，但是HashMap的扩容也不是简单的扩大点容量这么简单的。  </p>
<p><strong>扩容？它是怎么扩容的呢？</strong><br>分为两步：  </p>
<p>扩容：创建一个新的Entry空数组，长度是原数组的2倍。  </p>
<p>ReHash：遍历原Entry数组，把所有的Entry重新Hash到新数组。  </p>
<p><strong>问：为什么要重新Hash呢，直接复制过去不香么？</strong><br>是因为长度扩大以后，Hash的规则也随之改变。  </p>
<p>Hash的公式—&gt; index &#x3D; HashCode（Key） &amp; （Length - 1）  </p>
<p>原来长度（Length）是8你位运算出来的值是2 ，新的长度是16你位运算出来的值明显不一样了。  </p>
<p>扩容前：<br><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/13.png" alt="在这里插入图片描述"></p>
<p>扩容后：<br><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/14.png" alt="在这里插入图片描述"></p>
<p><strong>问：说完扩容机制我们言归正传，为啥之前用头插法，java8之后改成尾插了呢？</strong><br>我先举个例子吧，我们现在往一个容量大小为2的put两个值，负载因子是0.75是不是我们在put第二个的时候就会进行resize？  </p>
<p>2*0.75 &#x3D; 1 所以插入第二个就要resize了<br><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/15.png" alt="在这里插入图片描述"></p>
<p>现在我们要在容量为2的容器里面用不同线程插入A，B，C，假如我们在resize之前打个短点，那意味着数据都插入了但是还没resize那扩容前可能是这样的。</p>
<p>我们可以看到链表的指向A-&gt;B-&gt;C  </p>
<p>Tip：A的下一个指针是指向B的  </p>
<p><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/16.png" alt="在这里插入图片描述"></p>
<p>因为resize的赋值方式，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置，在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p>
<p>就可能出现下面的情况，大家发现问题没有？</p>
<p>B的下一个指针指向了A  </p>
<p><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/17.png" alt="在这里插入图片描述"></p>
<p>一旦几个线程都调整完成，就可能出现环形链表  </p>
<p><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/18.png" alt="在这里插入图片描述"></p>
<p>如果这个时候去取值，悲剧就出现了——Infinite Loop。 </p>
<p><strong>问：头插是JDK1.7的那1.8的尾插是怎么样的呢？</strong><br>因为java8之后链表有红黑树的部分，大家可以看到代码已经多了很多if else的逻辑判断了，红黑树的引入巧妙的将原本O(n)的时间复杂度降低到了O(logn)。 </p>
<p>使用头插会改变链表的上的顺序，但是如果使用尾插，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了。</p>
<p>就是说原本是A-&gt;B，在扩容后那个链表还是A-&gt;B<br><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/19.png" alt="在这里插入图片描述"></p>
<p>Java7在多线程操作HashMap时可能引起死循环，原因是扩容转移后前后链表顺序倒置，在转移过程中修改了原来链表中节点的引用关系。</p>
<p>Java8在同样的前提下并不会引起死循环，原因是扩容转移后前后链表顺序不变，保持之前节点的引用关系。  </p>
<p><strong>问：那是不是意味着Java8就可以把HashMap用在多线程中呢？</strong><br>    即使不会出现死循环，但是通过源码看到put&#x2F;get方法都没有加同步锁，多线程情况最容易出现的就是：无法保证上一秒put的值，下一秒get的时候还是原值，所以线程安全还是无法保证。  </p>
<p><strong>问：HashMap的默认初始化长度是多少？</strong><br><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/20.png" alt="在这里插入图片描述"></p>
<p><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/21.png" alt="在这里插入图片描述"></p>
<p>位与运算比算数计算的效率高了很多，之所以选择16，是为了服务将Key映射到index的算法。<br>我前面说了所有的key我们都会拿到他的hash，但是我们怎么尽可能的得到一个均匀分布的hash呢？</p>
<p>是的我们通过Key的HashCode值去做位运算。</p>
<p>我打个比方，key为”帅丙“的十进制为766132那二进制就是 10111011000010110100<br><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/22.png" alt="在这里插入图片描述"></p>
<p>我们再看下index的计算公式：index &#x3D; HashCode（Key） &amp; （Length- 1）<br>15的的二进制是1111，那10111011000010110100 &amp;1111 十进制就是4<br><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/23.png" alt="在这里插入图片描述"></p>
<p>之所以用位与运算效果与取模一样，性能也提高了不少！  </p>
<p><strong>问：那为啥用16不用别的呢？</strong><br>因为在使用不是2的幂的数字的时候，Length-1的值是所有二进制位全为1，这种情况下，index的结果等同于HashCode后几位的值。</p>
<p>只要输入的HashCode本身分布均匀，Hash算法的结果就是均匀的。</p>
<p>这是为了实现均匀分布。  </p>
<p><strong>我们重写equals方法的时候需要重写hashCode方法呢？你能用HashMap给我举个例子么？</strong></p>
<p>因为在java中，所有的对象都是继承于Object类。Ojbect类中有两个方法equals、hashCode，这两个方法都是用来比较两个对象是否相等的。</p>
<p>在未重写equals方法我们是继承了object的equals方法，那里的 equals是比较两个对象的内存地址，显然我们new了2个对象内存地址肯定不一样</p>
<p>对于值对象，&#x3D;&#x3D;比较的是两个对象的值</p>
<p>对于引用对象，比较的是两个对象的地址</p>
<p>大家是否还记得我说的HashMap是通过key的hashCode去寻找index的，那index一样就形成链表了，也就是说”帅丙“和”丙帅“的index都可能是2，在一个链表上的。</p>
<p>我们去get的时候，他就是根据key去hash然后计算出index，找到了2，那我怎么找到具体的”帅丙“还是”丙帅“呢？</p>
<p>equals！是的，所以如果我们对equals方法进行了重写，建议一定要对hashCode方法重写，以保证相同的对象返回相同的hash值，不同的对象返回不同的hash值。</p>
<p>不然一个链表的对象，你哪里知道你要找的是哪个，到时候发现hashCode都一样，这不是完犊子嘛。  </p>
<p><strong>问：我记得你上面说过他是线程不安全的，那你能跟我聊聊你们是怎么处理HashMap在线程安全的场景么？</strong></p>
<p>面试官，在这样的场景，我们一般都会使用HashTable或者CurrentHashMap，但是因为前者的并发度的原因基本上没啥使用场景了，所以存在线程不安全的场景我们都使用的是CorruentHashMap。</p>
<p>HashTable我看过他的源码，很简单粗暴，直接在方法上锁，并发度很低，最多同时允许一个线程访问，currentHashMap就好很多了，1.7和1.8有较大的不同，不过并发度都比前者好太多了。<br><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/24.png" alt="在这里插入图片描述"></p>
<p><strong>问：那你能跟我聊聊CurrentHashMap么？</strong></p>
<p>往下看。。。。。。。。</p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="1-存储结构-1"><a href="#1-存储结构-1" class="headerlink" title="1. 存储结构"></a>1. 存储结构</h3><p><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/25.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HashEntry</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcurrentHashMap采用了二次hash的方式，第一次hash将key映射到对应的segment，而第二次hash则是映射到segment的不同桶(bucket)中。<br>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。</p>
<p>Segment 继承自 ReentrantLock。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Segment</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">2249069246763182397L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SCAN_RETRIES</span> <span class="operator">=</span></span><br><span class="line">        Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span> ? <span class="number">64</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br></pre></td></tr></table></figure>

<p>默认的并发级别为 16，也就是说默认创建 16 个 Segment。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CONCURRENCY_LEVEL</span> <span class="operator">=</span> <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<p>HashEntry跟HashMap差不多的，但是不同点是，他使用volatile去修饰了他的数据Value还有下一个节点next。</p>
<blockquote>
<p>volatile的特性是啥？</p>
</blockquote>
<ul>
<li><p>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。（实现<strong>可见性</strong>）</p>
</li>
<li><p>禁止进行指令重排序。（实现<strong>有序性</strong>）</p>
</li>
<li><p>volatile 只能保证对单次读&#x2F;写的原子性。i++ 这种操作不能保证<strong>原子性</strong>。</p>
</li>
</ul>
<h3 id="2-size-操作"><a href="#2-size-操作" class="headerlink" title="2. size 操作"></a>2. size 操作</h3><p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of elements. Accessed only either within locks</span></span><br><span class="line"><span class="comment"> * or among other volatile reads that maintain visibility.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> count;</span><br></pre></td></tr></table></figure>

<p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。</p>
<p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。</p>
<p>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。</p>
<p>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Number of unsynchronized retries in size and containsValue</span></span><br><span class="line"><span class="comment"> * methods before resorting to locking. This is used to avoid</span></span><br><span class="line"><span class="comment"> * unbounded retries if tables undergo continuous modification</span></span><br><span class="line"><span class="comment"> * which would make it impossible to obtain an accurate result.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RETRIES_BEFORE_LOCK</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">    <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="built_in">this</span>.segments;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">    <span class="type">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">last</span> <span class="operator">=</span> <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">retries</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// first iteration isn&#x27;t retry</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 超过尝试次数，则对每个 Segment 加锁</span></span><br><span class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="number">0L</span>;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            overflow = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="literal">null</span>) &#123;</span><br><span class="line">                    sum += seg.modCount;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> seg.count;</span><br><span class="line">                    <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                        overflow = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 连续两次得到的结果一致，则认为这个结果是正确的</span></span><br><span class="line">            <span class="keyword">if</span> (sum == last)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            last = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们看看他的put源代码，你就知道他是怎么做到线程安全的了，关键句子我注释了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">put</span><span class="params">(K key, <span class="type">int</span> hash, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">          <span class="comment">// 将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry</span></span><br><span class="line">            HashEntry&lt;K,V&gt; node = tryLock() ? <span class="literal">null</span> :</span><br><span class="line">                scanAndLockForPut(key, hash, value);</span><br><span class="line">            V oldValue;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">                HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                        K k;</span><br><span class="line"> <span class="comment">// 遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。</span></span><br><span class="line">                        <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                            (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                            oldValue = e.value;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                                e.value = value;</span><br><span class="line">                                ++modCount;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        e = e.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// 不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。</span></span><br><span class="line">                        <span class="keyword">if</span> (node != <span class="literal">null</span>)</span><br><span class="line">                            node.setNext(first);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            node = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> count + <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                            rehash(node);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            setEntryAt(tab, index, node);</span><br><span class="line">                        ++modCount;</span><br><span class="line">                        count = c;</span><br><span class="line">                        oldValue = <span class="literal">null</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="comment">//释放锁</span></span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>首先第一步的时候会尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 <code>scanAndLockForPut()</code> 自旋获取锁。</p>
<ol>
<li>尝试自旋获取锁。</li>
<li>如果重试的次数达到了 <code>MAX_SCAN_RETRIES</code> 则改为阻塞锁获取，保证能获取成功。</li>
</ol>
<blockquote>
<p>那他get的逻辑呢？</p>
</blockquote>
<p>get 逻辑比较简单，只需要将 Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上。</p>
<p>由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值。</p>
<p>ConcurrentHashMap 的 get 方法是非常高效的，<strong>因为整个过程都不需要加锁</strong>。</p>
<blockquote>
<p>你有没有发现1.7虽然可以支持每个Segment并发访问，但是还是存在一些问题？</p>
</blockquote>
<p>是的，因为基本上还是数组加链表的方式，我们去查询的时候，还得遍历链表，会导致效率很低，这个跟jdk1.7的HashMap是存在的一样问题，所以他在jdk1.8完全优化了。</p>
<h3 id="3-JDK-1-8-的改动"><a href="#3-JDK-1-8-的改动" class="headerlink" title="3. JDK 1.8 的改动"></a>3. JDK 1.8 的改动</h3><p>JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。</p>
<p>其中抛弃了原有的 Segment 分段锁，而采用了 <code>CAS + synchronized</code> 来保证并发安全性。并且 JDK 1.8 的实现也在链表过长时会转换为红黑树。</p>
<p>跟HashMap很像，也把之前的HashEntry改成了Node，但是作用不变，把值和next采用了volatile去修饰，保证了可见性，并且也引入了红黑树，在链表大于一定值的时候会转换（默认是8）。</p>
<blockquote>
<p>同样的，你能跟我聊一下他值的存取操作么？以及是怎么保证线程安全的？</p>
</blockquote>
<p>ConcurrentHashMap在进行put操作的还是比较复杂的，大致可以分为以下步骤：</p>
<ol>
<li>根据 key 计算出 hashcode 。</li>
<li>判断是否需要进行初始化。</li>
<li>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li>
<li>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</li>
<li>如果都不满足，则利用 synchronized 锁写入数据。</li>
<li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</li>
</ol>
<p><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/26.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>你在上面提到CAS是什么？自旋又是什么？</p>
</blockquote>
<p>CAS 是乐观锁的一种实现方式，是一种轻量级锁，JUC 中很多工具类的实现就是基于 CAS 的。</p>
<p>CAS 操作的流程如下图所示，线程在读取数据时不进行加锁，在准备写回数据时，比较原值是否修改，若未被其他线程修改则写回，若已被修改，则重新执行读取流程。</p>
<p>这是一种乐观策略，认为并发操作并不总会发生。<br><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/27.png" alt="在这里插入图片描述"></p>
<p>还是不明白？那我再说明下，乐观锁在实际开发场景中非常常见，大家还是要去理解。</p>
<p>就比如我现在要修改数据库的一条数据，修改之前我先拿到他原来的值，然后在SQL里面还会加个判断，原来的值和我手上拿到的他的原来的值是否一样，一样我们就可以去修改了，不一样就证明被别的线程修改了你就return错误就好了。</p>
<p>SQL伪代码大概如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">update a <span class="type">set</span> <span class="variable">value</span> <span class="operator">=</span> newValue <span class="type">where</span> <span class="variable">value</span> <span class="operator">=</span> #&#123;oldValue&#125;<span class="comment">//oldValue就是我们执行前查询出来的值 </span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>CAS就一定能保证数据没被别的线程修改过么？</p>
</blockquote>
<p>并不是的，比如很经典的ABA问题，CAS就无法判断了。</p>
<blockquote>
<p>什么是ABA？</p>
</blockquote>
<p>就是说来了一个线程把值改回了B，又来了一个线程把值又改回了A，对于这个时候判断的线程，就发现他的值还是A，所以他就不知道这个值到底有没有被人改过，其实很多场景如果只追求最后结果正确，这是没关系的。</p>
<p>但是实际过程中还是需要记录修改过程的，比如资金修改什么的，你每次修改的都应该有记录，方便回溯。</p>
<blockquote>
<p>那怎么解决ABA问题？</p>
</blockquote>
<p>用版本号去保证就好了，就比如说，我在修改前去查询他原来的值的时候再带一个版本号，每次判断就连值和版本号一起判断，判断成功就给版本号加1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">update a <span class="type">set</span> <span class="variable">value</span> <span class="operator">=</span> newValue ，vision = vision + <span class="number">1</span> <span class="type">where</span> <span class="variable">value</span> <span class="operator">=</span> #&#123;oldValue&#125; <span class="type">and</span> <span class="variable">vision</span> <span class="operator">=</span> #&#123;vision&#125; <span class="comment">// 判断原来的值和版本号是否匹配，中间有别的线程修改，值可能相等，但是版本号100%不一样</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>牛*，有点东西，除了版本号还有别的方法保证么？</p>
</blockquote>
<p>其实有很多方式，比如时间戳也可以，查询的时候把时间戳一起查出来，对的上才修改并且更新值的时候一起修改更新时间，这样也能保证，方法很多但是跟版本号都是异曲同工之妙，看场景大家想怎么设计吧。</p>
<blockquote>
<p>CAS性能很高，但是我知道synchronized性能可不咋地，为啥jdk1.8升级之后反而多了synchronized？</p>
</blockquote>
<p>synchronized之前一直都是重量级的锁，但是后来java官方是对他进行过升级的，他现在采用的是锁升级的方式去做的。</p>
<p>针对 synchronized 获取锁的方式，JVM 使用了锁升级的优化方式，就是先使用<strong>偏向锁</strong>优先同一线程然后再次获取锁，如果失败，就升级为 <strong>CAS 轻量级锁</strong>，如果失败就会短暂<strong>自旋</strong>，防止线程被系统挂起。最后如果以上都失败就升级为<strong>重量级锁</strong>。</p>
<p>所以是一步步升级上去的，最初也是通过很多轻量级的方式锁定的。</p>
<blockquote>
<p>🐂，那我们回归正题，ConcurrentHashMap的get操作又是怎么样子的呢？</p>
</blockquote>
<ul>
<li>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</li>
<li>如果是红黑树那就按照树的方式获取值。</li>
<li>就不满足那就按照链表的方式遍历获取值。<br><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/28.png" alt="在这里插入图片描述"></li>
</ul>
<p>小结：1.8 在 1.7 的数据结构上做了大的改动，采用红黑树之后可以保证查询效率（<code>O(logn)</code>），甚至取消了 ReentrantLock 改为了 synchronized，这样可以看出在新版的 JDK 中对 synchronized 优化是很到位的。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>OIDC认证授权</title>
    <url>/2022/10/24/OIDC%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83/</url>
    <content><![CDATA[<h1 id="五分钟理解什么是-OIDC-（OpenID-Connect）"><a href="#五分钟理解什么是-OIDC-（OpenID-Connect）" class="headerlink" title="五分钟理解什么是 OIDC （OpenID Connect）"></a>五分钟理解什么是 OIDC （OpenID Connect）</h1><p><img src="/2022/10/24/OIDC%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83/1.png" alt="在这里插入图片描述"></p>
<h2 id="什么是-OIDC？"><a href="#什么是-OIDC？" class="headerlink" title="什么是 OIDC？"></a>什么是 OIDC？</h2><p>OIDC 的全称是 OpenID Connect，是一套基于 OAuth 2.0 的<strong>认证 + 授权</strong>协议，用于用户身份认证，将用户数据安全地暴露给第三方。</p>
<h2 id="OIDC-与-OAuth-2-0-有何不同？"><a href="#OIDC-与-OAuth-2-0-有何不同？" class="headerlink" title="OIDC 与 OAuth 2.0 有何不同？"></a>OIDC 与 OAuth 2.0 有何不同？</h2><p>OAuth 2.0 是用于授权的行业标准协议。OAuth 2.0 致力于简化客户端开发人员的工作，同时为 Web 应用程序，桌面应用程序，移动电话和物联网设备提供特定的授权流程。</p>
<p>以上是 OAuth 2.0 的官方定义。我们举一个实际的例子，你在登录京东的时候，会发现在京东的登录框中有使用 QQ 登录、使用 QQ 登录的按钮，这些地方就是 OAuth 2.0 协议的用武之地。京东希望从 QQ 获取你的 QQ 用户数据，从而完成在京东的注册，这就需要数据的主人——你的授权。完成授权之后， QQ 会给京东一个 access_token，京东携带这个凭证，就能以你的名义，以及你授予此网站的权限（例如你授权京东能够访问你的个人信息而不是转账能力），访问你在 QQ 服务器上的数据，从而获取你的信息，在此过程中，你无须告诉京东你的 QQ 账号和密码，你输入账密信息的时候，是在腾讯的服务器完成的认证。</p>
<p>OIDC 与 OAuth 2.0 相比，多了认证的能力。不但能够返回用户的 access_token，让第三方通过 access_token 调用用户授权过的接口（用户授权），还可以返回用户的 id_token，第三方可以将 id_token 用作用户身份标识（用户认证）。</p>
<p>回到刚才的例子，京东获取到 QQ 颁发的 access_token （是一个随机字符串）之后确实能够获取到你的信息，但是如果不借助其他手段，是不具备用户身份认证功能的。而在 OIDC 协议中，获取 access_token 的同时，会返回一个 JWT 格式的 id_token，可直接用作身份标识，供第三方确认用户身份。</p>
<p>JWT Token 是这个样子的：</p>
<pre><code>eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ.dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk
</code></pre>
<p>格式为“点分 base64 编码”，一共三段，第一部分叫作<strong>头部（JOSE Header）</strong>，第二部分叫作<strong>荷载（Payload）</strong>，第三部分叫作<strong>签名（Signature）</strong>。其中的签名根据头部、荷载和一个密钥计算得出，不可伪造。</p>
<p>base64 解码之后是这样子的：</p>
<pre><code>&#123;&quot;typ&quot;:&quot;JWT&quot;, &quot;alg&quot;:&quot;HS256&quot;&#125;.&#123;&quot;iss&quot;:&quot;joe&quot;, &quot;exp&quot;:1300819380, &quot;http://example.com/is_root&quot;:true&#125;.&lt; 签名 &gt;
</code></pre>
<p>更多 JWT 知识请参考 JWT 规范。</p>
<p>总结成一句话：OAuth 2.0 能做的 OIDC 都能做，OAuth 2.0 不具备的认证能力，OIDC 也具备。</p>
<h2 id="OIDC-协议的应用场景"><a href="#OIDC-协议的应用场景" class="headerlink" title="OIDC 协议的应用场景"></a>OIDC 协议的应用场景</h2><p>所有使用 OAuth 2.0 的场景都可以升级为 OIDC 协议，OIDC 协议是 OAuth 2.0 的超集。以下是一些 OIDC 协议的应用场景：</p>
<p>1.社会化登录场景，网站登录框上常见许多按钮「使用 XXX 登录」。<br>物联网设备的身份认证和授权。<br>2.企业内多个应用统一身份，单点登录。<br>3.开放平台对外暴露应用数据，做用户认证与授权。<br>4.Serverless 中的身份层。<br>5.OIDC 协议是 OAuth 2.0 协议的下一代，是身份认证协议升级的不二之选。</p>
<h3 id="OIDC-协议中的四个主体"><a href="#OIDC-协议中的四个主体" class="headerlink" title="OIDC 协议中的四个主体"></a>OIDC 协议中的四个主体</h3><p>在介绍 OIDC 授权模式之前，先要明确四个主体：<strong>第三方应用</strong>、<strong>资源服务器</strong>、<strong>资源所有者</strong>、<strong>认证授权服务器</strong>。我们继续沿用前文京东与 QQ 登录的例子。</p>
<p>P.S. QQ 使用的是变种 OAuth 2.0 协议，并不完全符合 OIDC 规范，在此假设 QQ 使用 OIDC 协议进行对外数据授权。</p>
<p><strong>第三方应用</strong></p>
<p>京东的角色是第三方应用。</p>
<p><strong>资源服务器</strong></p>
<p>QQ 的个人信息存放于资源服务器。</p>
<p><strong>资源所有者</strong></p>
<p>用户是 QQ 账号的所有者。</p>
<p><strong>认证授权服务器</strong></p>
<p>QQ 的授权服务器负责用户的身份认证和授权，管理第三方应用、受保护资源、资源所有者之间的关系。<br><img src="/2022/10/24/OIDC%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83/2.png" alt="在这里插入图片描述"></p>
<h2 id="OIDC-的三种授权模式"><a href="#OIDC-的三种授权模式" class="headerlink" title="OIDC 的三种授权模式"></a>OIDC 的三种授权模式</h2><h3 id="Authorization-Code-Flow"><a href="#Authorization-Code-Flow" class="headerlink" title="Authorization Code Flow"></a>Authorization Code Flow</h3><p>应用最为广泛的是授权码模式，此模式的交互过程如下图：<br><img src="/2022/10/24/OIDC%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83/3.png" alt="在这里插入图片描述"></p>
<p>1.第三方应用访问认证服务器的授权链接。（用户在京东网站登录框点击使用 QQ 登录）<br>2.用户与认证服务器完成身份认证。（浏览器跳转到 QQ 授权页面，用户输入 QQ 号和密码）<br>3.认证服务器向第三方应用返回授权码 code。（QQ 服务器将用户的浏览器重定向，将授权码发送到京东服务器）<br>4.第三方应用携带授权码访问认证服务器的 token 接口。（京东服务器携带授权码与 QQ 服务器交互）<br>5.认证服务器返回 access_token 和 id_token 给第三方应用。（QQ 服务器返回 access_token 和 id_token 给京东服务器）<br>此后，第三方应用可以利用 access_token 到资源服务器获取用户的信息，完成在第三方应用的注册和登录业务，并可以将 id_token 作为用户的身份凭证，存放在前端。第三方应用的前端需要访问受保护的资源（例如用户账单信息、购物车）时需要携带 id_token，后端验证 id_token 合法性，核实用户身份之后，返回相关资源数据。</p>
<h3 id="OIDC-认证时相关-Token-解释"><a href="#OIDC-认证时相关-Token-解释" class="headerlink" title="OIDC 认证时相关 Token 解释"></a>OIDC 认证时相关 Token 解释</h3><p>OIDC 认证时会签发两种 Token，一类叫 id_token，还有一类叫 access_token。</p>
<ol>
<li>id_token 是用户身份的凭证，只起到判定用户身份的作用。</li>
</ol>
<p>id_token 示例：</p>
<pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI1ZTQ5NjBkZmJkOTE1OGZiODQ0OTAzYTkiLCJiaXJ0aGRhdGUiOiIiLCJmYW1pbHlfbmFtZSI6IiIsImdlbmRlciI6IiIsImdpdmVuX25hbWUiOiIiLCJsb2NhbGUiOiIiLCJtaWRkbGVfbmFtZSI6IiIsIm5hbWUiOiIiLCJuaWNrbmFtZSI6IiIsInBpY3R1cmUiOiJodHRwczovL3VzZXJjb250ZW50cy5hdXRoaW5nLmNuL2F1dGhpbmctYXZhdGFyLnBuZyIsInByZWZlcnJlZF91c2VybmFtZSI6IiIsInByb2ZpbGUiOiIiLCJ1cGRhdGVkX2F0IjoiIiwid2Vic2l0ZSI6IiIsInpvbmVpbmZvIjoiIiwiY29tcGFueSI6IiIsImJyb3dzZXIiOiJNb3ppbGxhLzUuMCAoTWFjaW50b3NoOyBJbnRlbCBNYWMgT1MgWCAxMF8xNF82KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvODAuMC4zOTg3Ljg3IFNhZmFyaS81MzcuMzYiLCJkZXZpY2UiOiIiLCJsb2dpbnNfY291bnQiOjEsInJlZ2lzdGVyX21ldGhvZCI6ImRlZmF1bHQ6dXNlcm5hbWUtcGFzc3dvcmQiLCJibG9ja2VkIjpmYWxzZSwibGFzdF9pcCI6IjEyMS4yMS41Ni4xNzEiLCJyZWdpc3Rlcl9pbl91c2VycG9vbCI6IjVjOTU5MDU1NzhmY2U1MDAwMTY2Zjg1MyIsImxhc3RfbG9naW4iOiIyMDIwLTAyLTE2VDE1OjMzOjUyLjQ0NFoiLCJzaWduZWRfdXAiOiIyMDIwLTAyLTE2VDE1OjMzOjUxLjY2NVoiLCJlbWFpbCI6InRlc3QxQDEyMy5jb20iLCJlbWFpbF92ZXJpZmllZCI6ZmFsc2UsInBob25lX251bWJlciI6IiIsInBob25lX251bWJlcl92ZXJpZmllZCI6ZmFsc2UsImF0X2hhc2giOiJWYW9sSnVqWXltQjUxNlNGOGNaQkpBIiwic2lkIjoiZGYzMGFlNDgtOTkzMS00YjZlLWI0YzgtMWI5NjRkOGZjOWIyIiwiYXVkIjoiNWQwMWUzODk5ODVmODFjNmMxZGQzMWRlIiwiZXhwIjoxNTgxODcwOTc4LCJpYXQiOjE1ODE4NjczODEsImlzcyI6Imh0dHBzOi8vb2F1dGguYXV0aGluZy5jbi9vYXV0aC9vaWRjIn0.pH-bWm-Im0wnOcUEA-OG_iKwy9DTZlAXuik50HPsfGY
</code></pre>
<p>解码后：</p>
<pre><code>&#123;  &quot;alg&quot;: &quot;HS256&quot;,  &quot;typ&quot;: &quot;JWT&quot;&#125;.&#123;  &quot;sub&quot;: &quot;5e3a3b2315a0b8398cdaaa08&quot;,  &quot;birthdate&quot;: &quot;&quot;,  &quot;family_name&quot;: &quot;&quot;,  &quot;gender&quot;: &quot;&quot;,  &quot;given_name&quot;: &quot;&quot;,  &quot;locale&quot;: &quot;&quot;,  &quot;middle_name&quot;: &quot;&quot;,  &quot;name&quot;: &quot;&quot;,  &quot;nickname&quot;: &quot;&quot;,  &quot;picture&quot;: &quot;https://usercontents.authing.cn/authing-avatar.png&quot;,  &quot;preferred_username&quot;: &quot;&quot;,  &quot;profile&quot;: &quot;&quot;,  &quot;updated_at&quot;: &quot;&quot;,  &quot;website&quot;: &quot;&quot;,  &quot;zoneinfo&quot;: &quot;&quot;,  &quot;company&quot;: &quot;&quot;,  &quot;browser&quot;: &quot;&quot;,  &quot;device&quot;: &quot;&quot;,  &quot;logins_count&quot;: 8,  &quot;register_method&quot;: &quot;default:username-password&quot;,  &quot;blocked&quot;: false,  &quot;last_ip&quot;: &quot;127.0.0.1&quot;,  &quot;register_in_userpool&quot;: &quot;5e3a3b2315a0b8398cdaaa04&quot;,  &quot;last_login&quot;: &quot;2020-02-16T09:04:09.764Z&quot;,  &quot;signed_up&quot;: &quot;2020-02-05T03:48:51.447Z&quot;,  &quot;email&quot;: &quot;test@test.com&quot;,  &quot;email_verified&quot;: false,  &quot;phone_number&quot;: &quot;&quot;,  &quot;at_hash&quot;: &quot;6k-IWJwh-Dd3_hLOay0s7A&quot;,  &quot;sid&quot;: &quot;d50a8c9d-23db-4156-80ea-1c82d199d0e9&quot;,  &quot;aud&quot;: &quot;5e3a3b2315a0b8398cdaaa0e&quot;,  &quot;exp&quot;: 1581948533,  &quot;iat&quot;: 1581944933,  &quot;iss&quot;: &quot;https://core.littleimp.cn/oauth/oidc&quot;&#125;. 签名
</code></pre>
<p>access_token 是用户授权给第三方应用的一个令牌，第三方应用可以使用这个令牌访问用户在资源服务器上受保护的资源，一般不用于用户凭证和身份标识。<br>access_token 示例：</p>
<pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJXaXdndEdHYzVMeGtZRUFRY012RFkiLCJzdWIiOiI1ZTNhM2IyMzE1YTBiODM5OGNkYWFhMDgiLCJpc3MiOiJodHRwczovL2NvcmUubGl0dGxlaW1wLmNuL29hdXRoL29pZGMiLCJpYXQiOjE1ODE5NDQ5MzMsImV4cCI6MTU4MTk0ODUzMywic2NvcGUiOiJvcGVuaWQgcHJvZmlsZSBlbWFpbCBwaG9uZSIsImF1ZCI6IjVlM2EzYjIzMTVhMGI4Mzk4Y2RhYWEwZSJ9.MnAAGj6HlYvN3FOAo6PA2cxNxZDZbL3yhxTM3uxnt0M
</code></pre>
<p>解码后：</p>
<pre><code>&#123;  &quot;alg&quot;: &quot;HS256&quot;,  &quot;typ&quot;: &quot;JWT&quot;&#125;.&#123;  &quot;jti&quot;: &quot;WiwgtGGc5LxkYEAQcMvDY&quot;,  &quot;sub&quot;: &quot;5e3a3b2315a0b8398cdaaa08&quot;,  &quot;iss&quot;: &quot;https://core.littleimp.cn/oauth/oidc&quot;,  &quot;iat&quot;: 1581944933,  &quot;exp&quot;: 1581948533,  &quot;scope&quot;: &quot;openid profile email phone&quot;,  &quot;aud&quot;: &quot;5e3a3b2315a0b8398cdaaa0e&quot;&#125;. 签名
</code></pre>
<h2 id="bImplicit-Flow"><a href="#bImplicit-Flow" class="headerlink" title="bImplicit Flow"></a>bImplicit Flow</h2><p>在隐式模式中，认证服务器的授权接口不会返回授权码 code，而是在与用户完成认证后返回 id_token 和 access_token，交互模式如下图所示：</p>
<p><img src="/2022/10/24/OIDC%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83/4.png" alt="在这里插入图片描述"></p>
<ol>
<li>第三方应用访问认证服务器的授权链接。（用户在京东网站登录框点击使用 QQ 登录）</li>
<li>用户与认证服务器完成身份认证。（浏览器跳转到 QQ 授权页面，用户输入 QQ 号和密码）</li>
<li>认证服务器向第三方应用返回 id_token 和 access_token。（QQ 服务器将用户的浏览器重定向，将 id_token access_token 发送到京东前端页面）</li>
</ol>
<p>隐式模式比授权码模式简单，经常用于将 id_token、access_token 直接返回到前端，方便前端直接存储 id_token 用于证明用户身份。也需要前端自行将 access_token 发回后端，后端用于获取用户的详细信息，这增加了暴露 access_token 的风险。隐式模式不支持返回 refresh_token，即不能从后端刷新 access_token，登录一旦过期需要用户重新登录。</p>
<h2 id="Hybrid-Flow"><a href="#Hybrid-Flow" class="headerlink" title="Hybrid Flow"></a>Hybrid Flow</h2><p>混合模式是以上两种模式的组合，特点是能够在授权接口一次性获取到 c ode、id_token、access_token，一般 code 会与 id_token、access_token 混合出现，混合模式的交互如下图所示：</p>
<p><img src="/2022/10/24/OIDC%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83/5.png" alt="在这里插入图片描述"></p>
<ol>
<li>第三方应用访问认证服务器的授权链接。（用户在京东网站登录框点击使用 QQ 登录）</li>
<li>用户与认证服务器完成身份认证。（浏览器跳转到 QQ 授权页面，用户输入 QQ 号和密码）</li>
<li>认证服务器向第三方应用返回 code、id_token 和 access_token。（QQ 服务器将用户的浏览器重定向，将 id_token access_token 发送到京东前端页面）</li>
<li>第三方应用携带授权码访问认证服务器的 token 接口。（京东服务器携带授权码与 QQ 服务器交互）</li>
<li>认证服务器返回 access_token 和 id_token 给第三方应用。（QQ 服务器返回 access_token 和 id_token 给京东服务器）<br>混合模式可以灵活满足 code、id_token、access_token 的各种处理方式，可以在享有隐式模式便利的同时，利用 code 获取 refresh_token，从而可以在后端刷新用户 access_token，不必重复让用户登录。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>OIDC 协议是 OAuth 2.0 协议的超集，是可以替代 OAuth 2.0 的下一代身份认证协议，能够解决认证 + 授权两个问题。OIDC 的授权流程与 OAuth 2.0 完全一致，能够保持向下兼容。</p>
<p>授权服务器的意义在于管理第三方应用、受保护资源、资源所有者之间的关系，让互相不信任的应用之间安全地暴露数据——应用之间约定好某种规范，按照这种规范，就能在用户授权的前提下，安全地将数据暴露给第三方，而第三方也无需获知用户的账密信息。</p>
<p>此外，我们介绍了两种 Token 的区别，其中，<strong>id_token</strong> 是用户的身份凭证，<strong>access_token</strong> 是用户的授权凭证。</p>
<p>最后，我们介绍了 OIDC 的三种授权模式，分别是授权码模式、隐式模式、混合模式。授权码模式中只能获取到 code；隐式模式中只能获取到 access_token id_token；混合模式中都能够获取到。</p>
<p>Authing 拥有 OIDC 的无服务器实现，基于 Authing，可不用搭建或管理任何 OIDC 服务器即可完成身份认证，详情请查看文档：<a href="https://docs.authing.cn/authing/quickstart/implement-sso-with-authing%E3%80%82">https://docs.authing.cn/authing/quickstart/implement-sso-with-authing。</a><br><img src="/2022/10/24/OIDC%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83/6.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>认证授权</tag>
      </tags>
  </entry>
  <entry>
    <title>Paxos协议</title>
    <url>/2022/10/24/Paxos%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>Google的粗粒度锁服务Chubby的设计开发者Burrows曾经说过：<strong>所有一致性协议本质上要么是Paxos要么是其变体</strong>。</p>
<p>网上有很多讲解Paxos算法的文章，但是质量层次不齐。今天笔者带大家深入聊一下Paxos</p>
<h2 id="Paxos是什么？"><a href="#Paxos是什么？" class="headerlink" title="Paxos是什么？"></a>Paxos是什么？</h2><p>Paxos算法是基于<strong>消息传递</strong>且具有<strong>高度容错特性</strong>的<strong>一致性算法</strong>，是目前公认的解决<strong>分布式一致性</strong>问题<strong>最有效</strong>的算法之一。</p>
<p>Paxos算法是Lamport宗师提出的一种基于消息传递的分布式一致性算法，使其获得2013年图灵奖。</p>
<p>自Paxos问世以来就持续垄断了分布式一致性算法，Paxos这个名词几乎等同于分布式一致性。</p>
<p>Google的很多大型分布式系统都采用了Paxos算法来解决分布式一致性问题，如<strong>Chubby</strong>、<strong>Megastore</strong>以及Spanner等。开源的<strong>ZooKeeper</strong>，以及MySQL 5.7推出的用来取代传统的主从复制的MySQL Group Replication等纷纷采用Paxos算法解决分布式一致性问题。</p>
<p>但是它也有两个明显的缺点：</p>
<ol>
<li>难以理解</li>
<li>在工程是实现上比较复杂。</li>
</ol>
<h2 id="问题产生的背景"><a href="#问题产生的背景" class="headerlink" title="问题产生的背景"></a>问题产生的背景</h2><p>在常见的分布式系统中，总会发生诸如<strong>机器宕机</strong>或<strong>网络异常</strong>（包括消息的延迟、丢失、重复、乱序，还有网络分区）等情况。Paxos算法需要解决的问题就是如何在一个可能发生上述异常的分布式系统中，快速且正确地在集群内部对<strong>某个数据的值</strong>达成<strong>一致</strong>，并且保证不论发生以上任何异常，都不会破坏整个系统的一致性。</p>
<blockquote>
<p>“</p>
<p>这里<strong>某个数据的值</strong>并不只是狭义上的某个数，它可以是一条日志，也可以是一条命令（command）。根据应用场景不同，<strong>某个数据的值</strong>有不同的含义。</p>
<p>”</p>
</blockquote>
<p><img src="/2022/10/24/Paxos%E5%8D%8F%E8%AE%AE/1.png" alt="图片"></p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>在Paxos算法中，有三种角色：</p>
<ul>
<li>Proposer (提案者)</li>
<li>Acceptor (人大代表)</li>
<li>Learners (广大群众)</li>
</ul>
<p>需要注意的是，在具体的算法实现过程中，并不是一个进程只能担任其中一种角色，它有可能会同时充当多个。比如一个进程<strong>既是Proposer又是Acceptor还是Learner</strong>。</p>
<p>还有一个很重要的概念叫<strong>提案（Proposal）</strong>。最终要达成一致的value就在提案里。</p>
<p>这个提案包括什么呢？是仅仅包括一个信息数值吗？到底是如何咱们继续向下阅读，目前咱们先认为仅仅是一个普普通通的value。</p>
<p><img src="/2022/10/24/Paxos%E5%8D%8F%E8%AE%AE/2.png" alt="图片"></p>
<h3 id="初次认识"><a href="#初次认识" class="headerlink" title="初次认识"></a>初次认识</h3><p>Paxos算法过程和我国的立法过程是极其相似的（法律案的提出、法律案的审议、法律案的表决、法律的公布四个阶段），所谓的提案就是新颁布法律。</p>
<p>Proposer (提案者)可以提出（propose）提案；Accoptor可以接受（accept）提案；如果某个提案被选定（chosen），那么该提案里的value就被选定了。</p>
<p>回到刚刚说的『对某个数据的值达成一致』，指的是Proposer、Acceptor、Learner都认为同一个value被选定（chosen）。那么，Proposer、Acceptor、Learner分别在什么情况下才能认为某个value被选定呢？</p>
<ul>
<li>Proposer：只要Proposer发的提案被Acceptor接受（刚开始先认为只需要一个Acceptor接受即可，在推导过程中会发现需要半数以上的Acceptor同意才行），Proposer就认为该提案里的value被选定了。</li>
<li>Acceptor：只要Acceptor接受了某个提案，Acceptor就认为该提案里的value被选定了。</li>
<li>Learner：作为一个学习者，Acceptor告诉Learner哪个value被选定，Learner就认为那个value被选定。</li>
</ul>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>假设有一组可以<strong>提出（propose）value</strong>的进程集合（提案者团队），一个一致性算法需要保证提出的这么多value中，仅仅<strong>只有一个相同的</strong>value被选定（chosen）。也就是说要么没有value被提出，只要提出了value并且被选定，那么大家最终学习到的value必须是一致的。对于一致性算法，<strong>安全性</strong>（safaty）要求如下：</p>
<ul>
<li>只有被提出的value才能被选定。</li>
<li>只有一个value被选定。</li>
<li>如果某个进程认为某个value被选定了，那么这个value必须是真的被选定的那个。</li>
</ul>
<blockquote>
<p>“</p>
<p>Paxos的目标：保证最终有一个value会被选定，当value被选定后，进程最终也能获取到被选定的value。</p>
<p>”</p>
</blockquote>
<p>俗话说的好，<strong>哪里有需求，哪里就会出现糟糕的问题</strong>。如果假设不同角色之间可以通过发送消息来进行通信，那么：</p>
<ul>
<li>每个角色以各自任意的速度进行通信执行，在这个过程中可能会因为各种原因出错而导致执行停止或重启。当一个value被选定之后，因为故障原因才恢复正常的角色因为失去了某些重要的信息，导致它们无法确定被选定的值。</li>
<li>消息在传递过程中可能出现任意时长的延迟，可能会重复，也可能丢失。但是消息不会被损坏，即消息内容不会被篡改（拜占庭将军问题）。</li>
</ul>
<p>以上都是可能会遇到的问题，要怎么解决？？？</p>
<h2 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h2><h3 id="最简单的方案——只有一个Acceptor"><a href="#最简单的方案——只有一个Acceptor" class="headerlink" title="最简单的方案——只有一个Acceptor"></a>最简单的方案——只有一个Acceptor</h3><p>假设只有一个Acceptor（可以有多个Proposer），只要Acceptor接受它收到的第一个提案，则该提案被选定，该提案里的value就是被选定的value。这样就保证只有一个value会被选定。</p>
<p>但是，如果这个唯一的Acceptor宕机了，那么整个系统就<strong>无法工作</strong>了！</p>
<p>因此，一个Acceptor是不可行的，必须要有<strong>多个Acceptor</strong>！</p>
<p><img src="/2022/10/24/Paxos%E5%8D%8F%E8%AE%AE/3.png" alt="图片"></p>
<h3 id="多个Acceptor"><a href="#多个Acceptor" class="headerlink" title="多个Acceptor"></a>多个Acceptor</h3><p>当有多个Acceptor的时候，如何保证在多个Proposer和多个Acceptor的情况下选定一个value呢？</p>
<p>大家可以自己先进行思考。</p>
<p>首先，我们的最终目标是无论有多少Proposer提出提案，有且仅有一个value被选定。</p>
<p>那么，我们可以先定义一个约束：</p>
<blockquote>
<p>“</p>
<p>P1：一个Acceptor必须接受它收到的第一个提案。</p>
<p>”</p>
</blockquote>
<p>但是，这样又会出现其它的问题：如果每个Proposer所提出的提案value是不同的，并且将提案发送给不同的Acceptor。根据P1约束，每个Acceptor都接受它收到的第一个提案，就会出现不同value被选定的情况，出现了不一致。</p>
<p><img src="/2022/10/24/Paxos%E5%8D%8F%E8%AE%AE/4.png" alt="图片"></p>
<p>刚刚是因为『一个提案只要被一个Acceptor接受，则该提案的value就被选定了』才导致了出现上面不一致的问题。因此，我们需要加一个规定：</p>
<blockquote>
<p>“</p>
<p>规定：一个提案被选定需要被<strong>半数以上</strong>的Acceptor接受</p>
<p>”</p>
</blockquote>
<p>一个提案被半数以上接受，说明『一个Acceptor必须能够接受不止一个提案！』，不然可能导致最终没有value被选定。比如上图的情况。v1、v2、v3都没有被选定，因为它们都只被一个Acceptor的接受，并没有被超过半数以上的Acceptor接受。</p>
<p>最开始将【<strong>提案 &#x3D; value</strong>】已经无法满足现在的需求，因为当一个Proposer发送多个提案到一个Acceptor的时候，需要使用一个编号来区分被提出的顺序。现在【<strong>提案&#x3D;提案编号+value</strong>】。</p>
<p>虽然允许多个提案被选定，但必须保证所有被选定的提案都具有相同的value值。否则又会出现不一致。</p>
<blockquote>
<p>“</p>
<p>P2：如果某个value为v的提案被选定了，那么每个编号更高的被选定提案的value必须也是v。</p>
<p>”</p>
</blockquote>
<p>一个提案只有被Acceptor接受才可能被选定，因此我们可以把P2约束改写成对Acceptor接受的提案的约束P2a。</p>
<blockquote>
<p>“</p>
<p>P2a：如果某个value为v的提案被选定了，那么每个编号更高的被Acceptor接受的提案的value必须也是v。</p>
<p>”</p>
</blockquote>
<p>只要满足了P2a，就能满足P2。</p>
<p>但是，考虑如下的情况：以立法过程为背景，假设总的有5个人大代表（Acceptor）。</p>
<p><strong>人民法院</strong>（Proposer2）提出[M1,V1]的提案，<strong>人大代表2-5号</strong>（半数以上）均接受了该提案，于是对于人大代表2-5号和人民法院来讲，它们都认为V1提案是被选定的。此时，<strong>人大代表1</strong>在办完其它事务之后也参与到其中（之前人大代表1没有收到过任何提案），此时<strong>最高人民检察院</strong>（另一个提案者Proposer1）向人大代表1发送了[M2,V2]的提案（V2≠V1且M2&gt;M1），对于人大代表1来讲，这是它收到的第一个提案。根据P1（一个Acceptor必须接受它收到的第一个提案。）,人大代表1必须接受该提案！同时人大代表1认为V2被选定。这就出现了两个问题：</p>
<ol>
<li>人大代表1认为V2被选定，人大代表2-5和人民法院认为V1被选定。出现了不一致。</li>
<li>V1被选定了，但是编号更高的被人大代表1接受的提案[M2,V2]的value为V2，且V2≠V1。这就跟P2a（如果某个value为v的提案被选定了，那么每个编号更高的被Acceptor接受的提案的value必须也是v）矛盾了。</li>
</ol>
<p><img src="/2022/10/24/Paxos%E5%8D%8F%E8%AE%AE/5.png" alt="图片"></p>
<p>所以，我们要对P2a约束进行加强！</p>
<p>P2a是对Acceptor接受的提案约束，但其实提案是Proposer提出来的，所有我们可以对Proposer提出的提案进行约束。得到P2b：</p>
<blockquote>
<p>“</p>
<p>P2b：如果某个value为v的提案被选定了，那么之后任何Proposer提出的编号更高的提案的value必须也是v。</p>
<p>”</p>
</blockquote>
<p>那么，如何确保在某个value为v的提案被选定后，Proposer提出的编号更高的提案的value都是v呢？</p>
<p>只要满足P2c即可：</p>
<blockquote>
<p>“</p>
<p>P2c：对于任意的N和V，如果提案[N, V]被提出，那么存在一个半数以上的Acceptor组成的集合S，满足以下两个条件中的任意一个：</p>
<ul>
<li>S中每个Acceptor都没有接受过编号小于N的提案。</li>
<li>S中Acceptor接受过的最大编号的提案的value为V。</li>
</ul>
<p>”</p>
</blockquote>
<h3 id="Proposer生成提案"><a href="#Proposer生成提案" class="headerlink" title="Proposer生成提案"></a>Proposer生成提案</h3><p>为了满足P2b，这里有个比较重要的思想：Proposer生成提案之前，应该先去<strong>『学习』</strong>已经被选定或者可能被选定的value，然后以该value作为自己提出的提案的value。如果没有value被选定，Proposer才可以自己决定value的值。这样才能达成一致。这个学习的阶段是通过一个<strong>『Prepare请求』</strong>实现的。</p>
<p>于是我们得到了如下的<strong>提案生成算法</strong>：</p>
<ol>
<li><p>Proposer选择一个<strong>新的提案编号N</strong>，然后向<strong>某个Acceptor集合</strong>（半数以上）发送请求，要求该集合中的每个Acceptor做出如下响应（response）。</p>
<p>(a) 向Proposer承诺保证<strong>不再接受</strong>任何编号<strong>小于N的提案</strong>。</p>
<p>(b) 如果Acceptor已经接受过提案，那么就向Proposer响应<strong>已经接受过</strong>的编号小于N的<strong>最大编号的提案</strong>。</p>
<p>我们将该请求称为<strong>编号为N</strong>的<strong>Prepare请求</strong>。</p>
</li>
<li><p>如果Proposer收到了<strong>半数以上</strong>的Acceptor的<strong>响应</strong>，那么它就可以生成编号为N，Value为V的<strong>提案[N,V]。这里的V是所有的响应中编号最大的提案的Value</strong>。如果所有的响应中<strong>都没有提案</strong>，那 么此时V就可以由Proposer<strong>自己选择</strong>(一般为当前提案)。</p>
<p>生成提案后，Proposer将该<strong>提案</strong>发送给<strong>半数以上</strong>的Acceptor集合，并期望这些Acceptor能接受该提案。我们称该请求为<strong>Accept请求</strong>。（注意：此时接受Accept请求的Acceptor集合<strong>不一定</strong>是之前响应Prepare请求的Acceptor集合）</p>
</li>
</ol>
<h3 id="Acceptor接受提案"><a href="#Acceptor接受提案" class="headerlink" title="Acceptor接受提案"></a>Acceptor接受提案</h3><p>Acceptor<strong>可以忽略任何请求</strong>（包括Prepare请求和Accept请求）而不用担心破坏算法的<strong>安全性</strong>。因此，我们这里要讨论的是什么时候Acceptor可以响应一个请求。</p>
<p>我们对Acceptor接受提案给出如下约束：</p>
<blockquote>
<p>“</p>
<p>P1a：一个Acceptor只要尚<strong>未响应过</strong>任何<strong>编号大于N</strong>的<strong>Prepare请求</strong>，那么他就可以<strong>接受</strong>这个<strong>编号为N的提案</strong>。</p>
<p>”</p>
</blockquote>
<p>如果Acceptor收到一个编号为N的Prepare请求，在此之前它已经响应过编号大于N的Prepare请求。根据P1a，该Acceptor不可能接受编号为N的提案。因此，该Acceptor可以忽略编号为N的Prepare请求。当然，也可以回复一个error，让Proposer尽早知道自己的提案不会被接受。</p>
<p>因此，一个Acceptor<strong>只需记住</strong>：1. 已接受的编号最大的提案 2. 已响应的请求的最大编号。</p>
<h3 id="Paxos算法描述"><a href="#Paxos算法描述" class="headerlink" title="Paxos算法描述"></a>Paxos算法描述</h3><p>经过上面的推导，我们总结下Paxos算法的流程。</p>
<p>Paxos算法分为<strong>两个阶段</strong>。具体如下：</p>
<p>1.<strong>阶段一：</strong></p>
<ol>
<li>Proposer选择一个<strong>提案编号N</strong>，然后向<strong>半数以上</strong>的Acceptor发送编号为N的<strong>Prepare请求</strong>。</li>
<li>如果一个Acceptor收到一个编号为N的Prepare请求，且N<strong>大于</strong>该Acceptor已经<strong>响应过的</strong>所有<strong>Prepare请求</strong>的编号，那么它就会将它已经<strong>接受过的编号最大的提案（如果有的话）</strong> 作为响应反馈给Proposer，同时该Acceptor承诺<strong>不再接受</strong>任何<strong>编号小于N的提案</strong>。</li>
</ol>
<p>2.<strong>阶段二：</strong></p>
<ol>
<li>如果Proposer收到<strong>半数以上</strong>Acceptor对其发出的编号为N的Prepare请求的<strong>响应</strong>，那么它就会发送一个针对[N,V]提案的Accept请求给<strong>半数以上</strong>的Acceptor（和之前的Acceptor不一定相同）。注意：V就是收到的响应中编号最大的提案的value，如果响应中<strong>不包含任何提案</strong>，那么V就由Proposer<strong>自己决定</strong>。</li>
<li>如果Acceptor收到一个针对编号为N的提案的Accept请求，只要该Acceptor<strong>没有</strong>对编号<strong>大于N</strong>的<strong>Prepare请求</strong>做出过<strong>响应</strong>，它就<strong>接受该提案</strong>。</li>
</ol>
<p><img src="/2022/10/24/Paxos%E5%8D%8F%E8%AE%AE/6.png" alt="图片"></p>
<h2 id="Learner学习被选定的value"><a href="#Learner学习被选定的value" class="headerlink" title="Learner学习被选定的value"></a>Learner学习被选定的value</h2><p>Learner学习（获取）被选定的value有如下三种方案：</p>
<h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>Acceptor接受到一个提案，就将该提案发送给所有Learners.</p>
<ul>
<li>优点：Learner能够快速获取被选定的value</li>
<li>缺点：通信次数为M*N（M为提案数，N为Learner数）</li>
</ul>
<h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>Acceptor接受一个提案，就将提案发送给<strong>主Learner</strong>,主Learner再通知其它Learner</p>
<ul>
<li>优点：通信次数减少（M+N-1）（M为提案数，N为Learner数，M个提案发送给主Learner，然后主Learner通知N-1个Learner）</li>
<li>缺点：单点故障问题（主Learner可能出现故障）</li>
</ul>
<h3 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h3><p>Acceptor接受一个提案，就将提案发送给<strong>Learner团</strong>,Learner团再通知其它Learner</p>
<ul>
<li>优点：解决了方案二单点故障问题，可靠性好</li>
<li>缺点：实现复杂，网络通信复杂度高</li>
</ul>
<h2 id="如何保证Paxos算法的活性"><a href="#如何保证Paxos算法的活性" class="headerlink" title="如何保证Paxos算法的活性"></a>如何保证Paxos算法的活性</h2><p>通过选取<strong>主Proposer</strong>，就可以保证Paxos算法的活性。通过选取主Proposer，并规定只有主Proposer才能提出议案。这样一来只要主Proposer和过半的Acceptor能够正常进行网络通信，那么但凡主Proposer提出一个编号更高的提案，该提案终将会被批准，这样通过选择一个主Proposer，整套Paxos算法就能够保持活性。至此，我们得到一个<strong>既能保证安全性，又能保证活性</strong>的<strong>分布式一致性算法</strong>——<strong>Paxos算法</strong>。</p>
<p><img src="/2022/10/24/Paxos%E5%8D%8F%E8%AE%AE/7.png" alt="图片"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到此，我们针对Paxos算法是什么、它的特性以及算法的具体推导过程做了详细的阐述。<strong>Paxos算法</strong>是现在很多一致性算法的变体，非常值得我们学习</p>
]]></content>
      <categories>
        <category>分布式一致性协议</category>
      </categories>
      <tags>
        <tag>分布式一致性协议</tag>
        <tag>Paxos协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis知识点PDF总结</title>
    <url>/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9PDF%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>Redis知识点PDF总结</p>
<div class="pdf-container" data-target="./Redis高手心法-码哥字节原创.pdf" data-height="1000px"></div>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>AOF</tag>
        <tag>RDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程总结</title>
    <url>/2022/10/24/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="1进程-x2F-线程是什么？"><a href="#1进程-x2F-线程是什么？" class="headerlink" title="1进程&#x2F;线程是什么？"></a>1进程&#x2F;线程是什么？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进程是“执行中的程序”，进行资源分配和调度的独立单位，线程是进程的实体，一个进程可以拥有多个线程，线程的上下文切换比进程要快，线程之间共享地址空间和其他资源。</span><br></pre></td></tr></table></figure>



<h3 id="2线程状态？"><a href="#2线程状态？" class="headerlink" title="2线程状态？"></a>2线程状态？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread 的源码中定义了6种状态：new（新建）、runnnable（可运行）、blocked（阻塞）、waiting（等待）、time waiting （定时等待）和 terminated（终止）。</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210411150209579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>线程状态转换如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411150228520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</p>
<p>对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">        B(A a) &#123;</span><br><span class="line">            <span class="built_in">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                a.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(a);</span><br><span class="line">        b.start();</span><br><span class="line">        a.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">JoinExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JoinExample</span>();</span><br><span class="line">    example.test();</span><br><span class="line">&#125;</span><br><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure>



<h4 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h4><p>对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    Thread.yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h4><p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I&#x2F;O 阻塞和 synchronized 锁阻塞。</p>
<p>对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread run&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread1.interrupt();</span><br><span class="line">    System.out.println(<span class="string">&quot;Main run&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at InterruptExample.lambda$main$<span class="number">0</span>(InterruptExample.java:<span class="number">5</span>)</span><br><span class="line">    at InterruptExample$$Lambda$<span class="number">1</span>/<span class="number">713338599.</span>run(Unknown Source)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br></pre></td></tr></table></figure>



<h4 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted()"></a>interrupted()</h4><p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。</p>
<p>但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!interrupted()) &#123;</span><br><span class="line">                <span class="comment">// ..</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread end&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line">    thread2.start();</span><br><span class="line">    thread2.interrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread end</span><br></pre></td></tr></table></figure>



<h3 id="3wait-x2F-sleep的区别？"><a href="#3wait-x2F-sleep的区别？" class="headerlink" title="3wait&#x2F;sleep的区别？"></a>3wait&#x2F;sleep的区别？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>sleep() 方法正在执行的线程主动让出 cpu（然后 cpu 就可以去执行其他任务），在sleep 指定时间后 cpu 再回到该线程继续往下执行（注意：sleep 方法只让出了cpu，而并不会释放同步资源锁）；</span><br><span class="line">  而 wait() 方法则是指当前线程让自己暂时退让出同步资源锁，以便其他正在等待该资源的线程得到该资源进而运行，只有调用了notify()方法，之前调用 wait() 的线程才会解除 wait 状态，可以去参与竞争同步资源锁，进而得到执行。（注意notify 的作用相当于叫醒睡着的人，而并不会给他分配任务，就是说 notify 只是让之前调用 wait 的线程有权利重新参与线程的调度）；</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>sleep() 方法可以在任何地方使用，而 wait() 方法则只能在同步方法或同步块中使用；</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>sleep() 是线程类（Thread）的方法，调用会暂停此线程指定的时间，但监控依然保持，不会释放对象锁，到时间自动恢复；wait() 是 Object 的方法，调用会放弃对象锁,进入等待队列，待调用 notify()/notifyAll() 唤醒指定的线程或者所有线程，才会进入竞争队列，再次获得对象锁才会进入运行状态。</span><br></pre></td></tr></table></figure>



<h3 id="4什么是并发？什么是并行？"><a href="#4什么是并发？什么是并行？" class="headerlink" title="4什么是并发？什么是并行？"></a>4什么是并发？什么是并行？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.解释一：并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。</span><br><span class="line"></span><br><span class="line">2.解释二：并行是在不同实体上的多个事件，并发是在同一实体上的多个事件.</span><br></pre></td></tr></table></figure>

<h1 id="2、Synchronized"><a href="#2、Synchronized" class="headerlink" title="2、Synchronized"></a>2、Synchronized</h1><p>我们知道并发编程会产生各种问题的源头是可见性，原子性，有序性。而synchronized能同时保证可见性，原子性，有序性。所以我们在解决并发问题的时候经常用synchronized，当然还有很多其他工具，如volatile。但是volatile只能保证可见性，有序性，不能保证原子性 .</p>
<p>synchronized可以用在如下地方</p>
<ol>
<li><p>修饰实例方法，对当前实例对象this加锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SynchronizedDemo <span class="keyword">synchronized</span>=<span class="keyword">new</span> <span class="title class_">SynchronizedDemo</span>();</span><br><span class="line"><span class="keyword">synchronized</span>.methodOne(); <span class="comment">//锁的是当前this对象，即synchronized,在此期间其他线程不能调用改方法中其他synchronized修饰的方法</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>修饰静态方法，对当前类的Class对象加锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SynchronizedDemo <span class="keyword">synchronized</span>=<span class="keyword">new</span> <span class="title class_">SynchronizedDemo</span>();</span><br><span class="line"><span class="keyword">synchronized</span>.methodTwo(); <span class="comment">//锁的是当前类的class对象，SynchronizedDemo.class 因为static修饰的方法是类方法</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>修饰代码块，指定加锁对象，对给定对象加锁</p>
</li>
</ol>
<p><strong>修饰实例方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">methodOne</span><span class="params">()</span> &#123;    </span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>修饰静态方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">methodTwo</span><span class="params">()</span> &#123; </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>修饰代码块</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodThree</span><span class="params">()</span> &#123;        </span><br><span class="line">        <span class="comment">// 对当前实例对象this加锁        </span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;   </span><br><span class="line">            </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodFour</span><span class="params">()</span> &#123;        </span><br><span class="line">        <span class="comment">// 对class对象加锁        </span></span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedDemo.class) &#123;        </span><br><span class="line">            </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第一章：并发编程中的三个问题"><a href="#第一章：并发编程中的三个问题" class="headerlink" title="第一章：并发编程中的三个问题"></a>第一章：并发编程中的三个问题</h2><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>学习什么是可见性问题 </p>
<h4 id="可见性概念"><a href="#可见性概念" class="headerlink" title="可见性概念"></a>可见性概念</h4><p>可见性（Visibility）：是指一个线程对共享变量进行修改，另一个先立即得到修改后的新值。 </p>
<h4 id="可见性演示"><a href="#可见性演示" class="headerlink" title="可见性演示"></a>可见性演示</h4><p>案例演示：一个线程根据boolean类型的标记ﬂag， while循环，另一个线程改变这个ﬂag变量的值，另 一个线程并不会停止循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.concurrent_problem;</span><br><span class="line"><span class="comment">/**    案例演示:        </span></span><br><span class="line"><span class="comment">		一个线程对共享变量的修改,另一个线程不能立即得到新值 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01Visibility</span> &#123;</span><br><span class="line">	<span class="comment">// 多个线程都会访问的数据，我们称为线程的共享数据    </span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">			<span class="keyword">while</span> (run) &#123;</span><br><span class="line">                </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		t1.start();</span><br><span class="line">        </span><br><span class="line">		Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        </span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">			run = <span class="literal">false</span>;</span><br><span class="line">			System.out.println(<span class="string">&quot;时间到，线程2设置为false&quot;</span>);</span><br><span class="line">		&#125;);</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>并发编程时，会出现可见性问题，当一个线程对共享变量进行了修改，另外的线程并没有立即看到修改后的最新值。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><h4 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h4><p>学习什么是原子性问题 </p>
<h4 id="原子性概念"><a href="#原子性概念" class="headerlink" title="原子性概念"></a>原子性概念</h4><p>原子性（Atomicity）：在一次或多次操作中，要么所有的操作都执行并且不会受其他因素干扰而中断，要么所有的操作都不执行。 </p>
<h4 id="原子性演示"><a href="#原子性演示" class="headerlink" title="原子性演示"></a>原子性演示</h4><p>案例演示:5个线程各执行1000次 i++;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo01_concurrent_problem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    目标:演示原子性问题</span></span><br><span class="line"><span class="comment">        1.定义一个共享变量number</span></span><br><span class="line"><span class="comment">        2.对number进行1000的++操作</span></span><br><span class="line"><span class="comment">        3.使用5个线程来进行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02Atomicity</span> &#123;</span><br><span class="line">    <span class="comment">// 1.定义一个共享变量number</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 2.对number进行1000的++操作</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">increment</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                number++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        List&lt;Thread&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 3.使用5个线程来进行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(increment);</span><br><span class="line">            t.start();</span><br><span class="line">            list.add(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread t : list) &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;number = &quot;</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用javap反汇编class文件，得到下面的字节码指令：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411150300410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>其中，对于 number++ 而言（number 为静态变量），实际会产生如下的 JVM 字节码指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">9: getstatic     #12                 // Field number:I </span><br><span class="line">12: iconst_1 </span><br><span class="line">13: iadd </span><br><span class="line">14: putstatic     #12                 // Field number:I</span><br></pre></td></tr></table></figure>

<p>由此可见number++是由多条语句组成，以上多条指令在一个线程的情况下是不会出问题的，但是在多 线程情况下就可能会出现问题。比如一个线程在执行13: iadd时，另一个线程又执行9: getstatic。会导 致两次number++，实际上只加了1。 </p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>并发编程时，会出现原子性问题，当一个线程对共享变量操作到一半时，另外的线程也有可能来操作共 享变量，干扰了前一个线程的操作。</p>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><h4 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h4><p>学习什么是有序性问题 </p>
<h4 id="有序性概念"><a href="#有序性概念" class="headerlink" title="有序性概念"></a>有序性概念</h4><p>有序性（Ordering）：是指程序中代码的执行顺序，Java在编译时和运行时会对代码进行优化，会导致 程序终的执行顺序不一定就是我们编写代码时的顺序。</p>
<h4 id="有序性演示"><a href="#有序性演示" class="headerlink" title="有序性演示"></a>有序性演示</h4><p>jcstress是java并发压测工具。<a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">https://wiki.openjdk.java.net/display/CodeTools/jcstress</a> 修改pom文件，添加依赖：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;   </span><br><span class="line"> &lt;groupId&gt;org.openjdk.jcstress&lt;/groupId&gt;    </span><br><span class="line">&lt;artifactId&gt;jcstress-core&lt;/artifactId&gt;    </span><br><span class="line">&lt;version&gt;$&#123;jcstress.version&#125;&lt;/version&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo01_concurrent_problem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.infra.results.I_Result;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@JCStressTest</span></span><br><span class="line"> <span class="meta">@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)</span></span><br><span class="line"> <span class="meta">@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;danger&quot;)</span></span><br><span class="line"> <span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03Ordering</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 线程1执行的代码</span></span><br><span class="line">    <span class="comment">// @Actor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ready) &#123;</span><br><span class="line">            r.r1 = num + num;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.r1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程2执行的代码</span></span><br><span class="line">    <span class="comment">// @Actor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>I_Result 是一个对象，有一个属性 r1 用来保存结果，在多线程情况下可能出现几种结果？</p>
<p>情况1：线 程1先执行actor1，这时ready &#x3D; false，所以进入else分支结果为1。</p>
<p>情况2：线程2执行到actor2，执行了num &#x3D; 2;和ready &#x3D; true，线程1执行，这回进入 if 分支，结果为 4。 </p>
<p>情况3：线程2先执行actor2，只执行num &#x3D; 2；但没来得及执行 ready &#x3D; true，线程1执行，还是进入 else分支，结果为1。<br>还有一种结果0。<br>运行测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn clean install </span><br><span class="line"></span><br><span class="line">java -jar target/jcstress.jar</span><br></pre></td></tr></table></figure>

<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>程序代码在执行过程中的先后顺序，由于Java在编译期以及运行期的优化，导致了代码的执行顺序未必 就是开发者编写代码时的顺序。</p>
<h2 id="第二章：Java内存模型-JMM"><a href="#第二章：Java内存模型-JMM" class="headerlink" title="第二章：Java内存模型(JMM)"></a>第二章：Java内存模型(JMM)</h2><p>在介绍Java内存模型之前，先来看一下到底什么是计算机内存模型。 </p>
<h3 id="计算机结构"><a href="#计算机结构" class="headerlink" title="计算机结构"></a>计算机结构</h3><h4 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a>目标</h4><p>学习计算机的主要组成<br>学习缓存的作用 </p>
<h4 id="计算机结构简介"><a href="#计算机结构简介" class="headerlink" title="计算机结构简介"></a>计算机结构简介</h4><p>冯诺依曼，提出计算机由五大组成部分，输入设备，输出设备存储器，控制器，运算器。</p>
<p><img src="https://img-blog.csdnimg.cn/20210411150313874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><p>中央处理器，是计算机的控制和运算的核心，我们的程序终都会变成指令让CPU去执行，处理程序中 的数据。<br><img src="https://img-blog.csdnimg.cn/20210411150326659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><p>我们的程序都是在内存中运行的，内存会保存程序运行时的数据，供CPU处理。</p>
<p><img src="https://img-blog.csdnimg.cn/20210411150338507.png#pic_center" alt="在这里插入图片描述"></p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>CPU的运算速度和内存的访问速度相差比较大。这就导致CPU每次操作内存都要耗费很多等待时间。内存的读写速度成为了计算机运行的瓶颈。于是就有了在CPU和主内存之间增加缓存的设计。靠近CPU 的缓存称为L1，然后依次是 L2，L3和主内存，CPU缓存模型如图下图所示。 </p>
<p><img src="https://img-blog.csdnimg.cn/20210411150352725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>CPU Cache分成了三个级别: L1， L2， L3。都集成在CPU中，级别越小越接近CPU，速度也更快，同时也代表着容量越 小。</p>
<ol>
<li>L1是接近CPU的，它容量小，例如32K，速度快，每个核上都有一个L1 Cache。 </li>
<li>L2 Cache 更大一些，例如256K，速度要慢一些，一般情况下每个核上都有一个独立的L2 Cache。 </li>
<li>L3 Cache是三级缓存中大的一级，例如12MB，同时也是缓存中慢的一级，在同一个CPU插槽 之间的核共享一个L3 Cache。<br><img src="https://img-blog.csdnimg.cn/20210411150406716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ol>
<p>Cache的出现是为了解决CPU直接访问内存效率低下问题的，程序在运行的过程中，CPU接收到指令 后，它会先向CPU中的一级缓存（L1 Cache）去寻找相关的数据，如果命中缓存，CPU进行计算时就 可以直接对CPU Cache中的数据进行读取和写人，当运算结束之后，再将CPUCache中的新数据刷新 到主内存当中，CPU通过直接访问Cache的方式替代直接访问主存的方式极大地提高了CPU 的吞吐能 力。但是由于一级缓存（L1 Cache）容量较小，所以不可能每次都命中。这时CPU会继续向下一级的二 级缓存（L2 Cache）寻找，同样的道理，当所需要的数据在二级缓存中也没有的话，会继续转向L3 Cache、内存(主存)和硬盘。</p>
<p>把CPU比做大脑  寄存器就像你正在思考的问题,而cahe就是你的记忆(临时的)</p>
<h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p>计算机的主要组成CPU，内存，输入设备，输出设备。</p>
<h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><h4 id="目标-4"><a href="#目标-4" class="headerlink" title="目标"></a>目标</h4><p>学习Java内存模型的概念和作用 Java内存模型的概念<br>Java Memory Molde (Java内存模型&#x2F;JMM)，千万不要和Java内存结构混淆 关于“Java内存模型”的权威解释，请参考 <a href="https://download.oracle.com/otn-pub/jcp/memory_model1.0-pfd-spec-oth-JSpec/memory_model-1_0-pfd-spec.pdf%E3%80%82">https://download.oracle.com/otn-pub/jcp/memory_model1.0-pfd-spec-oth-JSpec/memory_model-1_0-pfd-spec.pdf。</a><br>Java内存模型，是Java虚拟机规范中所定义的一种内存模型，Java内存模型是标准化的，屏蔽掉了底层 不同计算机的区别。<br>Java内存模型是一套规范，描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量 存储到内存和从内存中读取变量这样的底层细节，具体如下。</p>
<p><strong>主内存</strong> </p>
<p>主内存是所有线程都共享的，都能访问的。所有的共享变量都存储于主内存。 </p>
<p><strong>工作内存</strong> </p>
<p>每一个线程有自己的工作内存，工作内存只存储该线程对共享变量的副本。线程对变量的所有的操 作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量，不同线程之间也不能直接 访问对方工作内存中的变量。<br><img src="https://img-blog.csdnimg.cn/20210411150420196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="Java内存模型的作用"><a href="#Java内存模型的作用" class="headerlink" title="Java内存模型的作用"></a>Java内存模型的作用</h4><p>Java内存模型是一套在多线程读写共享数据时，对共享数据的可见性、有序性、和原子性的规则和保障。<br>synchronized,volatile </p>
<h4 id="CPU缓存，内存与Java内存模型的关系"><a href="#CPU缓存，内存与Java内存模型的关系" class="headerlink" title="CPU缓存，内存与Java内存模型的关系"></a>CPU缓存，内存与Java内存模型的关系</h4><p>通过对前面的CPU硬件内存架构、Java内存模型以及Java多线程的实现原理的了解，我们应该已经意识到，多线程的执行终都会映射到硬件处理器上进行执行。<br>但Java内存模型和硬件内存架构并不完全一致。对于硬件内存来说只有寄存器、缓存内存、主内存的概 念，并没有工作内存和主内存之分，也就是说Java内存模型对内存的划分对硬件内存并没有任何影响， 因为JMM只是一种抽象的概念，是一组规则，不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存中，当然也有可能存储到CPU缓存或者寄存器中，因此总体上来说， Java内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种抽象概念划分与真实物理硬件的交叉。</p>
<p>JMM内存模型与CPU硬件内存架构的关系：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411150432337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><p>Java内存模型是一套规范，描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节，Java内存模型是对共享数据的可见性、有序性、和原子性的规则和保障。</p>
<h3 id="主内存与工作内存之间的交互"><a href="#主内存与工作内存之间的交互" class="headerlink" title="主内存与工作内存之间的交互"></a>主内存与工作内存之间的交互</h3><p><img src="https://img-blog.csdnimg.cn/2021041115044483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="目标-5"><a href="#目标-5" class="headerlink" title="目标"></a>目标</h4><p>了解主内存与工作内存之间的数据交互过程<br>Java内存模型中定义了以下8种操作来完成，主内存与工作内存之间具体的交互协议，即一个变量如何 从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，虚拟机实现时必须保证下面 提及的每一种操作都是原子的、不可再分的。<br>对应如下的流程图：</p>
<p><strong>可见性：</strong></p>
<p>CPU和主内存通过总线进行数据交互，其中有8大原子操作<br><img src="https://img-blog.csdnimg.cn/20210411150523755.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>先了解CPU和内存之间如何实现缓存一致性以及有序性的</p>
<p><img src="https://img-blog.csdnimg.cn/20210411150543568.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>CPU和内存之间通过总线进行数据交互，其中通过缓存一致性协议（MESI）+CPU嗅探技术解决缓存一致性问题</p>
<p>当CPU修改了缓存值会通过原子操作锁机制（将主内存值锁定然后将最新的值刷新，再解锁）将最新的缓存值刷新到主内存，其中经过总线，其他CPU嗅探到后将自己缓存中的值设置为无效，这样会重新取主内存读取最新的值，</p>
<p><img src="https://img-blog.csdnimg.cn/20210411150558294.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>其中JMM内存模型Volatile关键值实现可见性底层就是通过上述方式，通过Lock前缀指令，锁定这块区域缓存（缓存行锁定）并写会到主内存</p>
<p><img src="https://img-blog.csdnimg.cn/2021041115061243.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>有序性：</strong></p>
<p>指令重排序：CPU在不影响单线程执行结果的前提下，计算机为了最大限度的发挥机器性能，会对机器指令重排序优化</p>
<p><img src="https://img-blog.csdnimg.cn/20210411150633315.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>as-if-serial</strong>:不管怎么重排序（编译期和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。</p>
<p><strong>happens-before原则：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">单线程happen-before原则：在同一个线程中，书写在前面的操作happen-before后面的操作。</span><br><span class="line"></span><br><span class="line">锁的happen-before原则：同一个锁的unlock操作happen-before此锁的lock操作。</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span>的happen-before原则：对一个<span class="keyword">volatile</span>变量的写操作happen-before对此变量的任意操作(当然也包括写操作了)。</span><br><span class="line"></span><br><span class="line">happen-before的传递性原则：如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作。</span><br><span class="line"></span><br><span class="line">线程启动的happen-before原则：同一个线程的start方法happen-before此线程的其它方法。</span><br><span class="line"></span><br><span class="line">线程中断的happen-before原则：对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。</span><br><span class="line"></span><br><span class="line">线程终结的happen-before原则：线程中的所有操作都happen-before线程的终止检测。</span><br><span class="line"></span><br><span class="line">对象创建的happen-before原则：一个对象的初始化完成先于他的finalize方法调用。</span><br></pre></td></tr></table></figure>

<p>JVM规范了内存屏障，为了实现有序性，其中Volatile需要实现内存屏障</p>
<p><img src="https://img-blog.csdnimg.cn/20210411150649314.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>CPU层面的内存屏障</p>
<p><img src="https://img-blog.csdnimg.cn/2021041115070589.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>因为指令重排序可能出现的问题：双重校验锁实现单例</strong>（不加volatile）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;  <span class="comment">// 禁止别的类使用该构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="comment">//类对象加锁 </span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123; </span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;  <span class="comment">// 进一步确保uniqueInstance为null才生成对象</span></span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先为什么需要两个if呢？原因是多个线程都一开始判断uniqueInstance &#x3D;&#x3D; null，然后有了一个线程获取了锁资源，其他线程等待，创建了uniqueInstance实例对象，然后它释放了锁，又有了新的线程获取到锁实例，如果这时候不判断uniqueInstance&#x3D;&#x3D;null ,那它就会又创建了一个实例对象。</p>
<p>那么为什么要加入volatile? </p>
<p><img src="https://img-blog.csdnimg.cn/20210411150721737.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>打印出字节码，加载、验证、准备、解析、初始化，加载阶段会先在堆内存分配内存，创建一个代表该类的class对象，作为方法区中该类各种数据的访问入口，然后准备阶段类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存，如果不是final修饰，赋值为0。          进行变量的初始化动作，初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 &lt;clinit&gt;() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源(即构造函数)</p>
<p>如果不加volatile,可能导致21行和24行互换顺序，初始化动作在把对象内存地址赋值给引用之后了，这时候引用可能拿到没执行构造方法的变量。</p>
<p><strong>总线风暴：</strong></p>
<p>在多核处理器架构上，所有的处理器是共用一条总线的，都是靠此总线来和主内存进行数据交互。当主内存的数据同时存在于多个处理的高速缓存中时，某一处理器更新了此共享数据后。会通过总线触发嗅探机制来通知其他处理器将自己高速缓存内的共享数据置为无效，在下次使用时重新从主内存加载最新数据。而这种通过总线来进行通信则称之为”缓存一致性流量“。</p>
<p>因为总线是固定的，所有相应可以接受的通信能力也就是固定的了，如果缓存一致性流量突然激增，必然会使总线的处理能力受到影响。而恰好CAS和volatile 会导致缓存一致性流量增大。如果很多线程都共享一个变量，当共享变量进行CAS等数据变更时，就有可能产生总线风暴。解决方法是部分使用synchronized。</p>
<h2 id="第四章：synchronized的特性"><a href="#第四章：synchronized的特性" class="headerlink" title="第四章：synchronized的特性"></a>第四章：synchronized的特性</h2><h3 id="可重入特性"><a href="#可重入特性" class="headerlink" title="可重入特性"></a>可重入特性</h3><h4 id="目标-6"><a href="#目标-6" class="headerlink" title="目标"></a>目标</h4><p>了解什么是可重入<br>了解可重入的原理 </p>
<h4 id="什么是可重入"><a href="#什么是可重入" class="headerlink" title="什么是可重入"></a>什么是可重入</h4><p>一个线程可以多次执行synchronized,重复获取同一把锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 演示可重入锁是什么意思，可重入，就是可以重复获取相同的锁，synchronized和ReentrantLock都是可重入的</span></span><br><span class="line"><span class="comment">// 可重入降低了编程复杂性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WhatReentrant</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				<span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;第1次获取锁，这个锁是：&quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">					<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">						<span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">							System.out.println(<span class="string">&quot;第&quot;</span> + (++index) + <span class="string">&quot;次获取锁，这个锁是：&quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">if</span> (index == <span class="number">10</span>) &#123;</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h4><p>synchronized的锁对象中有一个计数器（recursions变量）会记录线程获得几次锁. 可重入的好处 </p>
<ol>
<li>可以避免死锁 </li>
<li>可以让我们更好的来封装代码</li>
</ol>
<h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><p>synchronized是可重入锁，内部锁对象中会有一个计数器记录线程获取几次锁啦，在执行完同步代码块 时，计数器的数量会-1，知道计数器的数量为0，就释放这个锁。 </p>
<h3 id="不可中断特性"><a href="#不可中断特性" class="headerlink" title="不可中断特性"></a>不可中断特性</h3><h4 id="目标-7"><a href="#目标-7" class="headerlink" title="目标"></a>目标</h4><p>学习synchronized不可中断特性<br>学习Lock的可中断特性 </p>
<h4 id="什么是不可中断"><a href="#什么是不可中断" class="headerlink" title="什么是不可中断"></a>什么是不可中断</h4><p>一个线程获得锁后，另一个线程想要获得锁，必须处于阻塞或等待状态，如果第一个线程不释放锁，第 二个线程会一直阻塞或等待，不可被中断。 </p>
<h4 id="synchronized不可中断演示"><a href="#synchronized不可中断演示" class="headerlink" title="synchronized不可中断演示"></a>synchronized不可中断演示</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    目标:演示synchronized不可中断</span></span><br><span class="line"><span class="comment">        1.定义一个Runnable</span></span><br><span class="line"><span class="comment">        2.在Runnable定义同步代码块</span></span><br><span class="line"><span class="comment">        3.先开启一个线程来执行同步代码块,保证不退出同步代码块</span></span><br><span class="line"><span class="comment">        4.后开启一个线程来执行同步代码块(阻塞状态)</span></span><br><span class="line"><span class="comment">        5.停止第二个线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02_Uninterruptible</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1.定义一个Runnable</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">run</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="comment">// 2.在Runnable定义同步代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">                System.out.println(name + <span class="string">&quot;进入同步代码块&quot;</span>);</span><br><span class="line">                <span class="comment">// 保证不退出同步代码块</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">888888</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.先开启一个线程来执行同步代码块</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 4.后开启一个线程来执行同步代码块(阻塞状态)</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.停止第二个线程</span></span><br><span class="line">        System.out.println(<span class="string">&quot;停止线程前&quot;</span>);</span><br><span class="line">        t2.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;停止线程后&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(t1.getState());</span><br><span class="line">        System.out.println(t2.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ReentrantLock可中断演示"><a href="#ReentrantLock可中断演示" class="headerlink" title="ReentrantLock可中断演示"></a>ReentrantLock可中断演示</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    目标:演示Lock不可中断和可中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03_Interruptible</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">         test01();</span><br><span class="line"><span class="comment">//        test02();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示Lock可中断</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">run</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                b = lock.tryLock(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">                <span class="keyword">if</span> (b) &#123;</span><br><span class="line">                    System.out.println(name + <span class="string">&quot;获得锁,进入锁执行&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">88888</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(name + <span class="string">&quot;在指定时间没有得到锁做其他操作&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (b) &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                    System.out.println(name + <span class="string">&quot;释放锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">         System.out.println(<span class="string">&quot;停止t2线程前&quot;</span>);</span><br><span class="line">         t2.interrupt();</span><br><span class="line">         System.out.println(<span class="string">&quot;停止t2线程后&quot;</span>);</span><br><span class="line"></span><br><span class="line">         Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">         System.out.println(t1.getState());</span><br><span class="line">         System.out.println(t2.getState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示Lock不可中断</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">run</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(name + <span class="string">&quot;获得锁,进入锁执行&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">88888</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(name + <span class="string">&quot;释放锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;停止t2线程前&quot;</span>);</span><br><span class="line">        t2.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;停止t2线程后&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(t1.getState());</span><br><span class="line">        System.out.println(t2.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><p>不可中断是指，当一个线程获得锁后，另一个线程一直处于阻塞或等待状态，前一个线程不释放锁，后 一个线程会一直阻塞或等待，不可被中断。<br>synchronized属于不可被中断</p>
<p>Lock的lock方法是不可中断的 </p>
<p>Lock的tryLock方法是可中断的</p>
<h2 id="第五章：synchronized原理"><a href="#第五章：synchronized原理" class="headerlink" title="第五章：synchronized原理"></a>第五章：synchronized原理</h2><h3 id="javap-反汇编"><a href="#javap-反汇编" class="headerlink" title="javap 反汇编"></a>javap 反汇编</h3><h4 id="目标-8"><a href="#目标-8" class="headerlink" title="目标"></a>目标</h4><p>通过javap反汇编学习synchronized的原理   我们编写一个简单的synchronized代码，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们要看synchronized的原理，但是synchronized是一个关键字，看不到源码。我们可以将class文件 进行反汇编。</p>
<p>JDK自带的一个工具： javap ，对字节码进行反汇编，查看字节码指令。<br>在DOS命令行输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javap -p -v -c C:\Users\13666\IdeaProjects\HeiMa\Synchronized\target\classes\com\itheima\demo04 _synchronized_monitor\Increment.class</span><br></pre></td></tr></table></figure>

<p>反汇编后的效果如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411150823122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411150842113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021041115084227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="monitorenter"><a href="#monitorenter" class="headerlink" title="monitorenter"></a>monitorenter</h4><p>首先我们来看一下JVM规范中对于monitorenter的描述： <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorenter">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorenter</a></p>
<blockquote>
<p>Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref， as follows: • If the entry count of the monitor associated with objectref is zero， the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor. • If the thread already owns the monitor associated with objectref， it reenters the monitor， incrementing its entry count. • If another thread already owns the monitor associated with objectref， the thread blocks until the monitor’s entry count is zero， then tries again to gain ownership. </p>
</blockquote>
<p>翻译过来： 每一个对象都会和一个监视器monitor关联。监视器被占用时会被锁住，其他线程无法来获 取该monitor。 当JVM执行某个线程的某个方法内部的monitorenter时，它会尝试去获取当前对象对应 的monitor的所有权。其过程如下：</p>
<ol>
<li>若monior的进入数为0，线程可以进入monitor，并将monitor的进入数置为1。当前线程成为 monitor的owner（所有者） </li>
<li>若线程已拥有monitor的所有权，允许它重入monitor，则进入monitor的进入数加1</li>
<li>若其他线程已经占有monitor的所有权，那么当前尝试获取monitor的所有权的线程会被阻塞，直 到monitor的进入数变为0，才能重新尝试获取monitor的所有权。</li>
</ol>
<p>monitorenter小结:<br>synchronized的锁对象会关联一个monitor,这个monitor不是我们主动创建的,是JVM的线程执行到这个 同步代码块,发现锁对象没有monitor就会创建monitor,monitor内部有两个重要的成员变量owner:拥有 这把锁的线程,recursions会记录线程拥有锁的次数,当一个线程拥有monitor后其他线程只能等待 </p>
<h4 id="monitorexit"><a href="#monitorexit" class="headerlink" title="monitorexit"></a>monitorexit</h4><p>首先我们来看一下JVM规范中对于monitorexit的描述： <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit</a></p>
<blockquote>
<p>The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref. The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero， the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.</p>
</blockquote>
<p>翻译过来：</p>
<p> 1.能执行monitorexit指令的线程一定是拥有当前对象的monitor的所有权的线程。</p>
<pre><code>2. 执行monitorexit时会将monitor的进入数减1。当monitor的进入数减为0时，当前线程退出 monitor，不再拥有monitor的所有权，此时其他被这个monitor阻塞的线程可以尝试去获取这个 monitor的所有权
</code></pre>
<p>monitorexit释放锁。<br>monitorexit插入在方法结束处和异常处，JVM保证每个monitorenter必须有对应的monitorexit。  </p>
<p> 面试题synchroznied出现异常会释放锁吗?<br>会释放锁</p>
<h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10</a> 可以看到同步方法在反汇编后，会增加 ACC_SYNCHRONIZED 修饰。会隐式调用monitorenter和 monitorexit。在执行同步方法前会调用monitorenter，在执行完同步方法后会调用monitorexit。</p>
<h4 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h4><p>通过javap反汇编我们看到synchronized使用编程了monitorentor和monitorexit两个指令.每个锁对象 都会关联一个monitor(监视器,它才是真正的锁对象),它内部有两个重要的成员变量owner会保存获得锁 的线程,recursions会保存线程获得锁的次数,当执行到monitorexit时,recursions会-1,当计数器减到0时 这个线程就会释放锁</p>
<h4 id="面试题：synchronized与Lock的区别"><a href="#面试题：synchronized与Lock的区别" class="headerlink" title="面试题：synchronized与Lock的区别"></a>面试题：synchronized与Lock的区别</h4><ol>
<li>synchronized是关键字，而Lock是一个接口。</li>
<li>synchronized会自动释放锁，而Lock必须手动释放锁。</li>
<li>synchronized是不可中断的，Lock可以中断也可以不中断。</li>
<li>通过Lock可以知道线程有没有拿到锁，而synchronized不能。</li>
<li>synchronized能锁住方法和代码块，而Lock只能锁住代码块。</li>
<li>Lock可以使用读锁提高多线程读效率。</li>
<li>synchronized是非公平锁，ReentrantLock可以控制是否是公平锁。</li>
</ol>
<h3 id="深入JVM源码"><a href="#深入JVM源码" class="headerlink" title="深入JVM源码"></a>深入JVM源码</h3><h4 id><a href="#" class="headerlink" title></a></h4><p>通过JVM源码分析synchronized的原理   </p>
<h4 id="JVM源码下载"><a href="#JVM源码下载" class="headerlink" title="JVM源码下载"></a>JVM源码下载</h4><p><a href="http://openjdk.java.net/">http://openjdk.java.net/</a> –&gt; Mercurial –&gt; jdk8 –&gt; hotspot –&gt; zip </p>
<h4 id="IDE-Clion-下载"><a href="#IDE-Clion-下载" class="headerlink" title="IDE(Clion )下载"></a>IDE(Clion )下载</h4><p><a href="https://www.jetbrains.com/">https://www.jetbrains.com/</a></p>
<h4 id="monitor监视器锁"><a href="#monitor监视器锁" class="headerlink" title="monitor监视器锁"></a>monitor监视器锁</h4><p>可以看出无论是synchronized代码块还是synchronized方法，其线程安全的语义实现终依赖一个叫 monitor的东西，那么这个神秘的东西是什么呢？下面让我们来详细介绍一下。  </p>
<p>在HotSpot虚拟机中，monitor是由ObjectMonitor实现的。其源码是用c++来实现的，位于HotSpot虚 拟机源码ObjectMonitor.hpp文件中(src&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;objectMonitor.hpp)。ObjectMonitor主 要数据结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ObjectMonitor</span>() &#123;    </span><br><span class="line">	_header       = <span class="literal">NULL</span>;    </span><br><span class="line">	_count        = <span class="number">0</span>;   </span><br><span class="line">    _waiters      = <span class="number">0</span>，    </span><br><span class="line">    _recursions   = <span class="number">0</span>;  <span class="comment">// 线程的重入次数</span></span><br><span class="line">    _object       = <span class="literal">NULL</span>; <span class="comment">// 存储该monitor的对象    </span></span><br><span class="line">    _owner        = <span class="literal">NULL</span>; <span class="comment">// 标识拥有该monitor的线程    </span></span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>; <span class="comment">// 处于wait状态的线程，会被加入到_WaitSet    </span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;    </span><br><span class="line">    _Responsible  = <span class="literal">NULL</span>;    </span><br><span class="line">    _succ         = <span class="literal">NULL</span>;    </span><br><span class="line">    _cxq          = <span class="literal">NULL</span>; <span class="comment">// 多线程竞争锁时的单向列表    </span></span><br><span class="line">    FreeNext      = <span class="literal">NULL</span>;    </span><br><span class="line">    _EntryList    = <span class="literal">NULL</span>; <span class="comment">// 处于等待锁block状态的线程，会被加入到该列表   </span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span>;   </span><br><span class="line">    _SpinClock    = <span class="number">0</span>;    </span><br><span class="line">    OwnerIsThread = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>_owner：初始时为NULL。当有线程占有该monitor时，owner标记为该线程的唯一标识。当线程 释放monitor时，owner又恢复为NULL。owner是一个临界资源，JVM是通过CAS操作来保证其线 程安全的。</li>
<li>_ _cxq：竞争队列，所有请求锁的线程首先会被放在这个队列中（单向链接）。_cxq是一个临界资源，JVM通过CAS原子指令来修改_cxq队列。修改前_cxq的旧值填入了node的next字段，_cxq指 向新值（新线程）。因此_cxq是一个后进先出的stack（栈）。 </li>
<li>_EntryList：_cxq队列中有资格成为候选资源的线程会被移动到该队列中。 </li>
<li>_WaitSet：因为调用wait方法而被阻塞的线程会被放在该队列中。</li>
</ol>
<p>每一个Java对象都可以与一个监视器monitor关联，我们可以把它理解成为一把锁，当一个线程想要执 行一段被synchronized圈起来的同步方法或者代码块时，该线程得先获取到synchronized修饰的对象 对应的monitor。 我们的Java代码里不会显示地去创造这么一个monitor对象，我们也无需创建，事实上可以这么理解： monitor并不是随着对象创建而创建的。我们是通过synchronized修饰符告诉JVM需要为我们的某个对 象创建关联的monitor对象。每个线程都存在两个ObjectMonitor对象列表，分别为free和used列表。 同时JVM中也维护着global locklist。当线程需要ObjectMonitor对象时，首先从线程自身的free表中申请，若存在则使用，若不存在则从global list中申请。<br>  ObjectMonitor的数据结构中包含：_owner、_WaitSet和_EntryList，它们之间的关系转换可以用下图 表示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411150935274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210411150935225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>对象头保存对应的montor对象，其中_recursions会记录线程的重入次数，进入+1，离开-1，</p>
<p>_object会存储这个synchronized锁的实例对象，</p>
<p>_owner就保存抢到锁进来的线程，</p>
<p>_WaitSet是当有线程获取锁后调用obj.wait()方法，那么当前线程就会进入WaitSet队列，</p>
<p>_cxq是单向链表（指的是如果已经有t1线程获取到monitor对象拿到锁后_，t2和t3没有竞争到，t2、t3线程会进行到cxq队列，先自己尝试竞争锁，如果竞争不到则自旋再去挣扎一下获取锁，当t1执行完同步代码块，释放锁后，由t1、t2、t3再去争抢锁，如果t1再次抢到锁，那么t2、t3会进行到EntryList阻塞队列，如果此时又有t4、t5线程过来会被放到cxq队列，t2,t3,t4,t5，通过自旋尝试获取锁，如果还是没有获取到锁，则通过park将当 前线程挂起，等待被唤醒。如果t1被释放， 根据不同的策略（由QMode指定），从cxq或EntryList中获取头节点，通过 ObjectMonitor::ExitEpilog 方法唤醒该节点封装的线程，唤醒操作终由unpark完成，被唤醒的线程，继续执行monitor 的竞争。</p>
<p>当获取锁的线程释放后，EntryList中的线程和WaitSet中的线程被唤醒都可能去获取锁变成owner的拥有者。）</p>
<h4 id="monitor竞争"><a href="#monitor竞争" class="headerlink" title="monitor竞争"></a>monitor竞争</h4><ol>
<li>执行monitorenter时，会调用InterpreterRuntime.cpp (位于：src&#x2F;share&#x2F;vm&#x2F;interpreter&#x2F;interpreterRuntime.cpp) 的 InterpreterRuntime::monitorenter函 数。具体代码可参见HotSpot源码。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210411151015318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>   2.对于重量级锁，monitorenter函数中会调用 ObjectSynchronizer::slow_enter<br>   3.终调用 ObjectMonitor::enter（位于：src&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;objectMonitor.cpp），源码如下：<br><img src="https://img-blog.csdnimg.cn/20210411151041252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411151041274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411151041201.png#pic_center" alt="在这里插入图片描述"></p>
<p>   此处省略锁的自旋优化等操作，统一放在后面synchronzied优化中说。<br>   以上代码的具体流程概括如下：</p>
<pre><code>  1. 通过CAS尝试把monitor的owner字段设置为当前线程。 
  2. 如果设置之前的owner指向当前线程，说明当前线程再次进入monitor，即重入锁，执行 recursions ++ ，记录重入的次数。 
  3. 如果当前线程是第一次进入该monitor，设置recursions为1，_owner为当前线程，该线程成功获 得锁并返回。 
  4. 如果获取锁失败，则等待锁的释放。
</code></pre>
<h4 id="monitor等待"><a href="#monitor等待" class="headerlink" title="monitor等待"></a>monitor等待</h4><p>竞争失败等待调用的是ObjectMonitor对象的EnterI方法（位于： src&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;objectMonitor.cpp），源码如下所示：<br><img src="https://img-blog.csdnimg.cn/20210411151309797.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210411151309889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210411151309920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411151309823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>当该线程被唤醒时，会从挂起的点继续执行，通过 ObjectMonitor::TryLock 尝试获取锁，TryLock方 法实现如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411151507713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>以上代码的具体流程概括如下：</p>
<ol>
<li>当前线程被封装成ObjectWaiter对象node，状态设置成ObjectWaiter::TS_CXQ。 </li>
<li>在for循环中，通过CAS把node节点push到_cxq列表中，同一时刻可能有多个线程把自己的node 节点push到_cxq列表中。 </li>
<li>node节点push到_cxq列表之后，通过自旋尝试获取锁，如果还是没有获取到锁，则通过park将当 前线程挂起，等待被唤醒。 </li>
<li>当该线程被唤醒时，会从挂起的点继续执行，通过 ObjectMonitor::TryLock 尝试获取锁。</li>
</ol>
<h4 id="monitor释放"><a href="#monitor释放" class="headerlink" title="monitor释放"></a>monitor释放</h4><p>当某个持有锁的线程执行完同步代码块时，会进行锁的释放，给其它线程机会执行同步代码，在 HotSpot中，通过退出monitor的方式实现锁的释放，并通知被阻塞的线程，具体实现位于 ObjectMonitor的exit方法中。（位于：src&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;objectMonitor.cpp），源码如下所 示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411151522706.png#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411151536882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411151548250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411151600992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210411151613139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411151623814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ol>
<li>退出同步代码块时会让_recursions减1，当_recursions的值减为0时，说明线程释放了锁。 </li>
<li>根据不同的策略（由QMode指定），从cxq或EntryList中获取头节点，通过 ObjectMonitor::ExitEpilog 方法唤醒该节点封装的线程，唤醒操作终由unpark完成，实现 如下：</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210411151637957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>被唤醒的线程，会回到 void ATTR ObjectMonitor::EnterI (TRAPS) 的第600行，继续执行monitor 的竞争。<br><img src="https://img-blog.csdnimg.cn/20210411151650828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="monitor是重量级锁"><a href="#monitor是重量级锁" class="headerlink" title="monitor是重量级锁"></a>monitor是重量级锁</h4><p>可以看到ObjectMonitor的函数调用中会涉及到Atomic::cmpxchg_ptr，Atomic::inc_ptr等内核函数， 执行同步代码块，没有竞争到锁的对象会park()被挂起，竞争到锁的线程会unpark()唤醒。这个时候就 会存在操作系统用户态和内核态的转换，这种切换会消耗大量的系统资源。所以synchronized是Java语 言中是一个重量级(Heavyweight)的操作。 用户态和和内核态是什么东西呢？要想了解用户态和内核态还需要先了解一下Linux系统的体系架构：<br><img src="https://img-blog.csdnimg.cn/20210411151703407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>从上图可以看出，Linux操作系统的体系架构分为：用户空间（应用程序的活动空间）和内核。<br>内核：本质上可以理解为一种软件，控制计算机的硬件资源，并提供上层应用程序运行的环境。<br>用户空间：上层应用程序活动的空间。应用程序的执行必须依托于内核提供的资源，包括CPU资源、存 储资源、I&#x2F;O资源等。<br>系统调用：为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口：即系统调用。</p>
<p>所有进程初始都运行于用户空间，此时即为用户运行状态（简称：用户态）；但是当它调用系统调用执 行某些操作时，例如 I&#x2F;O调用，此时需要陷入内核中运行，我们就称进程处于内核运行态（或简称为内 核态）。 系统调用的过程可以简单理解为： </p>
<ol>
<li>用户态程序将一些数据值放在寄存器中， 或者使用参数创建一个堆栈， 以此表明需要操作系统提供的服务。 </li>
<li>用户态程序执行系统调用。 </li>
<li>CPU切换到内核态，并跳到位于内存指定位置的指令。 </li>
<li>系统调用处理器(system call handler)会读取程序放入内存的数据参数，并执行程序请求的服务。 </li>
<li>系统调用完成后，操作系统会重置CPU为用户态并返回系统调用的结果。<br>由此可见用户态切换至内核态需要传递许多变量，同时内核还需要保护好用户态在切换时的一些寄存器值、变量等，以备内核态切换回用户态。这种切换就带来了大量的系统资源消耗，这就是在 synchronized未优化之前，效率低的原因。</li>
</ol>
<h2 id="第六章：JDK6-synchronized优化"><a href="#第六章：JDK6-synchronized优化" class="headerlink" title="第六章：JDK6 synchronized优化"></a>第六章：JDK6 synchronized优化</h2><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><h4 id="目标-9"><a href="#目标-9" class="headerlink" title="目标"></a>目标</h4><p>学习CAS的作用 学习CAS的原理 </p>
<h4 id="CAS概述和作用"><a href="#CAS概述和作用" class="headerlink" title="CAS概述和作用"></a>CAS概述和作用</h4><p>CAS的全称是： Compare And Swap(比较相同再交换)。是现代CPU广泛支持的一种对内存中的共享数 据进行操作的一种特殊指令。<br>CAS的作用：CAS可以将比较和交换转换为原子操作，这个原子操作直接由CPU保证。CAS可以保证共 享变量赋值时的原子操作。CAS操作依赖3个值：内存中的值V，旧的预估值X，要修改的新值B，如果旧 的预估值X等于内存中的值V，就将新的值B保存到内存中。</p>
<h4 id="CAS和volatile实现无锁并发"><a href="#CAS和volatile实现无锁并发" class="headerlink" title="CAS和volatile实现无锁并发"></a>CAS和volatile实现无锁并发</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    目标:演示原子性问题</span></span><br><span class="line"><span class="comment">        1.定义一个共享变量number</span></span><br><span class="line"><span class="comment">        2.对number进行1000的++操作</span></span><br><span class="line"><span class="comment">        3.使用5个线程来进行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="comment">// 1.定义一个共享变量number</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 2.对number进行1000的++操作</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">increment</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                atomicInteger.incrementAndGet(); <span class="comment">// 变量赋值的原子性</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        List&lt;Thread&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 3.使用5个线程来进行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(increment);</span><br><span class="line">            t.start();</span><br><span class="line">            list.add(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread t : list) &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;atomicInteger = &quot;</span> + atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h4><p>通过刚才AtomicInteger的源码我们可以看到，Unsafe类提供了原子操作。 </p>
<h4 id="Unsafe类介绍"><a href="#Unsafe类介绍" class="headerlink" title="Unsafe类介绍"></a>Unsafe类介绍</h4><p>Unsafe类使Java拥有了像C语言的指针一样操作内存空间的能力，同时也带来了指针的问题。过度的使 用Unsafe类会使得出错的几率变大，因此Java官方并不建议使用的，官方文档也几乎没有。Unsafe对 象不能直接调用，只能通过反射获得。</p>
<p><img src="https://img-blog.csdnimg.cn/20210411151724567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="Unsafe实现CAS"><a href="#Unsafe实现CAS" class="headerlink" title="Unsafe实现CAS"></a>Unsafe实现CAS</h4><p><img src="https://img-blog.csdnimg.cn/2021041115173973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h4><p><strong>悲观锁</strong>从悲观的角度出发：<br>总是假设坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这 样别人想拿这个数据就会阻塞。因此synchronized我们也将其称之为悲观锁。JDK中的ReentrantLock 也是一种悲观锁。性能较差！<br><strong>乐观锁</strong>从乐观的角度出发:<br>总是假设好的情况，每次去拿数据的时候都认为别人不会修改，就算改了也没关系，再重试即可。所 以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去修改这个数据，如何没有人修改则更 新，如果有人修改则重试。<br>CAS这种机制我们也可以将其称之为乐观锁。综合性能较好！  </p>
<blockquote>
<p>CAS获取共享变量时，为了保证该变量的可见性，需要使用volatile修饰。结合CAS和volatile可以 实现无锁并发，适用于竞争不激烈、多核 CPU 的场景下。 1. 因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一。 2. 但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响。</p>
</blockquote>
<h4 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h4><p>CAS的作用? Compare And Swap，CAS可以将比较和交换转换为原子操作，这个原子操作直接由处理 器保证。<br>CAS的原理？CAS需要3个值:内存地址V，旧的预期值A，要修改的新值B，如果内存地址V和旧的预期值 A相等就修改内存地址值为B </p>
<h3 id="synchronized锁升级过程"><a href="#synchronized锁升级过程" class="headerlink" title="synchronized锁升级过程"></a>synchronized锁升级过程</h3><p>高效并发是从JDK 5到JDK 6的一个重要改进，HotSpot虛拟机开发团队在这个版本上花费了大量的精力 去实现各种锁优化技术，包括偏向锁( Biased Locking )、轻量级锁( Lightweight Locking )和如适应性 自旋(Adaptive Spinning)、锁消除( Lock Elimination)、锁粗化( Lock Coarsening )等，这些技术都是为 了在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">无锁--》偏向锁--》轻量级锁–》重量级锁</span><br></pre></td></tr></table></figure>



<h3 id="Java对象的布局"><a href="#Java对象的布局" class="headerlink" title="Java对象的布局"></a>Java对象的布局</h3><h4 id="目标-10"><a href="#目标-10" class="headerlink" title="目标"></a>目标</h4><p>学习Java对象的布局<br>术语参考: <a href="http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html">http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html</a> 在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411151752779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p>当一个线程尝试访问synchronized修饰的代码块时，它首先要获得锁，那么这个锁到底存在哪里呢？是 存在锁对象的对象头中的。<br>HotSpot采用instanceOopDesc和arrayOopDesc来描述对象头，arrayOopDesc对象用来描述数组类型。instanceOopDesc的定义的在Hotspot源码的 instanceOop.hpp 文件中，另外，arrayOopDesc 的定义对应 arrayOop.hpp 。</p>
<p><img src="https://img-blog.csdnimg.cn/20210411151803946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>从instanceOopDesc代码中可以看到 instanceOopDesc继承自oopDesc，oopDesc的定义载Hotspot 源码中的 oop.hpp 文件中。<br><img src="https://img-blog.csdnimg.cn/20210411151814950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411151825586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>在普通实例对象中，oopDesc的定义包含两个成员，分别是 _mark 和 _metadata</p>
<p>_mark 表示对象标记、属于markOop类型，也就是接下来要讲解的Mark World，它记录了对象和锁有关的信息</p>
<p>_metadata 表示类元信息，类元信息存储的是对象指向它的类元数据(Klass)的首地址，其中Klass表示 普通指针、 _compressed_klass 表示压缩类指针。</p>
<p>对象头由两部分组成，一部分用于存储自身的运行时数据，称之为 Mark Word，另外一部分是类型指 针，及对象指向它的类元数据的指针。</p>
<h5 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h5><p>Mark Word用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、 线程持有的锁、偏向线程ID、偏向时间戳等等，占用内存大小与虚拟机位长一致。Mark Word对应的类 型是 markOop 。源码位于 markOop.hpp 中。</p>
<p><img src="https://img-blog.csdnimg.cn/20210411151838118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411151847972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411151901531.png#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411151920218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>在64位虚拟机下，Mark Word是64bit大小的，其存储结构如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411151936532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>在32位虚拟机下，Mark Word是32bit大小的，其存储结构如下：</p>
<p><img src="https://img-blog.csdnimg.cn/2021041115195084.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="klass-pointer"><a href="#klass-pointer" class="headerlink" title="klass pointer"></a>klass pointer</h5><p>这一部分用于存储对象的类型指针，该指针指向它的类元数据，JVM通过这个指针确定对象是哪个类的 实例。该指针的位长度为JVM的一个字大小，即32位的JVM为32位，64位的JVM为64位。 如果应用的对 象过多，使用64位的指针将浪费大量内存，统计而言，64位的JVM将会比32位的JVM多耗费50%的内 存。为了节约内存可以使用选项**-XX:+UseCompressedOops** 开启指针压缩，其中，oop即ordinary object pointer普通对象指针。开启该选项后，下列指针将压缩至32位： </p>
<ol>
<li>每个Class的属性指针（即静态变量）</li>
<li>每个对象的属性指针（即对象变量） </li>
<li>普通对象数组的每个元素指针</li>
</ol>
<p>当然，也不是所有的指针都会压缩，一些特殊类型的指针JVM不会优化，比如指向PermGen的Class对 象指针(JDK8中指向元空间的Class对象指针)、本地变量、堆栈元素、入参、返回值和NULL指针等。   对象头 &#x3D; Mark Word + 类型指针（未开启指针压缩的情况下）<br>在32位系统中，Mark Word &#x3D; 4 bytes，类型指针 &#x3D; 4bytes，对象头 &#x3D; 8 bytes &#x3D; 64 bits；<br>在64位系统中，Mark Word &#x3D; 8 bytes，类型指针 &#x3D; 8bytes，对象头 &#x3D; 16 bytes &#x3D; 128bits；</p>
<h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><p>就是类中定义的成员变量。</p>
<h4 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h4><p>对齐填充并不是必然存在的，也没有什么特别的意义，他仅仅起着占位符的作用，由于HotSpot VM的 自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是<strong>8字节的 整数倍</strong>。而对象头正好是8字节的倍数，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充 来补全。</p>
<h4 id="查看Java对象布局"><a href="#查看Java对象布局" class="headerlink" title="查看Java对象布局"></a>查看Java对象布局</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;    </span><br><span class="line">	&lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;    </span><br><span class="line">	&lt;artifactId&gt;jol-core&lt;/artifactId&gt;    </span><br><span class="line">	&lt;version&gt;<span class="number">0.9</span>&lt;/version&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>示例：以64bit虚拟机为例展示（默认开启指针压缩）</p>
<p><img src="https://img-blog.csdnimg.cn/20210411152007784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>-XX:-UseCompressedOops</strong>关闭指针压缩</p>
<p><img src="https://img-blog.csdnimg.cn/20210411152018673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h4><p><strong>Java对象由3部分组成，对象头，实例数据，对齐数据</strong><br><strong>对象头分成两部分：Mark World + Klass pointer</strong> </p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><h4 id="目标-11"><a href="#目标-11" class="headerlink" title="目标"></a>目标</h4><p>学习偏向锁的原理和好处</p>
<h4 id="什么是偏向锁"><a href="#什么是偏向锁" class="headerlink" title="什么是偏向锁"></a>什么是偏向锁</h4><p>偏向锁是JDK 6中的重要引进，因为HotSpot作者经过研究实践发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低，引进了偏向锁。<br>偏向锁的“偏”，就是偏心的“偏”、偏袒的“偏”，它的意思是这个锁会偏向于第一个获得它的线程，会在对 象头存储锁偏向的线程ID，以后该线程进入和退出同步块时只需要检查是否为偏向锁、锁标志位以及 ThreadID即可。</p>
<p><img src="https://img-blog.csdnimg.cn/20210411152031158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>不过一旦出现多个线程竞争时必须撤销偏向锁，所以撤销偏向锁消耗的性能必须小于之前节省下来的 CAS原子操作的性能消耗，不然就得不偿失了。</p>
<h4 id="偏向锁原理"><a href="#偏向锁原理" class="headerlink" title="偏向锁原理"></a>偏向锁原理</h4><p>当线程第一次访问同步块并获取锁时，偏向锁处理流程如下：</p>
<blockquote>
<p>1.虚拟机将会把对象头中的标志位设为“01”，即偏向模式。</p>
<p>2.同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中 ，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作，偏向锁的效率高。</p>
</blockquote>
<h4 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h4><ol>
<li>暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态 </li>
<li>偏向锁的撤销动作必须等待全局安全点 </li>
<li><strong>撤销偏向锁，恢复到无锁（标志位为 01）或轻量级锁（标志位为 00）的状态</strong></li>
</ol>
<p>偏向锁在Java 6之后是默认启用的，但在应用程序启动几秒钟之后才激活，可以使用-XX:BiasedLockingStartupDelay&#x3D;0 参数关闭延迟，如果确定应用程序中所有锁通常情况下处于竞争 状态，可以通过 XX:-UseBiasedLocking&#x3D;false 参数关闭偏向锁。</p>
<h4 id="偏向锁好处"><a href="#偏向锁好处" class="headerlink" title="偏向锁好处"></a>偏向锁好处</h4><p>偏向锁是在只有一个线程执行同步块时进一步提高性能，适用于一个线程反复获得同一锁的情况。偏向 锁可以提高带有同步但无竞争的程序性能。<br>它同样是一个带有效益权衡性质的优化，也就是说，它并不一定总是对程序运行有利，如果程序中大多 数的锁总是被多个不同的线程访问比如线程池，那偏向模式就是多余的。</p>
<p>在JDK5中偏向锁默认是关闭的，而到了JDK6中偏向锁已经默认开启。但在应用程序启动几秒钟之后才 激活，可以使用-XX:BiasedLockingStartupDelay&#x3D;0 参数关闭延迟，如果确定应用程序中所有锁通常 情况下处于竞争状态，可以通过 XX:-UseBiasedLocking&#x3D;false 参数关闭偏向锁。 </p>
<h4 id="偏向锁的升级"><a href="#偏向锁的升级" class="headerlink" title="偏向锁的升级"></a>偏向锁的升级</h4><p>当线程1访问代码块并获取锁对象时，会在java对象头和栈帧中记录偏向的锁的threadID，因为<strong>偏向锁不会主动释放锁</strong>，因此以后线程1再次获取锁的时候，需要<strong>比较当前线程的threadID和Java对象头中的threadID是否一致</strong>，如果一致（还是线程1获取锁对象），则无需使用CAS来加锁、解锁；如果不一致（其他线程，如线程2要竞争锁对象，而偏向锁不会主动释放因此还是存储的线程1的threadID），那么需要<strong>查看Java对象头中记录的线程1是否存活</strong>，如果没有存活，那么锁对象被重置为无锁状态，其它线程（线程2）可以竞争将其设置为偏向锁；如果存活，那么立刻<strong>查找该线程（线程1）的栈帧信息，如果还是需要继续持有这个锁对象</strong>，那么暂停当前线程1，撤销偏向锁，然后线程1升级为轻量级锁，如果线程1 不再使用该锁对象，那么将锁对象状态设为无锁状态，重新偏向新的线程。</p>
<h4 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h4><p>偏向锁的原理是什么?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“<span class="number">01</span>”，即偏向模式。同时使用CAS操 作把获取到这个锁的线程的ID记录在对象的Mark Word之中 ，如果CAS操作成功，持有偏向锁的线程以后每 次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作，偏向锁的效率高。</span><br></pre></td></tr></table></figure>

<p>偏向锁的好处是什么?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">偏向锁是在只有一个线程执行同步块时进一步提高性能，适用于一个线程反复获得同一锁的情况。偏向锁可以 提高带有同步但无竞争的程序性能。</span><br></pre></td></tr></table></figure>





<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><h4 id="目标-12"><a href="#目标-12" class="headerlink" title="目标"></a>目标</h4><p>学习轻量级锁的原理和好处</p>
<h4 id="什么是轻量级锁"><a href="#什么是轻量级锁" class="headerlink" title="什么是轻量级锁"></a>什么是轻量级锁</h4><p>轻量级锁是JDK 6之中加入的新型锁机制，它名字中的“轻量级”是相对于使用monitor的传统锁而言的， 因此传统的锁机制就称为“重量级”锁。首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的。<br>引入轻量级锁的目的：在多线程交替执行同步块的情况下，尽量避免重量级锁引起的性能消耗，但是如 果多个线程在同一时刻进入临界区，会导致轻量级锁膨胀升级重量级锁，所以轻量级锁的出现并非是要 替代重量级锁。 </p>
<h4 id="轻量级锁原理"><a href="#轻量级锁原理" class="headerlink" title="轻量级锁原理"></a>轻量级锁原理</h4><p>当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁，其步 骤如下： <strong>获取锁</strong><br>当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式。同时使用CAS操 作把获取到这个锁的线程的ID记录在对象的Mark Word之中 ，如果CAS操作成功，持有偏向锁的线程以后每 次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作，偏向锁的效率高。<br>偏向锁是在只有一个线程执行同步块时进一步提高性能，适用于一个线程反复获得同一锁的情况。偏向锁可以 提高带有同步但无竞争的程序性能。</p>
<ol>
<li>判断当前对象是否处于无锁状态（hashcode、0、01），如果是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方 把这份拷贝加了一个Displaced前缀，即Displaced Mark Word），将对象的Mark Word复制到栈 帧中的Lock Record中，将Lock Reocrd中的owner指向当前对象。 </li>
<li>JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，如果成功表示竞争到锁，则将锁标志位变成00，执行同步操作。 </li>
<li>如果失败则判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持 有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210411152043810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411152056960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411152108466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="轻量级锁什么时候升级为重量级锁？"><a href="#轻量级锁什么时候升级为重量级锁？" class="headerlink" title="轻量级锁什么时候升级为重量级锁？"></a>轻量级锁什么时候升级为重量级锁？</h4><p>线程1获取轻量级锁时会先把锁对象的<strong>对象头MarkWord复制一份到线程1的栈帧中创建的用于存储锁记录的空间</strong>（称为DisplacedMarkWord），然后<strong>使用CAS把对象头中的内容替换为线程1存储的锁记录（</strong>DisplacedMarkWord<strong>）的地址</strong>；</p>
<p>如果在线程1复制对象头的同时（在线程1CAS之前），线程2也准备获取锁，复制了对象头到线程2的锁记录空间中，但是在线程2CAS的时候，发现线程1已经把对象头换了，<strong>线程2的CAS失败，那么线程2就尝试使用自旋锁来等待线程1释放锁</strong>。</p>
<p>但是如果自旋的时间太长也不行，因为自旋是要消耗CPU的，因此自旋的次数是有限制的，比如10次或者100次，如果<strong>自旋次数到了线程1还没有释放锁，或者线程1还在执行，线程2还在自旋等待，这时又有一个线程3过来竞争这个锁对象，那么这个时候轻量级锁就会膨胀为重量级锁。重量级锁把除了拥有锁的线程都阻塞，防止CPU空转。</strong></p>
<p><strong>注意</strong>：为了避免无用的自旋，轻量级锁一旦膨胀为重量级锁就不会再降级为轻量级锁了；偏向锁升级为轻量级锁也不能再降级为偏向锁。一句话就是锁可以升级不可以降级，但是偏向锁状态可以被重置为无锁状态。</p>
<p>写的方法进入栈中执行，一个进入栈中的方法就是栈帧。</p>
<h4 id="轻量级锁的释放"><a href="#轻量级锁的释放" class="headerlink" title="轻量级锁的释放"></a>轻量级锁的释放</h4><p>轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下：</p>
<ol>
<li>取出在获取轻量级锁保存在Displaced Mark Word中的数据。 </li>
<li>用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功。</li>
<li>如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要将轻量级锁需要膨胀升级为重量级 锁。</li>
</ol>
<p>对于轻量级锁，其性能提升的依据是“对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”，如 果打破这个依据则除了互斥的开销外，还有额外的CAS操作，因此在有多线程竞争的情况下，轻量级锁 比重量级锁更慢。</p>
<h4 id="轻量级锁好处"><a href="#轻量级锁好处" class="headerlink" title="轻量级锁好处"></a>轻量级锁好处</h4><p>在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。 小结 </p>
<h4 id="轻量级锁的原理是什么？"><a href="#轻量级锁的原理是什么？" class="headerlink" title="轻量级锁的原理是什么？"></a>轻量级锁的原理是什么？</h4><p>将对象的Mark Word复制到栈帧中的Lock Recod中。Mark Word更新为指向Lock Record的指针。<br>轻量级锁好处是什么？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗</span><br></pre></td></tr></table></figure>



<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><h4 id="目标-13"><a href="#目标-13" class="headerlink" title="目标"></a>目标</h4><p>学习自旋锁原理</p>
<h4 id="自旋锁原理"><a href="#自旋锁原理" class="headerlink" title="自旋锁原理"></a>自旋锁原理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (Demo01.class) &#123;  </span><br><span class="line">    ...    </span><br><span class="line">	System.out.println(<span class="string">&quot;aaa&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面我们讨论monitor实现锁的时候，知道monitor会阻塞和唤醒线程，线程的阻塞和唤醒需要CPU从 用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，这些操作给系统的并发性能 带来了很大的压力。同时，虚拟机的开发团队也注意到在许多应用上，共享数据的锁定状态只会持续很 短的一段时间，为了这段时间阻塞和唤醒线程并不值得。如果物理机器有一个以上的处理器，能让两个 或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行 时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环(自 旋) , 这项技术就是所谓的自旋锁。  </p>
<p>自旋锁在JDK 1.4.2中就已经引入 ，只不过默认是关闭的，可以使用-XX:+UseSpinning参数来开启，在 JDK 6中 就已经改为默认开启了。自旋等待不能代替阻塞，且先不说对处理器数量的要求，自旋等待本 身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果锁被占用的时间很短，自旋等 待的效果就会非常好，反之，如果锁被占用的时间很长。那么自旋的线程只会白白消耗处理器资源，而 不会做任何有用的工作，反而会带来性 能上的浪费。因此，自旋等待的时间必须要有一定的限度，如果在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。自旋次数的默认值 是10次，用户可以使用参数-XX : PreBlockSpin来更改。 </p>
<h4 id="适应性自旋锁"><a href="#适应性自旋锁" class="headerlink" title="适应性自旋锁"></a>适应性自旋锁</h4><p>在JDK 6中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上 的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持 有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持 续相对更长的时间，比如100次循环。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取 这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行和性能监控 信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确，虛拟机就会变得越来越“聪明”了。 </p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><h4 id="目标-14"><a href="#目标-14" class="headerlink" title="目标"></a>目标</h4><p>学习如何进行锁消除</p>
<p> 锁消除是指虚拟机即时编译器（JIT）在运行时，对一些代码上要求同步，但是被检测到不可能存在共享 数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码中， 堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们 是线程私有的，同步加锁自然就无须进行。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确 定，但是程序员自己应该是很清楚的，怎么会在明知道不存在数据争用的情况下要求同步呢?实际上有 许多同步措施并不是程序员自己加入的，同步的代码在Java程序中的普遍程度也许超过了大部分读者的 想象。下面这段非常简单的代码仅仅是输出3个字符串相加的结果，无论是源码字面上还是程序语义上 都没有同步。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        contactString(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">contactString</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>().append(s1).append(s2).append(s3).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StringBuﬀer的append ( ) 是一个同步方法，锁就是this也就是(new StringBuilder())。虚拟机发现它的 动态作用域被限制在concatString( )方法内部。也就是说, new StringBuilder()对象的引用永远不会“逃 逸”到concatString ( )方法之外，其他线程无法访问到它，因此，虽然这里有锁，但是可以被安全地消除 掉，在即时编译之后，这段代码就会忽略掉所有的同步而直接执行了。 </p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><h4 id="目标-15"><a href="#目标-15" class="headerlink" title="目标"></a>目标</h4><p>学习锁粗化的原理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// synchronized (Demo01.class) &#123;</span></span><br><span class="line">        <span class="comment">//     System.out.println(&quot;aaa&quot;);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，只在共享数据的实际作 用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线 程也能尽快拿到锁。大部分情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对 象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操 作也会导致不必要的性能损耗。</p>
<h4 id="小结-11"><a href="#小结-11" class="headerlink" title="小结"></a>小结</h4><p>什么是锁粗化？</p>
<p>JVM会探测到一连串细小的操作都使用同一个对象加锁，将同步代码块的范围放大，放到这串操作的外面，这样只需要加一次锁即可。</p>
<h3 id="平时写代码如何对synchronized优化"><a href="#平时写代码如何对synchronized优化" class="headerlink" title="平时写代码如何对synchronized优化"></a>平时写代码如何对synchronized优化</h3><h4 id="减少synchronized的范围"><a href="#减少synchronized的范围" class="headerlink" title="减少synchronized的范围"></a>减少synchronized的范围</h4><p>同步代码块中尽量短，减少同步代码块中代码的执行时间，减少锁的竞争。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (Demo01.class) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="降低synchronized锁的粒度"><a href="#降低synchronized锁的粒度" class="headerlink" title="降低synchronized锁的粒度"></a>降低synchronized锁的粒度</h4><p>将一个锁拆分为多个锁提高并发度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Hashtable</span> <span class="variable">hs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">    hs.put(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>);</span><br><span class="line">    hs.put(<span class="string">&quot;xx&quot;</span>, <span class="string">&quot;yy&quot;</span>);</span><br><span class="line">    hs.get(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    hs.remove(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210411152126270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411152140792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411152153408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><p>读取时不加锁，写入和删除时加锁<br>ConcurrentHashMap，CopyOnWriteArrayList和ConyOnWriteSet</p>
<h2 id="Lock接口的使用"><a href="#Lock接口的使用" class="headerlink" title="Lock接口的使用"></a>Lock接口的使用</h2><p>既然有了synchronized，为啥还要提供Lock接口呢？也许你会说Lock接口比synchronized性能高。在jdk1.5之前确实如此，但是在jdk1.6之后，两者性能差不多了。直接来看Lock接口的定义，看看比synchronized多了哪些功能？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 能够响应中断</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="comment">// 非阻塞获取锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 非阻塞超时获取锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 定义阻塞条件</span></span><br><span class="line">    Condition <span class="title function_">newCondition</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到Lock接口相比synchronized多了很多特性，详细解释一下方法</p>
<ol>
<li>lock()方法，用来获取锁，如果锁被其他线程获得则进行等待，需要和unlock方法配合主动释放锁。发生异常时，不会主动释放锁，所以释放锁的操作放在finally块中</li>
<li>lockInterruptibly()方法，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程</li>
<li>tryLock()方法，用来尝试获取锁，如果获取成功，则返回true。如果获取失败则返回false。也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待</li>
<li>tryLock(long time, TimeUnit unit)方法，和tryLock()类似。只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果一开始拿到锁或者在等待期间内拿到了锁，则返回true</li>
<li>unlock()方法，解锁</li>
<li>newCondition()方法，定义条件</li>
</ol>
<p>其余的应该都很好理解，演示一下lockInterruptibly()和newCondition()方法</p>
<p><strong>lockInterruptibly()方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">myLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">// 先获取一次锁，让后续获取锁的操作阻塞</span></span><br><span class="line">myLock.lock();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// myLock.lock();</span></span><br><span class="line">        myLock.lockInterruptibly();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 当使用myLock.lockInterruptibly()时</span></span><br><span class="line">        <span class="comment">// 会抛出java.lang.InterruptedException，打印over</span></span><br><span class="line">        <span class="comment">// 使用myLock.lock()，一直阻塞获取锁，不会打印over</span></span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">thread.interrupt();</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p><strong>Condition的使用</strong></p>
<p>synchronized与wait()和nitofy()&#x2F;notifyAll()方法相结合可以实现等待&#x2F;通知模型，ReentrantLock同样可以，但是需要借助Condition，且Condition有更好的灵活性，具体体现在</p>
<ol>
<li>一个Lock里面可以创建多个Condition实例，实现多路通知</li>
<li>notify()方法进行通知时，被通知的线程时Java虚拟机随机选择的，但是ReentrantLock结合Condition可以实现有选择性地通知</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotify</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">conditionA</span>  <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">conditionB</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">waitThreadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">WaitA</span>(), <span class="string">&quot;WaitThreadA&quot;</span>);</span><br><span class="line">        waitThreadA.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">waitThreadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">WaitB</span>(), <span class="string">&quot;WaitThreadB&quot;</span>);</span><br><span class="line">        waitThreadB.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conditionA.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WaitA</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot; begin await @ &quot;</span></span><br><span class="line">                        + <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">                conditionA.await();</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot; end await @ &quot;</span></span><br><span class="line">                        + <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WaitB</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot; begin await @ &quot;</span></span><br><span class="line">                        + <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">                conditionB.await();</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot; end await @ &quot;</span></span><br><span class="line">                        + <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Thread[WaitThreadA,<span class="number">5</span>,main] begin await @ <span class="number">00</span>:<span class="number">49</span>:<span class="number">57</span></span><br><span class="line">Thread[WaitThreadB,<span class="number">5</span>,main] begin await @ <span class="number">00</span>:<span class="number">49</span>:<span class="number">57</span></span><br><span class="line">Thread[WaitThreadA,<span class="number">5</span>,main] end await @ <span class="number">00</span>:<span class="number">49</span>:<span class="number">59</span></span><br></pre></td></tr></table></figure>

<p>WaitThreadB因为没有被通知，一直阻塞</p>
<p><strong>最后总结一波，synchronized和ReentrantLock的异同</strong></p>
<ol>
<li>ReentrantLock支持非阻塞的方式获取锁，能够响应中断，而synchronized不行</li>
<li>ReentrantLock必须手动获取和释放锁，而synchronized不需要</li>
<li>ReentrantLock可以是公平锁或者非公平锁，而synchronized只能是非公平锁</li>
<li>synchronized在发生异常的时候，会自动释放线程占有的锁，而ReentrantLock在发生异常时，如果没有通过unlock去释放锁，很有可能造成死锁，因此需要在finally块中释放锁</li>
<li>synchronized和ReentrantLock都是可重入锁</li>
</ol>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>在开始本篇文章的内容讲述前，先来回答我一个问题，为什么 JDK 提供一个 <code>synchronized</code> 关键字之后还要提供一个 Lock 锁，这不是多此一举吗？难道 JDK 设计人员都是沙雕吗？</p>
<p>我听过一句话非常的经典，也是我认为是每个人都应该了解的一句话：<code>你以为的并不是你以为的</code>。明白什么意思么？不明白的话，加我微信我告诉你。</p>
<h2 id="初识-ReentrantLock"><a href="#初识-ReentrantLock" class="headerlink" title="初识 ReentrantLock"></a>初识 ReentrantLock</h2><p>ReentrantLock 位于 <code>java.util.concurrent.locks</code> 包下，它实现了 <code>Lock</code> 接口和 <code>Serializable</code> 接口。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/34d61e26fb506eb7ec6e3017b0ef0cbc.png" alt="img"></p>
<p>ReentrantLock 是一把<code>可重入锁</code>和<code>互斥锁</code>，它具有与 synchronized 关键字相同的含有隐式监视器锁（monitor）的基本行为和语义，但是它比 synchronized 具有更多的方法和功能。</p>
<h2 id="ReentrantLock-基本方法"><a href="#ReentrantLock-基本方法" class="headerlink" title="ReentrantLock 基本方法"></a>ReentrantLock 基本方法</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>ReentrantLock 类中带有两个构造函数，一个是默认的构造函数，不带任何参数；一个是带有 fair 参数的构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">  sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">  sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个构造函数也是判断 ReentrantLock 是否是公平锁的条件，如果 fair 为 true，则会创建一个<code>公平锁</code>的实现，也就是 <code>new FairSync()</code>，如果 fair 为 false，则会创建一个 <code>非公平锁</code>的实现，也就是 <code>new NonfairSync()</code>，默认的情况下创建的是非公平锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建的是公平锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建的是非公平锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认创建非公平锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br></pre></td></tr></table></figure>

<p>FairSync 和 NonfairSync 都是 ReentrantLock 的内部类，继承于 <code>Sync</code> 类，下面来看一下它们的继承结构，便于梳理。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/973efa8f64b3b48f1b725891730bc90c.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;...&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>在多线程尝试加锁时，如果是公平锁，那么<strong>锁获取的机会是相同的</strong>。否则，如果是非公平锁，那么 ReentrantLock 则<strong>不会保证每个锁的访问顺序</strong>。</p>
<p>下面是一个<code>公平锁</code>的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFairLock</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fairLock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()  + <span class="string">&quot;正在持有锁&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()  + <span class="string">&quot;释放了锁&quot;</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyFairLock</span> <span class="variable">myFairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyFairLock</span>();</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;启动&quot;</span>);</span><br><span class="line">            myFairLock.fairLock();</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread[] thread = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">            thread[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">            thread[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不信？不信你输出试试啊！懒得输出？就知道你懒得输出，所以直接告诉你结论吧，结论就是<code>自己试</code>。</p>
<p>试完了吗？试完了我是不会让你休息的，过来再试一下非公平锁的测试和结论，知道怎么试吗？上面不是讲过要给 ReentrantLock 传递一个参数的吗？你想，传 true 的时候是公平锁，那么反过来不就是非公平锁了？其他代码还用改吗？不需要了啊。</p>
<p>明白了吧，再来测试一下非公平锁的流程，看看是不是你想要的结果。</p>
<h3 id="公平锁的加锁（lock）流程详解"><a href="#公平锁的加锁（lock）流程详解" class="headerlink" title="公平锁的加锁（lock）流程详解"></a>公平锁的加锁（lock）流程详解</h3><p>通常情况下，使用多线程访问公平锁的效率会<code>非常低</code>（通常情况下会慢很多），但是 ReentrantLock 会保证每个线程都会公平的持有锁，<code>线程饥饿的次数比较小</code>。锁的公平性并不能保证线程调度的公平性。</p>
<p>此时如果你想了解更多的话，那么我就从源码的角度跟你聊聊如何 ReentrantLock 是如何实现这两种锁的。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/3a31a563cfc1eb81b02c27464013f9b6.png" alt="img"></p>
<p>如上图所示，公平锁的加锁流程要比非公平锁的加锁流程简单，下面要聊一下具体的流程了，请小伙伴们备好板凳。</p>
<p>下面先看一张流程图，这张图是 acquire 方法的三条主要流程</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/08983b9c3ad0f3964d3e97bb5a350365.png" alt="img"></p>
<p><strong>首先是第一条路线</strong>，tryAcquire 方法，顾名思义尝试获取，也就是说可以成功获取锁，也可以获取锁失败。</p>
<p>使用 <code>ctrl+左键</code> 点进去是调用 AQS 的方法，但是 ReentrantLock 实现了 AQS 接口，所以调用的是 ReentrantLock 的 tryAcquire 方法；</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/accd500e60338ce36de9c49d36d42ccc.png" alt="img"></p>
<p>首先会取得当前线程，然后去读取当前锁的同步状态，还记得锁的四种状态吗？分别是 <code>无锁、偏向锁、轻量级锁和重量级锁</code>，如果你不是很明白的话，请参考博主这篇文章（<a href="https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&mid=2247484919&idx=1&sn=b36b9b84ad50559210b6f21901a882b9&chksm=fc45f804cb327112bb4301191d8f3a464244ca7cb93da73f3b1d8ff28821d6ac32e2512d66e0&token=1671614453&lang=zh_CN&scene=21#wechat_redirect"><strong>不懂什么是锁？看看这篇你就明白了</strong></a>），如果判断同步状态是 0 的话，就证明是无锁的，参考下面这幅图( 1bit 表示的是是否偏向锁 )</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6cb08686f27c02343840eb23d107ce3c.png" alt="img"></p>
<p>如果是无锁（也就是没有加锁），说明是第一次上锁，首先会先判断一下队列中是否有比当前线程等待时间更长的线程（hasQueuedPredecessors）；然后通过 <code>CAS</code> 方法原子性的更新锁的状态，CAS 方法更新的要求涉及三个变量，<code>currentValue(当前线程的值)，expectedValue(期望更新的值)，updateValue(更新的值)</code>，它们的更新如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(currentValue == expectedValue)&#123;</span><br><span class="line">  currentValue = updateValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CAS 通过 C 底层机制保证原子性，这个你不需要考虑它。如果既没有排队的线程而且使用 CAS 方法成功的把 0 -&gt; 1 （偏向锁），那么当前线程就会获得偏向锁，记录获取锁的线程为当前线程。</p>
<p>然后我们看 <code>else if</code> 逻辑，如果读取的同步状态是1，说明已经线程获取到了锁，那么就先判断当前线程是不是获取锁的线程，如果是的话，记录一下获取锁的次数 + 1，也就是说，只有同步状态为 0 的时候是无锁状态。如果当前线程不是获取锁的线程，直接返回 false。</p>
<p>acquire 方法会先查看同步状态是否获取成功，如果成功则方法结束返回，也就是 <code>!tryAcquire == false</code> ，若失败则先调用 addWaiter 方法再调用 acquireQueued 方法</p>
<p><strong>然后看一下第二条路线 addWaiter</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/3c5402d5a446dfd0924000f9fa5da927.png" alt="img"></p>
<p>这里首先把当前线程和 Node 的节点类型进行封装，Node 节点的类型有两种，<code>EXCLUSIVE</code> 和 <code>SHARED</code> ，前者为独占模式，后者为共享模式，具体的区别我们会在 AQS 源码讨论，这里读者只需要知道即可。</p>
<p>首先会进行 tail 节点的判断，有没有尾节点，其实没有头节点也就相当于没有尾节点，如果有尾节点，就会原子性的将当前节点插入同步队列中，再执行 enq 入队操作，入队操作相当于原子性的把节点插入队列中。</p>
<p>如果当前同步队列尾节点为null，说明当前线程是第一个加入同步队列进行等待的线程。</p>
<p><strong>在看第三条路线 acquireQueued</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1b967e531e07ba246285bcc5cf0db7c9.png" alt="img"></p>
<p>主要会有两个分支判断，首先会进行无限循环中，循环中每次都会判断给定当前节点的先驱节点，如果没有先驱节点会直接抛出空指针异常，直到返回 true。</p>
<p>然后判断给定节点的先驱节点是不是头节点，并且当前节点能否获取独占式锁，如果是头节点并且成功获取独占锁后，队列头指针用指向当前节点，然后释放前驱节点。如果没有获取到独占锁，就会进入 <code>shouldParkAfterFailedAcquire</code> 和 <code>parkAndCheckInterrupt</code> 方法中，我们贴出这两个方法的源码</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9d48e24ab82805f7ae1174d10b398dc7.png" alt="img"></p>
<p><code>shouldParkAfterFailedAcquire</code> 方法主要逻辑是使用<code>compareAndSetWaitStatus(pred, ws, Node.SIGNAL)</code>使用CAS将节点状态由 INITIAL 设置成 SIGNAL，表示当前线程阻塞。当 compareAndSetWaitStatus 设置失败则说明 shouldParkAfterFailedAcquire 方法返回 false，然后会在 acquireQueued 方法中死循环中会继续重试，直至compareAndSetWaitStatus 设置节点状态位为 SIGNAL 时 shouldParkAfterFailedAcquire 返回 true 时才会执行方法 parkAndCheckInterrupt 方法。（这块在后面研究 AQS 会细讲）</p>
<p><code>parkAndCheckInterrupt</code> 该方法的关键是会调用 LookSupport.park 方法（关于LookSupport会在以后的文章进行讨论），该方法是用来阻塞当前线程。</p>
<p>所以 acquireQueued 主要做了两件事情：如果当前节点的前驱节点是头节点，并且能够获取独占锁，那么当前线程能够获得锁该方法执行结束退出</p>
<p>如果获取锁失败的话，先将节点状态设置成 SIGNAL，然后调用 <code>LookSupport.park</code> 方法使得当前线程阻塞。</p>
<p>如果 <code>!tryAcquire</code> 和 <code>acquireQueued</code> 都为 true 的话，则打断当前线程。</p>
<p>那么它们的主要流程如下（注：只是加锁流程，并不是 lock 所有流程）</p>
<p><img src="https://img-blog.csdnimg.cn/20210411152305164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="非公平锁的加锁（lock）流程详解"><a href="#非公平锁的加锁（lock）流程详解" class="headerlink" title="非公平锁的加锁（lock）流程详解"></a>非公平锁的加锁（lock）流程详解</h3><p>非公平锁的加锁步骤和公平锁的步骤只有两处不同，一处是非公平锁在加锁前会直接使用 CAS 操作设置同步状态，如果设置成功，就会把当前线程设置为偏向锁的线程；一处是 CAS 操作失败执行 <code>tryAcquire</code> 方法，读取线程同步状态，如果未加锁会使用 CAS 再次进行加锁，不会等待 <code>hasQueuedPredecessors</code> 方法的执行，达到只要线程释放锁就会加锁的目的。下面通过源码和流程图来详细理解</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/94f03269a093d2f750711ad6870843e3.png" alt="img"></p>
<p>这是非公平锁和公平锁不同的两处地方，下面是非公平锁的加锁流程图</p>
<p><img src="https://img-blog.csdnimg.cn/20210411152332290.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="lockInterruptibly-以可中断的方式获取锁"><a href="#lockInterruptibly-以可中断的方式获取锁" class="headerlink" title="lockInterruptibly 以可中断的方式获取锁"></a>lockInterruptibly 以可中断的方式获取锁</h3><p>以下是 JavaDoc 官方解释：</p>
<p>lockInterruptibly 的中文意思为如果没有被打断，则获取锁。如果没有其他线程持有该锁，则获取该锁并立即返回，将锁保持计数设置为1。如果当前线程已经持有锁，那么此方法会立刻返回并且持有锁的数量会 + 1。如果锁是由另一个线程持有的，则出于线程调度目的，当前线程将被禁用，并处于休眠状态，直到发生以下两种情况之一</p>
<ul>
<li>锁被当前线程持有</li>
<li>一些其他线程打断了当前线程</li>
</ul>
<p>如果当前线程获取了锁，则锁保持计数将设置为1。</p>
<p>如果当前线程发生了如下情况：</p>
<ul>
<li>在进入此方法时设置了其中断状态</li>
<li>当获取锁的时候发生了中断（Thread.interrupt）</li>
</ul>
<p>那么当前线程就会抛出<code>InterruptedException</code> 并且当前线程的中断状态会清除。</p>
<p><strong>下面看一下它的源码是怎么写的</strong><br><img src="https://img-blog.csdnimg.cn/20210411152518440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>首先会调用 <code>acquireInterruptibly</code> 这个方法，判断当前线程是否被中断，如果中断抛出异常，没有中断则判断<code>公平锁/非公平锁</code> 是否已经获取锁，如果没有获取锁（tryAcquire 返回 false）则调用 <code>doAcquireInterruptibly</code> 方法，这个方法和 acquireQueued 方法没什么区别，就是线程在等待状态的过程中，如果线程被中断，线程会抛出异常。</p>
<p>下面是它的流程图<br><img src="https://img-blog.csdnimg.cn/20210411152757856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="tryLock-尝试加锁"><a href="#tryLock-尝试加锁" class="headerlink" title="tryLock 尝试加锁"></a>tryLock 尝试加锁</h3><p>仅仅当其他线程没有获取这把锁的时候获取这把锁，tryLock 的源代码和非公平锁的加锁流程基本一致，它的源代码如下<br><img src="https://img-blog.csdnimg.cn/20210411152834600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>tryLock 超时获取锁</p>
<p><code>ReentrantLock</code>除了能以中断的方式去获取锁，还可以以超时等待的方式去获取锁，所谓超时等待就是线程如果在超时时间内没有获取到锁，那么就会返回<code>false</code>，而不是一直死循环获取。可以使用 tryLock 和 tryLock(timeout, unit)) 结合起来实现公平锁，像这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (lock.tryLock() || lock.tryLock(timeout, unit)) &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>如果超过了指定时间，则返回值为 false。如果时间小于或者等于零，则该方法根本不会等待。</p>
<p>它的源码如下</p>
<p><img src="https://img-blog.csdnimg.cn/20210411152857258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>首先需要了解一下 <code>TimeUnit</code> 工具类，TimeUnit 表示给定粒度单位的持续时间，并且提供了一些用于时分秒跨单位转换的方法，通过使用这些方法进行定时和延迟操作。</p>
<p><code>toNanos</code> 用于把 long 型表示的时间转换成为纳秒，然后判断线程是否被打断，如果没有打断，则以<code>公平锁/非公平锁</code> 的方式获取锁，如果能够获取返回true，获取失败则调用<code>doAcquireNanos</code>方法使用超时等待的方式获取锁。在超时等待获取锁的过程中，如果等待时间大于应等待时间，或者应等待时间设置不合理的话，返回 false。</p>
<p><img src="https://img-blog.csdnimg.cn/2021041115292296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>这里面以超时的方式获取锁也可以画一张流程图如下</p>
<p><img src="https://img-blog.csdnimg.cn/2021041115294225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="unlock-解锁流程"><a href="#unlock-解锁流程" class="headerlink" title="unlock 解锁流程"></a>unlock 解锁流程</h3><p><code>unlock</code> 和 <code>lock</code> 是一对情侣，它们分不开彼此，在调用 lock 后必须通过 unlock 进行解锁。如果当前线程持有锁，在调用 unlock 后，count 计数将减少。如果保持计数为0就会进行解锁。如果当前线程没有持有锁，在调用 unlock 会抛出 <code>IllegalMonitorStateException</code> 异常。下面是它的源码</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b328b41d5fd146139a0e5c3698588e6d.png" alt="img"></p>
<p>在有了上面阅读源码的经历后，相信你会很快明白这段代码的意思，锁的释放不会区分公平锁还是非公平锁，主要的判断逻辑就是 <code>tryRelease</code> 方法，<code>getState</code> 方法会取得同步锁的重入次数，如果是获取了偏向锁，那么可能会多次获取，state 的值会大于 1，这时候 c 的值 &gt; 0 ，返回 false，解锁失败。如果 state &#x3D; 1，那么 c &#x3D; 0，再判断当前线程是否是独占锁的线程，释放独占锁，返回 true，当 head 指向的头结点不为 null，并且该节点的状态值不为0的话才会执行 unparkSuccessor 方法，再进行锁的获取。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/baa75efc307bfb4d37e60e53195d4636.png" alt="img"></p>
<h2 id="ReentrantLock-其他方法"><a href="#ReentrantLock-其他方法" class="headerlink" title="ReentrantLock 其他方法"></a>ReentrantLock 其他方法</h2><h3 id="isHeldByCurrentThread-amp-getHoldCount"><a href="#isHeldByCurrentThread-amp-getHoldCount" class="headerlink" title="isHeldByCurrentThread &amp; getHoldCount"></a>isHeldByCurrentThread &amp; getHoldCount</h3><p>在多线程同时访问时，ReentrantLock 由<code>最后一次</code>成功锁定的线程拥有，当这把锁没有被其他线程拥有时，线程调用 <code>lock()</code> 方法会立刻返回并成功获取锁。如果当前线程已经拥有锁，这个方法会立刻返回。可以通过 <code>isHeldByCurrentThread</code> 和 <code>getHoldCount</code> 来进行检查。</p>
<p>首先来看 isHeldByCurrentThread 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHeldByCurrentThread</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据方法名可以略知一二，<code>是否被当前线程持有</code>，它用来询问锁是否被其他线程拥有，这个方法和 <code>Thread.holdsLock(Object)</code> 方法内置的监视器锁相同，而 Thread.holdsLock(Object) 是 <code>Thread</code> 类的静态方法，是一个 <code>native</code> 类，它表示的意思是如果当前线程在某个对象上持有 monitor lock(监视器锁) 就会返回 true。这个类没有实际作用，仅仅用来测试和调试所用。例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> lock.isHeldByCurrentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法也可以确保重入锁能够表现出<code>不可重入</code>的行为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> !lock.isHeldByCurrentThread();</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行业务代码</span></span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前线程持有锁则 lock.isHeldByCurrentThread() 返回 true，否则返回 false。</p>
<p>我们在了解它的用法后，看一下它内部是怎样实现的，它内部只是调用了一下  sync.isHeldExclusively()，<code>sync</code> 是 ReentrantLock 的一个<code>静态内部类</code>，基于 AQS 实现，而 AQS 它是一种抽象队列同步器，是许多并发实现类的基础，例如 <strong>ReentrantLock&#x2F;Semaphore&#x2F;CountDownLatch</strong>。sync.isHeldExclusively() 方法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法会在拥有锁之前先去读一下状态，如果当前线程是锁的拥有者，则不需要检查。</p>
<p><code>getHoldCount()</code>方法和<code>isHeldByCurrentThread</code> 都是用来检查线程是否持有锁的方法，不同之处在于 getHoldCount() 用来查询当前线程持有锁的数量，对于每个未通过解锁操作匹配的锁定操作，线程都会保持锁定状态，这个方法也通常用于调试和测试，例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> lock.getHoldCount() == <span class="number">0</span>;</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行业务代码</span></span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法会返回当前线程持有锁的次数，如果当前线程没有持有锁，则返回0。</p>
<h3 id="newCondition-创建-ConditionObject-对象"><a href="#newCondition-创建-ConditionObject-对象" class="headerlink" title="newCondition 创建 ConditionObject 对象"></a>newCondition 创建 ConditionObject 对象</h3><p>ReentrantLock 可以通过 <code>newCondition</code> 方法创建 ConditionObject 对象，而 ConditionObject 实现了 <code>Condition</code> 接口，关于 Condition 的用法我们后面再讲。</p>
<h3 id="isLocked-判断是否锁定"><a href="#isLocked-判断是否锁定" class="headerlink" title="isLocked 判断是否锁定"></a>isLocked 判断是否锁定</h3><p>查询是否有任意线程已经获取锁，这个方法用来监视系统状态，而不是用来同步控制，很简单，直接判断 <code>state</code> 是否等于0。</p>
<h3 id="isFair-判断是否是公平锁的实例"><a href="#isFair-判断是否是公平锁的实例" class="headerlink" title="isFair 判断是否是公平锁的实例"></a>isFair 判断是否是公平锁的实例</h3><p>这个方法也比较简单，直接使用 <code>instanceof</code> 判断是不是 <code>FairSync</code> 内部类的实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isFair</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> sync <span class="keyword">instanceof</span> FairSync;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getOwner-判断锁拥有者"><a href="#getOwner-判断锁拥有者" class="headerlink" title="getOwner 判断锁拥有者"></a>getOwner 判断锁拥有者</h3><p>判断同步状态是否为0，如果是0，则没有线程拥有锁，如果不是0，直接返回获取锁的线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Thread <span class="title function_">getOwner</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getState() == <span class="number">0</span> ? <span class="literal">null</span> : getExclusiveOwnerThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="hasQueuedThreads-是否有等待线程"><a href="#hasQueuedThreads-是否有等待线程" class="headerlink" title="hasQueuedThreads 是否有等待线程"></a>hasQueuedThreads 是否有等待线程</h3><p>判断是否有线程正在等待获取锁，如果头节点与尾节点不相等，说明有等待获取锁的线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedThreads</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> head != tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="isQueued-判断线程是否排队"><a href="#isQueued-判断线程是否排队" class="headerlink" title="isQueued 判断线程是否排队"></a>isQueued 判断线程是否排队</h3><p>判断给定的线程是否正在排队，如果正在排队，返回 true。这个方法会遍历队列，如果找到匹配的线程，返回true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isQueued</span><span class="params">(Thread thread)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (thread == <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> tail; p != <span class="literal">null</span>; p = p.prev)</span><br><span class="line">    <span class="keyword">if</span> (p.thread == thread)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getQueueLength-获取队列长度"><a href="#getQueueLength-获取队列长度" class="headerlink" title="getQueueLength 获取队列长度"></a>getQueueLength 获取队列长度</h3><p>此方法会返回一个队列长度的估计值，该值只是一个估计值，因为在此方法遍历内部数据结构时，线程数可能会动态变化。 此方法设计用于监视系统状态，而不用于同步控制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getQueueLength</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> tail; p != <span class="literal">null</span>; p = p.prev) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p.thread != <span class="literal">null</span>)</span><br><span class="line">      ++n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getQueuedThreads-获取排队线程"><a href="#getQueuedThreads-获取排队线程" class="headerlink" title="getQueuedThreads 获取排队线程"></a>getQueuedThreads 获取排队线程</h3><p>返回一个包含可能正在等待获取此锁的线程的集合。 因为实际的线程集在构造此结果时可能会动态更改，所以返回的集合只是一个大概的列表集合。 返回的集合的元素没有特定的顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Collection&lt;Thread&gt; <span class="title function_">getQueuedThreads</span><span class="params">()</span> &#123;</span><br><span class="line">  ArrayList&lt;Thread&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Thread&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> tail; p != <span class="literal">null</span>; p = p.prev) &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> p.thread;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">null</span>)</span><br><span class="line">      list.add(t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="回答上面那个问题"><a href="#回答上面那个问题" class="headerlink" title="回答上面那个问题"></a>回答上面那个问题</h2><p>那么你看完源码分析后，你能总结出 <code>synchronized</code> 和 <code>lock</code> 锁的实现 <code>ReentrantLock</code> 有什么异同吗？</p>
<p>Synchronzied 和 Lock 的主要区别如下：</p>
<ul>
<li><p><strong>存在层面</strong>：Syncronized 是Java 中的一个关键字，存在于 JVM 层面，Lock 是 Java 中的一个接口</p>
</li>
<li><p><strong>锁的释放条件</strong>：1. 获取锁的线程执行完同步代码后，自动释放；2. 线程发生异常时，JVM会让线程释放锁；Lock 必须在 finally 关键字中释放锁，不然容易造成线程死锁</p>
</li>
<li><p><strong>锁的获取</strong>: 在 Syncronized 中，假设线程 A 获得锁，B 线程等待。如果 A 发生阻塞，那么 B 会一直等待。在 Lock 中，会分情况而定，Lock 中有尝试获取锁的方法，如果尝试获取到锁，则不用一直等待</p>
</li>
<li><p><strong>锁的状态</strong>：Synchronized 无法判断锁的状态，Lock 则可以判断</p>
</li>
<li><p><strong>锁的类型</strong>：Synchronized 是可重入，不可中断，非公平锁；Lock 锁则是 可重入，可判断，可公平锁</p>
</li>
<li><p><strong>锁的性能</strong>：Synchronized 适用于少量同步的情况下，性能开销比较大。Lock 锁适用于大量同步阶段：</p>
<p>Lock 锁可以提高多个线程进行读的效率(使用 readWriteLock)</p>
</li>
<li><p>在竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态；</p>
</li>
<li><p>ReetrantLock 提供了多样化的同步，比如有时间限制的同步，可以被Interrupt的同步（synchronized的同步是不能Interrupt的）等</p>
</li>
<li><p><strong>Synchronized和实现Lock接口的都是悲观锁</strong></p>
</li>
</ul>
<h3 id="还有什么要说的吗"><a href="#还有什么要说的吗" class="headerlink" title="还有什么要说的吗"></a>还有什么要说的吗</h3><p>面试官可能还会问你 ReentrantLock 的加锁流程是怎样的，其实如果你能把源码给他讲出来的话，一定是高分。如果你记不住源码流程的话可以记住下面这个<strong>简化版的加锁流程</strong></p>
<ul>
<li><p>如果 lock 加锁设置成功，设置当前线程为独占锁的线程；</p>
</li>
<li><p>如果 lock 加锁设置失败，还会再尝试获取一次锁数量，</p>
<p>如果锁数量为0，再基于 CAS 尝试将 state（锁数量）从0设置为1一次，如果设置成功，设置当前线程为独占锁的线程；</p>
<p>如果锁数量不为0或者上边的尝试又失败了，查看当前线程是不是已经是独占锁的线程了，如果是，则将当前的锁数量+1；如果不是，则将该线程封装在一个Node内，并加入到等待队列中去。等待被其前一个线程节点唤醒。</p>
</li>
</ul>
<h1 id="3、创建线程的方式"><a href="#3、创建线程的方式" class="headerlink" title="3、创建线程的方式"></a>3、创建线程的方式</h1><h3 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1.继承Thread类"></a>1.继承Thread类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadDemo1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;通过extendsThread来创建线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadDemo1</span> <span class="variable">threadDemo1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadDemo1</span>();</span><br><span class="line">        threadDemo1.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-实现Runnable接口创建线程"><a href="#2-实现Runnable接口创建线程" class="headerlink" title="2.实现Runnable接口创建线程"></a>2.实现Runnable接口创建线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实现Runnable接口创建线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-通过实现Callable接口创建线程"><a href="#3-通过实现Callable接口创建线程" class="headerlink" title="3.通过实现Callable接口创建线程"></a>3.通过实现Callable接口创建线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过实现Callable接口创建线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread02</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">MyThread02</span> <span class="variable">myThread02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread02</span>();</span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(myThread02);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">        System.out.println(o);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="4-通过创建线程池的方法创建线程"><a href="#4-通过创建线程池的方法创建线程" class="headerlink" title="4.通过创建线程池的方法创建线程"></a>4.通过创建线程池的方法创建线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过创建线程池的方法创建线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor=(ThreadPoolExecutor)service;</span><br><span class="line">        threadPoolExecutor.execute(<span class="keyword">new</span> <span class="title class_">NumberThread</span>());</span><br><span class="line"><span class="comment">//       service.execute(new NumberThread());</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="4、线程间通信"><a href="#4、线程间通信" class="headerlink" title="4、线程间通信"></a>4、线程间通信</h1><h3 id="1运用notify和wait实现线程的通信"><a href="#1运用notify和wait实现线程的通信" class="headerlink" title="1运用notify和wait实现线程的通信"></a>1运用notify和wait实现线程的通信</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShareData</span><span class="comment">//资源类</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//初始值为零的一个变量</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span><br><span class="line">  &#123;</span><br><span class="line">     <span class="comment">//判断</span></span><br><span class="line">     <span class="keyword">while</span>(number!=<span class="number">0</span>) &#123;</span><br><span class="line">       <span class="built_in">this</span>.wait();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//干活</span></span><br><span class="line">     ++number;</span><br><span class="line">     System.out.println(Thread.currentThread().getName()+<span class="string">&quot; \t &quot;</span>+number);</span><br><span class="line">     <span class="comment">//通知</span></span><br><span class="line">     <span class="built_in">this</span>.notifyAll();;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span><br><span class="line">  &#123;</span><br><span class="line">     <span class="comment">//判断</span></span><br><span class="line">     <span class="keyword">while</span>(number!=<span class="number">1</span>) &#123;</span><br><span class="line">       <span class="built_in">this</span>.wait();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//干活</span></span><br><span class="line">     --number;</span><br><span class="line">     System.out.println(Thread.currentThread().getName()+<span class="string">&quot; \t &quot;</span>+number);</span><br><span class="line">     <span class="comment">//通知</span></span><br><span class="line">     <span class="built_in">this</span>.notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> *现在两个线程，</span></span><br><span class="line"><span class="comment"> * 可以操作初始值为零的一个变量，</span></span><br><span class="line"><span class="comment"> * 实现一个线程对该变量加1，一个线程对该变量减1，</span></span><br><span class="line"><span class="comment"> * 交替，来10轮。 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xialei</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * 笔记：Java里面如何进行工程级别的多线程编写</span></span><br><span class="line"><span class="comment"> * 1 多线程变成模板（套路）-----上</span></span><br><span class="line"><span class="comment"> *     1.1  线程    操作    资源类  </span></span><br><span class="line"><span class="comment"> *     1.2  高内聚  低耦合</span></span><br><span class="line"><span class="comment"> * 2 多线程变成模板（套路）-----下</span></span><br><span class="line"><span class="comment"> *     2.1  判断</span></span><br><span class="line"><span class="comment"> *     2.2  干活</span></span><br><span class="line"><span class="comment"> *     2.3  通知</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotifyWaitDemo</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">  &#123;</span><br><span class="line">     <span class="type">ShareData</span> <span class="variable">sd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShareData</span>();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            sd.increment();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            sd.decrement();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            sd.increment();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            sd.decrement();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">     </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="https://img-blog.csdnimg.cn/20210411153106416.png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="2Condition实现"><a href="#2Condition实现" class="headerlink" title="2Condition实现"></a>2Condition实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShareData</span><span class="comment">//资源类</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//初始值为零的一个变量</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span>  <span class="operator">=</span> lock.newCondition(); </span><br><span class="line">   </span><br><span class="line">  <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span><br><span class="line">  &#123;</span><br><span class="line">     </span><br><span class="line">      lock.lock();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//判断</span></span><br><span class="line">          <span class="keyword">while</span>(number!=<span class="number">0</span>) &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//干活</span></span><br><span class="line">          ++number;</span><br><span class="line">          System.out.println(Thread.currentThread().getName()+<span class="string">&quot; \t &quot;</span>+number);</span><br><span class="line">          <span class="comment">//通知</span></span><br><span class="line">          condition.signalAll();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span><br><span class="line">  &#123;</span><br><span class="line">      </span><br><span class="line">      lock.lock();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//判断</span></span><br><span class="line">          <span class="keyword">while</span>(number!=<span class="number">1</span>) &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//干活</span></span><br><span class="line">          --number;</span><br><span class="line">          System.out.println(Thread.currentThread().getName()+<span class="string">&quot; \t &quot;</span>+number);</span><br><span class="line">          <span class="comment">//通知</span></span><br><span class="line">          condition.signalAll();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotifyWaitDemo</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">  &#123;</span><br><span class="line">     <span class="type">ShareData</span> <span class="variable">sd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShareData</span>();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            sd.increment();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            sd.decrement();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            sd.increment();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            sd.decrement();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">     </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<h1 id="5、线程间定制化调用通信"><a href="#5、线程间定制化调用通信" class="headerlink" title="5、线程间定制化调用通信"></a>5、线程间定制化调用通信</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> JUCProject.Condition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * 多线程之间按顺序调用，实现A-&gt;B-&gt;C</span></span><br><span class="line"><span class="comment"> * 三个线程启动，要求如下：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * AA打印5次，BB打印10次，CC打印15次</span></span><br><span class="line"><span class="comment"> * 接着</span></span><br><span class="line"><span class="comment"> * AA打印5次，BB打印10次，CC打印15次</span></span><br><span class="line"><span class="comment"> * ......来10轮</span></span><br><span class="line"><span class="comment"> *1 多线程变成模板（套路）-----上</span></span><br><span class="line"><span class="comment"> *     1.1  线程    操作    资源类</span></span><br><span class="line"><span class="comment"> *     1.2  高内聚  低耦合</span></span><br><span class="line"><span class="comment"> * 2 多线程变成模板（套路）-----下</span></span><br><span class="line"><span class="comment"> *     2.1  判断</span></span><br><span class="line"><span class="comment"> *     2.2  干活</span></span><br><span class="line"><span class="comment"> *     2.3  通知</span></span><br><span class="line"><span class="comment">3 防止虚假唤醒用while</span></span><br><span class="line"><span class="comment">4.注意标志位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShareResource</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> Condition condition1=lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition2=lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition3=lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print5</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">1</span>)&#123;</span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&#x27;\t&#x27;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">            number=<span class="number">2</span>;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print10</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">2</span>)&#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&#x27;\t&#x27;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">            number=<span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print15</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">3</span>)&#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;=<span class="number">15</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&#x27;\t&#x27;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">            number=<span class="number">1</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadOrderAccess</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ShareResource</span> <span class="variable">shareResource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShareResource</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                shareResource.print5();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                shareResource.print10();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                shareResource.print15();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="6、NotSafeDemo"><a href="#6、NotSafeDemo" class="headerlink" title="6、NotSafeDemo"></a>6、NotSafeDemo</h1><h3 id="1证明集合不安全"><a href="#1证明集合不安全" class="headerlink" title="1证明集合不安全"></a>1证明集合不安全</h3><p>java.util.ConcurrentModificationException</p>
<p>ArrayList在迭代的时候如果同时对其进行修改就会抛出java.util.ConcurrentModificationException异常<br>并发修改异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">30</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">8</span>));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">看ArrayList的源码</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">没有<span class="keyword">synchronized</span>线程不安全</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2解决方案"><a href="#2解决方案" class="headerlink" title="2解决方案"></a>2解决方案</h3><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">看Vector的源码</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">有<span class="keyword">synchronized</span>线程安全</span><br></pre></td></tr></table></figure>



<h4 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br></pre></td></tr></table></figure>


<p>Collections提供了方法synchronizedList保证list是同步线程安全的</p>
<p>那HashMap，HashSet是线程安全的吗？也不是<br>所以有同样的线程安全方法</p>
<p><img src="https://img-blog.csdnimg.cn/20210411153120467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">   <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">   lock.lock();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       Object[] elements = getArray();</span><br><span class="line">       <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">       Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">       newElements[len] = e;</span><br><span class="line">       setArray(newElements);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">CopyOnWrite容器即写时复制的容器。往一个容器添加元素的时候，不直接往当前容器Object[]添加，</span><br><span class="line">而是先将当前容器Object[]进行Copy，复制出一个新的容器Object[] newElements，然后向新的容器Object[] newElements里添加元素。</span><br><span class="line">添加元素后，再将原容器的引用指向新的容器setArray(newElements)。</span><br><span class="line">这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。</span><br><span class="line">所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</span><br></pre></td></tr></table></figure>

<h1 id="7、多线程锁"><a href="#7、多线程锁" class="headerlink" title="7、多线程锁"></a>7、多线程锁</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* * 1 标准访问，先打印邮件还是短信</span></span><br><span class="line"><span class="comment">2 停4秒在邮件方法内，先打印邮件还是短信</span></span><br><span class="line"><span class="comment">3 普通的hello方法，是先打邮件还是hello</span></span><br><span class="line"><span class="comment">4 现在有两部手机，先打印邮件还是短信</span></span><br><span class="line"><span class="comment">5 两个静态同步方法，1部手机，先打印邮件还是短信</span></span><br><span class="line"><span class="comment">6 两个静态同步方法，2部手机，先打印邮件还是短信</span></span><br><span class="line"><span class="comment">7 1个静态同步方法，1个普通同步方法，1部手机，先打印邮件还是hello</span></span><br><span class="line"><span class="comment">8 1个静态同步方法，1个普通同步方法，2部手机，先打印邮件还是hello</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        1、邮件</span></span><br><span class="line"><span class="comment">        2、邮件</span></span><br><span class="line"><span class="comment">        3、Hello</span></span><br><span class="line"><span class="comment">        4、短信</span></span><br><span class="line"><span class="comment">        5、邮件</span></span><br><span class="line"><span class="comment">        6、邮件</span></span><br><span class="line"><span class="comment">        7、hello</span></span><br><span class="line"><span class="comment">        8、hello</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>   <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="comment">//发邮件</span></span><br><span class="line">       TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="comment">//发短信</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----------sendSMS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    phone01.sendEmail();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                phone02.hello();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="8锁分析"><a href="#8锁分析" class="headerlink" title="8锁分析"></a>8锁分析</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A 一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，</span><br><span class="line">其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized方法</span><br><span class="line">锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法</span><br><span class="line"></span><br><span class="line">加个普通方法后发现和同步锁无关</span><br><span class="line">换成两个对象后，不是同一把锁了，情况立刻变化。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">synchronized实现同步的基础：Java中的每一个对象都可以作为锁。</span><br><span class="line">具体表现为以下3种形式。</span><br><span class="line">对于普通同步方法，锁是当前实例对象。</span><br><span class="line">对于静态同步方法，锁是当前类的Class对象。</span><br><span class="line">对于同步方法块，锁是Synchonized括号里配置的对象</span><br><span class="line"></span><br><span class="line">当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</span><br><span class="line"></span><br><span class="line">也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，</span><br><span class="line">可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，</span><br><span class="line">所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。</span><br><span class="line"></span><br><span class="line">所有的静态同步方法用的也是同一把锁——类对象本身，</span><br><span class="line">这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。</span><br><span class="line">但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，</span><br><span class="line">而不管是同一个实例对象的静态同步方法之间，</span><br><span class="line">还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！</span><br></pre></td></tr></table></figure>

<h1 id="8、ReentrantReadWriteLock读写锁"><a href="#8、ReentrantReadWriteLock读写锁" class="headerlink" title="8、ReentrantReadWriteLock读写锁"></a>8、ReentrantReadWriteLock读写锁</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        rwLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 正在写&quot;</span> + key);</span><br><span class="line">            <span class="comment">//暂停一会儿线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 写完了&quot;</span> + key);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        rwLock.readLock().lock();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 正在读&quot;</span> + key);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            result = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 读完了&quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyCache</span> <span class="variable">myCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCache</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                myCache.put(num + <span class="string">&quot;&quot;</span>, num + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                myCache.get(num + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="9、BlockingQueueDemo阻塞队列"><a href="#9、BlockingQueueDemo阻塞队列" class="headerlink" title="9、BlockingQueueDemo阻塞队列"></a>9、BlockingQueueDemo阻塞队列</h1><h3 id="种类分析"><a href="#种类分析" class="headerlink" title="种类分析"></a>种类分析</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayBlockingQueue：由数组结构组成的有界阻塞队列。</span><br><span class="line"></span><br><span class="line">LinkedBlockingQueue：由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列。</span><br><span class="line"></span><br><span class="line">PriorityBlockingQueue：支持优先级排序的无界阻塞队列。</span><br><span class="line"></span><br><span class="line">DelayQueue：使用优先级队列实现的延迟无界阻塞队列。</span><br><span class="line"></span><br><span class="line">SynchronousQueue：不存储元素的阻塞队列，也即单个元素的队列。</span><br><span class="line"></span><br><span class="line">LinkedTransferQueue：由链表组成的无界阻塞队列。</span><br><span class="line"></span><br><span class="line">LinkedBlockingDeque：由链表组成的双向阻塞队列。</span><br></pre></td></tr></table></figure>



<h3 id="BlockingQueue核心方法"><a href="#BlockingQueue核心方法" class="headerlink" title="BlockingQueue核心方法"></a>BlockingQueue核心方法</h3><p><img src="https://img-blog.csdnimg.cn/20210411153139907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210411153139984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用reentrantLock实现</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> Condition condition=lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">product</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">0</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+number);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">1</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+number);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product_Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.product();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.consumer();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.product();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.consumer();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用blockingQueue实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductConsumerTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;String&gt; blockingQueue=<span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;String&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Product</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            blockingQueue.put(<span class="string">&quot;product..&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;produce..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Consumer</span><span class="params">()</span>&#123;</span><br><span class="line">        String product=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             product = blockingQueue.take();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ProductConsumerTest</span> <span class="variable">productConsumerTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProductConsumerTest</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                productConsumerTest.Product();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                productConsumerTest.Consumer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                productConsumerTest.Product();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="10、ThreadPool线程池"><a href="#10、ThreadPool线程池" class="headerlink" title="10、ThreadPool线程池"></a>10、ThreadPool线程池</h1><h3 id="1为什么用线程池"><a href="#1为什么用线程池" class="headerlink" title="1为什么用线程池"></a>1为什么用线程池</h3><p>线程池的优势：<br>线程池做的工作只要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。</p>
<p>它的主要特点为：线程复用;控制最大并发数;管理线程。</p>
<p>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的销耗。<br>第二：提高响应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行。<br>第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>
<h3 id="2程池如何使用"><a href="#2程池如何使用" class="headerlink" title="2程池如何使用"></a>2程池如何使用</h3><h4 id="架构说明"><a href="#架构说明" class="headerlink" title="架构说明"></a>架构说明</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java中的线程池是通过Executor框架实现的，该框架中用到了Executor，Executors，ExecutorService，ThreadPoolExecutor这几个类</span><br></pre></td></tr></table></figure>

<img src="/2022/10/24/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/Users/lileitang/Desktop/Java/Java并发编程/JUC/12.png" alt="1584760706315" style="zoom: 80%;">

<h4 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Executors.newFixedThreadPool(<span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>执行长期任务性能好，创建一个线程池，一池有N个固定的线程，有固定线程数的线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的是LinkedBlockingQueue</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Executors.newSingleThreadExecutor()</span><br></pre></td></tr></table></figure>

<p>一个任务一个任务的执行，一池一线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">newSingleThreadExecutor 创建的线程池corePoolSize和maximumPoolSize值都是<span class="number">1</span>，它使用的是LinkedBlockingQueue</span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Executors.newCachedThreadPool()</span><br></pre></td></tr></table></figure>

<p>执行很多短期异步任务，线程池根据需要创建新线程，但在先前构建的线程可用时将重用它们。可扩容，遇强则强</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line">newCachedThreadPool创建的线程池将corePoolSize设置为<span class="number">0</span>，将maximumPoolSize设置为Integer.MAX_VALUE，它使用的是SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过<span class="number">60</span>秒，就销毁线程。</span><br></pre></td></tr></table></figure>



<h3 id="3线程池几个重要参数"><a href="#3线程池几个重要参数" class="headerlink" title="3线程池几个重要参数"></a>3线程池几个重要参数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、corePoolSize：线程池中的常驻核心线程数</span><br><span class="line">2、maximumPoolSize：线程池中能够容纳同时执行的最大线程数，此值必须大于等于1</span><br><span class="line">3、keepAliveTime：多余的空闲线程的存活时间，当前池中线程数量超过corePoolSize时，当空闲时间达到	keepAliveTime时，多余线程会被销毁直到只剩下corePoolSize个线程为止</span><br><span class="line">4、unit：keepAliveTime的单位 </span><br><span class="line">5、workQueue：任务队列，被提交但尚未被执行的任务</span><br><span class="line">6、threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程，一般默认的即可</span><br><span class="line">7、handler：拒绝策略，表示当队列满了，并且工作线程大于等于线程池的最大线程数（maximumPoolSize）时如何来拒绝请求执行的runnable的策略</span><br></pre></td></tr></table></figure>



<h3 id="4线程池底层工作原理"><a href="#4线程池底层工作原理" class="headerlink" title="4线程池底层工作原理"></a>4线程池底层工作原理</h3><p><img src="https://img-blog.csdnimg.cn/2021041115321658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411153216108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、在创建了线程池后，开始等待请求。</span><br><span class="line">2、当调用execute()方法添加一个请求任务时，线程池会做出如下判断：</span><br><span class="line">  2.1如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务；</span><br><span class="line">  2.2如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列；</span><br><span class="line">  2.3如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</span><br><span class="line">  2.4如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。</span><br><span class="line">3、当一个线程完成任务时，它会从队列中取下一个任务来执行。</span><br><span class="line">4、当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：</span><br><span class="line">    如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。</span><br><span class="line">    所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小。</span><br></pre></td></tr></table></figure>



<h3 id="5线程池的拒绝策略"><a href="#5线程池的拒绝策略" class="headerlink" title="5线程池的拒绝策略"></a>5线程池的拒绝策略</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">等待队列已经排满了，再也塞不下新任务了，同时，线程池中的max线程也达到了，无法继续为新任务服务。</span><br><span class="line"></span><br><span class="line">这个是时候我们就需要拒绝策略机制合理的处理这个问题。</span><br></pre></td></tr></table></figure>

<h4 id="JDK内置的拒绝策略"><a href="#JDK内置的拒绝策略" class="headerlink" title="JDK内置的拒绝策略"></a>JDK内置的拒绝策略</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AbortPolicy(默认)：直接抛出RejectedExecutionException异常阻止系统正常运行</span><br><span class="line">CallerRunsPolicy：“调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。</span><br><span class="line">DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加人队列中尝试再次提交当前任务。</span><br><span class="line">DiscardPolicy：该策略默默地丢弃无法处理的任务，不予任何处理也不抛出异常。如果允许任务丢失，这是最好的一种策略。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上内置拒绝策略均实现了RejectedExecutionHandle接口</p>
<h3 id="6自定义线程池"><a href="#6自定义线程池" class="headerlink" title="6自定义线程池"></a>6自定义线程池</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadPoolDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());<span class="comment">//</span></span><br><span class="line"><span class="comment">//        ExecutorService threadPool= Executors.newFixedThreadPool(5);//一池5个处理线程</span></span><br><span class="line"><span class="comment">//        ExecutorService threadPool = Executors.newSingleThreadExecutor();//一池1个线程</span></span><br><span class="line"><span class="comment">//       ExecutorService threadPool = Executors.newCachedThreadPool();//一池n个线程</span></span><br><span class="line">        ExecutorService threadPool= <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>,<span class="number">7</span>,<span class="number">2</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">3</span>),Executors.defaultThreadFactory(), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardOldestPolicy()</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟有10 个顾客来银行办理业务，目前池子里有五个工作人员提供服务</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">200</span>; i++) &#123;</span><br><span class="line">                threadPool.execute(()-&gt;&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 办理业务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="11、Java8之流式计算"><a href="#11、Java8之流式计算" class="headerlink" title="11、Java8之流式计算"></a>11、Java8之流式计算</h1><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><h4 id="java内置核心四大函数式接口"><a href="#java内置核心四大函数式接口" class="headerlink" title="java内置核心四大函数式接口"></a>java内置核心四大函数式接口</h4><p><img src="https://img-blog.csdnimg.cn/20210411153238445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//R apply(T t);函数型接口，一个参数，一个返回值</span></span><br><span class="line">Function&lt;String,Integer&gt; function = t -&gt;&#123;<span class="keyword">return</span> t.length();&#125;;</span><br><span class="line">System.out.println(function.apply(<span class="string">&quot;abcd&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//boolean test(T t);断定型接口，一个参数，返回boolean</span></span><br><span class="line">Predicate&lt;String&gt; predicate = t-&gt;&#123;<span class="keyword">return</span> t.startsWith(<span class="string">&quot;a&quot;</span>);&#125;;</span><br><span class="line">System.out.println(predicate.test(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// void accept(T t);消费型接口，一个参数，没有返回值</span></span><br><span class="line">Consumer&lt;String&gt; consumer = t-&gt;&#123;</span><br><span class="line">    System.out.println(t);</span><br><span class="line">&#125;;</span><br><span class="line">consumer.accept(<span class="string">&quot;javaXXXX&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//T get(); 供给型接口，无参数，有返回值</span></span><br><span class="line">Supplier&lt;String&gt; supplier =()-&gt;&#123;<span class="keyword">return</span> UUID.randomUUID().toString();&#125;;</span><br><span class="line">System.out.println(supplier.get());</span><br></pre></td></tr></table></figure>



<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stream 自己不会存储元素</span><br><span class="line"></span><br><span class="line">Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</span><br><span class="line"></span><br><span class="line">Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</span><br></pre></td></tr></table></figure>



<h3 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建一个Stream：一个数据源（数组、集合）</span><br><span class="line"></span><br><span class="line">中间操作：一个中间操作，处理数据源数据</span><br><span class="line"></span><br><span class="line">终止操作：一个终止操作，执行中间操作链，产生结果</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String  userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>     age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-02-26 22:24</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 题目：请按照给出数据，找出同时满足</span></span><br><span class="line"><span class="comment"> *      偶数ID且年龄大于24且用户名转为大写且用户名字母倒排序</span></span><br><span class="line"><span class="comment"> *      最后只输出一个用户名字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">11</span>,<span class="string">&quot;a&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">12</span>,<span class="string">&quot;b&quot;</span>,<span class="number">24</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">u3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">13</span>,<span class="string">&quot;c&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">u4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">14</span>,<span class="string">&quot;d&quot;</span>,<span class="number">28</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">u5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">16</span>,<span class="string">&quot;e&quot;</span>,<span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; list = Arrays.asList(u1,u2,u3,u4,u5);</span><br><span class="line"></span><br><span class="line">        list.stream().filter(p -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> p.getId() % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">        &#125;).filter(p -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> p.getAge() &gt; <span class="number">24</span>;</span><br><span class="line">        &#125;).map(f -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> f.getUserName().toUpperCase();</span><br><span class="line">        &#125;).sorted((o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">        &#125;).limit(<span class="number">1</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//    R apply(T t);</span></span><br><span class="line">        Function&lt;String,Integer&gt; function = t -&gt; &#123;<span class="keyword">return</span> t.length();&#125;;</span><br><span class="line">        System.out.println(function.apply(<span class="string">&quot;abc&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// boolean test(T t);</span></span><br><span class="line">        Predicate&lt;String&gt; predicate = t -&gt; &#123;<span class="keyword">return</span> t.startsWith(<span class="string">&quot;a&quot;</span>);&#125;;</span><br><span class="line">        System.out.println(predicate.test(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//void accept(T t);</span></span><br><span class="line">        Consumer&lt;String&gt; consumer = t -&gt; &#123;System.out.println(t);&#125;;</span><br><span class="line">        consumer.accept(<span class="string">&quot;java1018&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//    T get();</span></span><br><span class="line">        Supplier&lt;String&gt; supplier =  () -&gt; &#123;<span class="keyword">return</span> UUID.randomUUID().toString();&#125;;</span><br><span class="line">        System.out.println(supplier.get());;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="12、分支合并框架"><a href="#12、分支合并框架" class="headerlink" title="12、分支合并框架"></a>12、分支合并框架</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Fork：把一个复杂任务进行分拆，大事化小<br>Join：把分拆任务的结果进行合并<br><img src="https://img-blog.csdnimg.cn/20210411153253495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210411153253637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">ADJUST_VALUE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> begin;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> end;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.begin = begin;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>((end - begin)&lt;=ADJUST_VALUE)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>begin;i &lt;= end;i++)&#123;</span><br><span class="line">                result = result + i;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (begin + end)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">MyTask</span> <span class="variable">task01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(begin,middle);</span><br><span class="line">            <span class="type">MyTask</span> <span class="variable">task02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(middle+<span class="number">1</span>,end);</span><br><span class="line">            task01.fork();</span><br><span class="line">            task02.fork();</span><br><span class="line">            result =  task01.join() + task02.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分支合并例子</span></span><br><span class="line"><span class="comment"> * ForkJoinPool</span></span><br><span class="line"><span class="comment"> * ForkJoinTask</span></span><br><span class="line"><span class="comment"> * RecursiveTask</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">MyTask</span> <span class="variable">myTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        ForkJoinTask&lt;Integer&gt; forkJoinTask = forkJoinPool.submit(myTask);</span><br><span class="line"></span><br><span class="line">        System.out.println(forkJoinTask.get());</span><br><span class="line"></span><br><span class="line">        forkJoinPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="13、异步回调"><a href="#13、异步回调" class="headerlink" title="13、异步回调"></a>13、异步回调</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;没有返回,update mysql ok&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        completableFuture.get();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integerCompletableFuture</span> <span class="operator">=</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;有返回,insert mysql ok&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">        &#125;).whenComplete((t,u)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;****t:&quot;</span>+t);</span><br><span class="line">            System.out.println(<span class="string">&quot;****u:&quot;</span>+u);</span><br><span class="line">        &#125;).exceptionally(f-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;****exception:&quot;</span>+f.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">44444</span>;</span><br><span class="line">        &#125;).get();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="14、谈谈你对volatile的理解"><a href="#14、谈谈你对volatile的理解" class="headerlink" title="14、谈谈你对volatile的理解"></a>14、谈谈你对volatile的理解</h1><h3 id="1-volatile是Java虚拟机提供的轻量级的同步机制"><a href="#1-volatile是Java虚拟机提供的轻量级的同步机制" class="headerlink" title="1.volatile是Java虚拟机提供的轻量级的同步机制"></a>1.volatile是Java虚拟机提供的轻量级的同步机制</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.1保证可见性</span><br><span class="line">1.2不保证原子性</span><br><span class="line">1.3禁止指令重排</span><br></pre></td></tr></table></figure>

<h3 id="2-JMM你谈谈"><a href="#2-JMM你谈谈" class="headerlink" title="2.JMM你谈谈"></a>2.JMM你谈谈</h3><p>JMM(Java内存模型Java Memory Model,简称JMM)本身是一种抽象的概念 并不真实存在,它描述的是一组规则或规范通过规范定制了程序中各个变量(包括实例字段,静态字段和构成数组对象的元素)的访问方式.<br>JMM关于同步规定:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.线程解锁前,必须把共享变量的值刷新回主内存</span><br><span class="line">2.线程加锁前,必须读取主内存的最新值到自己的工作内存</span><br><span class="line">3.加锁解锁是同一把锁</span><br></pre></td></tr></table></figure>

<p>由于JVM运行程序的实体是线程,而每个线程创建时JVM都会为其创建一个工作内存(有些地方成为栈空间),工作内存是每个线程的私有数据区域,而Java内存模型中规定所有变量都存储在主内存,主内存是共享内存区域,所有线程都可访问,但线程对变量的操作(读取赋值等)必须在工作内存中进行,首先要将变量从主内存拷贝到自己的工作空间,然后对变量进行操作,操作完成再将变量写回主内存,不能直接操作主内存中的变量,各个线程中的工作内存储存着主内存中的变量副本拷贝,因此不同的线程无法访问对方的工作内存,此案成间的通讯(传值) 必须通过主内存来完成,其简要访问过程如下图:</p>
<p><img src="https://img-blog.csdnimg.cn/20210411153317652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="2-1可见性"><a href="#2-1可见性" class="headerlink" title="2.1可见性"></a>2.1可见性</h4><p>通过前面对JMM的介绍,我们知道各个线程对主内存中共享变量的操作都是各个线程各自拷贝到自己的工作内存操作后再写回主内存中的.这就可能存在一个线程AAA修改了共享变量X的值还未写回主内存中时 ,另外一个线程BBB又对内存中的一个共享变量X进行操作,但此时A线程工作内存中的共享比那里X对线程B来说并不不可见.这种工作内存与主内存同步延迟现象就造成了可见性问题.</p>
<h4 id="2-2原子性"><a href="#2-2原子性" class="headerlink" title="2.2原子性"></a>2.2原子性</h4><p>number++在多线程下是非线程安全的,如何不加synchronized解决?</p>
<p><img src="https://img-blog.csdnimg.cn/20210411153333433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="2-3VolatileDemo代码演示可见性-原子性代码"><a href="#2-3VolatileDemo代码演示可见性-原子性代码" class="headerlink" title="2.3VolatileDemo代码演示可见性+原子性代码"></a>2.3VolatileDemo代码演示可见性+原子性代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span> &#123;</span><br><span class="line"><span class="comment">//    int num = 0;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addToSixty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num = <span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">addSelf</span><span class="params">()</span>&#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">atomicAddSelf</span><span class="params">()</span>&#123;</span><br><span class="line">        atomicInteger.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1验证volatile的可见性</span></span><br><span class="line"><span class="comment"> *  1.1 如果int num = 0，number变量没有添加volatile关键字修饰</span></span><br><span class="line"><span class="comment"> * 1.2 添加了volatile，可以解决可见性</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2.验证volatile不保证原子性</span></span><br><span class="line"><span class="comment"> *  2.1 原子性指的是什么</span></span><br><span class="line"><span class="comment"> *      不可分割、完整性，即某个线程正在做某个具体业务时，中间不可以被加塞或者被分割，需要整体完整，要么同时成功，要么同时失败</span></span><br><span class="line"><span class="comment"> *  2.2 如何解决原子性</span></span><br><span class="line"><span class="comment"> *      2.2.1 方法加synchronized</span></span><br><span class="line"><span class="comment"> *      2.2.2 Atomic</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        visibilityByVolatile();//验证volatile的可见性</span></span><br><span class="line">        atomicByVolatile();<span class="comment">//验证volatile不保证原子性</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * volatile可以保证可见性，及时通知其他线程，主物理内存的值已经被修改</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">visibilityByVolatile</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MyData</span> <span class="variable">myData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyData</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t come in&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//线程暂停3s</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                myData.addToSixty();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t update value:&quot;</span> + myData.num);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line">        <span class="comment">//第二个线程是main线程</span></span><br><span class="line">        <span class="keyword">while</span> (myData.num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果myData的num一直为零，main线程一直在这里循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t mission is over, num value is &quot;</span> + myData.num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * volatile不保证原子性</span></span><br><span class="line"><span class="comment">     * 以及使用Atomic保证原子性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">atomicByVolatile</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MyData</span> <span class="variable">myData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyData</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">1000</span>; j++)&#123;</span><br><span class="line">                    myData.addSelf();</span><br><span class="line">                  myData.atomicAddSelf();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">&quot;Thread &quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等待上面的线程都计算完成后，再用main线程取得最终结果值</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t finally num value is &quot;</span>+myData.num);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t finally atomicnum value is &quot;</span>+myData.atomicInteger);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-4有序性"><a href="#2-4有序性" class="headerlink" title="2.4有序性"></a>2.4有序性</h4><p>计算机在执行程序时,为了提高性能,编译器和处理器常常会做指令重排,一把分为以下3中</p>
<p><img src="https://img-blog.csdnimg.cn/20210411153347906.png#pic_center" alt="在这里插入图片描述"></p>
<p>单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致.<br>处理器在进行重新排序是必须要考虑指令之间的数据依赖性</p>
<p>多线程环境中线程交替执行,由于编译器优化重排的存在,两个线程使用的变量能否保持一致性是无法确定的,结果无法预测<br><img src="https://img-blog.csdnimg.cn/20210411153401999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411153402272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="3-你在哪些地方用到过volatile"><a href="#3-你在哪些地方用到过volatile" class="headerlink" title="3.你在哪些地方用到过volatile?"></a>3.你在哪些地方用到过volatile?</h3><h4 id="3-1-单例模式DCL代码"><a href="#3-1-单例模式DCL代码" class="headerlink" title="3.1 单例模式DCL代码"></a>3.1 单例模式DCL代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonDemo instance=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonDemo</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双重检测机制</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonDemo.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">                    instance=<span class="keyword">new</span> <span class="title class_">SingletonDemo</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">                SingletonDemo.getInstance();</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-2代理模式volatile分析"><a href="#3-2代理模式volatile分析" class="headerlink" title="3.2代理模式volatile分析"></a>3.2代理模式volatile分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DCL(双端检锁) 机制不一定线程安全,原因是有指令重排的存在,加入<span class="keyword">volatile</span>可以禁止指令重排</span><br><span class="line">  原因在于某一个线程在执行到第一次检测,读取到的instance不为<span class="literal">null</span>时,instance的引用对象可能没有完成初始化.</span><br><span class="line">instance=<span class="keyword">new</span> <span class="title class_">SingletonDem</span>(); 可以分为以下步骤(伪代码)</span><br><span class="line"> </span><br><span class="line">memory=allocate();<span class="comment">//1.分配对象内存空间</span></span><br><span class="line">instance(memory);<span class="comment">//2.初始化对象</span></span><br><span class="line">instance=memory;<span class="comment">//3.设置instance的指向刚分配的内存地址,此时instance!=null </span></span><br><span class="line"> </span><br><span class="line">步骤<span class="number">2</span>和步骤<span class="number">3</span>不存在数据依赖关系.而且无论重排前还是重排后程序执行的结果在单线程中并没有改变,因此这种重排优化是允许的.</span><br><span class="line">memory=allocate();<span class="comment">//1.分配对象内存空间</span></span><br><span class="line">instance=memory;<span class="comment">//3.设置instance的指向刚分配的内存地址,此时instance!=null 但对象还没有初始化完.</span></span><br><span class="line">instance(memory);<span class="comment">//2.初始化对象</span></span><br><span class="line">但是指令重排只会保证串行语义的执行一致性(单线程) 并不会关心多线程间的语义一致性</span><br><span class="line">所以当一条线程访问instance不为<span class="literal">null</span>时,由于instance实例未必完成初始化,也就造成了线程安全问题.</span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<h1 id="15、CAS你知道吗"><a href="#15、CAS你知道吗" class="headerlink" title="15、CAS你知道吗"></a>15、CAS你知道吗</h1><h3 id="1-比较并交换"><a href="#1-比较并交换" class="headerlink" title="1.比较并交换"></a>1.比较并交换</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> veliger@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-12 9:57</span></span><br><span class="line"><span class="comment"> * 1.什么是CAS ? ===&gt; compareAndSet</span></span><br><span class="line"><span class="comment"> *  比较并交换</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CASDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">5</span>);</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">2019</span>)+<span class="string">&quot;\t current&quot;</span>+atomicInteger.get());</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">2014</span>)+<span class="string">&quot;\t current&quot;</span>+atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-CAS底层原理-如果知道-谈谈你对UnSafe的理解"><a href="#2-CAS底层原理-如果知道-谈谈你对UnSafe的理解" class="headerlink" title="2.CAS底层原理?如果知道,谈谈你对UnSafe的理解"></a>2.CAS底层原理?如果知道,谈谈你对UnSafe的理解</h3><h4 id="atomicInteger-getAndIncrement"><a href="#atomicInteger-getAndIncrement" class="headerlink" title="atomicInteger.getAndIncrement();"></a>atomicInteger.getAndIncrement();</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">atomicInteger.getAndIncrement()方法的源代码:</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">印出来一个问题:UnSafe类是什么?</span><br></pre></td></tr></table></figure>



<h4 id="UnSafe"><a href="#UnSafe" class="headerlink" title="UnSafe"></a>UnSafe</h4><p><img src="https://img-blog.csdnimg.cn/20210411153424753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>1.UnSafe<br> 是CAS的核心类 由于Java 方法无法直接访问底层 ,需要通过本地(native)方法来访问,UnSafe相当于一个后面,基于该类可以直接操作特额定的内存数据.UnSafe类在于sun.misc包中,其内部方法操作可以向C的指针一样直接操作内存,因为Java中CAS操作的助兴依赖于UNSafe类的方法.<br>注意UnSafe类中所有的方法都是native修饰的,也就是说UnSafe类中的方法都是直接调用操作底层资源执行响应的任务<br> 2.变量ValueOffset,便是该变量在内存中的偏移地址,因为UnSafe就是根据内存偏移地址获取数据的</p>
<p><img src="https://img-blog.csdnimg.cn/20210411153436704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p> 3.变量value和volatile修饰,保证了多线程之间的可见性.</p>
<h4 id="CAS是什么"><a href="#CAS是什么" class="headerlink" title="CAS是什么"></a>CAS是什么</h4><p>CAS的全称为Compare-And-Swap ,它是一条CPU并发原语.<br>它的功能是判断内存某个位置的值是否为预期值,如果是则更新为新的值,这个过程是原子的.</p>
<p>CAS并发原语提现在Java语言中就是sun.miscUnSaffe类中的各个方法.调用UnSafe类中的CAS方法,JVM会帮我实现CAS汇编指令.这是一种完全依赖于硬件 功能,通过它实现了原子操作,再次强调,由于CAS是一种系统原语,原语属于操作系统用于范畴,是由若干条指令组成,用于完成某个功能的一个过程,并且原语的执行必须是连续的,在执行过程中不允许中断,也即是说CAS是一条原子指令,不会造成所谓的数据不一致的问题.</p>
<p><img src="https://img-blog.csdnimg.cn/20210411153507266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210411153507305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210411153507296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="unSafe-getAndIncrement"><a href="#unSafe-getAndIncrement" class="headerlink" title="unSafe.getAndIncrement"></a>unSafe.getAndIncrement</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var1 AtomicInteger对象本身.</span><br><span class="line">var2 该对象值的引用地址</span><br><span class="line">var4 需要变动的数值</span><br><span class="line">var5 是用过var1 var2找出内存中绅士的值</span><br><span class="line">用该对象当前的值与var5比较</span><br><span class="line">如果相同,更新var5的值并且返回true</span><br><span class="line">如果不同,继续取值然后比较,直到更新完成</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210411153534544.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  假设线程A和线程B两个线程同时执行getAndAddInt操作(分别在不同的CPU上):</span><br><span class="line"></span><br><span class="line">1.AtomicInteger里面的value原始值为3,即主内存中AtomicInteger的value为3,根据JMM模型,线程A和线程B各自持有一份值为3的value的副本分别到各自的工作内存.</span><br><span class="line"></span><br><span class="line">2.线程A通过getIntVolatile(var1,var2) 拿到value值3,这是线程A被挂起.</span><br><span class="line"></span><br><span class="line">3.线程B也通过getIntVolatile(var1,var2) 拿到value值3,此时刚好线程B没有被挂起并执行compareAndSwapInt方法比较内存中的值也是3 成功修改内存的值为4 线程B打完收工 一切OK.</span><br><span class="line"></span><br><span class="line"> 4.这是线程A恢复,执行compareAndSwapInt方法比较,发现自己手里的数值和内存中的数字4不一致,说明该值已经被其他线程抢先一步修改了,那A线程修改失败,只能重新来一遍了.</span><br><span class="line"></span><br><span class="line"> 5.线程A重新获取value值,因为变量value是volatile修饰,所以其他线程对他的修改,线程A总是能够看到,线程A继续执行compareAndSwapInt方法进行比较替换,直到成功.</span><br></pre></td></tr></table></figure>



<h5 id="底层汇编"><a href="#底层汇编" class="headerlink" title="底层汇编"></a>底层汇编</h5><p><img src="https://img-blog.csdnimg.cn/20210411153546489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="简单版小总结"><a href="#简单版小总结" class="headerlink" title="简单版小总结"></a>简单版小总结</h5><p><img src="https://img-blog.csdnimg.cn/20210411153600476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="3-CAS缺点"><a href="#3-CAS缺点" class="headerlink" title="3.CAS缺点"></a>3.CAS缺点</h3><h5 id="循环时间长开销很大"><a href="#循环时间长开销很大" class="headerlink" title="循环时间长开销很大"></a>循环时间长开销很大</h5><p><img src="https://img-blog.csdnimg.cn/20210411153615898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="只能保证一个共享变量的原子性"><a href="#只能保证一个共享变量的原子性" class="headerlink" title="只能保证一个共享变量的原子性"></a>只能保证一个共享变量的原子性</h5><p><img src="https://img-blog.csdnimg.cn/20210411153627352.png#pic_center" alt="在这里插入图片描述"></p>
<h5 id="引出来ABA问题"><a href="#引出来ABA问题" class="headerlink" title="引出来ABA问题???"></a>引出来ABA问题???</h5><p>往下看。。。。。。。。</p>
<h1 id="16、原子类AtomicInteger的ABA问题谈谈-原子更新引用知道吗"><a href="#16、原子类AtomicInteger的ABA问题谈谈-原子更新引用知道吗" class="headerlink" title="16、原子类AtomicInteger的ABA问题谈谈?原子更新引用知道吗"></a>16、原子类AtomicInteger的ABA问题谈谈?原子更新引用知道吗</h1><h3 id="ABA问题的产生"><a href="#ABA问题的产生" class="headerlink" title="ABA问题的产生"></a>ABA问题的产生</h3><p><img src="https://img-blog.csdnimg.cn/20210411153644240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> veliger@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-12 21:23</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Getter</span><span class="meta">@Setter</span><span class="meta">@AllArgsConstructor</span><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicReferenceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">zs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zs&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">ls</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;ls&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        AtomicReference&lt;User&gt; userAtomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">        userAtomicReference.set(zs);</span><br><span class="line">        System.out.println(userAtomicReference.compareAndSet(zs, ls)+<span class="string">&quot;\t&quot;</span>+userAtomicReference.get().toString());</span><br><span class="line">        System.out.println(userAtomicReference.compareAndSet(zs, ls)+<span class="string">&quot;\t&quot;</span>+userAtomicReference.get().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="时间戳原子引用"><a href="#时间戳原子引用" class="headerlink" title="时间戳原子引用"></a>时间戳原子引用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: ABA问题的解决</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> veliger@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-12 21:30</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ABADemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference=<span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; stampedReference=<span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===以下是ABA问题的产生===&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">100</span>,<span class="number">101</span>);</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">101</span>,<span class="number">100</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//先暂停1秒 保证完成ABA</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            System.out.println(atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>)+<span class="string">&quot;\t&quot;</span>+atomicReference.get());</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">2</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;===以下是ABA问题的解决===&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 第1次版本号&quot;</span>+stamp+<span class="string">&quot;\t值是&quot;</span>+stampedReference.getReference());</span><br><span class="line">            <span class="comment">//暂停1秒钟t3线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">            stampedReference.compareAndSet(<span class="number">100</span>,<span class="number">101</span>,stampedReference.getStamp(),stampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 第2次版本号&quot;</span>+stampedReference.getStamp()+<span class="string">&quot;\t值是&quot;</span>+stampedReference.getReference());</span><br><span class="line">            stampedReference.compareAndSet(<span class="number">101</span>,<span class="number">100</span>,stampedReference.getStamp(),stampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 第3次版本号&quot;</span>+stampedReference.getStamp()+<span class="string">&quot;\t值是&quot;</span>+stampedReference.getReference());</span><br><span class="line">        &#125;,<span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 第1次版本号&quot;</span>+stamp+<span class="string">&quot;\t值是&quot;</span>+stampedReference.getReference());</span><br><span class="line">            <span class="comment">//保证线程3完成1次ABA</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> stampedReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 修改成功否&quot;</span>+result+<span class="string">&quot;\t最新版本号&quot;</span>+stampedReference.getStamp());</span><br><span class="line">            System.out.println(<span class="string">&quot;最新的值\t&quot;</span>+stampedReference.getReference());</span><br><span class="line">        &#125;,<span class="string">&quot;t4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="17、公平锁-x2F-非公平锁-x2F-可重入锁-x2F-递归锁-x2F-自旋锁谈谈你的理解-请手写一个自旋锁"><a href="#17、公平锁-x2F-非公平锁-x2F-可重入锁-x2F-递归锁-x2F-自旋锁谈谈你的理解-请手写一个自旋锁" class="headerlink" title="17、公平锁&#x2F;非公平锁&#x2F;可重入锁&#x2F;递归锁&#x2F;自旋锁谈谈你的理解?请手写一个自旋锁"></a>17、公平锁&#x2F;非公平锁&#x2F;可重入锁&#x2F;递归锁&#x2F;自旋锁谈谈你的理解?请手写一个自旋锁</h1><h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><h5 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">公平锁</span><br><span class="line">    是指多个线程按照申请锁的顺序来获取锁类似排队打饭 先来后到</span><br><span class="line">非公平锁</span><br><span class="line">    是指在多线程获取锁的顺序并不是按照申请锁的顺序,有可能后申请的线程比先申请的线程优先获取到锁,在高并发的情况下,有可能造成优先级反转或者饥饿现象</span><br></pre></td></tr></table></figure>

<h5 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h5><p>公平锁&#x2F;非公平锁<br>  并发包ReentrantLock的创建可以指定构造函数的boolean类型来得到公平锁或者非公平锁 默认是非公平锁</p>
<p><img src="https://img-blog.csdnimg.cn/20210411153659409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="可重入锁-又名递归锁"><a href="#可重入锁-又名递归锁" class="headerlink" title="可重入锁(又名递归锁)"></a>可重入锁(又名递归锁)</h3><p><img src="https://img-blog.csdnimg.cn/20210411153711810.png#pic_center" alt="在这里插入图片描述"></p>
<h5 id="ReentrantLock-x2F-synchronized就是一个典型的可重入锁"><a href="#ReentrantLock-x2F-synchronized就是一个典型的可重入锁" class="headerlink" title="ReentrantLock&#x2F;synchronized就是一个典型的可重入锁"></a>ReentrantLock&#x2F;synchronized就是一个典型的可重入锁</h5><p>可重入锁最大的作用就是避免死锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSms</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\tsendSms&quot;</span>);</span><br><span class="line">        sendEmail();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\tsendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *  可重入锁(也叫做递归锁)</span></span><br><span class="line"><span class="comment"> *  指的是同一先生外层函数获得锁后,内层敌对函数任然能获取该锁的代码</span></span><br><span class="line"><span class="comment"> *  在同一线程外外层方法获取锁的时候,在进入内层方法会自动获取锁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  也就是说,线程可以进入任何一个它已经标记的锁所同步的代码块</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> veliger@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-12 23:36</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReenterLockDemo</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * t1 sendSms</span></span><br><span class="line"><span class="comment">     * t1 sendEmail</span></span><br><span class="line"><span class="comment">     * t2 sendSms</span></span><br><span class="line"><span class="comment">     * t2 sendEmail</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendSms();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendSms();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="自旋锁-1"><a href="#自旋锁-1" class="headerlink" title="自旋锁"></a>自旋锁</h3><p><img src="https://img-blog.csdnimg.cn/20210411153725494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> JUC.CAS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 题目：</span></span><br><span class="line"><span class="comment">*   实现一个自旋锁</span></span><br><span class="line"><span class="comment">*   自旋锁的好处：循环比较直到成功为止，没有类似wait的阻塞</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   通过CAS操作完成自旋锁，A线程先进来调用mylock方法自己持有锁5秒，B随后进来发现当前</span></span><br><span class="line"><span class="comment">*   有线程持有锁，不是null,所有只能通过自旋等待，所以只能通过自旋等待，直到A释放锁后B随后抢到</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原子引用线程</span></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference=<span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myLock</span><span class="params">()</span>&#123;</span><br><span class="line">        Thread thread=Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t come in&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="literal">null</span>,thread))&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myUnlock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        atomicReference.compareAndSet(thread,<span class="literal">null</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t invoked myUnLock()&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">SpinLockDemo</span> <span class="variable">spinLockDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpinLockDemo</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            spinLockDemo.myLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            spinLockDemo.myUnlock();</span><br><span class="line">        &#125;,<span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            spinLockDemo.myLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            spinLockDemo.myUnlock();</span><br><span class="line">        &#125;,<span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="独占锁-写-x2F-共享锁-读-x2F-互斥锁"><a href="#独占锁-写-x2F-共享锁-读-x2F-互斥锁" class="headerlink" title="独占锁(写)&#x2F;共享锁(读)&#x2F;互斥锁"></a>独占锁(写)&#x2F;共享锁(读)&#x2F;互斥锁</h3><p><img src="https://img-blog.csdnimg.cn/20210411153739624.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCaChe</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保证可见性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">reentrantReadWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        reentrantReadWriteLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t正在写入&quot;</span> + key);</span><br><span class="line">            <span class="comment">//模拟网络延时</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t正在完成&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            reentrantReadWriteLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        reentrantReadWriteLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t正在读取&quot;</span>);</span><br><span class="line">            <span class="comment">//模拟网络延时</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t正在完成&quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            reentrantReadWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearCaChe</span><span class="params">()</span> &#123;</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * 多个线程同时操作 一个资源类没有任何问题 所以为了满足并发量</span></span><br><span class="line"><span class="comment"> * 读取共享资源应该可以同时进行</span></span><br><span class="line"><span class="comment"> * 但是</span></span><br><span class="line"><span class="comment"> * 如果有一个线程想去写共享资源来  就不应该有其他线程可以对资源进行读或写</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 小总结:</span></span><br><span class="line"><span class="comment"> * 读 读能共存</span></span><br><span class="line"><span class="comment"> * 读 写不能共存</span></span><br><span class="line"><span class="comment"> * 写 写不能共存</span></span><br><span class="line"><span class="comment"> * 写操作 原子+独占 整个过程必须是一个完成的统一整体 中间不允许被分割 被打断</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> veliger@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-13 0:45</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyCaChe</span> <span class="variable">myCaChe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCaChe</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                myCaChe.put(temp + <span class="string">&quot;&quot;</span>, temp);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                myCaChe.get(finalI + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="18、JUC强大的辅助类讲解"><a href="#18、JUC强大的辅助类讲解" class="headerlink" title="18、JUC强大的辅助类讲解"></a>18、JUC强大的辅助类讲解</h1><h3 id="CountDownLatch减少计数"><a href="#CountDownLatch减少计数" class="headerlink" title="CountDownLatch减少计数"></a>CountDownLatch减少计数</h3><ul>
<li>CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。</li>
<li>其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)，</li>
<li>当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> *  *让一些线程阻塞直到另一些线程完成一系列操作后才被唤醒。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。</span></span><br><span class="line"><span class="comment"> * 其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)，</span></span><br><span class="line"><span class="comment"> * 当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 解释：6个同学陆续离开教室后值班同学才可以关门。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * main主线程必须要等前面6个线程完成全部工作后，自己才能开干 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line">   &#123;</span><br><span class="line">         <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">6</span>);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">6</span>; i++) <span class="comment">//6个上自习的同学，各自离开教室的时间不一致</span></span><br><span class="line">       &#123;</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">              System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 号同学离开教室&quot;</span>);</span><br><span class="line">              countDownLatch.countDown();</span><br><span class="line">          &#125;, String.valueOf(i)).start();</span><br><span class="line">       &#125;</span><br><span class="line">       countDownLatch.await();</span><br><span class="line">       System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t****** 班长关门走人，main线程是班长&quot;</span>);</span><br><span class="line">          </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="CyclicBarrier循环栅栏"><a href="#CyclicBarrier循环栅栏" class="headerlink" title="CyclicBarrier循环栅栏"></a>CyclicBarrier循环栅栏</h3><ul>
<li>CyclicBarrier的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。线程进入屏障通过CyclicBarrier的await()方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CyclicBarrier</span></span><br><span class="line"><span class="comment"> * 的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，</span></span><br><span class="line"><span class="comment"> * 让一组线程到达一个屏障（也可以叫同步点）时被阻塞，</span></span><br><span class="line"><span class="comment"> * 直到最后一个线程到达屏障时，屏障才会开门，所有</span></span><br><span class="line"><span class="comment"> * 被屏障拦截的线程才会继续干活。</span></span><br><span class="line"><span class="comment"> * 线程进入屏障通过CyclicBarrier的await()方法。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 集齐7颗龙珠就可以召唤神龙</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUMBER</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">  &#123;</span><br><span class="line">     <span class="comment">//CyclicBarrier(int parties, Runnable barrierAction) </span></span><br><span class="line">     </span><br><span class="line">     <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(NUMBER, ()-&gt;&#123;System.out.println(<span class="string">&quot;*****集齐7颗龙珠就可以召唤神龙&quot;</span>);&#125;) ;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 星龙珠被收集 &quot;</span>);</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">       </span><br><span class="line">       &#125;, String.valueOf(i)).start();</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Semaphore信号量"><a href="#Semaphore信号量" class="headerlink" title="Semaphore信号量"></a>Semaphore信号量</h3><p> 在信号量上我们定义两种操作：</p>
<ul>
<li>acquire（获取） 当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），要么一直等下去，直到有线程释放信号量，或超时。</li>
<li>release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。</li>
<li>信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO(这里用一句话描述这个类的作用)  </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 在信号量上我们定义两种操作：</span></span><br><span class="line"><span class="comment"> * acquire（获取） 当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），</span></span><br><span class="line"><span class="comment"> *             要么一直等下去，直到有线程释放信号量，或超时。</span></span><br><span class="line"><span class="comment"> * release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">  &#123;</span><br><span class="line">     <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);<span class="comment">//模拟3个停车位</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">6</span>; i++) <span class="comment">//模拟6部汽车</span></span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> </span><br><span class="line">          &#123;</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 抢到了车位&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">5</span>));</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t------- 离开&quot;</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;, String.valueOf(i)).start();</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="19、死锁编码及定位分析"><a href="#19、死锁编码及定位分析" class="headerlink" title="19、死锁编码及定位分析"></a>19、死锁编码及定位分析</h1><p><img src="https://img-blog.csdnimg.cn/2021041115375350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//产生死锁代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HoldThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lockA;</span><br><span class="line">    <span class="keyword">private</span> String lockB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HoldThread</span><span class="params">(String lockA, String lockB)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lockA = lockA;</span><br><span class="line">        <span class="built_in">this</span>.lockB = lockB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 自己持有锁&quot;</span> + lockA + <span class="string">&quot;尝试获得&quot;</span> + lockB);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 自己持有锁&quot;</span> + lockB + <span class="string">&quot;尝试获得&quot;</span> + lockA);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * 死锁是指两个或者以上的进程在执行过程中,</span></span><br><span class="line"><span class="comment"> * 因争夺资源而造成的一种相互等待的现象,</span></span><br><span class="line"><span class="comment"> * 若无外力干涉那他们都将无法推进下去</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> veliger@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-14 0:05</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="string">&quot;lockA&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="string">&quot;lockB&quot;</span>;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">HoldThread</span>(lockA, lockB), <span class="string">&quot;threadAAA&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">HoldThread</span>(lockB, lockA), <span class="string">&quot;threadBBB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><h5 id="jps命令定位进程编号"><a href="#jps命令定位进程编号" class="headerlink" title="jps命令定位进程编号"></a>jps命令定位进程编号</h5><p><img src="https://img-blog.csdnimg.cn/20210411153807155.png#pic_center" alt="在这里插入图片描述"></p>
<h5 id="jstack找到死锁查看"><a href="#jstack找到死锁查看" class="headerlink" title="jstack找到死锁查看"></a>jstack找到死锁查看</h5><p><img src="https://img-blog.csdnimg.cn/20210411153820912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h1 id="20、同步器-AQS"><a href="#20、同步器-AQS" class="headerlink" title="20、同步器 AQS"></a>20、同步器 AQS</h1><p>AQS 的全称为：AbstractQueuedSynchronizer，这个类在 java.util.concurrent.locks 包下面。AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如：我们提到的 ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。</p>
<h3 id="AQS-的原理是什么？"><a href="#AQS-的原理是什么？" class="headerlink" title="AQS 的原理是什么？"></a>AQS 的原理是什么？</h3><p>AQS 核心思想是：如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<p><img src="https://img-blog.csdnimg.cn/20210411153833574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLH队列：</span><br><span class="line"></span><br><span class="line">CLH(Craig, Landin, and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210411153847220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>AQS的主要思想就是维护一个单一的状态信息state，通过getState()，setState()，compareAndSetState()方法来修改其值。对于AQS来说，线程同步的关键就是对状态值state进行操作，根据操作state的方式，又分为独占锁和共享锁；在独占方式下的获取和释放资源的方法为：acquire()和release()，在共享方式下的获取和释放资源的方法为：acquireShared()和releaseShared()。</p>
<p>使用独占方式获取的资源是与具体线程绑定的，就是如果一个线程获取了资源，就会标记是这个线程获取到了，其他线程再尝试操作state时会发现当前资源不是自己持有的，就会在获取失败后阻塞，然后该线程会被包装为一个Node节点，加入到AQS阻塞队列当中，直到持有state的线程释放资源，该线程会被唤醒继续争取资源。比如独占锁ReentrantLock的实现，当一个线程获取了ReentrantLock后，在AQS内部会使用CAS操作把state状态值从0改为1，然后设置当前锁的持有者为当前线程，当该线程再次获取锁的时候发现它就是锁的持有者，则会把状态值从1改为2，也就是设置了重入次数为2，当另一个线程获取锁时发现自己并不是锁的持有者就会被放入AQS阻塞队列后挂起。</p>
<p>谈到并发，我们不得不说<code>AQS(AbstractQueuedSynchronizer)</code>，所谓的<code>AQS</code>即是抽象的队列式的同步器，内部定义了很多锁相关的方法，我们熟知的<code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code>、<code>CountDownLatch</code>、<code>Semaphore</code>等都是基于<code>AQS</code>来实现的。</p>
<p>我们先看下<code>AQS</code>相关的<code>UML</code>图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411153913582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210411154013902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="1AQS实现原理"><a href="#1AQS实现原理" class="headerlink" title="1AQS实现原理"></a>1AQS实现原理</h3><p><code>AQS</code>中 维护了一个<code>volatile int state</code>（代表共享资源）和一个<code>FIFO</code>线程等待队列（多线程争用资源被阻塞时会进入此队列）。</p>
<p>这里<code>volatile</code>能够保证多线程下的可见性，当<code>state=1</code>则代表当前对象锁已经被占有，其他线程来加锁时则会失败，加锁失败的线程会被放入一个<code>FIFO</code>的等待队列中，比列会被<code>UNSAFE.park()</code>操作挂起，等待其他获取锁的线程释放锁才能够被唤醒。</p>
<p>另外<code>state</code>的操作都是通过<code>CAS</code>来保证其并发修改的安全性。</p>
<p>具体原理我们可以用一张图来简单概括：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411154121167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><code>AQS</code> 中提供了很多关于锁的实现方法，</p>
<ul>
<li>getState()：获取锁的标志state值</li>
<li>setState()：设置锁的标志state值</li>
<li>tryAcquire(int)：独占方式获取锁。尝试获取资源，成功则返回true，失败则返回false。</li>
<li>tryRelease(int)：独占方式释放锁。尝试释放资源，成功则返回true，失败则返回false。</li>
</ul>
<p>这里还有一些方法并没有列出来，接下来我们以<code>ReentrantLock</code>作为突破点通过源码和画图的形式一步步了解<code>AQS</code>内部实现原理。</p>
<h3 id="2目录结构"><a href="#2目录结构" class="headerlink" title="2目录结构"></a>2目录结构</h3><p>文章准备模拟多线程竞争锁、释放锁的场景来进行分析<code>AQS</code>源码：</p>
<p><strong>三个线程(线程一、线程二、线程三)同时来加锁&#x2F;释放锁</strong></p>
<p><strong>目录如下：</strong></p>
<ul>
<li><strong>线程一</strong>加锁成功时<code>AQS</code>内部实现</li>
<li><strong>线程二&#x2F;三</strong>加锁失败时<code>AQS</code>中等待队列的数据模型</li>
<li><strong>线程一</strong>释放锁及<strong>线程二</strong>获取锁实现原理</li>
<li>通过线程场景来讲解<strong>公平锁</strong>具体实现原理</li>
<li>通过线程场景来讲解Condition中a<code>wait()</code>和<code>signal()</code>实现原理</li>
</ul>
<p>这里会通过画图来分析每个线程加锁、释放锁后<code>AQS</code>内部的数据结构和实现原理</p>
<h3 id="3-场景分析"><a href="#3-场景分析" class="headerlink" title="3 场景分析"></a>3 场景分析</h3><h4 id="线程一加锁成功"><a href="#线程一加锁成功" class="headerlink" title="线程一加锁成功"></a>线程一加锁成功</h4><p>如果同时有<strong>三个线程</strong>并发抢占锁，此时<strong>线程一</strong>抢占锁成功，<strong>线程二</strong>和<strong>线程三</strong>抢占锁失败，具体执行流程如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411154205505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>此时<code>AQS</code>内部数据为：</p>
<p><img src="https://img-blog.csdnimg.cn/2021041115421770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>线程二</strong>、<strong>线程三</strong>加锁失败：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411154230114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>有图可以看出，等待队列中的节点<code>Node</code>是一个双向链表，这里<code>SIGNAL</code>是<code>Node</code>中<code>waitStatus</code>属性，<code>Node</code>中还有一个<code>nextWaiter</code>属性，这个并未在图中画出来，这个到后面<code>Condition</code>会具体讲解的。</p>
<p>具体看下抢占锁代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.concurrent.locks.ReentrantLock .NonfairSync:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用的<strong>ReentrantLock非公平锁</strong>，线程进来直接利用<code>CAS</code>尝试抢占锁，如果抢占成功<code>state</code>值回被改为1，且设置对象独占锁线程为当前线程。如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setExclusiveOwnerThread</span><span class="params">(Thread thread)</span> &#123;</span><br><span class="line">    exclusiveOwnerThread = thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程二抢占锁失败"><a href="#线程二抢占锁失败" class="headerlink" title="线程二抢占锁失败"></a>线程二抢占锁失败</h4><p>我们按照真实场景来分析，<strong>线程一</strong>抢占锁成功后，<code>state</code>变为1，<strong>线程二</strong>通过<code>CAS</code>修改<code>state</code>变量必然会失败。此时<code>AQS</code>中<code>FIFO</code>(First In First Out 先进先出)队列中数据如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411154245489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>我们将<strong>线程二</strong>执行的逻辑一步步拆解来看：</p>
<p><code>java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看看<code>tryAcquire()</code>的具体实现：<code>java.util.concurrent.locks.ReentrantLock .nonfairTryAcquire()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>nonfairTryAcquire()</code>方法中首先会获取<code>state</code>的值，如果不为0则说明当前对象的锁已经被其他线程所占有，接着判断占有锁的线程是否为当前线程，如果是则累加<code>state</code>值，这就是可重入锁的具体实现，累加<code>state</code>值，释放锁的时候也要依次递减<code>state</code>值。</p>
<p>如果<code>state</code>为0，则执行<code>CAS</code>操作，尝试更新<code>state</code>值为1，如果更新成功则代表当前线程加锁成功。</p>
<p>以<strong>线程二</strong>为例，因为<strong>线程一</strong>已经将<code>state</code>修改为1，所以<strong>线程二</strong>通过<code>CAS</code>修改<code>state</code>的值不会成功。加锁失败。</p>
<p><strong>线程二</strong>执行<code>tryAcquire()</code>后会返回false，接着执行<code>addWaiter(Node.EXCLUSIVE)</code>逻辑，将自己加入到一个<code>FIFO</code>等待队列中，代码实现如下：</p>
<p><code>java.util.concurrent.locks.AbstractQueuedSynchronizer.addWaiter()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;    </span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码首先会创建一个和当前线程绑定的<code>Node</code>节点，<code>Node</code>为双向链表。此时等待队列中的<code>tail</code>指针为空，直接调用<code>enq(node)</code>方法将当前线程加入等待队列尾部：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一遍循环时<code>tail</code>指针为空，进入if逻辑，使用<code>CAS</code>操作设置<code>head</code>指针，将<code>head</code>指向一个新创建的<code>Node</code>节点。此时<code>AQS</code>中数据：<br><img src="https://img-blog.csdnimg.cn/20210411154257128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>执行完成之后，<code>head</code>、<code>tail</code>、<code>t</code>都指向第一个<code>Node</code>元素。</p>
<p>接着执行第二遍循环，进入<code>else</code>逻辑，此时已经有了<code>head</code>节点，这里要操作的就是将<strong>线程二</strong>对应的<code>Node</code>节点挂到<code>head</code>节点后面。此时队列中就有了两个<code>Node</code>节点：</p>
<p><img src="https://img-blog.csdnimg.cn/2021041115435024.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><code>addWaiter()</code>方法执行完后，会返回当前线程创建的节点信息。继续往后执行<code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code>逻辑，此时传入的参数为<strong>线程二</strong>对应的<code>Node</code>节点信息：</p>
<p><code>java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndChecknIterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>acquireQueued()</code>这个方法会先判断当前传入的<code>Node</code>对应的前置节点是否为<code>head</code>，如果是则尝试加锁。加锁成功过则将当前节点设置为<code>head</code>节点，然后空置之前的<code>head</code>节点，方便后续被垃圾回收掉。</p>
<p>如果加锁失败或者<code>Node</code>的前置节点不是<code>head</code>节点，就会通过<code>shouldParkAfterFailedAcquire</code>方法 将<code>head</code>节点的<code>waitStatus</code>变为了<code>SIGNAL=-1</code>，最后执行<code>parkAndChecknIterrupt</code>方法，调用<code>LockSupport.park()</code>挂起当前线程。</p>
<p>此时<code>AQS</code>中的数据如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411154403597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>此时<strong>线程二</strong>就静静的待在<code>AQS</code>的等待队列里面了，等着其他线程释放锁来唤醒它。</p>
<h4 id="线程三抢占锁失败"><a href="#线程三抢占锁失败" class="headerlink" title="线程三抢占锁失败"></a>线程三抢占锁失败</h4><p>看完了<strong>线程二</strong>抢占锁失败的分析，那么再来分析<strong>线程三</strong>抢占锁失败就很简单了，先看看<code>addWaiter(Node mode)</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时等待队列的<code>tail</code>节点指向<strong>线程二</strong>，进入<code>if</code>逻辑后，通过<code>CAS</code>指令将<code>tail</code>节点重新指向<strong>线程三</strong>。接着<strong>线程三</strong>调用<code>enq()</code>方法执行入队操作，和上面<strong>线程二</strong>执行方式是一致的，入队后会修改<strong>线程二</strong>对应的<code>Node</code>中的<code>waitStatus=SIGNAL</code>。最后<strong>线程三</strong>也会被挂起。此时等待队列的数据如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411154439195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="线程一释放锁"><a href="#线程一释放锁" class="headerlink" title="线程一释放锁"></a>线程一释放锁</h4><p>现在来分析下释放锁的过程，首先是<strong>线程一</strong>释放锁，释放锁后会唤醒<code>head</code>节点的后置节点，也就是我们现在的<strong>线程二</strong>，具体操作流程如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411154452872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>执行完后等待队列数据如下：</p>
<p><img src="https://img-blog.csdnimg.cn/202104111545354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>此时<strong>线程二</strong>已经被唤醒，继续尝试获取锁，如果获取锁失败，则会继续被挂起。如果获取锁成功，则<code>AQS</code>中数据如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411154547763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>接着还是一步步拆解来看，先看看<strong>线程一</strong>释放锁的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.concurrent.locks.AbstractQueuedSynchronizer.release()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先会执行<code>tryRelease()</code>方法，这个方法具体实现在<code>ReentrantLock</code>中，如果<code>tryRelease</code>执行成功，则继续判断<code>head</code>节点的<code>waitStatus</code>是否为0，前面我们已经看到过，<code>head</code>的<code>waitStatue</code>为<code>SIGNAL(-1)</code>，这里就会执行<code>unparkSuccessor()</code>方法来唤醒<code>head</code>的后置节点，也就是我们上面图中<strong>线程二</strong>对应的<code>Node</code>节点。</p>
<p>此时看<code>ReentrantLock.tryRelease()</code>中的具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行完<code>ReentrantLock.tryRelease()</code>后，<code>state</code>被设置成0，Lock对象的独占锁被设置为null。此时看下<code>AQS</code>中的数据：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411154602113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>接着执行<code>java.util.concurrent.locks.AbstractQueuedSynchronizer.unparkSuccessor()</code>方法，唤醒<code>head</code>的后置节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要是将<code>head</code>节点的<code>waitStatus</code>设置为0，然后解除<code>head</code>节点<code>next</code>的指向，使<code>head</code>节点空置，等待着被垃圾回收。</p>
<p>此时重新将<code>head</code>指针指向<strong>线程二</strong>对应的<code>Node</code>节点，且使用<code>LockSupport.unpark</code>方法来唤醒<strong>线程二</strong>。</p>
<p>被唤醒的<strong>线程二</strong>会接着尝试获取锁，用<code>CAS</code>指令修改<code>state</code>数据。执行完成后可以查看<code>AQS</code>中数据：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a761b57430a731f5e7fb7ddb187efd68.png" alt="img"></p>
<p>此时<strong>线程二</strong>被唤醒，<strong>线程二</strong>接着之前被<code>park</code>的地方继续执行，继续执行<code>acquireQueued()</code>方法。</p>
<h4 id="线程二唤醒继续加锁"><a href="#线程二唤醒继续加锁" class="headerlink" title="线程二唤醒继续加锁"></a>线程二唤醒继续加锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时<strong>线程二</strong>被唤醒，继续执行<code>for</code>循环，判断<strong>线程二</strong>的前置节点是否为<code>head</code>，如果是则继续使用<code>tryAcquire()</code>方法来尝试获取锁，其实就是使用<code>CAS</code>操作来修改<code>state</code>值，如果修改成功则代表获取锁成功。接着将<strong>线程二</strong>设置为<code>head</code>节点，然后空置之前的<code>head</code>节点数据，被空置的节点数据等着被<strong>垃圾回收</strong>。</p>
<p>此时线程三获取锁成功，<code>AQS</code>中队列数据如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411154613612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>等待队列中的数据都等待着被垃圾回收。</p>
<h4 id="线程二释放锁-x2F-线程三加锁"><a href="#线程二释放锁-x2F-线程三加锁" class="headerlink" title="线程二释放锁&#x2F;线程三加锁"></a>线程二释放锁&#x2F;线程三加锁</h4><p>当<strong>线程二</strong>释放锁时，会唤醒被挂起的<strong>线程三</strong>，流程和上面大致相同，被唤醒的<strong>线程三</strong>会再次尝试加锁，具体代码可以参考上面内容。具体流程图如下：<br><img src="https://img-blog.csdnimg.cn/20210411154625793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>此时<code>AQS</code>中队列数据如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411154636178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="4公平锁实现原理"><a href="#4公平锁实现原理" class="headerlink" title="4公平锁实现原理"></a>4公平锁实现原理</h3><p>上面所有的加锁场景都是基于<strong>非公平锁</strong>来实现的，<strong>非公平锁</strong>是<code>ReentrantLock</code>的默认实现，那我们接着来看一下<strong>公平锁</strong>的实现原理，这里先用一张图来解释<strong>公平锁</strong>和<strong>非公平锁</strong>的区别：</p>
<p><strong>非公平锁</strong>执行流程：</p>
<p><img src="https://img-blog.csdnimg.cn/2021041115471937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>这里我们还是用之前的线程模型来举例子，当<strong>线程二</strong>释放锁的时候，唤醒被挂起的<strong>线程三</strong>，<strong>线程三</strong>执行<code>tryAcquire()</code>方法使用<code>CAS</code>操作来尝试修改<code>state</code>值，如果此时又来了一个<strong>线程四</strong>也来执行加锁操作，同样会执行<code>tryAcquire()</code>方法。</p>
<p>这种情况就会出现竞争，<strong>线程四</strong>如果获取锁成功，<strong>线程三</strong>仍然需要待在等待队列中被挂起。这就是所谓的<strong>非公平锁</strong>，<strong>线程三</strong>辛辛苦苦排队等到自己获取锁，却眼巴巴的看到<strong>线程四</strong>插队获取到了锁。</p>
<p><strong>公平锁</strong>执行流程：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411154730865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>公平锁在加锁的时候，会先判断<code>AQS</code>等待队列中是存在节点，如果存在节点则会直接入队等待，具体代码如下.</p>
<p>公平锁在获取锁是也是首先会执行<code>acquire()</code>方法，只不过公平锁单独实现了<code>tryAcquire()</code>方法：</p>
<p><code>#java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会执行<code>ReentrantLock</code>中公平锁的<code>tryAcquire()</code>方法</p>
<p><code>#java.util.concurrent.locks.ReentrantLock.FairSync.tryAcquire()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会先判断<code>state</code>值，如果不为0且获取锁的线程不是当前线程，直接返回false代表获取锁失败，被加入等待队列。如果是当前线程则可重入获取锁。</p>
<p>如果<code>state=0</code>则代表此时没有线程持有锁，执行<code>hasQueuedPredecessors()</code>判断<code>AQS</code>等待队列中是否有元素存在，如果存在其他等待线程，那么自己也会加入到等待队列尾部，做到真正的先来后到，有序加锁。具体代码如下：</p>
<p><code>#java.util.concurrent.locks.AbstractQueuedSynchronizer.hasQueuedPredecessors()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedPredecessors</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="literal">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码很有意思，返回<code>false</code>代表队列中没有节点或者仅有一个节点是当前线程创建的节点。返回<code>true</code>则代表队列中存在等待节点，当前线程需要入队等待。<br><img src="https://img-blog.csdnimg.cn/20210411154805834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>先判断<code>head</code>是否等于<code>tail</code>，如果队列中只有一个<code>Node</code>节点，那么<code>head</code>会等于<code>tail</code>，接着判断<code>head</code>的后置节点，这里肯定会是<code>null</code>，如果此<code>Node</code>节点对应的线程和当前的线程是同一个线程，那么则会返回<code>false</code>，代表没有等待节点或者等待节点就是当前线程创建的<code>Node</code>节点。此时当前线程会尝试获取锁。</p>
<p>如果<code>head</code>和<code>tail</code>不相等，说明队列中有等待线程创建的节点，此时直接返回<code>true</code>，如果只有一个节点，而此节点的线程和当前线程不一致，也会返回<code>true</code></p>
<p><strong>非公平锁</strong>和<strong>公平锁</strong>的区别：<strong>非公平锁</strong>性能高于<strong>公平锁</strong>性能。<strong>非公平锁</strong>可以减少<code>CPU</code>唤醒线程的开销，整体的吞吐效率会高点，<code>CPU</code>也不必取唤醒所有线程，会减少唤起线程的数量</p>
<p><strong>非公平锁</strong>性能虽然优于<strong>公平锁</strong>，但是会存在导致<strong>线程饥饿</strong>的情况。在最坏的情况下，可能存在某个线程<strong>一直获取不到锁</strong>。不过相比性能而言，饥饿问题可以暂时忽略，这可能就是<code>ReentrantLock</code>默认创建非公平锁的原因之一了。</p>
<h3 id="5Condition实现原理"><a href="#5Condition实现原理" class="headerlink" title="5Condition实现原理"></a>5Condition实现原理</h3><p>**Condition 简介</p>
<p>**</p>
<p>上面已经介绍了<code>AQS</code>所提供的核心功能，当然它还有很多其他的特性，这里我们来继续说下<code>Condition</code>这个组件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Condition`是在`java 1.5`中才出现的，它用来替代传统的`Object`的`wait()`、`notify()`实现线程间的协作，相比使用`Object`的`wait()`、`notify()`，使用`Condition`中的`await()`、`signal()`这种方式实现线程间协作更加安全和高效。因此通常来说比较推荐使用`Condition</span><br></pre></td></tr></table></figure>

<p>其中<code>AbstractQueueSynchronizer</code>中实现了<code>Condition</code>中的方法，主要对外提供<code>awaite(Object.wait())</code>和<code>signal(Object.notify())</code>调用。</p>
<h4 id="Condition-Demo示例"><a href="#Condition-Demo示例" class="headerlink" title="Condition Demo示例"></a>Condition Demo示例</h4><p>使用示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ReentrantLock 实现源码学习</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 一枝花算不算浪漫</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/28 7:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程一加锁成功&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程一执行await被挂起&quot;</span>);</span><br><span class="line">                condition.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程一被唤醒成功&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程一释放锁成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程二加锁成功&quot;</span>);</span><br><span class="line">                condition.signal();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程二唤醒线程一&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程二释放锁成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果如下图：<br><img src="https://img-blog.csdnimg.cn/20210411154841170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>这里<strong>线程一</strong>先获取锁，然后使用<code>await()</code>方法挂起当前线程并<strong>释放锁</strong>，<strong>线程二</strong>获取锁后使用<code>signal</code>唤醒<strong>线程一</strong>。</p>
<h4 id="Condition实现原理图解"><a href="#Condition实现原理图解" class="headerlink" title="Condition实现原理图解"></a>Condition实现原理图解</h4><p>我们还是用上面的<code>demo</code>作为实例，执行的流程如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411154852823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>线程一</strong>执行<code>await()</code>方法：</p>
<p>先看下具体的代码实现，<code>#java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject.await()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>await()</code>方法中首先调用<code>addConditionWaiter()</code>将当前线程加入到<code>Condition</code>队列中。</p>
<p>执行完后我们可以看下<code>Condition</code>队列中的数据：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411154935348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>具体实现代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addConditionWaiter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> lastWaiter;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会用当前线程创建一个<code>Node</code>节点，<code>waitStatus</code>为<code>CONDITION</code>。接着会释放该节点的锁，调用之前解析过的<code>release()</code>方法，释放锁后此时会唤醒被挂起的<strong>线程二</strong>，<strong>线程二</strong>会继续尝试获取锁。</p>
<p>接着调用<code>isOnSyncQueue()</code>方法判断当前节点是否为<code>Condition</code>队列中的头部节点，如果是则调用<code>LockSupport.park(this)</code>挂起<code>Condition</code>中当前线程。此时<strong>线程一</strong>被挂起，<strong>线程二</strong>获取锁成功。</p>
<p>具体流程如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411155011715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>线程二</strong>执行<code>signal()</code>方法：</p>
<p>首先我们考虑下<strong>线程二</strong>已经获取到锁，此时<code>AQS</code>等待队列中已经没有了数据。</p>
<p>接着就来看看<strong>线程二</strong>唤醒<strong>线程一</strong>的具体执行流程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先判断当前线程是否为获取锁的线程，如果不是则直接抛出异常。接着调用<code>doSignal()</code>方法来唤醒线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>)</span><br><span class="line">            lastWaiter = <span class="literal">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> node&#x27;s predecessor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里先从<code>transferForSignal()</code>方法来看，通过上面的分析我们知道<code>Condition</code>队列中只有线程一创建的一个<code>Node</code>节点，且<code>waitStatue</code>为<code>CONDITION</code>，先通过<code>CAS</code>修改当前节点<code>waitStatus</code>为0，然后执行<code>enq()</code>方法将当前线程加入到等待队列中，并返回当前线程的前置节点。</p>
<p>加入等待队列的代码在上面也已经分析过，此时等待队列中数据如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411155024455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>接着开始通过<code>CAS</code>修改当前节点的前置节点<code>waitStatus</code>为<code>SIGNAL</code>，并且唤醒当前线程。此时<code>AQS</code>中等待队列数据为：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411155036381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>线程一</strong>被唤醒后，继续执行<code>await()</code>方法中的 while 循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为此时线程一的<code>waitStatus</code>已经被修改为0，所以执行<code>isOnSyncQueue()</code>方法会返回<code>false</code>。跳出<code>while</code>循环。</p>
<p>接着执行<code>acquireQueued()</code>方法，这里之前也有讲过，尝试重新获取锁，如果获取锁失败继续会被挂起。直到另外线程释放锁才被唤醒。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时<strong>线程一</strong>的流程都已经分析完了，等<strong>线程二</strong>释放锁后，<strong>线程一</strong>会继续重试获取锁，流程到此终结。</p>
<h4 id="Condition总结"><a href="#Condition总结" class="headerlink" title="Condition总结"></a>Condition总结</h4><p>我们总结下 Condition 和 wait&#x2F;notify 的比较：</p>
<ul>
<li>Condition 可以精准的对多个不同条件进行控制，wait&#x2F;notify 只能和 synchronized 关键字一起使用，并且只能唤醒一个或者全部的等待队列；</li>
<li>Condition 需要使用 Lock 进行控制，使用的时候要注意 lock() 后及时的 unlock()，Condition 有类似于 await 的机制，因此不会产生加锁方式而产生的死锁出现，同时底层实现的是 park&#x2F;unpark 的机制，因此也不会产生先唤醒再挂起的死锁，一句话就是不会产生死锁，但是 wait&#x2F;notify 会产生先唤醒再挂起的死锁。</li>
</ul>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h3><p><strong>这里用了一步一图的方式结合三个线程依次加锁&#x2F;释放锁来展示了</strong><code>ReentrantLock</code><strong>的实现方式和实现原理，而</strong><code>ReentrantLock</code><strong>底层就是基于</strong><code>AQS</code><strong>实现的，所以我们也对</strong><code>AQS</code>**有了深刻的理解。</p>
<p>**</p>
<p>另外还介绍了<strong>公平锁</strong>与<strong>非公平锁</strong>的实现原理，<code>Condition</code>的实现原理，基本上都是使用<strong>源码+绘图</strong>的讲解方式，尽量让大家更容易去理解。</p>
<h1 id="21、谈谈对-ThreadLocal-的理解？"><a href="#21、谈谈对-ThreadLocal-的理解？" class="headerlink" title="21、谈谈对 ThreadLocal 的理解？"></a>21、谈谈对 ThreadLocal 的理解？</h1><p>为共享变量在每个线程中创建一个副本，每个线程可以访问自己内部的副本变量</p>
<p>内部源码：</p>
<p>里面会维护一个ThreadLocalMap对象，在ThreadLocalMap中有Entry对象,其中key指的是当前ThreadLocal实例，value指的是ThreadLocal对应的值，其中Entry继承WeakReference，将ThreadLocal对象变成弱引用对象，这样做的好处是在线程销毁的时候，对应的实体就会被回收，不会存在内存泄漏，因为弱引用对象在垃圾回收机制一运行就会被销毁。</p>
<p><img src="https://img-blog.csdnimg.cn/20210411155056982.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.get() 方法是用来获取 ThreadLocal 在当前线程中保存的变量副本；</span><br><span class="line"></span><br><span class="line">2.set() 用来设置当前线程中变量的副本；</span><br><span class="line"></span><br><span class="line">3.remove() 用来移除当前线程中变量的副本；</span><br><span class="line"></span><br><span class="line">4.initialValue() 是一个 protected 方法，一般是用来在使用时进行重写的，如果在没有 set 的时候就调用 get，会调用 initialValue 方法初始化内容。</span><br></pre></td></tr></table></figure>

<p>其中key和ThreadLocal是弱引用关系，当gc执行时就会被回收，但是value和ThreadLocal是强引用的关系，不会被回收，因此就会出现key为null，value有值的情况，会导致内存泄露，所以需要remove来移除当前线程中变量的副本来避免内存泄露的问题。</p>
<p><a href="https://www.bilibili.com/read/cv9258735">https://www.bilibili.com/read/cv9258735</a></p>
<h3 id="在哪些场景下会使用到-ThreadLocal？"><a href="#在哪些场景下会使用到-ThreadLocal？" class="headerlink" title="在哪些场景下会使用到 ThreadLocal？"></a>在哪些场景下会使用到 ThreadLocal？</h3><p>获取数据库连接，这是我们刚开始学习jdbc的用法，简单使用是没有问题的。但还是有两个问题无法解决：</p>
<p>高并发的情况下，可能多个线程同时获取到数据库连接，就会产生并发的问题。我们想到可以使用同步锁来处理，保证只有一个线程获取到数据库连接，但这样毫无疑问效率非常低。</p>
<p>如果有多条sql需要执行，需要用同一个connection对象。那就需要在多个方法中传递这个connection对象，方法传递会有点麻烦。<br>那么有没有更好的方法呢，就是本文讲到的ThreadLocal了。我们稍微修改一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectionManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span><span class="string">&quot;***&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Connection&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Connection&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">openConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connect</span> <span class="operator">=</span> threadLocal.get();</span><br><span class="line">        <span class="keyword">if</span>(connect == <span class="literal">null</span>)&#123;</span><br><span class="line">            connect = DriverManager.getConnection(url);</span><br><span class="line">            threadLocal.set(connect);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connect;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用了ThreadLocal后，由于线程访问的都是自己的Connection对象，所以就不存在高并发的问题。同时还解决了事务的问题，同一个事务里，Connection对象不需要传来传去，直接用ThreadLocal获取就可以了。<br>所以我们总结一下ThreadLocal的两点好处：</p>
<p>1.每个线程有自己的ThreadLocalMap对象，线程各自访问各自的，提供了保存对象到线程的方法。</p>
<p>2.减少了线程间传递参数的麻烦。</p>
<p>基于这样两点好处，我们在获取数据库连接，获取session，获取token信息等场景下使用ThreadLocal会很方便。</p>
]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>Java并发编程</tag>
        <tag>线程池</tag>
        <tag>线程进程</tag>
      </tags>
  </entry>
  <entry>
    <title>第316场力扣周赛</title>
    <url>/2022/10/24/%E7%AC%AC316%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h4 id="1-6214-判断两个事件是否存在冲突"><a href="#1-6214-判断两个事件是否存在冲突" class="headerlink" title="1.6214. 判断两个事件是否存在冲突"></a>1.<a href="https://leetcode.cn/problems/determine-if-two-events-have-conflict/">6214. 判断两个事件是否存在冲突</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">haveConflict</span><span class="params">(String[] event1, String[] event2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start1</span> <span class="operator">=</span> helper(event1[<span class="number">0</span>]), end1 = helper(event1[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">start2</span> <span class="operator">=</span> helper(event2[<span class="number">0</span>]), end2 = helper(event2[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (start1 &gt; end2 || start2 &gt; end1) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">helper</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">//将时间全部转化为分钟</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> (str.charAt(<span class="number">0</span>) - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + (str.charAt(<span class="number">1</span>) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (str.charAt(<span class="number">3</span>) - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + (str.charAt(<span class="number">4</span>) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> h * <span class="number">60</span> + m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-2447-最大公因数等于-K-的子数组数目"><a href="#2-2447-最大公因数等于-K-的子数组数目" class="headerlink" title="2.2447. 最大公因数等于 K 的子数组数目"></a>2.<a href="https://leetcode.cn/problems/number-of-subarrays-with-gcd-equal-to-k/">2447. 最大公因数等于 K 的子数组数目</a></h4><p>两个或多个<a href="https://baike.baidu.com/item/%E6%95%B4%E6%95%B0/1293937?fromModule=lemma_inlink">整数</a>公有的<a href="https://baike.baidu.com/item/%E5%80%8D%E6%95%B0/7827981?fromModule=lemma_inlink">倍数</a>叫做它们的公倍数，其中除0以外最小的一个公倍数就叫做这几个整数的最小公倍数。整数a，b的最小公倍数记为[a，b]，同样的，a，b，c的最小公倍数记为[a，b，c]，多个整数的最小公倍数也有同样的记号。</p>
<p>与最小公倍数相对应的概念是<a href="https://baike.baidu.com/item/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/869308?fromModule=lemma_inlink">最大公约数</a>，a，b的最大公约数记为（a，b）。关于最小公倍数与最大公约数，我们有这样的定理：(a,b)x[a,b]&#x3D;ab(a,b均为整数)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarrayGCD</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; k) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == k) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                temp = gcd(temp, nums[j]);</span><br><span class="line">                <span class="keyword">if</span> (temp &lt; k) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == k) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-6216-使数组相等的最小开销"><a href="#3-6216-使数组相等的最小开销" class="headerlink" title="3.6216. 使数组相等的最小开销"></a>3.<a href="https://leetcode.cn/problems/minimum-cost-to-make-array-equal/">6216. 使数组相等的最小开销</a></h4><p>显然，我们可以得到下面的目标函数：</p>
<p>$$<br>min:z&#x3D;<br>i&#x3D;0<br>∑<br>size<br>​	<br> (∣target−nums[i]∣∗cost[i])<br>$$<br>问题转化为：如何找到使目标函数值最小的target？这需要一点高中知识：当n个绝对值相加，在何处取到最小？</p>
<p>也就是说，考虑下面的问题：</p>
<p>$$<br>min:∣x−a<br>1<br>​	<br> ∣+∣x−a<br>2<br>​	<br> ∣+…+∣x−a<br>n<br>​	<br> ∣<br>$$<br>在x为何值时最小？其实就是在a1~an的中位数处。这和<a href="https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/">462. 最小操作次数使数组元素相等 II</a> 的思想是类似的。推广到这一题，也就是说，我们要找到nums[i]的加权中位数。也就是每个nums[i]，都视为有cost[i]个，然后找到它们的中位数，就是target，然后算出目标函数就行了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">minCost</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; o1[<span class="number">0</span>] - o2[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">long</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nums[i], cost[i]&#125;);</span><br><span class="line">            len += cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">pivot</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">targetNum</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span>[] temp = queue.poll();</span><br><span class="line">            pivot += temp[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (pivot &gt;= len / <span class="number">2</span>) &#123;</span><br><span class="line">                targetNum = temp[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            res += (<span class="type">long</span>) Math.abs(targetNum - nums[i]) * cost[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>扩展</strong>： <a href="https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/">462. 最小操作次数使数组元素相等 II</a></p>
<p>思路：<a href="https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/solution/java-wu-xu-shu-xue-zheng-ming-si-lu-qing-01v2/">https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/solution/java-wu-xu-shu-xue-zheng-ming-si-lu-qing-01v2/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMoves2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="literal">null</span> || nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> target=nums[nums.length/<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            res+=Math.abs(nums[i]-target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-2449-使数组相似的最少操作次数"><a href="#4-2449-使数组相似的最少操作次数" class="headerlink" title="4.2449. 使数组相似的最少操作次数"></a>4.<a href="https://leetcode.cn/problems/minimum-number-of-operations-to-make-arrays-similar/">2449. 使数组相似的最少操作次数</a></h4><p>思路：<a href="https://leetcode.cn/problems/minimum-number-of-operations-to-make-arrays-similar/solution/by-endlesscheng-lusx/">https://leetcode.cn/problems/minimum-number-of-operations-to-make-arrays-similar/solution/by-endlesscheng-lusx/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">makeSimilar</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span>[] target)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        Arrays.sort(target);</span><br><span class="line">        List&lt;Integer&gt; odd = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; even = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; oddTarget = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; evenTarget = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((nums[i] &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                odd.add(nums[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                even.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((target[i] &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                oddTarget.add(target[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                evenTarget.add(target[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">stepOdd</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stepEven</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//2 4 4 6    //4 4 4 4</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; odd.size(); i++) &#123;</span><br><span class="line">            stepOdd += Math.abs(odd.get(i) - oddTarget.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; even.size(); i++) &#123;</span><br><span class="line">            stepEven += Math.abs(even.get(i) - evenTarget.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (stepOdd + stepEven) / <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈命令查询职责分离CQRS模式</title>
    <url>/2022/10/24/%E6%B5%85%E8%B0%88%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2%E8%81%8C%E8%B4%A3%E5%88%86%E7%A6%BBCQRS%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="浅谈命令查询职责分离-CQRS-模式"><a href="#浅谈命令查询职责分离-CQRS-模式" class="headerlink" title="浅谈命令查询职责分离(CQRS)模式"></a>浅谈命令查询职责分离(CQRS)模式</h1><p>在常用的三层架构中，通常都是通过数据访问层来修改或者查询数据，一般修改和查询使用的是相同的实体。在一些业务逻辑简单的系统中可能没有什么问题，但是随着系统逻辑变得复杂，用户增多，这种设计就会出现一些性能问题。虽然在DB上可以做一些读写分离的设计，但在业务上如果在读写方面混合在一起的话，仍然会出现一些问题。</p>
<p>本文介绍了命令查询职责分离模式(Command Query Responsibility Segregation，CQRS)，该模式从业务上分离修改 (Command，增，删，改，会对系统状态进行修改)和查询（Query，查，不会对系统状态进行修改)的行为。从而使得逻辑更加清晰，便于对不同部分进行针对性的优化。文章首先简要介绍了传统的CRUD方式存在的问题，接着介绍了CQRS模式，最后以一个简单的在线日记系统演示了如何实现CQRS模式。要谈到读写操作，首先我们来看传统的CRUD的问题。</p>
<h1 id="一-CRUD方式的问题"><a href="#一-CRUD方式的问题" class="headerlink" title="一 CRUD方式的问题"></a>一 CRUD方式的问题</h1><p>在以前的管理系统中，命令(Command，通常用来更新数据，操作DB)和查询(Query)通常使用的是在数据访问层中Repository中的实体对象(这些对象是对DB中表的映射)，这些实体有可能是SQLServer中的一行数据或者多个表。</p>
<p>通常对DB执行的增，删，改，查（CRUD）都是针对的系统的实体对象。如通过数据访问层获取数据，然后通过数据传输对象DTO传给表现层。或者，用户需要更新数据，通过DTO对象将数据传给Model，然后通过数据访问层写回数据库，系统中的所有交互都是和数据查询和存储有关，可以认为是数据驱动（<a href="http://en.wikipedia.org/wiki/Data-driven_programming">Data-Driven</a>）的，如下图：</p>
<p> <a href="http://images.cnitblog.com/blog/94031/201408/261851410161370.png"><img src="/2022/10/24/%E6%B5%85%E8%B0%88%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2%E8%81%8C%E8%B4%A3%E5%88%86%E7%A6%BBCQRS%E6%A8%A1%E5%BC%8F/1.png" alt="Traditional CRUD Architecture"></a></p>
<p>对于一些比较简单的系统，使用这种CRUD的设计方式能够满足要求。特别是通过一些代码生成工具及ORM等能够非常方便快速的实现功能。</p>
<p>但是传统的<a href="http://msdn.microsoft.com/en-us/library/ms978509.aspx">CRUD方法有一些问题</a>：</p>
<ul>
<li>使用同一个对象实体来进行数据库读写可能会太粗糙，大多数情况下，比如编辑的时候可能只需要更新个别字段，但是却需要将整个对象都穿进去，有些字段其实是不需要更新的。在查询的时候在表现层可能只需要个别字段，但是需要查询和返回整个实体对象。</li>
<li>使用同一实体对象对同一数据进行读写操作的时候，可能会遇到资源竞争的情况，经常要处理的锁的问题，在写入数据的时候，需要加锁。读取数据的时候需要判断是否允许脏读。这样使得系统的逻辑性和复杂性增加，并且会对系统吞吐量的增长会产生影响。</li>
<li>同步的，直接与数据库进行交互在大数据量同时访问的情况下可能会影响性能和响应性，并且可能会产生性能瓶颈。</li>
<li>由于同一实体对象都会在读写操作中用到，所以对于安全和权限的管理会变得比较复杂。</li>
</ul>
<p>这里面很重要的一个问题是，系统中的读写频率比，是偏向读，还是偏向写，就如同一般的数据结构在查找和修改上时间复杂度不一样，在设计系统的结构时也需要考虑这样的问题。解决方法就是我们经常用到的对数据库进行读写分离。 让主数据库处理事务性的增，删，改操作(Insert,Update,Delete)操作，让从数据库处理查询操作(Select操作)，数据库复制被用来将事务性操作导致的变更同步到集群中的从数据库。这只是从DB角度处理了读写分离，但是从业务或者系统上面读和写仍然是存放在一起的。他们都是用的同一个实体对象。</p>
<p>要从业务上将读和写分离，就是接下来要介绍的命令查询职责分离模式。</p>
<h1 id="二-什么是CQRS"><a href="#二-什么是CQRS" class="headerlink" title="二 什么是CQRS"></a>二 什么是CQRS</h1><p>CQRS最早来自于Betrand Meyer（Eiffel语言之父，<a href="http://msdn.microsoft.com/en-us/magazine/cc546578.aspx">开-闭原则</a>OCP提出者）在 <a href="http://www.amazon.com/gp/product/0136291554">Object-Oriented Software Construction</a> 这本书中提到的一种 <a href="http://martinfowler.com/bliki/CommandQuerySeparation.html">命令查询分离</a> (<a href="http://en.wikipedia.org/wiki/Command-query_separation">Command Query Separation</a>,CQS) 的概念。其基本思想在于，任何一个对象的方法可以分为两大类：</p>
<ul>
<li>命令(Command):不返回任何结果(void)，但会改变对象的状态。</li>
<li>查询(Query):返回结果，但是不会改变对象的状态，对系统没有副作用。</li>
</ul>
<p>根据CQS的思想，任何一个方法都可以拆分为命令和查询两部分，比如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">int</span> <span class="title">Increase</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    i += <span class="keyword">value</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法，我们执行了一个命令即对变量i进行相加，同时又执行了一个Query，即查询返回了i的值，如果按照CQS的思想，该方法可以拆成Command和Query两个方法，如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">IncreaseCommand</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    i += <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">int</span> <span class="title">QueryValue</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>操作和查询分离使得我们能够更好的把握对象的细节，能够更好的理解哪些操作会改变系统的状态。当然<a href="http://en.wikipedia.org/wiki/Command-query_separation">CQS</a>也有一些缺点，比如代码需要处理多线程的情况。</p>
<p>CQRS是对CQS模式的进一步改进成的一种简单模式。 它由Greg Young在<a href="http://codebetter.com/gregyoung/2010/02/16/cqrs-task-based-uis-event-sourcing-agh/">CQRS, Task Based UIs, Event Sourcing agh!</a> 这篇文章中提出。“CQRS只是简单的将之前只需要创建一个对象拆分成了两个对象，这种分离是基于方法是执行命令还是执行查询这一原则来定的(这个和CQS的定义一致)”。</p>
<p>CQRS使用分离的接口将数据查询操作(Queries)和数据修改操作(Commands)分离开来，这也意味着在查询和更新过程中使用的数据模型也是不一样的。这样读和写逻辑就隔离开来了。</p>
<p><a href="http://images.cnitblog.com/blog/94031/201408/261851415951714.png"><img src="/2022/10/24/%E6%B5%85%E8%B0%88%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2%E8%81%8C%E8%B4%A3%E5%88%86%E7%A6%BBCQRS%E6%A8%A1%E5%BC%8F/2.png" alt="A basic CQRS architecture"></a></p>
<p>使用CQRS分离了读写职责之后，可以对数据进行读写分离操作来改进性能，可扩展性和安全。如下图：</p>
<p><a href="http://images.cnitblog.com/blog/94031/201408/261851421105570.png"><img src="/2022/10/24/%E6%B5%85%E8%B0%88%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2%E8%81%8C%E8%B4%A3%E5%88%86%E7%A6%BBCQRS%E6%A8%A1%E5%BC%8F/3.png" alt="A CQRS architecture with separate read and write stores"></a></p>
<p>主数据库处理CUD，从库处理R，从库的的结构可以和主库的结构完全一样，也可以不一样，从库主要用来进行只读的查询操作。在数量上从库的个数也可以根据查询的规模进行扩展，在业务逻辑上，也可以根据专题从主库中划分出不同的从库。从库也可以实现成<a href="http://martinfowler.com/bliki/ReportingDatabase.html">ReportingDatabase</a>，根据查询的业务需求，从主库中抽取一些必要的数据生成一系列查询报表来存储。</p>
<p><a href="http://images.cnitblog.com/blog/94031/201408/261851428451429.png"><img src="/2022/10/24/%E6%B5%85%E8%B0%88%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2%E8%81%8C%E8%B4%A3%E5%88%86%E7%A6%BBCQRS%E6%A8%A1%E5%BC%8F/4.png" alt="reportingDatabase"></a></p>
<p>使用ReportingDatabase的一些优点通常可以使得查询变得更加简单高效：</p>
<ul>
<li>ReportingDatabase的结构和数据表会针对常用的查询请求进行设计。</li>
<li>ReportingDatabase数据库通常会去正规化，存储一些冗余而减少必要的Join等联合查询操作，使得查询简化和高效，一些在主数据库中用不到的数据信息，在ReportingDatabase可以不用存储。</li>
<li>可以对ReportingDatabase重构优化，而不用去改变操作数据库。</li>
<li>对ReportingDatabase数据库的查询不会给操作数据库带来任何压力。</li>
<li>可以针对不同的查询请求建立不同的ReportingDatabase库。</li>
</ul>
<p>当然这也有一些缺点，比如从库数据的更新。如果使用SQLServer，本身也提供了一些如故障转移和复制机制来方便部署。</p>
<h1 id="三-什么时候可以考虑CQRS"><a href="#三-什么时候可以考虑CQRS" class="headerlink" title="三 什么时候可以考虑CQRS"></a>三 什么时候可以考虑CQRS</h1><p>CQRS模式有一些优点：</p>
<ol>
<li>分工明确，可以负责不同的部分</li>
<li>将业务上的命令和查询的职责分离能够提高系统的性能、可扩展性和安全性。并且在系统的演化中能够保持高度的灵活性，能够防止出现CRUD模式中，对查询或者修改中的某一方进行改动，导致另一方出现问题的情况。</li>
<li>逻辑清晰，能够看到系统中的那些行为或者操作导致了系统的状态变化。</li>
<li>可以从数据驱动(Data-Driven) 转到任务驱动(Task-Driven)以及事件驱动(<a href="http://en.wikipedia.org/wiki/Event-driven_programming">Event-Driven</a>).</li>
</ol>
<p>在下场景中，可以考虑使用CQRS模式：</p>
<ol>
<li>当在业务逻辑层有很多操作需要相同的实体或者对象进行操作的时候。CQRS使得我们可以对读和写定义不同的实体和方法，从而可以减少或者避免对某一方面的更改造成冲突</li>
<li>对于一些基于任务的用户交互系统，通常这类系统会引导用户通过一系列复杂的步骤和操作，通常会需要一些复杂的领域模型，并且整个团队已经熟悉领域驱动设计技术。写模型有很多和业务逻辑相关的命令操作的堆，输入验证，业务逻辑验证来保证数据的一致性。读模型没有业务逻辑以及验证堆，仅仅是返回DTO对象为视图模型提供数据。读模型最终和写模型相一致。</li>
<li>适用于一些需要对查询性能和写入性能分开进行优化的系统，尤其是读&#x2F;写比非常高的系统，横向扩展是必须的。比如，在很多系统中读操作的请求时远大于写操作。为适应这种场景，可以考虑将写模型抽离出来单独扩展，而将写模型运行在一个或者少数几个实例上。少量的写模型实例能够减少合并冲突发生的情况</li>
<li>适用于一些团队中，一些有经验的开发者可以关注复杂的领域模型，这些用到写操作，而另一些经验较少的开发者可以关注用户界面上的读模型。</li>
<li>对于系统在将来会随着时间不段演化，有可能会包含不同版本的模型，或者业务规则经常变化的系统</li>
<li>需要和其他系统整合，特别是需要和事件溯源Event Sourcing进行整合的系统，这样子系统的临时异常不会影响整个系统的其他部分。</li>
</ol>
<p>但是在以下场景中，可能不适宜使用CQRS：</p>
<ol>
<li>领域模型或者业务逻辑比较简单，这种情况下使用CQRS会把系统搞复杂。</li>
<li>对于简单的，CRUD模式的用户界面以及与之相关的数据访问操作已经足够的话，没必要使用CQRS，这些都是一个简单的对数据进行增删改查。</li>
<li>不适合在整个系统中到处使用该模式。在整个数据管理场景中的特定模块中CQRS可能比较有用。但是在有些地方使用CQRS会增加系统不必要的复杂性。</li>
</ol>
<h1 id="四-CQRS与Event-Sourcing的关系"><a href="#四-CQRS与Event-Sourcing的关系" class="headerlink" title="四 CQRS与Event Sourcing的关系"></a>四 CQRS与Event Sourcing的关系</h1><p>在CQRS中，查询方面，直接通过方法查询数据库，然后通过DTO将数据返回。在操作(Command)方面，是通过发送Command实现，由CommandBus处理特定的Command，然后由Command将特定的Event发布到EventBus上，然后EventBus使用特定的Handler来处理事件，执行一些诸如，修改，删除，更新等操作。这里，所有与Command相关的操作都通过Event实现。这样我们可以通过记录Event来记录系统的运行历史记录，并且能够方便的回滚到某一历史状态。<a href="http://msdn.microsoft.com/en-us/library/dn589792.aspx">Event Sourcing</a>就是用来进行存储和管理事件的。这里不展开介绍。</p>
<h1 id="五-CQRS的简单实现"><a href="#五-CQRS的简单实现" class="headerlink" title="五 CQRS的简单实现"></a>五 CQRS的简单实现</h1><p>CQRS模式在思想上比较简单，但是实现上还是有些复杂。它涉及到DDD，以及Event Sourcing，这里使用codeproject上的 <a href="http://www.codeproject.com/Articles/555855/Introduction-to-CQRS">Introduction to CQRS</a> 这篇文章的例子来说明CQRS模式。这个例子是一个简单的在线记日志(Diary)系统，实现了日志的增删改查功能。整体结构如下：</p>
<p><a href="http://images.cnitblog.com/blog/94031/201408/261851438603372.jpg"><img src="/2022/10/24/%E6%B5%85%E8%B0%88%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2%E8%81%8C%E8%B4%A3%E5%88%86%E7%A6%BBCQRS%E6%A8%A1%E5%BC%8F/5.png" alt="CQRS"></a></p>
<p>上图很清晰的说明了CQRS在读写方面的分离，在读方面，通过QueryFacade到数据库里去读取数据，这个库有可能是ReportingDB。在写方面，比较复杂，操作通过Command发送到CommandBus上，然后特定的CommandHandler处理请求，产生对应的Event，将Eevnt持久化后，通过EventBus特定的EevntHandler对数据库进行修改等操作。</p>
<p>例子代码可以到<a href="http://www.codeproject.com/Articles/555855/Introduction-to-CQRS">codeproject</a>上下载，整体结构如下：</p>
<p><a href="http://images.cnitblog.com/blog/94031/201408/261851446735785.png"><img src="/2022/10/24/%E6%B5%85%E8%B0%88%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2%E8%81%8C%E8%B4%A3%E5%88%86%E7%A6%BBCQRS%E6%A8%A1%E5%BC%8F/6.png" alt="DiaryCQRS project"></a></p>
<p>由三个项目构成，Diary.CQRS包含了所有的Domain和消息对象。Configuration通过使用一个名为StructMap的IOC来初始化一些变量方便Web调用，Web是一个简单的MVC3项目，在Controller中有与CQRS交互的代码。</p>
<p>下面分别看Query和Command方面的实现：</p>
<h2 id="Query方向的实现"><a href="#Query方向的实现" class="headerlink" title="Query方向的实现"></a>Query方向的实现</h2><p>查询方面很简单，日志列表和明细获取就是简单的查询。下面先看列表查询部分的代码。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActionResult <span class="title">Index</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    ViewBag.Model = ServiceLocator.ReportDatabase.GetItems();</span><br><span class="line">    <span class="keyword">return</span> View();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ActionResult <span class="title">Edit</span>(<span class="params">Guid id</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> item = ServiceLocator.ReportDatabase.GetById(id);</span><br><span class="line">    <span class="keyword">var</span> model = <span class="keyword">new</span> DiaryItemDto()</span><br><span class="line">    &#123;</span><br><span class="line">        Description = item.Description,</span><br><span class="line">        From = item.From,</span><br><span class="line">        Id = item.Id,</span><br><span class="line">        Title = item.Title,</span><br><span class="line">        To = item.To,</span><br><span class="line">        Version = item.Version</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> View(model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReportDatabase的GetItems和GetById(id)方法就是简单的查询，从命名可以看出他是ReportDatabase。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ReportDatabase</span> : <span class="title">IReportDatabase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;DiaryItemDto&gt; items = <span class="keyword">new</span> List&lt;DiaryItemDto&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DiaryItemDto <span class="title">GetById</span>(<span class="params">Guid id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> items.Where(a =&gt; a.Id == id).FirstOrDefault();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">DiaryItemDto item</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        items.Add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Delete</span>(<span class="params">Guid id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        items.RemoveAll(i =&gt; i.Id == id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;DiaryItemDto&gt; <span class="title">GetItems</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> items;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReportDataBase只是在内部维护了一个List的DiaryItemDto列表。在使用的时候，是通过IRepositoryDatabase对其进行操作的，这样便于mock代码。</p>
<p>Query方面的代码很简单。在实际的应用中，这一块就是直接对DB进行查询，然后通过DTO对象返回，这个DB可能是应对特定场景的报表数据库，这样可以提升查询性能。</p>
<p>下面来看Command方向的实现：</p>
<h2 id="Command方向的实现"><a href="#Command方向的实现" class="headerlink" title="Command方向的实现"></a>Command方向的实现</h2><p>Command的实现比较复杂，下面以简单的创建一个新的日志来说明。</p>
<p>在MVC的Control中，可以看到Add的Controller中只调用了一句话:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> ActionResult <span class="title">Add</span>(<span class="params">DiaryItemDto item</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ServiceLocator.CommandBus.Send(<span class="keyword">new</span> CreateItemCommand(Guid.NewGuid(), item.Title, item.Description, <span class="number">-1</span>, item.From, item.To));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RedirectToAction(<span class="string">&quot;Index&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先声明了一个CreateItemCommand，这个Command只是保存了一些必要的信息。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CreateItemCommand</span>:<span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Description &#123; <span class="keyword">get</span>;<span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTime From &#123; <span class="keyword">get</span>; <span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTime To &#123; <span class="keyword">get</span>; <span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CreateItemCommand</span>(<span class="params">Guid aggregateId, <span class="built_in">string</span> title, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">string</span> description,<span class="built_in">int</span> version,DateTime <span class="keyword">from</span>, DateTime to</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">aggregateId,version</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Title = title;</span><br><span class="line">        Description = description;</span><br><span class="line">        From = <span class="keyword">from</span>;</span><br><span class="line">        To = to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将Command发送到了CommandBus上，其实就是让CommandBus来选择合适的CommandHandler来处理。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CommandBus</span>:<span class="title">ICommandBus</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ICommandHandlerFactory _commandHandlerFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommandBus</span>(<span class="params">ICommandHandlerFactory commandHandlerFactory</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _commandHandlerFactory = commandHandlerFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span>&lt;<span class="title">T</span>&gt;(<span class="params">T command</span>) <span class="keyword">where</span> T : Command</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> handler = _commandHandlerFactory.GetHandler&lt;T&gt;();</span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            handler.Execute(command);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnregisteredDomainCommandException(<span class="string">&quot;no handler registered&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个里面需要值得注意的是CommandHandlerFactory这个类型的GetHandler方法，他接受一个类型为T的泛型，这里就是我们之前传入的CreateItemCommand。来看他的GetHandler方法。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StructureMapCommandHandlerFactory</span> : <span class="title">ICommandHandlerFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ICommandHandler</span>&lt;<span class="title">T</span>&gt; <span class="title">GetHandler</span>&lt;<span class="title">T</span>&gt;() <span class="keyword">where</span> T : Command</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> handlers = GetHandlerTypes&lt;T&gt;().ToList();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> cmdHandler = handlers.Select(handler =&gt; </span><br><span class="line">            (ICommandHandler&lt;T&gt;)ObjectFactory.GetInstance(handler)).FirstOrDefault();</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> cmdHandler;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IEnumerable</span>&lt;<span class="title">Type</span>&gt; <span class="title">GetHandlerTypes</span>&lt;<span class="title">T</span>&gt;() <span class="keyword">where</span> T : Command</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> handlers = <span class="keyword">typeof</span>(ICommandHandler&lt;&gt;).Assembly.GetExportedTypes()</span><br><span class="line">            .Where(x =&gt; x.GetInterfaces()</span><br><span class="line">                .Any(a =&gt; a.IsGenericType &amp;&amp; a.GetGenericTypeDefinition() == <span class="keyword">typeof</span>(ICommandHandler&lt;&gt;) ))</span><br><span class="line">                .Where(h=&gt;h.GetInterfaces()</span><br><span class="line">                    .Any(ii=&gt;ii.GetGenericArguments()</span><br><span class="line">                        .Any(aa=&gt;aa==<span class="keyword">typeof</span>(T)))).ToList();</span><br><span class="line"></span><br><span class="line">           </span><br><span class="line">        <span class="keyword">return</span> handlers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到，他首先查找当前的程序集中(ICommandHandler)所在的程序集中的所有的实现了ICommandHandler的接口的类型，然后在所有的类型找查找实现了该泛型接口并且泛型的类型参数类型为T类型的所有类型。以上面的代码为例，就是要找出实现了ICommandHandler<CreateItemCommand>接口的类型。可以看到就是CreateItemCommandHandler类型。</CreateItemCommand></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CreateItemCommandHandler</span> : <span class="title">ICommandHandler</span>&lt;<span class="title">CreateItemCommand</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IRepository&lt;DiaryItem&gt; _repository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CreateItemCommandHandler</span>(<span class="params">IRepository&lt;DiaryItem&gt; repository</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _repository = repository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">CreateItemCommand command</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="string">&quot;command&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_repository == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">&quot;Repository is not initialized.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> aggregate = <span class="keyword">new</span> DiaryItem(command.Id, command.Title, command.Description, command.From, command.To);</span><br><span class="line">        aggregate.Version = <span class="number">-1</span>;</span><br><span class="line">        _repository.Save(aggregate, aggregate.Version);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到之后然后使用IOC实例化了该对象返回。</p>
<p>现在CommandBus中，找到了处理特定Command的Handler。然后执行该类型的Execute方法。</p>
<p>可以看到在该类型中实例化了一个名为aggregate的DiaryItem对象。这个和我们之前查询所用到的DiaryItemDto有所不同，这个一个领域对象，里面包含了一系列事件。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DiaryItem</span> : <span class="title">AggregateRoot</span>, </span><br><span class="line">    <span class="title">IHandle</span>&lt;<span class="title">ItemCreatedEvent</span>&gt;,</span><br><span class="line">    <span class="title">IHandle</span>&lt;<span class="title">ItemRenamedEvent</span>&gt;,</span><br><span class="line">    <span class="title">IHandle</span>&lt;<span class="title">ItemFromChangedEvent</span>&gt;, </span><br><span class="line">    <span class="title">IHandle</span>&lt;<span class="title">ItemToChangedEvent</span>&gt;,</span><br><span class="line">    <span class="title">IHandle</span>&lt;<span class="title">ItemDescriptionChangedEvent</span>&gt;,</span><br><span class="line">    <span class="title">IOriginator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> DateTime From &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTime To &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Description &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiaryItem</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiaryItem</span>(<span class="params">Guid id,<span class="built_in">string</span> title, <span class="built_in">string</span> description,  DateTime <span class="keyword">from</span>, DateTime to</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ApplyChange(<span class="keyword">new</span> ItemCreatedEvent(id, title,description, <span class="keyword">from</span>, to));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangeTitle</span>(<span class="params"><span class="built_in">string</span> title</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ApplyChange(<span class="keyword">new</span> ItemRenamedEvent(Id, title));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span>(<span class="params">ItemCreatedEvent e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Title = e.Title;</span><br><span class="line">        From = e.From;</span><br><span class="line">        To = e.To;</span><br><span class="line">        Id = e.AggregateId;</span><br><span class="line">        Description = e.Description;</span><br><span class="line">        Version = e.Version;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span>(<span class="params">ItemRenamedEvent e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Title = e.Title;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ItemCreatedEvent 事件的定义如下，其实就是用来存储传输过程中需要用到的数据。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ItemCreatedEvent</span>:<span class="title">Event</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTime From &#123; <span class="keyword">get</span>; <span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTime To &#123; <span class="keyword">get</span>; <span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Description &#123; <span class="keyword">get</span>;<span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ItemCreatedEvent</span>(<span class="params">Guid aggregateId, <span class="built_in">string</span> title ,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">string</span> description, DateTime <span class="keyword">from</span>, DateTime to</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        AggregateId = aggregateId;</span><br><span class="line">        Title = title;</span><br><span class="line">        From = <span class="keyword">from</span>;</span><br><span class="line">        To = to;</span><br><span class="line">        Description = description;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在Domain对象中，除了定义基本的字段外，还定义了一些相应的事件，比如在构造函数中，实际上是发起了一个名为ItemCreateEvent的事件，同时还定义了处理时间的逻辑，这些逻辑都放在名为Handle的接口方法发，例如ItemCerateEvent的处理方法为Handle(ItemCreateEvent)方法。</p>
<p>ApplyChange方法在AggregateRoot对象中，他是聚集根，这是DDD中的概念。通过这个根可以串起所有对象。 该类实现了IEventProvider接口，他保存了所有在_changes中的所有没有提交的变更，其中的ApplyChange的用来为特定的Event查找Eventhandler的方法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AggregateRoot</span> : <span class="title">IEventProvider</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> List&lt;Event&gt; _changes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Guid Id &#123; <span class="keyword">get</span>; <span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Version &#123; <span class="keyword">get</span>; <span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> EventVersion &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AggregateRoot</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _changes = <span class="keyword">new</span> List&lt;Event&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;Event&gt; <span class="title">GetUncommittedChanges</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _changes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MarkChangesAsCommitted</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _changes.Clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadsFromHistory</span>(<span class="params">IEnumerable&lt;Event&gt; history</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> e <span class="keyword">in</span> history) ApplyChange(e, <span class="literal">false</span>);</span><br><span class="line">        Version = history.Last().Version;</span><br><span class="line">        EventVersion = Version;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">ApplyChange</span>(<span class="params">Event @<span class="keyword">event</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ApplyChange(@event, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ApplyChange</span>(<span class="params">Event @<span class="keyword">event</span>, <span class="built_in">bool</span> isNew</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dynamic</span> d = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        d.Handle(Converter.ChangeTo(@event, @event.GetType()));</span><br><span class="line">        <span class="keyword">if</span> (isNew)</span><br><span class="line">        &#123;</span><br><span class="line">            _changes.Add(@event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ApplyChange的实现中，this其实就是对应的实现了AggregateRoot的DiaryItem的Domain对象，调用的Handle方法就是我们之前在DiaryItem中定义的行为。然后将该event保存在内部的未提交的事件列表中。相关的信息及事件都保存在了定义的aggregate对象中并返回。</p>
<p>然后Command继续执行，然后调用了_repository.Save(aggregate, aggregate.Version);这个方法。先看这个Repository对象。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Repository</span>&lt;<span class="title">T</span>&gt; : <span class="title">IRepository</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">AggregateRoot</span>, <span class="title">new</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IEventStorage _storage;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">object</span> _lockStorage = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Repository</span>(<span class="params">IEventStorage storage</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _storage = storage;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Save</span>(<span class="params">AggregateRoot aggregate, <span class="built_in">int</span> expectedVersion</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (aggregate.GetUncommittedChanges().Any())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">lock</span> (_lockStorage)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> item = <span class="keyword">new</span> T();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (expectedVersion != <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    item = GetById(aggregate.Id);</span><br><span class="line">                    <span class="keyword">if</span> (item.Version != expectedVersion)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrencyException(<span class="built_in">string</span>.Format(<span class="string">&quot;Aggregate &#123;0&#125; has been previously modified&quot;</span>,</span><br><span class="line">                                                                        item.Id));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                _storage.Save(aggregate);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">GetById</span>(<span class="params">Guid id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        IEnumerable&lt;Event&gt; events;</span><br><span class="line">        <span class="keyword">var</span> memento = _storage.GetMemento&lt;BaseMemento&gt;(id);</span><br><span class="line">        <span class="keyword">if</span> (memento != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            events = _storage.GetEvents(id).Where(e=&gt;e.Version&gt;=memento.Version);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            events = _storage.GetEvents(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> obj = <span class="keyword">new</span> T();</span><br><span class="line">        <span class="keyword">if</span>(memento!=<span class="literal">null</span>)</span><br><span class="line">            ((IOriginator)obj).SetMemento(memento);</span><br><span class="line">            </span><br><span class="line">        obj.LoadsFromHistory(events);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要是用来对事件进行持久化的。 所有的聚合的变动都会存在该Repository中，首先，检查当前的聚合是否和之前存储在storage中的聚合一致，如果不一致，则表示对象在其他地方被更改过，抛出ConcurrencyException，否则将该变动保存在Event Storage中。</p>
<p>IEventStorage用来存储所有的事件，其实现类型为InMemoryEventStorage。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InMemoryEventStorage</span>:<span class="title">IEventStorage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Event&gt; _events;</span><br><span class="line">    <span class="keyword">private</span> List&lt;BaseMemento&gt; _mementos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IEventBus _eventBus;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InMemoryEventStorage</span>(<span class="params">IEventBus eventBus</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _events = <span class="keyword">new</span> List&lt;Event&gt;();</span><br><span class="line">        _mementos = <span class="keyword">new</span> List&lt;BaseMemento&gt;();</span><br><span class="line">        _eventBus = eventBus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;Event&gt; <span class="title">GetEvents</span>(<span class="params">Guid aggregateId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> events = _events.Where(p =&gt; p.AggregateId == aggregateId).Select(p =&gt; p);</span><br><span class="line">        <span class="keyword">if</span> (events.Count() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AggregateNotFoundException(<span class="built_in">string</span>.Format(<span class="string">&quot;Aggregate with Id: &#123;0&#125; was not found&quot;</span>, aggregateId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> events;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Save</span>(<span class="params">AggregateRoot aggregate</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> uncommittedChanges = aggregate.GetUncommittedChanges();</span><br><span class="line">        <span class="keyword">var</span> version = aggregate.Version;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> @event <span class="keyword">in</span> uncommittedChanges)</span><br><span class="line">        &#123;</span><br><span class="line">            version++;</span><br><span class="line">            <span class="keyword">if</span> (version &gt; <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (version % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> originator = (IOriginator)aggregate;</span><br><span class="line">                    <span class="keyword">var</span> memento = originator.GetMemento();</span><br><span class="line">                    memento.Version = version;</span><br><span class="line">                    SaveMemento(memento);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            @event.Version=version;</span><br><span class="line">            _events.Add(@event);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> @event <span class="keyword">in</span> uncommittedChanges)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> desEvent = Converter.ChangeTo(@event, @event.GetType());</span><br><span class="line">            _eventBus.Publish(desEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">GetMemento</span>&lt;<span class="title">T</span>&gt;(<span class="params">Guid aggregateId</span>) <span class="keyword">where</span> T : BaseMemento</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> memento = _mementos.Where(m =&gt; m.Id == aggregateId).Select(m=&gt;m).LastOrDefault();</span><br><span class="line">        <span class="keyword">if</span> (memento != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> (T) memento;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SaveMemento</span>(<span class="params">BaseMemento memento</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _mementos.Add(memento);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在GetEvent方法中，会找到所有的聚合根Id相关的事件。在Save方法中，将所有的事件保存在内存中，然后每隔三个事件建立一个快照。可以看到这里面使用了备忘录模式。</p>
<p>然后在foreach循环中，对于所有的没有提交的变更，EventBus将该事件发布出去。</p>
<p>现在，所有的发生变更的事件已经记录下来了。事件已经被发布到EventBus上，然后对应的EventHandler再处理对应的事件，然后与DB交互。现在来看EventBus的Publish方法。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventBus</span>:<span class="title">IEventBus</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IEventHandlerFactory _eventHandlerFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventBus</span>(<span class="params">IEventHandlerFactory eventHandlerFactory</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _eventHandlerFactory = eventHandlerFactory;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Publish</span>&lt;<span class="title">T</span>&gt;(<span class="params">T @<span class="keyword">event</span></span>) <span class="keyword">where</span> T : Event</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> handlers = _eventHandlerFactory.GetHandlers&lt;T&gt;();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> eventHandler <span class="keyword">in</span> handlers)</span><br><span class="line">        &#123;</span><br><span class="line">            eventHandler.Handle(@event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到EventBus的Publish和CommandBus中的Send方法很相似，都是首先通过EventHandlerFactory查找对应Event的Handler，然后调用其Handler方法。比如</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StructureMapEventHandlerFactory</span> : <span class="title">IEventHandlerFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IEnumerable</span>&lt;<span class="title">IEventHandler</span>&lt;<span class="title">T</span>&gt;&gt; <span class="title">GetHandlers</span>&lt;<span class="title">T</span>&gt;() <span class="keyword">where</span> T : Event</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> handlers = GetHandlerType&lt;T&gt;();</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">var</span> lstHandlers = handlers.Select(handler =&gt; (IEventHandler&lt;T&gt;) ObjectFactory.GetInstance(handler)).ToList();</span><br><span class="line">        <span class="keyword">return</span> lstHandlers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="title">IEnumerable</span>&lt;<span class="title">Type</span>&gt; <span class="title">GetHandlerType</span>&lt;<span class="title">T</span>&gt;() <span class="keyword">where</span> T : Event</span></span><br><span class="line">    &#123;</span><br><span class="line">           </span><br><span class="line">        <span class="keyword">var</span> handlers = <span class="keyword">typeof</span>(IEventHandler&lt;&gt;).Assembly.GetExportedTypes()</span><br><span class="line">            .Where(x =&gt; x.GetInterfaces()</span><br><span class="line">                .Any(a =&gt; a.IsGenericType &amp;&amp; a.GetGenericTypeDefinition() == <span class="keyword">typeof</span>(IEventHandler&lt;&gt;)))</span><br><span class="line">                .Where(h =&gt; h.GetInterfaces()</span><br><span class="line">                    .Any(ii =&gt; ii.GetGenericArguments()</span><br><span class="line">                        .Any(aa =&gt; aa == <span class="keyword">typeof</span>(T))))</span><br><span class="line">                 .ToList();</span><br><span class="line">        <span class="keyword">return</span> handlers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后返回并实例化了ItemCreatedEventHandler 对象，该对象的实现如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ItemCreatedEventHandler</span> : <span class="title">IEventHandler</span>&lt;<span class="title">ItemCreatedEvent</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IReportDatabase _reportDatabase;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ItemCreatedEventHandler</span>(<span class="params">IReportDatabase reportDatabase</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _reportDatabase = reportDatabase;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span>(<span class="params">ItemCreatedEvent handle</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        DiaryItemDto item = <span class="keyword">new</span> DiaryItemDto()</span><br><span class="line">            &#123;</span><br><span class="line">                Id = handle.AggregateId,</span><br><span class="line">                Description =  handle.Description,</span><br><span class="line">                From = handle.From,</span><br><span class="line">                Title = handle.Title,</span><br><span class="line">                To=handle.To,</span><br><span class="line">                Version =  handle.Version</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">        _reportDatabase.Add(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在Handler方法中，从事件中获取参数，然后新建DTO对象，然后将该对象更新到DB中。</p>
<p>到此，整个Command执行完成。</p>
<h1 id="六-结语"><a href="#六-结语" class="headerlink" title="六 结语"></a>六 结语</h1><p>CQRS是一种思想很简单清晰的设计模式，他通过在业务上分离操作和查询来使得系统具有更好的可扩展性及性能，使得能够对系统的不同部分进行扩展和优化。在CQRS中，所有的涉及到对DB的操作都是通过发送Command，然后特定的Command触发对应事件来完成操作，这个过程是异步的，并且所有涉及到对系统的变更行为都包含在具体的事件中，结合Eventing Source模式，可以记录下所有的事件，而不是以往的某一点的数据信息，这些信息可以作为系统的操作日志，可以来对系统进行回退或者重放。</p>
<p>CQRS 模式在实现上有些复杂，很多地方比如AggregationRoot、Domain Object都涉及到DDD中的相关概念，本人对DDD不太懂。这里仅为了演示CQRS模式，所以使用的例子是codeproject上的，末尾列出了一些参考文章，如果您想了解更多，可以有针对性的阅读。</p>
<p>最后，希望CQRS模式能让您在设计高性能，可扩展性的程序时能够多一种选择和考虑。</p>
<h1 id="七-参考文献"><a href="#七-参考文献" class="headerlink" title="七 参考文献"></a>七 参考文献</h1><ol>
<li>Introduction to CQRS <a href="http://www.codeproject.com/Articles/555855/Introduction-to-CQRS">http://www.codeproject.com/Articles/555855/Introduction-to-CQRS</a></li>
<li>CQRS <a href="http://martinfowler.com/bliki/CQRS.html">http://martinfowler.com/bliki/CQRS.html</a></li>
<li>CQRS Journey <a href="http://msdn.microsoft.com/en-us/library/jj554200.aspx">http://msdn.microsoft.com/en-us/library/jj554200.aspx</a></li>
<li>Command and Query Responsibility Segregation (CQRS) Pattern <a href="http://msdn.microsoft.com/en-us/library/dn568103.aspx">http://msdn.microsoft.com/en-us/library/dn568103.aspx</a></li>
<li>EntityFramework之领域驱动设计实践：CQRS体系结构模式 <a href="http://www.cnblogs.com/daxnet/archive/2010/08/02/1790299.html">http://www.cnblogs.com/daxnet/archive/2010/08/02/1790299.html</a></li>
<li>Event Sourcing Pattern <a href="http://msdn.microsoft.com/en-us/library/dn589792.aspx">http://msdn.microsoft.com/en-us/library/dn589792.aspx</a></li>
</ol>
]]></content>
      <categories>
        <category>DDD领域驱动设计</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis知识点总结</title>
    <url>/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="1-在分布式数据库中CAP原理CAP-BASE"><a href="#1-在分布式数据库中CAP原理CAP-BASE" class="headerlink" title="1.在分布式数据库中CAP原理CAP+BASE"></a>1.在分布式数据库中CAP原理CAP+BASE</h1><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:Consistency（强一致性）</span><br><span class="line"></span><br><span class="line">A:Availability（可用性）</span><br><span class="line"></span><br><span class="line">P:Partition tolerance（分区容错性）</span><br><span class="line"></span><br><span class="line">注意：分布式架构的时候必须做出取舍。</span><br><span class="line">一致性和可用性之间取一个平衡。多余大多数web应用，其实并不需要强一致性。因此牺牲C换取P，这是目前分布式数据库产品的方向</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="经典CAP图"><a href="#经典CAP图" class="headerlink" title="经典CAP图"></a>经典CAP图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，</span><br><span class="line">最多只能同时较好的满足两个。</span><br><span class="line">因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三大类：</span><br><span class="line">CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。</span><br><span class="line">CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。</span><br><span class="line">AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/1.png" alt="在这里插入图片描述"></p>
<h3 id="Base"><a href="#Base" class="headerlink" title="Base"></a>Base</h3><p>BASE就是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。</p>
<p>BASE其实是下面三个术语的缩写：<br>    基本可用（Basically Available）<br>    软状态（Soft state）<br>    最终一致（Eventually consistent）</p>
<p>它的思想是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观。为什么这么说呢，缘由就在于大型系统往往由于地域分布和极高性能的要求，不可能采用分布式事务来完成这些指标，要想获得这些指标，我们必须采用另外一种方式来完成，这里BASE就是解决这个问题的办法</p>
<h3 id="分布式-集群简介"><a href="#分布式-集群简介" class="headerlink" title="分布式+集群简介"></a>分布式+集群简介</h3><p>分布式系统</p>
<p>分布式系统（distributed system）<br> 由多台计算机和通信的软件组件通过计算机网络连接（本地网络或广域网）组成。分布式系统是建立在网络之上的软件系统。正是因为软件的特性，所以分布式系统具有高度的内聚性和透明性。因此，网络和分布式系统之间的区别更多的在于高层软件（特别是操作系统），而不是硬件。分布式系统可以应用在在不同的平台上如：Pc、工作站、局域网和广域网上等。</p>
<p>简单来讲：<br>1分布式：不同的多台服务器上面部署不同的服务模块（工程），他们之间通过Rpc&#x2F;Rmi之间通信和调用，对外提供服务和组内协作。</p>
<p>2集群：不同的多台服务器上面部署相同的服务模块，通过分布式调度软件进行统一的调度，对外提供服务和访问。</p>
<h1 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h1><table>
<thead>
<tr>
<th>数据类型</th>
<th>可以存储的值</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>STRING</td>
<td>字符串、整数或者浮点数</td>
<td>对整个字符串或者字符串的其中一部分执行操作对整数和浮点数执行自增或者自减操作</td>
</tr>
<tr>
<td>LIST</td>
<td>列表</td>
<td>从两端压入或者弹出元素对单个或者多个元素进行修剪，只保留一个范围内的元素</td>
</tr>
<tr>
<td>SET</td>
<td>无序集合</td>
<td>添加、获取、移除单个元素，检查一个元素是否存在于集合中，计算交集、并集、差集，从集合里面随机获取元素</td>
</tr>
<tr>
<td>HASH</td>
<td>包含键值对的无序散列表</td>
<td>添加、获取、移除单个键值对，获取所有键值对，检查某个键是否存在</td>
</tr>
<tr>
<td>ZSET</td>
<td>有序集合</td>
<td>添加、获取、删除元素，根据分值范围或者成员来获取元素，计算一个键的排名</td>
</tr>
</tbody></table>
<h3 id="Redis字符串-String"><a href="#Redis字符串-String" class="headerlink" title="Redis字符串(String)"></a>Redis字符串(String)</h3><h4 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h4><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/2.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411163156202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">set/get/del/append/strlen</span><br><span class="line"></span><br><span class="line">Incr/decr/incrby/decrby,一定要是数字才能进行加减</span><br><span class="line"></span><br><span class="line">getrange/setrange</span><br></pre></td></tr></table></figure>

<p>getrange:获取指定区间范围内的值，类似between……and的关系<br>从零到负一表示全部</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/3.png" alt="在这里插入图片描述"></p>
<p>setrange设置指定区间范围内的值，格式是setrange key值 具体值</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/4.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setex(set with expire)键秒值/setnx(set if not exist)</span><br></pre></td></tr></table></figure>

<p>setex:设置带过期时间的key，动态设置。<br>setex 键 秒值 真实值</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/5.png" alt="在这里插入图片描述"></p>
<p>setnx:只有在 key 不存在时设置 key 的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mset/mget/msetnx</span><br></pre></td></tr></table></figure>

<p>mset:同时设置一个或多个 key-value 对。</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/6.png" alt="在这里插入图片描述"></p>
<p>mget:获取所有(一个或多个)给定 key 的值。</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/7.png" alt="在这里插入图片描述"></p>
<p>msetnx:同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/8.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getset(先get再set)</span><br></pre></td></tr></table></figure>

<p>getset:将给定 key 的值设为 value ，并返回 key 的旧值(old value)。<br>简单一句话，先get然后立即set</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/9.png" alt="在这里插入图片描述"></p>
<h3 id="Redis列表-List"><a href="#Redis列表-List" class="headerlink" title="Redis列表(List)"></a>Redis列表(List)</h3><h4 id="常用-1"><a href="#常用-1" class="headerlink" title="常用"></a>常用</h4><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/10.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411163635194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lpush/rpush/lrange</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lpop/rpop</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/11.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lindex，按照索引下标获得元素(从上到下)</span><br></pre></td></tr></table></figure>

<p>通过索引获取列表中的元素 lindex key index</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/12.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">llen</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lrem key 删N个value</span><br></pre></td></tr></table></figure>

<ul>
<li>从left往right删除2个值等于v1的元素，返回的值为实际删除的数量</li>
<li>LREM list3 0 值，表示删除全部给定的值。零个就是全部值</li>
</ul>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/13.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ltrim key 开始index 结束index，截取指定范围的值后再赋值给key</span><br></pre></td></tr></table></figure>

<p>ltrim：截取指定索引区间的元素，格式是ltrim list的key 起始索引 结束索引</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/14.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpoplpush 源列表 目的列表</span><br></pre></td></tr></table></figure>

<p>移除列表的最后一个元素，并将该元素添加到另一个列表并返回</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/15.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lset key index value</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/16.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">linsert key  before/after 值1 值2</span><br></pre></td></tr></table></figure>

<p>在list某个已有值的前后再添加具体值</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/17.png" alt="在这里插入图片描述"></p>
<h3 id="Redis集合-Set"><a href="#Redis集合-Set" class="headerlink" title="Redis集合(Set)"></a>Redis集合(Set)</h3><h4 id="常用-2"><a href="#常用-2" class="headerlink" title="常用"></a>常用</h4><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/18.png" alt="在这里插入图片描述"></p>
<h4 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sadd/smembers/sismember</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/19.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scard，获取集合里面的元素个数</span><br></pre></td></tr></table></figure>

<p>获取集合里面的元素个数</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/20.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">srem key value 删除集合中元素</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/21.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">srandmember key 某个整数(随机出几个数)</span><br></pre></td></tr></table></figure>

<ul>
<li>从set集合里面随机取出2个</li>
<li>如果超过最大数量就全部取出，</li>
<li>如果写的值是负数，比如-3 ，表示需要取出3个，但是可能会有重复值。</li>
</ul>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/22.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spop key 随机出栈</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/23.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">smove key1 key2 在key1里某个值      作用是将key1里的某个值赋给key2</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/24.png" alt="在这里插入图片描述"></p>
<h4 id="数学集合类"><a href="#数学集合类" class="headerlink" title="数学集合类"></a>数学集合类</h4><h5 id="差集：sdiff"><a href="#差集：sdiff" class="headerlink" title="差集：sdiff"></a>差集：sdiff</h5><p>在第一个set里面而不在后面任何一个set里面的项</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/25.png" alt="在这里插入图片描述"></p>
<h5 id="交集：sinter"><a href="#交集：sinter" class="headerlink" title="交集：sinter"></a>交集：sinter</h5><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/26.png" alt="在这里插入图片描述"></p>
<h5 id="并集：sunion"><a href="#并集：sunion" class="headerlink" title="并集：sunion"></a>并集：sunion</h5><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/27.png" alt="在这里插入图片描述"></p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/28.png" alt="在这里插入图片描述"></p>
<h3 id="Redis哈希-Hash"><a href="#Redis哈希-Hash" class="headerlink" title="Redis哈希(Hash)"></a>Redis哈希(Hash)</h3><h4 id="常用-3"><a href="#常用-3" class="headerlink" title="常用"></a>常用</h4><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/29.png" alt="在这里插入图片描述"></p>
<h4 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hset/hget/hmset/hmget/hgetall/hdel</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/30.png" alt="在这里插入图片描述"></p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/31.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hlen</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexists key 在key里面的某个值的key</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hkeys/hvals</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/32.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hincrby/hincrbyfloat</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/33.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hsetnx</span><br></pre></td></tr></table></figure>

<p>不存在赋值，存在了无效</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/34.png" alt="在这里插入图片描述"></p>
<h3 id="Redis有序集合Zset-sorted-set"><a href="#Redis有序集合Zset-sorted-set" class="headerlink" title="Redis有序集合Zset(sorted set)"></a>Redis有序集合Zset(sorted set)</h3><h4 id="常用-4"><a href="#常用-4" class="headerlink" title="常用"></a>常用</h4><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/35.png" alt="在这里插入图片描述"></p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/36.png" alt="在这里插入图片描述"></p>
<h4 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zadd/zrange</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zrangebyscore key 开始score 结束score</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/37.png" alt="在这里插入图片描述"></p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/38.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zrem key 某score下对应的value值，作用是删除元素</span><br></pre></td></tr></table></figure>


<p>删除元素，格式是zrem zset的key 项的值，项的值可以是多个zrem key score某个对应值，可以是多个值</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/39.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zcard/zcount key score区间/zrank key values值，作用是获得下标值/zscore key 对应值,获得分数</span><br></pre></td></tr></table></figure>

<h5 id="zcard-：获取集合中元素个数"><a href="#zcard-：获取集合中元素个数" class="headerlink" title="zcard ：获取集合中元素个数"></a>zcard ：获取集合中元素个数</h5><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/40.png" alt="在这里插入图片描述"></p>
<h5 id="zcount-：获取分数区间内元素个数，zcount-key-开始分数区间-结束分数区间"><a href="#zcount-：获取分数区间内元素个数，zcount-key-开始分数区间-结束分数区间" class="headerlink" title="zcount ：获取分数区间内元素个数，zcount key 开始分数区间 结束分数区间"></a>zcount ：获取分数区间内元素个数，zcount key 开始分数区间 结束分数区间</h5><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/41.png" alt="在这里插入图片描述"></p>
<h5 id="zrank：-获取value在zset中的下标位置"><a href="#zrank：-获取value在zset中的下标位置" class="headerlink" title="zrank： 获取value在zset中的下标位置"></a>zrank： 获取value在zset中的下标位置</h5><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/42.png" alt="在这里插入图片描述"></p>
<h5 id="zscore：按照值获得对应的分数"><a href="#zscore：按照值获得对应的分数" class="headerlink" title="zscore：按照值获得对应的分数"></a>zscore：按照值获得对应的分数</h5><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/43.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zrevrank key values值，作用是逆序获得下标值</span><br></pre></td></tr></table></figure>

<p>正序、逆序获得下标索引值</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/44.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zrevrange</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/45.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zrevrangebyscore  key 结束score 开始score</span><br></pre></td></tr></table></figure>

<p>zrevrangebyscore zset1 90 60 withscores    分数是反着来的</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/46.png" alt="在这里插入图片描述"></p>
<h2 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h2><h3 id="1、Geospatial-地理位置"><a href="#1、Geospatial-地理位置" class="headerlink" title="1、Geospatial 地理位置"></a>1、Geospatial 地理位置</h3><p><strong>geoadd</strong> key 经度 纬度 城市（地点名称） </p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/47.png" alt="在这里插入图片描述"></p>
<p> 也可以一次加多个</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/48.png" alt="在这里插入图片描述"></p>
<p><strong>zrange</strong> 获得指定key中所有坐标信息</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/49.png" alt="在这里插入图片描述"></p>
<p><strong>zrem</strong> 删除指定key下指定目标的数据</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/50.png" alt="在这里插入图片描述"></p>
<p> <strong>geopos</strong> 获得指定key中指定地点的坐标</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/51.png" alt="在这里插入图片描述"></p>
<p> <strong>geodist</strong> key 第一个点 第二个点 单位 返回指定key中指定地点的距离 （单位可选 m（米）, km（千米）, ft(英尺), mi（英里））</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/52.png" alt="在这里插入图片描述"></p>
<p> <strong>GEORADIUS</strong> key 目标经度 目标纬度 查询范围 查询单位 显示范围内位置的坐标 目标坐标与范围内坐标的距离 取几条 距离排序  斜体字标识非必填参数</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/53.png" alt="在这里插入图片描述"></p>
<p><strong>GEORADIUSBYMEMBER</strong> 查询指定key中指定一个目标范围内的数据</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/54.png" alt="在这里插入图片描述"></p>
<p><strong>应用场景：</strong></p>
<p>　　附近的人，附近的美食</p>
<h3 id="2、Hyperloglog"><a href="#2、Hyperloglog" class="headerlink" title="2、Hyperloglog"></a>2、Hyperloglog</h3><p><strong>什么是基数？</strong></p>
<p>A {1,3,5,7,8,7} </p>
<p>B{1,3,5,7,8} </p>
<p>基数（不重复的元素） &#x3D; 5，可以接受误差！</p>
<p><strong>简介</strong></p>
<p>Redis 2.8.9 版本就更新了 Hyperloglog 数据结构！</p>
<p> Redis Hyperloglog 基数统计的算法！</p>
<p>优点：占用的内存是固定，2^64 不同的元素的技术，只需要废 12KB内存！如果要从内存角度来比较的 话 Hyperloglog 首选！ 网页的 UV （一个人访问一个网站多次，但是还是算作一个人！）</p>
<p> 传统的方式， set 保存用户的id，然后就可以统计 set 中的元素数量作为标准判断 ! </p>
<p>这个方式如果保存大量的用户id，就会比较麻烦！我们的目的是为了计数，而不是保存用户id； </p>
<p>0.81% 错误率！ 统计UV任务，可以忽略不计的！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PFadd mykey a b c d e f g h i j # 创建第一组元素 mykey</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT mykey # 统计 mykey 元素的基数数量</span><br><span class="line">(integer) 10</span><br><span class="line">127.0.0.1:6379&gt; PFadd mykey2 i j z x c v b n m # 创建第二组元素 mykey2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT mykey2</span><br><span class="line">(integer) 9</span><br><span class="line">127.0.0.1:6379&gt; PFMERGE mykey3 mykey mykey2 # 合并两组 mykey mykey2 =&gt; mykey3 并集</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT mykey3 # 看并集的数量！</span><br><span class="line">(integer) 15</span><br></pre></td></tr></table></figure>

<p>如果允许容错，那么一定可以使用 Hyperloglog ！</p>
<p>如果不允许容错，就使用 set 或者自己的数据类型即可！</p>
<h3 id="3、Bitmap"><a href="#3、Bitmap" class="headerlink" title="3、Bitmap"></a>3、Bitmap</h3><p>统计用户信息，活跃，不活跃！ 登录 、 未登录！ 打卡，365打卡！ 两个状态的，都可以使用</p>
<p>Bitmap 位图，数据结构！ 都是操作二进制位来进行记录，就只有0 和 1 两个状态！</p>
<p>365 天 &#x3D; 365 bit 1字节 &#x3D; 8bit 46 个字节左右！</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/55.png" alt="在这里插入图片描述"></p>
<p>使用bitmap 来记录 周一到周日的打卡！</p>
<p>周一：1 周二：0 周三：0 周四：1 ……</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/56.png" alt="在这里插入图片描述"></p>
<p>查看某一天是否有打卡！</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getbit sign 3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 6</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<p>统计操作，统计 打卡的天数！</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitcount sign <span class="comment"># 统计这周的打卡记录，就可以看到是否有全勤！</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>



<h1 id="3-谈下你对-Redis-的了解？"><a href="#3-谈下你对-Redis-的了解？" class="headerlink" title="3.谈下你对 Redis 的了解？"></a>3.谈下你对 Redis 的了解？</h1><p>Redis（全称：Remote Dictionary Server 远程字典服务）是一个开源的使用 ANSIC 语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API。</p>
<h1 id="4-Redis-一般都有哪些使用场景？"><a href="#4-Redis-一般都有哪些使用场景？" class="headerlink" title="4.Redis 一般都有哪些使用场景？"></a>4.Redis 一般都有哪些使用场景？</h1><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/57.png" alt="在这里插入图片描述"></p>
<h5 id="Redis-适合的场景"><a href="#Redis-适合的场景" class="headerlink" title="Redis 适合的场景"></a>Redis 适合的场景</h5><p>1.缓存：减轻 MySQL 的查询压力，提升系统性能；</p>
<p>2.排行榜：利用 Redis 的 SortSet（有序集合）实现；<br>3.计算器&#x2F;限速器：利用 Redis 中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等。这类操作如果用 MySQL，频繁的读写会带来相当大的压力；限速器比较典型的使用场景是限制某个用户访问某个 API 的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力；<br>4.好友关系：利用集合的一些命令，比如求交集、并集、差集等。可以方便解决一些共同好友、共同爱好之类的功能；</p>
<p>5.消息队列：除了 Redis 自身的发布&#x2F;订阅模式，我们也可以利用 List 来实现一个队列机制，比如：到货通知、邮件发送之类的需求，不需	要高可靠，但是会带来非常大的 DB 压力，完全可以用 List 来完成异步解耦；</p>
<p>6.Session 共享：Session 是保存在服务器的文件中，如果是集群服务，同一个用户过来	可能落在不同机器上，这就会导致用户频繁登陆；采用 Redis 保存 Session 后，无论用户落在那台机器上都能够获取到对应的 Session 信息。</p>
<h5 id="Redis-不适合的场景"><a href="#Redis-不适合的场景" class="headerlink" title="Redis 不适合的场景"></a>Redis 不适合的场景</h5><p>数据量太大、数据访问频率非常低的业务都不适合使用 Redis，数据太大会增加成本，访问频率太低，保存在内存中纯属浪费资源。</p>
<h1 id="5-Redis-为什么是单线程的？"><a href="#5-Redis-为什么是单线程的？" class="headerlink" title="5.Redis 为什么是单线程的？"></a>5.Redis 为什么是单线程的？</h1><p>官方 FAQ 表示，因为 Redis 是基于内存的操作，CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章地采用单线程的方案了，毕竟采用多线程会有很多麻烦。</p>
<h1 id="6-Redis-为什么这么快？"><a href="#6-Redis-为什么这么快？" class="headerlink" title="6.Redis 为什么这么快？"></a>6.Redis 为什么这么快？</h1><p>1.完全基于内存，绝大部分请求是纯粹的内存操作，非常快速；</p>
<p>2.数据结构简单，对数据操作也简单；</p>
<p>3.采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；<br>4.使用多路 I&#x2F;O 复用模型，非阻塞 IO。</p>
<h1 id="7-什么是缓存穿透？怎么解决？"><a href="#7-什么是缓存穿透？怎么解决？" class="headerlink" title="7.什么是缓存穿透？怎么解决？"></a>7.什么是缓存穿透？怎么解决？</h1><p>缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。</p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>1.缓存空对象：如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p>
<p>缓存空对象带来的问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.空值做了缓存，意味着缓存中存了更多的键，需要更多的内存空间，比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。</span><br><span class="line">2.缓存和存储的数据会有一段时间窗口的不一致，可能会对业务有一定影响。例如:过期时间设置为 5分钟，如果此时存储添加了这个数据，那此段时间就会出现缓存和存储数据的不一致，此时可以利用消息系统或者其他方式清除掉缓存层中的空对象。</span><br></pre></td></tr></table></figure>

<p>2.布隆过滤器：将db中所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。</p>
<h1 id="8-什么是缓存雪崩？该如何解决？"><a href="#8-什么是缓存雪崩？该如何解决？" class="headerlink" title="8.什么是缓存雪崩？该如何解决？"></a>8.什么是缓存雪崩？该如何解决？</h1><pre><code>如果缓存集中在一段时间内失效，发生大量的缓存穿透，所有的查询都落在数据库上，造成了缓存雪崩。
</code></pre>
<h4 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h4><p>1.加锁排队：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量.比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待；</p>
<p>2.数据预热：可以通过缓存 reload 机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存不同的 key，设置不同的过期时间，让缓存失效的时间点尽量		均匀；</p>
<p>3.做二级缓存，或者双缓存策略：Cache1 为原始缓存，Cache2 为拷贝缓存，Cache1 失效时，可以访问 Cache2，Cache1 缓存失效时间设置为短期，Cache2 设置为长期。</p>
<p>4.在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。</p>
<h1 id="9-什么是缓存击穿？该如何解决？"><a href="#9-什么是缓存击穿？该如何解决？" class="headerlink" title="9.什么是缓存击穿？该如何解决？"></a>9.什么是缓存击穿？该如何解决？</h1><p>对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。</p>
<p>缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p>
<p><strong>解决方案</strong><br><strong>1.使用互斥锁(mutex key)</strong><br>业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。</p>
<p>SETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果。在redis2.6.1之前版本未实现setnx的过期时间，所以这里给出两种版本代码参考：</p>
<p>&#x2F;&#x2F;2.6.1前单机版本锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">get</span><span class="params">(String key)</span> &#123;  </span><br><span class="line">   <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> redis.get(key);  </span><br><span class="line">   <span class="keyword">if</span> (value  == <span class="literal">null</span>) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (redis.setnx(key_mutex, <span class="string">&quot;1&quot;</span>)) &#123;  </span><br><span class="line">        <span class="comment">// 3 min timeout to avoid mutex holder crash  </span></span><br><span class="line">        redis.expire(key_mutex, <span class="number">3</span> * <span class="number">60</span>)  </span><br><span class="line">        value = db.get(key);  </span><br><span class="line">        redis.set(key, value);  </span><br><span class="line">        redis.delete(key_mutex);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">//其他线程休息50毫秒后重试  </span></span><br><span class="line">        Thread.sleep(<span class="number">50</span>);  </span><br><span class="line">        get(key);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最新版本代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(key)</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> redis.get(key);</span><br><span class="line">      <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123; <span class="comment">//代表缓存值过期</span></span><br><span class="line">          <span class="comment">//设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</span></span><br><span class="line">		  <span class="keyword">if</span> (redis.setnx(key_mutex, <span class="number">1</span>, <span class="number">3</span> * <span class="number">60</span>) == <span class="number">1</span>) &#123;  <span class="comment">//代表设置成功</span></span><br><span class="line">               value = db.get(key);</span><br><span class="line">                      redis.set(key, value, expire_secs);</span><br><span class="line">                      redis.del(key_mutex);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;  <span class="comment">//这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可</span></span><br><span class="line">                      sleep(<span class="number">50</span>);</span><br><span class="line">                      get(key);  <span class="comment">//重试</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> value;      </span><br><span class="line">          &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="9-怎么保证缓存和数据库数据的一致性？"><a href="#9-怎么保证缓存和数据库数据的一致性？" class="headerlink" title="9.怎么保证缓存和数据库数据的一致性？"></a>9.怎么保证缓存和数据库数据的一致性？</h1><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/58.png" alt="在这里插入图片描述"></p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/59.png" alt="在这里插入图片描述"></p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/60.png" alt="在这里插入图片描述"></p>
<h1 id="10-Redis-持久化有几种方式？"><a href="#10-Redis-持久化有几种方式？" class="headerlink" title="10.Redis 持久化有几种方式？"></a>10.Redis 持久化有几种方式？</h1><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。Redis 提供了两种持久化方式：RDB（默认） 和 AOF。</p>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>RDB 是 Redis DataBase 的缩写。按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件。即 Snapshot 快照存储，对应产生的数据文件为 dump.rdb，通过配置文件中的 save 参数来定义快照的周期。核心函数：rdbSave（生成 RDB 文件）和 rdbLoad（从文件加载内存）两个函数<img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/61.png" alt="在这里插入图片描述"></p>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>AOF 是 Append-only file 的缩写。Redis会将每一个收到的写命令都通过 Write 函数追加到文件最后，类似于 MySQL 的 binlog。当 Redis 重启是会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。每当执行服务器（定时）任务或者函数时，flushAppendOnlyFile 函数都会被调用， 这个函数执行以下两个工作：</p>
<p>WRITE：根据条件，将 aof_buf 中的缓存写入到 AOF 文件；</p>
<p>SAVE：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中。</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/62.png" alt="在这里插入图片描述"></p>
<h4 id="RDB-和-AOF-的区别："><a href="#RDB-和-AOF-的区别：" class="headerlink" title="RDB 和 AOF 的区别："></a>RDB 和 AOF 的区别：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.AOF 文件比 RDB 更新频率高，优先使用 AOF 还原数据；</span><br><span class="line"></span><br><span class="line">2.AOF比 RDB 更安全也更大；</span><br><span class="line"></span><br><span class="line">3.RDB 性能比 AOF 好；</span><br><span class="line"></span><br><span class="line">4.如果两个都配了优先加载 AOF。</span><br></pre></td></tr></table></figure>

<h1 id="12-Redis-淘汰策略有哪些？"><a href="#12-Redis-淘汰策略有哪些？" class="headerlink" title="12.Redis 淘汰策略有哪些？"></a>12.Redis 淘汰策略有哪些？</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰；</span><br><span class="line"></span><br><span class="line">2.volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。</span><br><span class="line"></span><br><span class="line">3.allkeys-lru：从数据集中挑选最近最少使用的数据淘汰。</span><br><span class="line"></span><br><span class="line">4.allkeys-random：从数据集中任意选择数据淘汰。</span><br><span class="line"></span><br><span class="line">5.volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰。</span><br><span class="line"></span><br><span class="line">6.no-enviction（驱逐）：禁止驱逐数据。</span><br></pre></td></tr></table></figure>

<h1 id="13-Redis的原子性如何保证"><a href="#13-Redis的原子性如何保证" class="headerlink" title="13.Redis的原子性如何保证"></a>13.Redis的原子性如何保证</h1><p>对于Redis而言，命令的原子性指的是：一个操作不可再分，操作要么执行要么不执行，Redis之所以是原子的，是因为Redis是单线程的。</p>
<p>Redis所有单个命令的执行都是原子的，Redis是实现事务的原理：</p>
<p>1.批量操作在发送EXEC（执行）命令前被放入队列缓存；</p>
<p>2.收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令都不会被执行；</p>
<p>3.在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>
<h1 id="14-Redis-有哪些架构模式讲讲各自的特点"><a href="#14-Redis-有哪些架构模式讲讲各自的特点" class="headerlink" title="14.Redis 有哪些架构模式讲讲各自的特点"></a>14.Redis 有哪些架构模式讲讲各自的特点</h1><h3 id="单机版"><a href="#单机版" class="headerlink" title="单机版"></a>单机版</h3><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/63.png" alt="在这里插入图片描述"></p>
<p>特点：简单</p>
<p>问题：</p>
<p>1、内存容量有限 2、处理能力有限 3、无法高可用。</p>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/64.png" alt="在这里插入图片描述"></p>
<p>Redis 的复制（replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器（master），而通过复制创建出来的服务器复制品则为从服务器（slave）。 只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，主服务器就会一直将发生在自己身上的数据更新同步 给从服务器，从而一直保证主从服务器的数据相同。</p>
<p>特点：</p>
<p>1、master&#x2F;slave 角色</p>
<p>2、master&#x2F;slave 数据相同</p>
<p>3、降低 master 读压力在转交从库</p>
<p>问题：</p>
<p>无法保证高可用</p>
<p>没有解决 master 写的压力</p>
<h3 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h3><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/65.png" alt="在这里插入图片描述"></p>
<p>Redis sentinel 是一个分布式系统中监控 redis 主从服务器，并在主服务器下线时自动进行故障转移。其中三个特性：</p>
<p>监控（Monitoring）：  Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</p>
<p>提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</p>
<p>自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作。</p>
<p>特点：</p>
<p>1、保证高可用</p>
<p>2、监控各个节点</p>
<p>3、自动故障迁移</p>
<p>缺点：主从模式，切换需要时间丢数据</p>
<p>没有解决 master 写的压力</p>
<h3 id="集群（proxy-型）"><a href="#集群（proxy-型）" class="headerlink" title="集群（proxy 型）"></a>集群（proxy 型）</h3><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/66.png" alt="在这里插入图片描述"></p>
<p>Twemproxy 是一个 Twitter 开源的一个 redis 和 memcache 快速&#x2F;轻量级代理服务器； Twemproxy 是一个快速的单线程代理程序，支持 Memcached ASCII 协议和 redis 协议。</p>
<p>特点：1、多种 hash 算法：MD5、CRC16、CRC32、CRC32a、hsieh、murmur、Jenkins </p>
<p>2、支持失败节点自动删除</p>
<p>3、后端 Sharding 分片逻辑对业务透明，业务方的读写方式和操作单个 Redis 一致</p>
<p>缺点：增加了新的 proxy，需要维护其高可用。</p>
<p>failover 逻辑需要自己实现，其本身不能支持故障的自动转移可扩展性差，进行扩缩容都需要手动干预</p>
<h3 id="集群（直连型）"><a href="#集群（直连型）" class="headerlink" title="集群（直连型）"></a>集群（直连型）</h3><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/67.png" alt="在这里插入图片描述"></p>
<p>从redis 3.0之后版本支持redis-cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。</p>
<p>特点：</p>
<p>1、无中心架构（不存在哪个节点影响性能瓶颈），少了 proxy 层。</p>
<p>2、数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。</p>
<p>3、可扩展性，可线性扩展到 1000 个节点，节点可动态添加或删除。</p>
<p>4、高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本</p>
<p>5、实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave到 Master 的角色提升。</p>
<p>缺点：</p>
<p>1、资源隔离性较差，容易出现相互影响的情况。</p>
<p>2、数据通过异步复制,不保证数据的强一致性</p>
<h1 id="15-使用过Redis做异步队列么，你是怎么用的？有什么缺点？"><a href="#15-使用过Redis做异步队列么，你是怎么用的？有什么缺点？" class="headerlink" title="15.使用过Redis做异步队列么，你是怎么用的？有什么缺点？"></a>15.使用过Redis做异步队列么，你是怎么用的？有什么缺点？</h1><p>一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试也可以使用blpop指令。</p>
<p>缺点：</p>
<p>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。</p>
<h1 id="16-能不能生产一次消费多次呢？"><a href="#16-能不能生产一次消费多次呢？" class="headerlink" title="16.能不能生产一次消费多次呢？"></a>16.能不能生产一次消费多次呢？</h1><p>使用pub&#x2F;sub主题订阅者模式，可以实现1:N的消息队列。</p>
<p>进程间的一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/68.png" alt="在这里插入图片描述"></p>
<h1 id="17-Redis相比memcached有哪些优势？"><a href="#17-Redis相比memcached有哪些优势？" class="headerlink" title="17.Redis相比memcached有哪些优势？"></a>17.Redis相比memcached有哪些优势？</h1><p>(1) memcached所有的值均是简单的字符串，redis作为其替代者， 支持更为丰富的数据类型<br>(2) redis的速度比memcached快很多<br>(3) redis可以持久化其数据</p>
<h1 id="18-Redis的过期策略"><a href="#18-Redis的过期策略" class="headerlink" title="18.Redis的过期策略"></a>18.Redis的过期策略</h1><p>我们都知道，Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。</p>
<p>过期策略通常有以下三种</p>
<p>· 定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</p>
<p>· 惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</p>
<p>· 定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。<br>(expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)</p>
<p>Redis中同时使用了惰性过期和定期过期两种过期策略。</p>
<h1 id="19-Redis底层数据结构"><a href="#19-Redis底层数据结构" class="headerlink" title="19.Redis底层数据结构"></a>19.Redis底层数据结构</h1><h3 id="1-简单动态字符串"><a href="#1-简单动态字符串" class="headerlink" title="1.简单动态字符串"></a>1.简单动态字符串</h3><p>　　第一篇文章我们就说过 Redis 是用 C 语言写的，但是对于Redis的字符串，却不是 C 语言中的字符串（即以空字符’\0’结尾的字符数组），它是自己构建了一种名为 简单动态字符串（simple dynamic string,SDS）的抽象类型，并将 SDS 作为 Redis的默认字符串表示。</p>
<p>在<code>Redis 3.2</code>之前使用的是第一个版本，其数据结构如下所示：</p>
<p>SDS 定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//记录buf数组中已使用字节的数量</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//等于 SDS 保存字符串的长度</span></span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//记录 buf 数组中未使用字节的数量</span></span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//字节数组，用于保存字符串</span></span><br><span class="line"></span><br><span class="line">   <span class="type">char</span> buf[];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　用SDS保存字符串 “Redis”具体图示如下：</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/69.png" alt="在这里插入图片描述"></p>
<p>　　</p>
<p> 　我们看上面对于 SDS 数据类型的定义：</p>
<p>　　1、len 保存了SDS保存字符串的长度</p>
<p>　　2、buf[] 数组用来保存字符串的每个元素</p>
<p>　　3、free j记录了 buf 数组中未使用的字节数量</p>
<p>　　上面的定义相对于 C 语言对于字符串的定义，多出了 len 属性以及 free 属性。为什么不使用C语言字符串实现，而是使用 SDS呢？这样实现有什么好处？</p>
<h5 id="①、常数复杂度获取字符串长度"><a href="#①、常数复杂度获取字符串长度" class="headerlink" title="①、常数复杂度获取字符串长度"></a>①、常数复杂度获取字符串长度</h5><p>　　由于 len 属性的存在，我们获取 SDS 字符串的长度只需要读取 len 属性，时间复杂度为 O(1)。而对于 C 语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。通过 strlen key 命令可以获取 key 的字符串长度。</p>
<h5 id="②、杜绝缓冲区溢出"><a href="#②、杜绝缓冲区溢出" class="headerlink" title="②、杜绝缓冲区溢出"></a>②、杜绝缓冲区溢出</h5><p>　　我们知道在 C 语言中使用 strcat 函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。而对于 SDS 数据类型，在进行字符修改的时候，会首先根据记录的 len 属性检查内存空间是否满足需求，如果不满足，会进行相应的空间扩展，然后在进行修改操作，所以不会出现缓冲区溢出。</p>
<h5 id="③、减少修改字符串的内存重新分配次数"><a href="#③、减少修改字符串的内存重新分配次数" class="headerlink" title="③、减少修改字符串的内存重新分配次数"></a>③、减少修改字符串的内存重新分配次数</h5><p>　　C语言由于不记录字符串的长度，所以如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。</p>
<p>　　而对于SDS，由于len属性和free属性的存在，对于修改字符串SDS实现了空间预分配和惰性空间释放两种策略：</p>
<p>　　1、空间预分配：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。</p>
<p>　　2、惰性空间释放：对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 free 属性将这些字节的数量记录下来，等待后续使用。（当然SDS也提供了相应的API，当我们有需要时，也可以手动释放这些未使用的空间。）</p>
<h5 id="④、二进制安全"><a href="#④、二进制安全" class="headerlink" title="④、二进制安全"></a>④、二进制安全</h5><p>　　因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；而所有 SDS 的API 都是以处理二进制的方式来处理 buf 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len 属性表示的长度来判断字符串是否结束。</p>
<h5 id="⑤、兼容部分-C-字符串函数"><a href="#⑤、兼容部分-C-字符串函数" class="headerlink" title="⑤、兼容部分 C 字符串函数"></a>⑤、兼容部分 C 字符串函数</h5><p>　　虽然 SDS 是二进制安全的，但是一样遵从每个字符串都是以空字符串结尾的惯例，这样可以重用 C 语言库&lt;string.h&gt; 中的一部分函数。</p>
<h5 id="⑥、总结"><a href="#⑥、总结" class="headerlink" title="⑥、总结"></a>⑥、总结</h5><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/70.png" alt="在这里插入图片描述"></p>
<p>一般来说，SDS 除了保存数据库中的字符串值以外，SDS 还可以作为缓冲区（buffer）：包括 AOF 模块中的AOF缓冲区以及客户端状态中的输入缓冲区。后面在介绍Redis的持久化时会进行介绍。</p>
<p>但是在<code>Redis 3.2 版本</code>中，对数据结构做出了修改，针对不同的长度范围定义了不同的结构，如下，这是目前的结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *sds;      </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span>     <span class="comment">// 对应的字符串长度小于 1&lt;&lt;5</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span>     <span class="comment">// 对应的字符串长度小于 1&lt;&lt;8</span></span><br><span class="line">    <span class="type">uint8_t</span> len; <span class="comment">/* used */</span>                       <span class="comment">//目前字符创的长度</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc;                                <span class="comment">//已经分配的总长度</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags;                          <span class="comment">//flag用3bit来标明类型，类型后续解释，其余5bit目前没有使用</span></span><br><span class="line">    <span class="type">char</span> buf[];                                   <span class="comment">//柔性数组，以&#x27;\0&#x27;结尾</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span>    <span class="comment">// 对应的字符串长度小于 1&lt;&lt;16</span></span><br><span class="line">    <span class="type">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span>    <span class="comment">// 对应的字符串长度小于 1&lt;&lt;32</span></span><br><span class="line">    <span class="type">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span>    <span class="comment">// 对应的字符串长度小于 1&lt;&lt;64</span></span><br><span class="line">    <span class="type">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>新版带来的好处就是针对长度不同的字符串做了优化，选取不同的数据类型uint8_t或者uint16_t或者uint32_t等来表示长度、一共申请字节的大小等。上面结构体中的__attribute__ ((<strong>packed</strong>)) 设置是告诉编译器取消字节对齐，则结构体的大小就是按照结构体成员实际大小相加得到的。</p>
<h3 id="2-链表"><a href="#2-链表" class="headerlink" title="2.链表"></a>2.链表</h3><p>　　链表是一种常用的数据结构，C 语言内部是没有内置这种数据结构的实现，所以Redis自己构建了链表的实现。</p>
<p>链表定义：</p>
<p>　　通过多个 listNode 结构就可以组成链表，这是一个双端链表，Redis还提供了操作链表的数据结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">//后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">//节点的值</span></span><br><span class="line">    <span class="type">void</span> *value; </span><br><span class="line">&#125;listNode</span><br></pre></td></tr></table></figure>

<p>　　</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//表头节点</span></span><br><span class="line">   listNode *head;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//表尾节点</span></span><br><span class="line">   listNode *tail;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//链表所包含的节点数量</span></span><br><span class="line">   <span class="type">unsigned</span>  <span class="type">long</span> len;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//节点值复制函数</span></span><br><span class="line">   <span class="type">void</span> (<span class="built_in">free</span>) (<span class="type">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//节点值释放函数</span></span><br><span class="line">   <span class="type">void</span> (<span class="built_in">free</span>) (<span class="type">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//节点值对比函数</span></span><br><span class="line">   <span class="type">int</span> (*match) (<span class="type">void</span> *ptr,<span class="type">void</span> *key);</span><br><span class="line"></span><br><span class="line">&#125;<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/71.png" alt="在这里插入图片描述"></p>
<p>　　Redis链表特性：</p>
<p>　　①、双端：链表具有前置节点和后置节点的引用，获取这两个节点时间复杂度都为O(1)。</p>
<p>　　②、无环：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL,对链表的访问都是以 NULL 结束。　　</p>
<p>　　③、带链表长度计数器：通过 len 属性获取链表长度的时间复杂度为 O(1)。</p>
<p>　　④、多态：链表节点使用 void* 指针来保存节点值，可以保存各种不同类型的值。</p>
<h3 id="3-字典"><a href="#3-字典" class="headerlink" title="3.字典"></a>3.字典</h3><p>　　字典又称为符号表或者关联数组、或映射（map），是一种用于保存键值对的抽象数据结构。字典中的每一个键 key 都是唯一的，通过 key 可以对值来进行查找或修改。C 语言中没有内置这种数据结构的实现，所以字典依然是 Redis自己构建的。</p>
<p>　　哈希表结构定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//哈希表数组</span></span><br><span class="line"></span><br><span class="line">   dictEntry **table;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//哈希表大小</span></span><br><span class="line"></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//哈希表大小掩码，用于计算索引值</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//总是等于 size-1</span></span><br><span class="line"></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//该哈希表已有节点的数量</span></span><br><span class="line"></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;dictht</span><br></pre></td></tr></table></figure>

<p>　　哈希表是由数组 table 组成，table 中每个元素都是指向 dict.h&#x2F;dictEntry 结构，dictEntry 结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//键</span></span><br><span class="line">   <span class="type">void</span> *key;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//值</span></span><br><span class="line">   <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line"></span><br><span class="line">     <span class="type">void</span> *val;</span><br><span class="line"></span><br><span class="line">     uint64_tu64;</span><br><span class="line"></span><br><span class="line">     int64_ts64;</span><br><span class="line"></span><br><span class="line">   &#125;v;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//指向下一个哈希表节点，形成链表</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;dictEntry</span><br></pre></td></tr></table></figure>

<p>　　key 用来保存键，val 属性用来保存值，值可以是一个指针，也可以是uint64_t整数，也可以是int64_t整数。</p>
<p>　　注意这里还有一个指向下一个哈希表节点的指针，我们知道哈希表最大的问题是存在哈希冲突，如何解决哈希冲突，有开放地址法和链地址法。这里采用的便是链地址法，通过next这个指针可以将多个哈希值相同的键值对连接在一起，用来解决哈希冲突。</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/72.png" alt="在这里插入图片描述"></p>
<p>　　①、哈希算法：Redis计算哈希值和索引值方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#<span class="number">1</span>、使用字典设置的哈希函数，计算键 key 的哈希值</span><br><span class="line"></span><br><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、使用哈希表的sizemask属性和第一步得到的哈希值，计算索引值</span><br><span class="line"></span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>

<p>　②、解决哈希冲突：这个问题上面我们介绍了，方法是链地址法。通过字典里面的 *next 指针指向下一个具有相同索引值的哈希表节点。</p>
<p>　③、扩容和收缩：当哈希表保存的键值对太多或者太少时，就要通过 rerehash(重新散列）来对哈希表进行相应的扩展或者收缩。具体步骤：</p>
<p>　　　　　　1、如果执行扩展操作，会基于原哈希表创建一个大小等于 ht[0].used*2n 的哈希表（也就是每次扩展都是根据原哈希表已使用的空间扩大一倍创建另一个哈希表）。相反如果执行的是收缩操作，每次收缩是根据已使用空间缩小一倍创建一个新的哈希表。</p>
<p>　　　　　　2、重新利用上面的哈希算法，计算索引值，然后将键值对放到新的哈希表位置上。</p>
<p>　　　　　　3、所有键值对都迁徙完毕后，释放原哈希表的内存空间。</p>
<p>　④、触发扩容的条件：</p>
<p>　　　　　　1、服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于1。</p>
<p>　　　　　　2、服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于5。</p>
<p>　　　　ps：负载因子 &#x3D; 哈希表已保存节点数量 &#x2F; 哈希表大小。</p>
<p>⑤、渐近式 rehash</p>
<p>　　　　什么叫渐进式 rehash？也就是说扩容和收缩操作不是一次性、集中式完成的，而是分多次、渐进式完成的。如果保存在Redis中的键值对只有几个几十个，那么 rehash 操作可以瞬间完成，但是如果键值对有几百万，几千万甚至几亿，那么要一次性的进行 rehash，势必会造成Redis一段时间内不能进行别的操作。所以Redis采用渐进式 rehash,这样在进行渐进式rehash期间，字典的删除查找更新等操作可能会在两个哈希表上进行，第一个哈希表没有找到，就会去第二个哈希表上进行查找。但是进行 增加操作，一定是在新的哈希表上进行的。</p>
<h3 id="4-跳跃表"><a href="#4-跳跃表" class="headerlink" title="4.跳跃表"></a>4.跳跃表</h3><p>　　跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其它节点的指针，从而达到快速访问节点的目的。具有如下性质：</p>
<p>　　1、由很多层结构组成；</p>
<p>　　2、每一层都是一个有序的链表，排列顺序为由高层到底层，都至少包含两个链表节点，分别是前面的head节点和后面的nil节点；</p>
<p>　　3、最底层的链表包含了所有的元素；</p>
<p>　　4、如果一个元素出现在某一层的链表中，那么在该层之下的链表也全都会出现（上一层的元素是当前层的元素的子集）；</p>
<p>　　5、链表中的每个节点都包含两个指针，一个指向同一层的下一个链表节点，另一个指向下一层的同一个链表节点；</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/73.png" alt="在这里插入图片描述"></p>
<p>　　Redis中跳跃表节点定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//层</span></span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span>&#123;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//前进指针</span></span><br><span class="line"></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//跨度</span></span><br><span class="line"></span><br><span class="line">      <span class="type">unsigned</span> ***\*<span class="type">int</span>\**** span;</span><br><span class="line"></span><br><span class="line">   &#125;level[];</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">   <span class="comment">//后退指针</span></span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//分值</span></span><br><span class="line"></span><br><span class="line">   <span class="type">double</span> score;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//成员对象</span></span><br><span class="line"></span><br><span class="line">   robj *obj;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125; zskiplistNode</span><br></pre></td></tr></table></figure>

<p>　　多个跳跃表节点构成一个跳跃表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span>&#123;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//表头节点和表尾节点</span></span><br><span class="line">   structz skiplistNode *header, *tail;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//表中节点的数量</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//表中层数最大的节点的层数</span></span><br><span class="line">   <span class="type">int</span> level;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;zskiplist;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/74.png" alt="在这里插入图片描述"></p>
<p>　　①、搜索：从最高层的链表节点开始，如果比当前节点要大和比当前层的下一个节点要小，那么则往下找，也就是和当前层的下一层的节点的下一个节点进行比较，以此类推，一直找到最底层的最后一个节点，如果找到则返回，反之则返回空。</p>
<p>　　②、插入：首先确定插入的层数，有一种方法是假设抛一枚硬币，如果是正面就累加，直到遇见反面为止，最后记录正面的次数作为插入的层数。当确定插入的层数k后，则需要将新元素插入到从底层到k层。</p>
<p>③、删除：在各个层中找到包含指定值的节点，然后将节点从链表中删除即可，如果删除以后只剩下头尾两个节点，则删除这一层。</p>
<h3 id="5-整数集合"><a href="#5-整数集合" class="headerlink" title="5.整数集合"></a>5.整数集合</h3><p>　　整数集合（intset）是Redis用于保存整数值的集合抽象数据类型，它可以保存类型为int16_t、int32_t 或者int64_t 的整数值，并且保证集合中不会出现重复元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//编码方式</span></span><br><span class="line"></span><br><span class="line">   <span class="type">uint32_t</span> encoding;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//集合包含的元素数量</span></span><br><span class="line"></span><br><span class="line">   <span class="type">uint32_t</span> length;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//保存元素的数组</span></span><br><span class="line"></span><br><span class="line">   <span class="type">int8_t</span> contents[];</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;intset;</span><br></pre></td></tr></table></figure>

<p>　　定义如下：</p>
<p>　　整数集合的每个元素都是 contents 数组的一个数据项，它们按照从小到大的顺序排列，并且不包含任何重复项。</p>
<p>　　length 属性记录了 contents 数组的大小。</p>
<p>　　需要注意的是虽然 contents 数组声明为 int8_t 类型，但是实际上contents 数组并不保存任何 int8_t 类型的值，其真正类型有 encoding 来决定。</p>
<p>　①、升级</p>
<p>　　当我们新增的元素类型比原集合元素类型的长度要大时，需要对整数集合进行升级，才能将新元素放入整数集合中。具体步骤：</p>
<p>　　1、根据新元素类型，扩展整数集合底层数组的大小，并为新元素分配空间。</p>
<p>　　2、将底层数组现有的所有元素都转成与新元素相同类型的元素，并将转换后的元素放到正确的位置，放置过程中，维持整个元素顺序都是有序的。</p>
<p>　　3、将新元素添加到整数集合中（保证有序）。</p>
<p>　　升级能极大地节省内存。</p>
<p>②、降级</p>
<p>　　整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。</p>
<h3 id="6-压缩列表"><a href="#6-压缩列表" class="headerlink" title="6.压缩列表"></a>6.压缩列表</h3><p>压缩列表（ziplist）是Redis为了节省内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构，一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。</p>
<p>压缩列表的原理：压缩列表并不是对数据利用某种算法进行压缩，而是将数据按照一定规则编码在一块连续的内存区域，目的是节省内存。</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/75.png" alt="在这里插入图片描述"></p>
<p>　　压缩列表的每个节点构成如下：</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/76.png" alt="在这里插入图片描述"></p>
<p>　　①、previous_entry_ength：记录压缩列表前一个字节的长度。previous_entry_ength的长度可能是1个字节或者是5个字节，如果上一个节点的长度小于254，则该节点只需要一个字节就可以表示前一个节点的长度了，如果前一个节点的长度大于等于254，则previous length的第一个字节为254，后面用四个字节表示当前节点前一个节点的长度。利用此原理即当前节点位置减去上一个节点的长度即得到上一个节点的起始位置，压缩列表可以从尾部向头部遍历。这么做很有效地减少了内存的浪费。</p>
<p>　　②、encoding：节点的encoding保存的是节点的content的内容类型以及长度，encoding类型一共有两种，一种字节数组一种是整数，encoding区域长度为1字节、2字节或者5字节长。</p>
<p>　　③、content：content区域用于保存节点的内容，节点内容类型和长度由encoding决定。</p>
<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h3><p>　　大多数情况下，Redis使用简单字符串SDS作为字符串的表示，相对于C语言字符串，SDS具有常数复杂度获取字符串长度，杜绝了缓存区的溢出，减少了修改字符串长度时所需的内存重分配次数，以及二进制安全能存储各种类型的文件，并且还兼容部分C函数。</p>
<p>　　通过为链表设置不同类型的特定函数，Redis链表可以保存各种不同类型的值，除了用作列表键，还在发布与订阅、慢查询、监视器等方面发挥作用（后面会介绍）。</p>
<p>　　Redis的字典底层使用哈希表实现，每个字典通常有两个哈希表，一个平时使用，另一个用于rehash时使用，使用链地址法解决哈希冲突。</p>
<p>　　跳跃表通常是有序集合的底层实现之一，表中的节点按照分值大小进行排序。</p>
<p>　　整数集合是集合键的底层实现之一，底层由数组构成，升级特性能尽可能的节省内存。</p>
<p>　　压缩列表是Redis为节省内存而开发的顺序型数据结构，通常作为列表键和哈希键的底层实现之一。</p>
<h1 id="20-一致性hash"><a href="#20-一致性hash" class="headerlink" title="20.一致性hash"></a>20.一致性hash</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>互联网公司中，绝大部分都没有马爸爸系列的公司那样财大气粗，他们即没有强劲的服务器、也没有钱去购买昂贵的海量数据库。那他们是怎么应对大数据量高并发的业务场景的呢？<br> 这个和当前的开源技术、海量数据架构都有着不可分割的关系。比如通过mysql、nginx等开源软件，通过架构和低成本的服务器搭建千万级别的用户访问系统。<br> 怎么样搭建一个好的系统架构，这个话题我们能聊上个七天七夜。这里我主要结合Redis集群来讲一下一致性Hash的相关问题。</p>
<h3 id="Redis集群的使用"><a href="#Redis集群的使用" class="headerlink" title="Redis集群的使用"></a>Redis集群的使用</h3><p>我们在使用Redis的过程中，为了保证Redis的高可用，我们一般会对Redis做主从复制，组成<code>Master-Master</code>或者<code>Master-Slave</code>的形式，进行数据的读写分离，如下图1-1所示：</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/77.png" alt="在这里插入图片描述"></p>
<p>图1-1：Master-Slave模式</p>
<p>当缓存数据量超过一定的数量时，我们就要对Redis集群做分库分表的操作。</p>
<p>来个栗子，我们有一个电商平台，需要使用Redis存储商品的图片资源，存储的格式为键值对，key值为图片名称，Value为该图片所在的文件服务器的路径，我们需要根据文件名，查找到文件所在的文件服务器上的路径，我们的图片数量大概在3000w左右，按照我们的规则进行分库，规则就是随机分配的，我们以每台服务器存500w的数量，部署12台缓存服务器，并且进行主从复制，架构图如下图1-2所示：</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/78.png" alt="在这里插入图片描述"></p>
<p>图1-2：Redis分库分表</p>
<p>由于我们定义的规则是随机的，所以我们的数据有可能存储在任何一组Redis中，比如我们需要查询”product.png”的图片，由于规则的随机性，我们需要遍历所有Redis服务器，才能查询得到。这样的结果显然不是我们所需要的。所以我们会想到按某一个字段值进行Hash值、取模。所以我们就看看使用Hash的方式是怎么进行的。</p>
<h3 id="使用Hash的Redis集群"><a href="#使用Hash的Redis集群" class="headerlink" title="使用Hash的Redis集群"></a>使用Hash的Redis集群</h3><p>如果我们使用Hash的方式，每一张图片在进行分库的时候都可以定位到特定的服务器，示意图如图1-3所示：</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/79.png" alt="在这里插入图片描述"></p>
<p>图1-3：使用Hash方式的命中缓存</p>
<p>从上图中，我们需要查询的是图<code>product.png</code>，由于我们有6台主服务器，所以计算的公式为：<code>hash(product.png) % 6 = 5</code>, 我们就可以定位到是5号主从，这们就省去了遍历所有服务器的时间，从而大大提升了性能。</p>
<h3 id="使用Hash时遇到的问题"><a href="#使用Hash时遇到的问题" class="headerlink" title="使用Hash时遇到的问题"></a>使用Hash时遇到的问题</h3><p>在上述hash取模的过程中，我们虽然不需要对所有Redis服务器进行遍历而提升了性能。但是，使用Hash算法缓存时会出现一些问题，<code>Redis服务器变动时，所有缓存的位置都会发生改变</code>。<br> 比如，现在我们的Redis缓存服务器增加到了8台，我们计算的公式从<code>hash(product.png) % 6 = 5</code>变成了<code>hash(product.png) % 8 = ?</code> 结果肯定不是原来的5了。<br> 再者，6台的服务器集群中，当某个主从群出现故障时，无法进行缓存，那我们需要把故障机器移除，所以取模数又会从6变成了5。我们计算的公式也会变化。</p>
<p>由于上面hash算法是使用取模来进行缓存的，为了规避上述情况，Hash一致性算法就诞生了~~</p>
<h3 id="一致性Hash算法原理"><a href="#一致性Hash算法原理" class="headerlink" title="一致性Hash算法原理"></a>一致性Hash算法原理</h3><p>一致性Hash算法也是使用取模的方法，不过，上述的取模方法是对服务器的数量进行取模，而一致性的Hash算法是对<code>2的32方</code>取模。即，一致性Hash算法将整个Hash空间组织成一个虚拟的圆环，Hash函数的值空间为<code>0 ~ 2^32 - 1(一个32位无符号整型)</code>，整个哈希环如下：</p>
<p>图1-4：Hash圆环</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/80.png" alt="在这里插入图片描述"></p>
<p> 整个圆环以<code>顺时针方向组织</code>，圆环正上方的点代表0，0点右侧的第一个点代表1，以此类推。<br> 第二步，我们将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台服务器就确定在了哈希环的一个位置上，比如我们有三台机器，使用IP地址哈希后在环空间的位置如图1-4所示：</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/81.png" alt="在这里插入图片描述"></p>
<p>图1-4：服务器在哈希环上的位置</p>
<p>现在，我们使用以下算法定位数据访问到相应的服务器：</p>
<blockquote>
<p>将数据Key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针查找，遇到的服务器就是其应该定位到的服务器。</p>
</blockquote>
<p>例如，现在有ObjectA，ObjectB，ObjectC三个数据对象，经过哈希计算后，在环空间上的位置如下：</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/82.png" alt="在这里插入图片描述"></p>
<p>图1-5：数据对象在环上的位置</p>
<p>根据一致性算法，Object -&gt; NodeA，ObjectB -&gt; NodeB, ObjectC -&gt; NodeC</p>
<h3 id="一致性Hash算法的容错性和可扩展性"><a href="#一致性Hash算法的容错性和可扩展性" class="headerlink" title="一致性Hash算法的容错性和可扩展性"></a>一致性Hash算法的容错性和可扩展性</h3><p>现在，假设我们的Node C宕机了，我们从图中可以看到，A、B不会受到影响，只有Object C对象被重新定位到Node A。所以我们发现，在一致性Hash算法中，如果一台服务器不可用，受影响的数据仅仅是此服务器到其环空间前一台服务器之间的数据（这里为Node C到Node B之间的数据），其他不会受到影响。如图1-6所示：</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/83.png" alt="在这里插入图片描述"></p>
<p>图1-6：C节点宕机情况，数据移到节点A上</p>
<p>另外一种情况，现在我们系统增加了一台服务器Node X，如图1-7所示：</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/84.png" alt="图1-7：增加新的服"><br>务器节点X</p>
<p>此时对象ObjectA、ObjectB没有受到影响，只有Object C重新定位到了新的节点X上。<br> 如上所述：</p>
<blockquote>
<p>一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，有很好的容错性和可扩展性。</p>
</blockquote>
<h3 id="数据倾斜问题"><a href="#数据倾斜问题" class="headerlink" title="数据倾斜问题"></a>数据倾斜问题</h3><p>在一致性Hash算法服务节点太少的情况下，容易因为节点分布不均匀面造成<code>数据倾斜（被缓存的对象大部分缓存在某一台服务器上）问题</code>，如图1-8特例：</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/85.png" alt="在这里插入图片描述"></p>
<p>图1-8：数据倾斜</p>
<p> 这时我们发现有大量数据集中在节点A上，而节点B只有少量数据。为了解决数据倾斜问题，一致性Hash算法引入了<code>虚拟节点机制</code>，即对每一个服务器节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。<br> 具体操作可以为服务器IP或主机名后加入编号来实现，实现如图1-9所示：</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/86.png" alt="在这里插入图片描述"></p>
<p>图1-9：增加虚拟节点情况</p>
<p>数据定位算法不变，只需要增加一步：虚拟节点到实际点的映射。<br> 所以加入虚拟节点之后，即使在服务节点很少的情况下，也能做到数据的均匀分布。</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><h6 id="算法接口类"><a href="#算法接口类" class="headerlink" title="算法接口类"></a>算法接口类</h6><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IHashService</span> &#123;</span><br><span class="line">    <span class="function">Long <span class="title">hash</span>(<span class="params">String key</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="算法接口实现类"><a href="#算法接口实现类" class="headerlink" title="算法接口实现类"></a>算法接口实现类</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashService</span> <span class="keyword">implements</span> <span class="title class_">IHashService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * MurMurHash算法,性能高,碰撞率低</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Long</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">hash</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(key.getBytes());</span><br><span class="line">        <span class="type">int</span> <span class="variable">seed</span> <span class="operator">=</span> <span class="number">0x1234ABCD</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteOrder</span> <span class="variable">byteOrder</span> <span class="operator">=</span> buf.order();</span><br><span class="line">        buf.order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0xc6a4a7935bd1e995L</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">h</span> <span class="operator">=</span> seed ^ (buf.remaining() * m);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> k;</span><br><span class="line">        <span class="keyword">while</span> (buf.remaining() &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">            k = buf.getLong();</span><br><span class="line"></span><br><span class="line">            k *= m;</span><br><span class="line">            k ^= k &gt;&gt;&gt; r;</span><br><span class="line">            k *= m;</span><br><span class="line"></span><br><span class="line">            h ^= k;</span><br><span class="line">            h *= m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (buf.remaining() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">finish</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">8</span>).order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">            finish.put(buf).rewind();</span><br><span class="line">            h ^= finish.getLong();</span><br><span class="line">            h *= m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        h ^= h &gt;&gt;&gt; r;</span><br><span class="line">        h *= m;</span><br><span class="line">        h ^= h &gt;&gt;&gt; r;</span><br><span class="line"></span><br><span class="line">        buf.order(byteOrder);</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="模拟机器节点"><a href="#模拟机器节点" class="headerlink" title="模拟机器节点"></a>模拟机器节点</h6><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">String</span> ip;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">String</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">Node</span>(<span class="title class_">String</span> ip, <span class="title class_">String</span> name) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">ip</span> = ip;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">getIp</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">setIp</span>(<span class="params"><span class="built_in">String</span> ip</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">ip</span> = ip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">setName</span>(<span class="params"><span class="built_in">String</span> name</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用IP当做hash的Key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> <span class="variable">String</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="一致性Hash操作"><a href="#一致性Hash操作" class="headerlink" title="一致性Hash操作"></a>一致性Hash操作</h6><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsistentHash</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// Hash函数接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IHashService iHashService;</span><br><span class="line">    <span class="comment">// 每个机器节点关联的虚拟节点数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> int          numberOfReplicas;</span><br><span class="line">    <span class="comment">// 环形虚拟节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SortedMap&lt;<span class="built_in">Long</span>, T&gt; circle = new TreeMap&lt;<span class="built_in">Long</span>, T&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ConsistentHash(IHashService iHashService, int numberOfReplicas, Collection&lt;T&gt; nodes) &#123;</span><br><span class="line">        <span class="keyword">this</span>.iHashService = iHashService;</span><br><span class="line">        <span class="keyword">this</span>.numberOfReplicas = numberOfReplicas;</span><br><span class="line">        <span class="keyword">for</span> (T node : nodes) &#123;</span><br><span class="line">            add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加真实机器节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node T</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> void add(T node) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.numberOfReplicas; i++) &#123;</span><br><span class="line">            circle.put(<span class="keyword">this</span>.iHashService.hash(node.toString() + i), node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除真实机器节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node T</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> void remove(T node) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.numberOfReplicas; i++) &#123;</span><br><span class="line">            circle.remove(<span class="keyword">this</span>.iHashService.hash(node.toString() + i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">get</span>(String key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (circle.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        long hash = iHashService.hash(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 沿环的顺时针找到一个虚拟节点</span></span><br><span class="line">        <span class="keyword">if</span> (!circle.containsKey(hash)) &#123;</span><br><span class="line">            SortedMap&lt;<span class="built_in">Long</span>, T&gt; tailMap = circle.tailMap(hash);</span><br><span class="line">            hash = tailMap.isEmpty() ? circle.firstKey() : tailMap.firstKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> circle.<span class="keyword">get</span>(hash);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h6><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TestHashCircle</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 机器节点IP前缀</span></span><br><span class="line">    private <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">String</span> IP_PREFIX = <span class="string">&quot;192.168.0.&quot;</span>;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">        <span class="comment">// 每台真实机器节点上保存的记录条数</span></span><br><span class="line">        <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;<span class="built_in">String</span>, Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 真实机器节点, 模拟10台</span></span><br><span class="line">        <span class="built_in">List</span>&lt;Node&lt;<span class="built_in">String</span>&gt;&gt; nodes = <span class="keyword">new</span> ArrayList&lt;Node&lt;<span class="built_in">String</span>&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            map.put(IP_PREFIX + i, <span class="number">0</span>); <span class="comment">// 初始化记录</span></span><br><span class="line">            Node&lt;<span class="built_in">String</span>&gt; node = <span class="keyword">new</span> Node&lt;<span class="built_in">String</span>&gt;(IP_PREFIX + i, <span class="string">&quot;node&quot;</span> + i);</span><br><span class="line">            nodes.add(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        IHashService iHashService = <span class="keyword">new</span> HashService();</span><br><span class="line">        <span class="comment">// 每台真实机器引入100个虚拟节点</span></span><br><span class="line">        ConsistentHash&lt;Node&lt;<span class="built_in">String</span>&gt;&gt; consistentHash = <span class="keyword">new</span> ConsistentHash&lt;Node&lt;<span class="built_in">String</span>&gt;&gt;(iHashService, <span class="number">500</span>, nodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将5000条记录尽可能均匀的存储到10台机器节点上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 产生随机一个字符串当做一条记录，可以是其它更复杂的业务对象,比如随机字符串相当于对象的业务唯一标识</span></span><br><span class="line">            <span class="built_in">String</span> data = UUID.randomUUID().toString() + i;</span><br><span class="line">            <span class="comment">// 通过记录找到真实机器节点</span></span><br><span class="line">            Node&lt;<span class="built_in">String</span>&gt; node = consistentHash.<span class="keyword">get</span>(data);</span><br><span class="line">            <span class="comment">// 再这里可以能过其它工具将记录存储真实机器节点上，比如MemoryCache等</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="comment">// 每台真实机器节点上保存的记录条数加1</span></span><br><span class="line">            map.put(node.getIp(), map.<span class="keyword">get</span>(node.getIp()) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印每台真实机器节点保存的记录条数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(IP_PREFIX + i + <span class="string">&quot;节点记录条数：&quot;</span> + map.<span class="keyword">get</span>(IP_PREFIX + i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/87.png" alt="在这里插入图片描述"></p>
<p>一致性hash测试结果</p>
<p>每台机器映射的虚拟节点越多，则分布的越均匀~~~</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>CAP原理</tag>
        <tag>缓存一致性协议</tag>
      </tags>
  </entry>
</search>
