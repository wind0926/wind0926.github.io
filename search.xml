<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>7种实现web实时消息推送的方案</title>
    <url>/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="7种实现web实时消息推送的方案"><a href="#7种实现web实时消息推送的方案" class="headerlink" title="7种实现web实时消息推送的方案"></a>7种实现web实时消息推送的方案</h1><p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/1.png" alt="图片"></p>
<h3 id="什么是消息推送（push）"><a href="#什么是消息推送（push）" class="headerlink" title="什么是消息推送（push）"></a><strong>什么是消息推送（push）</strong></h3><p>推送的场景比较多，比如有人关注我的公众号，这时我就会收到一条推送消息，以此来吸引我点击打开应用。</p>
<p>消息推送(push)通常是指网站的运营工作等人员，通过某种工具对用户当前网页或移动设备APP进行的主动消息推送。</p>
<p>消息推送一般又分为web端消息推送和移动端消息推送。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/2.png" alt="图片"></p>
<p>上边的这种属于移动端消息推送，web端消息推送常见的诸如站内信、未读邮件数量、监控报警数量等，应用的也非常广泛。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/3.png" alt="图片"></p>
<p>在具体实现之前，咱们再来分析一下前边的需求，其实功能很简单，只要触发某个事件（主动分享了资源或者后台主动推送消息），web页面的通知小红点就会实时的+1就可以了。</p>
<p>通常在服务端会有若干张消息推送表，用来记录用户触发不同事件所推送不同类型的消息，前端主动查询（拉）或者被动接收（推）用户所有未读的消息数。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/4.png" alt="图片"></p>
<p>消息推送无非是推（push）和拉（pull）两种形式，下边我们逐个了解下。</p>
<h3 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询"></a><strong>短轮询</strong></h3><hr>
<p>轮询(polling)应该是实现消息推送方案中最简单的一种，这里我们暂且将轮询分为短轮询和长轮询。</p>
<p>短轮询很好理解，指定的时间间隔，由浏览器向服务器发出HTTP请求，服务器实时返回未读消息数据给客户端，浏览器再做渲染显示。</p>
<p>一个简单的JS定时器就可以搞定，每秒钟请求一次未读消息数接口，返回的数据展示即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setInterval(() =&gt; &#123;</span><br><span class="line">  // 方法请求</span><br><span class="line">  messageCount().then((res) =&gt; &#123;</span><br><span class="line">      if (res.code === 200) &#123;</span><br><span class="line">          this.messageCount = res.data</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>



<p>效果还是可以的，短轮询实现固然简单，缺点也是显而易见，由于推送数据并不会频繁变更，无论后端此时是否有新的消息产生，客户端都会进行请求，势必会对服务端造成很大压力，浪费带宽和服务器资源。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/5.jpg" alt="图片"></p>
<h3 id><a href="#" class="headerlink" title></a></h3><h3 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a><strong>长轮询</strong></h3><hr>
<p>长轮询是对上边短轮询的一种改进版本，在尽可能减少对服务器资源浪费的同时，保证消息的相对实时性。长轮询在中间件中应用的很广泛，比如Nacos和apollo配置中心，消息队列kafka、RocketMQ中都有用到长轮询。</p>
<p>Nacos配置中心交互模型是push还是pull？一文中我详细介绍过Nacos长轮询的实现原理，感兴趣的小伙伴可以瞅瞅。</p>
<p>文章链接：<a href="https://mp.weixin.qq.com/s/94ftESkDoZI9gAGflLiGwg">https://mp.weixin.qq.com/s/94ftESkDoZI9gAGflLiGwg</a></p>
<p>这次我使用apollo配置中心实现长轮询的方式，应用了一个类DeferredResult，它是在servelet3.0后经过Spring封装提供的一种异步请求机制，直意就是延迟结果。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/6.png" alt="图片"></p>
<p>DeferredResult可以允许容器线程快速释放占用的资源，不阻塞请求线程，以此接受更多的请求提升系统的吞吐量，然后启动异步工作线程处理真正的业务逻辑，处理完成调用DeferredResult.setResult(200)提交响应结果。</p>
<p>下边我们用长轮询来实现消息推送。</p>
<p>因为一个ID可能会被多个长轮询请求监听，所以我采用了guava包提供的Multimap结构存放长轮询，一个key可以对应多个value。一旦监听到key发生变化，对应的所有长轮询都会响应。前端得到非请求超时的状态码，知晓数据变更，主动查询未读消息数接口，更新页面数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/polling&quot;)</span><br><span class="line">public class PollingController &#123;</span><br><span class="line"></span><br><span class="line">    // 存放监听某个Id的长轮询集合</span><br><span class="line">    // 线程同步结构</span><br><span class="line">    public static Multimap&lt;String, DeferredResult&lt;String&gt;&gt; watchRequests = Multimaps.synchronizedMultimap(HashMultimap.create());</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 公众号：程序员小富</span><br><span class="line">     * 设置监听</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(path = &quot;watch/&#123;id&#125;&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public DeferredResult&lt;String&gt; watch(@PathVariable String id) &#123;</span><br><span class="line">        // 延迟对象设置超时时间</span><br><span class="line">        DeferredResult&lt;String&gt; deferredResult = new DeferredResult&lt;&gt;(TIME_OUT);</span><br><span class="line">        // 异步请求完成时移除 key，防止内存溢出</span><br><span class="line">        deferredResult.onCompletion(() -&gt; &#123;</span><br><span class="line">            watchRequests.remove(id, deferredResult);</span><br><span class="line">        &#125;);</span><br><span class="line">        // 注册长轮询请求</span><br><span class="line">        watchRequests.put(id, deferredResult);</span><br><span class="line">        return deferredResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 公众号：程序员小富</span><br><span class="line">     * 变更数据</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(path = &quot;publish/&#123;id&#125;&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String publish(@PathVariable String id) &#123;</span><br><span class="line">        // 数据变更 取出监听ID的所有长轮询请求，并一一响应处理</span><br><span class="line">        if (watchRequests.containsKey(id)) &#123;</span><br><span class="line">            Collection&lt;DeferredResult&lt;String&gt;&gt; deferredResults = watchRequests.get(id);</span><br><span class="line">            for (DeferredResult&lt;String&gt; deferredResult : deferredResults) &#123;</span><br><span class="line">                deferredResult.setResult(&quot;我更新了&quot; + new Date());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>当请求超过设置的超时时间，会抛出AsyncRequestTimeoutException异常，这里直接用@ControllerAdvice全局捕获统一返回即可，前端获取约定好的状态码后再次发起长轮询请求，如此往复调用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ControllerAdvice</span><br><span class="line">public class AsyncRequestTimeoutHandler &#123;</span><br><span class="line"></span><br><span class="line">    @ResponseStatus(HttpStatus.NOT_MODIFIED)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    @ExceptionHandler(AsyncRequestTimeoutException.class)</span><br><span class="line">    public String asyncRequestTimeoutHandler(AsyncRequestTimeoutException e) &#123;</span><br><span class="line">        System.out.println(&quot;异步请求超时&quot;);</span><br><span class="line">        return &quot;304&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们来测试一下，首先页面发起长轮询请求&#x2F;polling&#x2F;watch&#x2F;10086监听消息更变，请求被挂起，不变更数据直至超时，再次发起了长轮询请求；紧接着手动变更数据&#x2F;polling&#x2F;publish&#x2F;10086，长轮询得到响应，前端处理业务逻辑完成后再次发起请求，如此循环往复。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/7.jpg" alt="图片"></p>
<p>长轮询相比于短轮询在性能上提升了很多，但依然会产生较多的请求，这是它的一点不完美的地方。</p>
<h3 id="iframe流"><a href="#iframe流" class="headerlink" title="iframe流"></a><strong>iframe流</strong></h3><hr>
<p>iframe流就是在页面中插入一个隐藏的<iframe>标签，通过在src中请求消息数量API接口，由此在服务端和客户端之间创建一条长连接，服务端持续向iframe传输数据。</iframe></p>
<p>传输的数据通常是HTML、或是内嵌的javascript脚本，来达到实时更新页面的效果。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/8.png" alt="图片"></p>
<p>这种方式实现简单，前端只要一个<iframe>标签搞定了。</iframe></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe src=&quot;/iframe/message&quot; style=&quot;display:none&quot;&gt;&lt;/iframe&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>服务端直接组装html、js脚本数据向response写入就行了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/iframe&quot;)</span><br><span class="line">public class IframeController &#123;</span><br><span class="line">    @GetMapping(path = &quot;message&quot;)</span><br><span class="line">    public void message(HttpServletResponse response) throws IOException, InterruptedException &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);</span><br><span class="line">            response.setDateHeader(&quot;Expires&quot;, 0);</span><br><span class="line">            response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache,no-store&quot;);</span><br><span class="line">            response.setStatus(HttpServletResponse.SC_OK);</span><br><span class="line">            response.getWriter().print(&quot; &lt;script type=\&quot;text/javascript\&quot;&gt;\n&quot; +</span><br><span class="line">                    &quot;parent.document.getElementById(&#x27;clock&#x27;).innerHTML = \&quot;&quot; + count.get() + &quot;\&quot;;&quot; +</span><br><span class="line">                    &quot;parent.document.getElementById(&#x27;count&#x27;).innerHTML = \&quot;&quot; + count.get() + &quot;\&quot;;&quot; +</span><br><span class="line">                    &quot;&lt;/script&gt;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>但我个人不推荐，因为它在浏览器上会显示请求未加载完，图标会不停旋转，简直是强迫症杀手。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/9.jpg" alt="图片"></p>
<h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><h3 id="SSE-我的方式"><a href="#SSE-我的方式" class="headerlink" title="SSE (我的方式)"></a><strong>SSE (我的方式)</strong></h3><hr>
<p>很多人可能不知道，服务端向客户端推送消息，其实除了可以用WebSocket这种耳熟能详的机制外，还有一种服务器发送事件(Server-sent events)，简称SSE。</p>
<p>SSE它是基于HTTP协议的，我们知道一般意义上的HTTP协议是无法做到服务端主动向客户端推送消息的，但SSE是个例外，它变换了一种思路。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/10.png" alt="图片"></p>
<p>SSE在服务器和客户端之间打开一个单向通道，服务端响应的不再是一次性的数据包而是text&#x2F;event-stream类型的数据流信息，在有数据变更时从服务器流式传输到客户端。</p>
<p>整体的实现思路有点类似于在线视频播放，视频流会连续不断的推送到浏览器，你也可以理解成，客户端在完成一次用时很长（网络不畅）的下载。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/11.png" alt="图片"></p>
<p>SSE与WebSocket作用相似，都可以建立服务端与浏览器之间的通信，实现服务端向客户端推送消息，但还是有些许不同：</p>
<ul>
<li>SSE 是基于HTTP协议的，它们不需要特殊的协议或服务器实现即可工作；WebSocket需单独服务器来处理协议。</li>
<li>SSE 单向通信，只能由服务端向客户端单向通信；webSocket全双工通信，即通信的双方可以同时发送和接受信息。</li>
<li>SSE 实现简单开发成本低，无需引入其他组件；WebSocket传输数据需做二次解析，开发门槛高一些。</li>
<li>SSE 默认支持断线重连；WebSocket则需要自己实现。</li>
<li>SSE 只能传送文本消息，二进制数据需要经过编码后传送；WebSocket默认支持传送二进制数据。</li>
</ul>
<p><strong>SSE 与 WebSocket 该如何选择？</strong></p>
<p>技术并没有好坏之分，只有哪个更合适。</p>
<p>SSE好像一直不被大家所熟知，一部分原因是出现了WebSockets，这个提供了更丰富的协议来执行双向、全双工通信。对于游戏、即时通信以及需要双向近乎实时更新的场景，拥有双向通道更具吸引力。</p>
<p>但是，在某些情况下，不需要从客户端发送数据。而你只需要一些服务器操作的更新。比如：站内信、未读消息数、状态更新、股票行情、监控数量等场景，SEE不管是从实现的难易和成本上都更加有优势。此外，SSE 具有WebSockets在设计上缺乏的多种功能，例如：自动重新连接、事件ID和发送任意事件的能力。</p>
<p>前端只需进行一次HTTP请求，带上唯一ID，打开事件流，监听服务端推送的事件就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    let source = null;</span><br><span class="line">    let userId = 7777</span><br><span class="line">    if (window.EventSource) &#123;</span><br><span class="line">        // 建立连接</span><br><span class="line">        source = new EventSource(&#x27;http://localhost:7777/sse/sub/&#x27;+userId);</span><br><span class="line">        setMessageInnerHTML(&quot;连接用户=&quot; + userId);</span><br><span class="line">        /**</span><br><span class="line">         * 连接一旦建立，就会触发open事件</span><br><span class="line">         * 另一种写法：source.onopen = function (event) &#123;&#125;</span><br><span class="line">         */</span><br><span class="line">        source.addEventListener(&#x27;open&#x27;, function (e) &#123;</span><br><span class="line">            setMessageInnerHTML(&quot;建立连接。。。&quot;);</span><br><span class="line">        &#125;, false);</span><br><span class="line">        /**</span><br><span class="line">         * 客户端收到服务器发来的数据</span><br><span class="line">         * 另一种写法：source.onmessage = function (event) &#123;&#125;</span><br><span class="line">         */</span><br><span class="line">        source.addEventListener(&#x27;message&#x27;, function (e) &#123;</span><br><span class="line">            setMessageInnerHTML(e.data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        setMessageInnerHTML(&quot;你的浏览器不支持SSE&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p>服务端的实现更简单，创建一个SseEmitter对象放入sseEmitterMap进行管理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static Map&lt;String, SseEmitter&gt; sseEmitterMap = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 创建连接</span><br><span class="line"> *</span><br><span class="line"> * @date: 2022/7/12 14:51</span><br><span class="line"> * @auther: 公众号：程序员小富</span><br><span class="line"> */</span><br><span class="line">public static SseEmitter connect(String userId) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 设置超时时间，0表示不过期。默认30秒</span><br><span class="line">        SseEmitter sseEmitter = new SseEmitter(0L);</span><br><span class="line">        // 注册回调</span><br><span class="line">        sseEmitter.onCompletion(completionCallBack(userId));</span><br><span class="line">        sseEmitter.onError(errorCallBack(userId));</span><br><span class="line">        sseEmitter.onTimeout(timeoutCallBack(userId));</span><br><span class="line">        sseEmitterMap.put(userId, sseEmitter);</span><br><span class="line">        count.getAndIncrement();</span><br><span class="line">        return sseEmitter;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        log.info(&quot;创建新的sse连接异常，当前用户：&#123;&#125;&quot;, userId);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 给指定用户发送消息</span><br><span class="line"> *</span><br><span class="line"> * @date: 2022/7/12 14:51</span><br><span class="line"> * @auther: 公众号：程序员小富</span><br><span class="line"> */</span><br><span class="line">public static void sendMessage(String userId, String message) &#123;</span><br><span class="line"></span><br><span class="line">    if (sseEmitterMap.containsKey(userId)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            sseEmitterMap.get(userId).send(message);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            log.error(&quot;用户[&#123;&#125;]推送异常:&#123;&#125;&quot;, userId, e.getMessage());</span><br><span class="line">            removeUser(userId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们模拟服务端推送消息，看下客户端收到了消息，和我们预期的效果一致。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/12.jpg" alt="图片"></p>
<p>注意： SSE不支持IE浏览器，对其他主流浏览器兼容性做的还不错。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/13.png" alt="图片"></p>
<h3 id="-2"><a href="#-2" class="headerlink" title></a></h3><h3 id="MQTT"><a href="#MQTT" class="headerlink" title="MQTT"></a><strong>MQTT</strong></h3><hr>
<p>什么是 MQTT协议？</p>
<p>MQTT 全称(Message Queue Telemetry Transport)：一种基于发布&#x2F;订阅（publish&#x2F;subscribe）模式的轻量级通讯协议，通过订阅相应的主题来获取消息，是物联网（Internet of Thing）中的一个标准传输协议。</p>
<p>该协议将消息的发布者（publisher）与订阅者（subscriber）进行分离，因此可以在不可靠的网络环境中，为远程连接的设备提供可靠的消息服务，使用方式与传统的MQ有点类似。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/14.png" alt="图片"></p>
<p>TCP协议位于传输层，MQTT 协议位于应用层，MQTT 协议构建于TCP&#x2F;IP协议上，也就是说只要支持TCP&#x2F;IP协议栈的地方，都可以使用MQTT协议。</p>
<p><strong>为什么要用 MQTT协议？</strong></p>
<p>MQTT协议为什么在物联网（IOT）中如此受偏爱？而不是其它协议，比如我们更为熟悉的 HTTP协议呢？</p>
<ul>
<li>首先HTTP协议它是一种同步协议，客户端请求后需要等待服务器的响应。而在物联网（IOT）环境中，设备会很受制于环境的影响，比如带宽低、网络延迟高、网络通信不稳定等，显然异步消息协议更为适合IOT应用程序。</li>
<li>HTTP是单向的，如果要获取消息客户端必须发起连接，而在物联网（IOT）应用程序中，设备或传感器往往都是客户端，这意味着它们无法被动地接收来自网络的命令。</li>
<li>通常需要将一条命令或者消息，发送到网络上的所有设备上。HTTP要实现这样的功能不但很困难，而且成本极高。</li>
</ul>
<p>具体的MQTT协议介绍和实践，这里我就不再赘述了，大家可以参考我之前的两篇文章，里边写的也都很详细了。</p>
<p>MQTT协议的介绍：<a href="https://mp.weixin.qq.com/s/udFE6k9pPetIWsa6KeErrA">https://mp.weixin.qq.com/s/udFE6k9pPetIWsa6KeErrA</a></p>
<p>MQTT实现消息推送：<a href="https://mp.weixin.qq.com/s/U-fUGr9i1MVa4PoVyiDFCg">https://mp.weixin.qq.com/s/U-fUGr9i1MVa4PoVyiDFCg</a></p>
<h3 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a><strong>Websocket</strong></h3><hr>
<p>websocket应该是大家都比较熟悉的一种实现消息推送的方式，上边我们在讲SSE的时候也和websocket进行过比较。</p>
<p>WebSocket是一种在TCP连接上进行全双工通信的协议，建立客户端和服务器之间的通信渠道。浏览器和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/15.png" alt="图片"></p>
<p>springboot整合websocket，先引入websocket相关的工具包，和SSE相比额外的开发成本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 引入websocket --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>





<p>服务端使用@ServerEndpoint注解标注当前类为一个websocket服务器，客户端可以通过ws:&#x2F;&#x2F;localhost:7777&#x2F;webSocket&#x2F;10086来连接到WebSocket服务器端。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">@ServerEndpoint(&quot;/websocket/&#123;userId&#125;&quot;)</span><br><span class="line">public class WebSocketServer &#123;</span><br><span class="line">    //与某个客户端的连接会话，需要通过它来给客户端发送数据</span><br><span class="line">    private Session session;</span><br><span class="line">    private static final CopyOnWriteArraySet&lt;WebSocketServer&gt; webSockets = new CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line">    // 用来存在线连接数</span><br><span class="line">    private static final Map&lt;String, Session&gt; sessionPool = new HashMap&lt;String, Session&gt;();</span><br><span class="line">    /**</span><br><span class="line">     * 公众号：程序员小富</span><br><span class="line">     * 链接成功调用的方法</span><br><span class="line">     */</span><br><span class="line">    @OnOpen</span><br><span class="line">    public void onOpen(Session session, @PathParam(value = &quot;userId&quot;) String userId) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.session = session;</span><br><span class="line">            webSockets.add(this);</span><br><span class="line">            sessionPool.put(userId, session);</span><br><span class="line">            log.info(&quot;websocket消息: 有新的连接，总数为:&quot; + webSockets.size());</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 公众号：程序员小富</span><br><span class="line">     * 收到客户端消息后调用的方法</span><br><span class="line">     */</span><br><span class="line">    @OnMessage</span><br><span class="line">    public void onMessage(String message) &#123;</span><br><span class="line">        log.info(&quot;websocket消息: 收到客户端消息:&quot; + message);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 公众号：程序员小富</span><br><span class="line">     * 此为单点消息</span><br><span class="line">     */</span><br><span class="line">    public void sendOneMessage(String userId, String message) &#123;</span><br><span class="line">        Session session = sessionPool.get(userId);</span><br><span class="line">        if (session != null &amp;&amp; session.isOpen()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                log.info(&quot;websocket消: 单点消息:&quot; + message);</span><br><span class="line">                session.getAsyncRemote().sendText(message);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>前端初始化打开WebSocket连接，并监听连接状态，接收服务端数据或向服务端发送数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var ws = new WebSocket(&#x27;ws://localhost:7777/webSocket/10086&#x27;);</span><br><span class="line">    // 获取连接状态</span><br><span class="line">    console.log(&#x27;ws连接状态：&#x27; + ws.readyState);</span><br><span class="line">    //监听是否连接成功</span><br><span class="line">    ws.onopen = function () &#123;</span><br><span class="line">        console.log(&#x27;ws连接状态：&#x27; + ws.readyState);</span><br><span class="line">        //连接成功则发送一个数据</span><br><span class="line">        ws.send(&#x27;test1&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 接听服务器发回的信息并处理展示</span><br><span class="line">    ws.onmessage = function (data) &#123;</span><br><span class="line">        console.log(&#x27;接收到来自服务器的消息：&#x27;);</span><br><span class="line">        console.log(data);</span><br><span class="line">        //完成通信后关闭WebSocket连接</span><br><span class="line">        ws.close();</span><br><span class="line">    &#125;</span><br><span class="line">    // 监听连接关闭事件</span><br><span class="line">    ws.onclose = function () &#123;</span><br><span class="line">        // 监听整个过程中websocket的状态</span><br><span class="line">        console.log(&#x27;ws连接状态：&#x27; + ws.readyState);</span><br><span class="line">    &#125;</span><br><span class="line">    // 监听并处理error事件</span><br><span class="line">    ws.onerror = function (error) &#123;</span><br><span class="line">        console.log(error);</span><br><span class="line">    &#125;</span><br><span class="line">    function sendMessage() &#123;</span><br><span class="line">        var content = $(&quot;#message&quot;).val();</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: &#x27;/socket/publish?userId=10086&amp;message=&#x27; + content,</span><br><span class="line">            type: &#x27;GET&#x27;,</span><br><span class="line">            data: &#123; &quot;id&quot;: &quot;7777&quot;, &quot;content&quot;: content &#125;,</span><br><span class="line">            success: function (data) &#123;</span><br><span class="line">                console.log(data)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>





<p>页面初始化建立websocket连接，之后就可以进行双向通信了，效果还不错。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/20.png" alt="图片"></p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/16.jpg" alt="图片"></p>
<h3 id="-3"><a href="#-3" class="headerlink" title></a></h3><h3 id="自定义推送"><a href="#自定义推送" class="headerlink" title="自定义推送"></a><strong>自定义推送</strong></h3><hr>
<p>上边我们给我出了6种方案的原理和代码实现，但在实际业务开发过程中，不能盲目的直接拿过来用，还是要结合自身系统业务的特点和实际场景来选择合适的方案。</p>
<p>推送最直接的方式就是使用第三推送平台，毕竟钱能解决的需求都不是问题，无需复杂的开发运维，直接可以使用，省时、省力、省心，像goEasy、极光推送都是很不错的三方服务商。</p>
<p>一般大型公司都有自研的消息推送平台，像我们本次实现的web站内信只是平台上的一个触点而已，短信、邮件、微信公众号、小程序凡是可以触达到用户的渠道都可以接入进来。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/17.png" alt="图片"></p>
<p>消息推送系统内部是相当复杂的，诸如消息内容的维护审核、圈定推送人群、触达过滤拦截（推送的规则频次、时段、数量、黑白名单、关键词等等）、推送失败补偿非常多的模块，技术上涉及到大数据量、高并发的场景也很多。所以我们今天的实现方式在这个庞大的系统面前只是小打小闹。</p>
<h3 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a><strong>Github地址</strong></h3><hr>
<p>文中所提到的案例我都一一的做了实现，整理放在了Github上，觉得有用就 Star 一下吧！</p>
<p>传送门：<a href="https://github.com/chengxy-nds/Springboot-Notebook/tree/master/springboot-realtime-data">https://github.com/chengxy-nds/Springboot-Notebook/tree/master/springboot-realtime-data</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK/Dubbo/Spring 三种 SPI 机制，谁更好？</title>
    <url>/2022/10/21/JDKDubboSpring%20%E4%B8%89%E7%A7%8D%20SPI%20%E6%9C%BA%E5%88%B6%EF%BC%8C%E8%B0%81%E6%9B%B4%E5%A5%BD/</url>
    <content><![CDATA[<h1 id="JDK-x2F-Dubbo-x2F-Spring-三种-SPI-机制，谁更好？"><a href="#JDK-x2F-Dubbo-x2F-Spring-三种-SPI-机制，谁更好？" class="headerlink" title="JDK&#x2F;Dubbo&#x2F;Spring 三种 SPI 机制，谁更好？"></a>JDK&#x2F;Dubbo&#x2F;Spring 三种 SPI 机制，谁更好？</h1><blockquote>
<p>SPI 全称为 Service Provider Interface，是一种服务发现机制。SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。正因此特性，我们可以很容易的通过 SPI 机制为我们的程序提供拓展功能。</p>
</blockquote>
<p>本文主要是特性 &amp; 用法介绍，不涉及源码解析（源码都很简单，相信你一定一看就懂）</p>
<h2 id="SPI-有什么用？"><a href="#SPI-有什么用？" class="headerlink" title="SPI 有什么用？"></a>SPI 有什么用？</h2><p>举个栗子，现在我们设计了一款全新的日志框架：<strong>super-logger</strong>。默认以XML文件作为我们这款日志的配置文件，并设计了一个配置文件解析的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.kongwu.spisamples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SuperLoggerConfiguration</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(String configFile)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后来一个默认的XML实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.kongwu.spisamples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XMLConfiguration</span> <span class="keyword">implements</span> <span class="title class_">SuperLoggerConfiguration</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(String configFile)</span>&#123;</span><br><span class="line">    	......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么我们在初始化，解析配置时，只需要调用这个XMLConfiguration来解析XML配置文件即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.kongwu.spisamples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">SuperLoggerConfiguration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLConfiguration</span>();</span><br><span class="line">		configuration.configure(configFile);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">getLogger</span><span class="params">(Class clazz)</span>&#123;</span><br><span class="line">    	......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样就完成了一个基础的模型，看起来也没什么问题。不过扩展性不太好，因为如果想定制&#x2F;扩展&#x2F;重写解析功能的话，我还得重新定义入口的代码，LoggerFactory 也得重写，不够灵活，侵入性太强了。</p>
<p>比如现在用户&#x2F;使用方想增加一个 yml 文件的方式，作为日志配置文件，那么只需要新建一个YAMLConfiguration，实现 SuperLoggerConfiguration 就可以。但是……怎么注入呢，怎么让 LoggerFactory中使用新建的这个 YAMLConfiguration ？难不成连 LoggerFactory 也重写了？</p>
<p>如果借助SPI机制的话，这个事情就很简单了，可以很方便的完成这个入口的扩展功能。</p>
<p>下面就先来看看，利用JDK 的 SPI 机制怎么解决上面的扩展性问题。</p>
<h2 id="JDK-SPI"><a href="#JDK-SPI" class="headerlink" title="JDK SPI"></a>JDK SPI</h2><p>JDK 中 提供了一个 SPI 的功能，核心类是 java.util.ServiceLoader。其作用就是，可以通过类名获取在”META-INF&#x2F;services&#x2F;“下的多个配置实现文件。</p>
<p>为了解决上面的扩展问题，现在我们在<code>META-INF/services/</code>下创建一个<code>com.github.kongwu.spisamples.SuperLoggerConfiguration</code>文件（没有后缀）。文件中只有一行代码，那就是我们默认的<code>com.github.kongwu.spisamples.XMLConfiguration</code>（注意，一个文件里也可以写多个实现，回车分隔）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">META-INF/services/com.github.kongwu.spisamples.SuperLoggerConfiguration:</span><br><span class="line"></span><br><span class="line">com.github.kongwu.spisamples.XMLConfiguration</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后通过 ServiceLoader 获取我们的 SPI 机制配置的实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServiceLoader&lt;SuperLoggerConfiguration&gt; serviceLoader = ServiceLoader.load(SuperLoggerConfiguration.class);</span><br><span class="line">Iterator&lt;SuperLoggerConfiguration&gt; iterator = serviceLoader.iterator();</span><br><span class="line">SuperLoggerConfiguration configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">    <span class="comment">//加载并初始化实现类</span></span><br><span class="line">	configuration = iterator.next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对最后一个configuration类调用configure方法</span></span><br><span class="line">configuration.configure(configFile);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后在调整LoggerFactory中初始化配置的方式为现在的SPI方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.kongwu.spisamples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">        ServiceLoader&lt;SuperLoggerConfiguration&gt; serviceLoader = ServiceLoader.load(SuperLoggerConfiguration.class);</span><br><span class="line">        Iterator&lt;SuperLoggerConfiguration&gt; iterator = serviceLoader.iterator();</span><br><span class="line">        SuperLoggerConfiguration configuration;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">            configuration = iterator.next();<span class="comment">//加载并初始化实现类</span></span><br><span class="line">        &#125;</span><br><span class="line">        configuration.configure(configFile);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">getLogger</span><span class="params">(Class clazz)</span>&#123;</span><br><span class="line">    	......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>等等，这里为什么是用 iterator ? 而不是get之类的只获取一个实例的方法？</strong></p>
<p>试想一下，如果是一个固定的get方法，那么get到的是一个固定的实例，SPI 还有什么意义呢？</p>
<p>SPI 的目的，就是增强扩展性。将固定的配置提取出来，通过 SPI 机制来配置。那既然如此，一般都会有一个默认的配置，然后通过 SPI 的文件配置不同的实现，这样就会存在一个接口多个实现的问题。要是找到多个实现的话，用哪个实现作为最后的实例呢？</p>
<p>所以这里使用iterator来获取所有的实现类配置。刚才已经在我们这个 <strong>super-logger</strong> 包里增加了默认的SuperLoggerConfiguration 实现。</p>
<p>为了支持 YAML 配置，现在在使用方&#x2F;用户的代码里，增加一个YAMLConfiguration的 SPI 配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">META-INF/services/com.github.kongwu.spisamples.SuperLoggerConfiguration:</span><br><span class="line"></span><br><span class="line">com.github.kongwu.spisamples.ext.YAMLConfiguration</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>此时通过iterator方法，就会获取到默认的XMLConfiguration和我们扩展的这个YAMLConfiguration两个配置实现类了。</p>
<p>在上面那段加载的代码里，我们遍历iterator，遍历到最后，我们使用最后一个实现配置作为最终的实例。</p>
<p><strong>再等等？最后一个？怎么算最后一个？</strong></p>
<p>使用方&#x2F;用户自定义的的这个 YAMLConfiguration 一定是最后一个吗？</p>
<p>这个真的不一定，取决于我们运行时的 ClassPath 配置，在前面加载的jar自然在前，最后的jar里的自然当然也在后面。所以<strong>如果用户的包在ClassPath中的顺序比super-logger的包更靠后，才会处于最后一个位置；如果用户的包位置在前，那么所谓的最后一个仍然是默认的XMLConfiguration。</strong></p>
<p>举个栗子，如果我们程序的启动脚本为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -<span class="built_in">cp</span> super-logger.jar:a.jar:b.jar:main.jar example.Main</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>默认的XMLConfiguration SPI配置在<code>super-logger.jar</code>，扩展的YAMLConfiguration SPI配置文件在<code>main.jar</code>，那么iterator获取的最后一个元素一定为YAMLConfiguration。</p>
<p>但这个classpath顺序如果反了呢？main.jar 在前，super-logger.jar 在后</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -<span class="built_in">cp</span> main.jar:super-logger.jar:a.jar:b.jar example.Main</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>这样一来，iterator 获取的最后一个元素又变成了默认的XMLConfiguration，我们使用 JDK SPI 没啥意义了，获取的又是第一个，还是默认的XMLConfiguration。</p>
<p>由于这个加载顺序（classpath）是由用户指定的，所以无论我们加载第一个还是最后一个，都有可能会导致加载不到用户自定义的那个配置。</p>
<p><strong>所以这也是JDK SPI机制的一个劣势，无法确认具体加载哪一个实现，也无法加载某个指定的实现，仅靠ClassPath的顺序是一个非常不严谨的方式</strong></p>
<h2 id="Dubbo-SPI"><a href="#Dubbo-SPI" class="headerlink" title="Dubbo SPI"></a>Dubbo SPI</h2><blockquote>
<p>Dubbo 就是通过 SPI 机制加载所有的组件。不过，Dubbo 并未使用 Java 原生的 SPI 机制，而是对其进行了增强，使其能够更好的满足需求。在 Dubbo 中，SPI 是一个非常重要的模块。基于 SPI，我们可以很容易的对 Dubbo 进行拓展。如果大家想要学习 Dubbo 的源码，SPI 机制务必弄懂。接下来，我们先来了解一下 Java SPI 与 Dubbo SPI 的用法，然后再来分析 Dubbo SPI 的源码。</p>
</blockquote>
<p>Dubbo 中实现了一套新的 SPI 机制，功能更强大，也更复杂一些。相关逻辑被封装在了 ExtensionLoader 类中，通过 ExtensionLoader，我们可以加载指定的实现类。Dubbo SPI 所需的配置文件需放置在 META-INF&#x2F;dubbo 路径下，配置内容如下（以下demo来自dubbo官方文档）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">optimusPrime = org.apache.spi.OptimusPrime</span><br><span class="line">bumblebee = org.apache.spi.Bumblebee</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>与 Java SPI 实现类配置不同，Dubbo SPI 是通过键值对的方式进行配置，这样我们可以按需加载指定的实现类。另外在使用时还需要在接口上标注 @SPI 注解。下面来演示 Dubbo SPI 的用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Robot</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptimusPrime</span> <span class="keyword">implements</span> <span class="title class_">Robot</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I am Optimus Prime.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bumblebee</span> <span class="keyword">implements</span> <span class="title class_">Robot</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I am Bumblebee.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DubboSPITest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ExtensionLoader&lt;Robot&gt; extensionLoader = </span><br><span class="line">            ExtensionLoader.getExtensionLoader(Robot.class);</span><br><span class="line">        <span class="type">Robot</span> <span class="variable">optimusPrime</span> <span class="operator">=</span> extensionLoader.getExtension(<span class="string">&quot;optimusPrime&quot;</span>);</span><br><span class="line">        optimusPrime.sayHello();</span><br><span class="line">        <span class="type">Robot</span> <span class="variable">bumblebee</span> <span class="operator">=</span> extensionLoader.getExtension(<span class="string">&quot;bumblebee&quot;</span>);</span><br><span class="line">        bumblebee.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p><strong>Dubbo SPI 和 JDK SPI 最大的区别就在于支持“别名”</strong>，可以通过某个扩展点的别名来获取固定的扩展点。就像上面的例子中，我可以获取 Robot 多个 SPI 实现中别名为“optimusPrime”的实现，也可以获取别名为“bumblebee”的实现，这个功能非常有用！</p>
<p>通过 @SPI 注解的 value 属性，还可以默认一个“别名”的实现。比如在Dubbo 中，默认的是Dubbo 私有协议：<strong>dubbo protocol - dubbo:&#x2F;&#x2F;</strong> ** 来看看Dubbo中协议的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;dubbo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Protocol</span> &#123;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>在 Protocol 接口上，增加了一个 @SPI 注解，而注解的 value 值为 Dubbo ，通过 SPI 获取实现时就会获取 Protocol SPI 配置中别名为dubbo的那个实现，<code>com.alibaba.dubbo.rpc.Protocol</code>文件如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">filter=com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper</span><br><span class="line">listener=com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper</span><br><span class="line">mock=com.alibaba.dubbo.rpc.support.MockProtocol</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">injvm=com.alibaba.dubbo.rpc.protocol.injvm.InjvmProtocol</span><br><span class="line">rmi=com.alibaba.dubbo.rpc.protocol.rmi.RmiProtocol</span><br><span class="line">hessian=com.alibaba.dubbo.rpc.protocol.hessian.HessianProtocol</span><br><span class="line">com.alibaba.dubbo.rpc.protocol.http.HttpProtocol</span><br><span class="line">com.alibaba.dubbo.rpc.protocol.webservice.WebServiceProtocol</span><br><span class="line">thrift=com.alibaba.dubbo.rpc.protocol.thrift.ThriftProtocol</span><br><span class="line">memcached=com.alibaba.dubbo.rpc.protocol.memcached.MemcachedProtocol</span><br><span class="line">redis=com.alibaba.dubbo.rpc.protocol.redis.RedisProtocol</span><br><span class="line">rest=com.alibaba.dubbo.rpc.protocol.rest.RestProtocol</span><br><span class="line">registry=com.alibaba.dubbo.registry.integration.RegistryProtocol</span><br><span class="line">qos=com.alibaba.dubbo.qos.protocol.QosProtocolWrapper</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>然后只需要通过getDefaultExtension，就可以获取到 @SPI 注解上value对应的那个扩展实现了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Protocol</span> <span class="variable">protocol</span> <span class="operator">=</span> ExtensionLoader.getExtensionLoader(Protocol.class).getDefaultExtension();</span><br><span class="line"><span class="comment">//protocol: DubboProtocol</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>还有一个 Adaptive 的机制，虽然非常灵活，但……用法并不是很“优雅”，这里就不介绍了</p>
<p>Dubbo 的 SPI 中还有一个“加载优先级”，优先加载内置（internal）的，然后加载外部的（external），按优先级顺序加载，<strong>如果遇到重复就跳过不会加载</strong>了。</p>
<p>所以如果想靠classpath加载顺序去覆盖内置的扩展，也是个不太理智的做法，原因同上 - 加载顺序不严谨</p>
<h2 id="Spring-SPI"><a href="#Spring-SPI" class="headerlink" title="Spring SPI"></a>Spring SPI</h2><p>Spring 的 SPI 配置文件是一个固定的文件 - <code>META-INF/spring.factories</code>，功能上和 JDK 的类似，每个接口可以有多个扩展实现，使用起来非常简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取所有factories文件中配置的LoggingSystemFactory</span></span><br><span class="line">List&lt;LoggingSystemFactory&gt;&gt; factories = </span><br><span class="line">    SpringFactoriesLoader.loadFactories(LoggingSystemFactory.class, classLoader);</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>下面是一段 Spring Boot 中 spring.factories 的配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Logging Systems</span><br><span class="line">org.springframework.boot.logging.LoggingSystemFactory=\</span><br><span class="line">org.springframework.boot.logging.logback.LogbackLoggingSystem.Factory,\</span><br><span class="line">org.springframework.boot.logging.log4j2.Log4J2LoggingSystem.Factory,\</span><br><span class="line">org.springframework.boot.logging.java.JavaLoggingSystem.Factory</span><br><span class="line"></span><br><span class="line"># PropertySource Loaders</span><br><span class="line">org.springframework.boot.env.PropertySourceLoader=\</span><br><span class="line">org.springframework.boot.env.PropertiesPropertySourceLoader,\</span><br><span class="line">org.springframework.boot.env.YamlPropertySourceLoader</span><br><span class="line"></span><br><span class="line"># ConfigData Location Resolvers</span><br><span class="line">org.springframework.boot.context.config.ConfigDataLocationResolver=\</span><br><span class="line">org.springframework.boot.context.config.ConfigTreeConfigDataLocationResolver,\</span><br><span class="line">org.springframework.boot.context.config.StandardConfigDataLocationResolver</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>Spring SPI 中，将所有的配置放到一个固定的文件中，省去了配置一大堆文件的麻烦。至于多个接口的扩展配置，是用一个文件好，还是每个单独一个文件好这个，这个问题就见仁见智了（个人喜欢 Spring 这种，干净利落）。</p>
<p>Spring的SPI 虽然属于spring-framework(core)，但是目前主要用在spring boot中……</p>
<p>和前面两种 SPI 机制一样，Spring 也是支持 ClassPath 中存在多个 spring.factories 文件的，加载时会按照 classpath 的顺序依次加载这些 spring.factories 文件，添加到一个 ArrayList 中。由于没有别名，所以也没有去重的概念，有多少就添加多少。</p>
<p>但由于 Spring 的 SPI 主要用在 Spring Boot 中，而 Spring Boot 中的 ClassLoader 会优先加载项目中的文件，而不是依赖包中的文件。所以如果在你的项目中定义个spring.factories文件，那么你项目中的文件会被第一个加载，得到的Factories中，项目中spring.factories里配置的那个实现类也会排在第一个</p>
<p>如果我们要扩展某个接口的话，只需要在你的项目（spring boot）里新建一个<code>META-INF/spring.factories</code>文件，<strong>只添加你要的那个配置，不要完整的复制一遍 Spring Boot 的 spring.factories 文件然后修改</strong> 比如我只想添加一个新的 LoggingSystemFactory 实现，那么我只需要新建一个<code>META-INF/spring.factories</code>文件，而不是完整的复制+修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.logging.LoggingSystemFactory=\</span><br><span class="line">com.example.log4j2demo.Log4J2LoggingSystem.Factory</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><table>
<thead>
<tr>
<th></th>
<th>JDK SPI</th>
<th>DUBBO SPI</th>
<th>Spring SPI</th>
</tr>
</thead>
<tbody><tr>
<td>文件方式</td>
<td>每个扩展点单独一个文件</td>
<td>每个扩展点单独一个文件</td>
<td>所有的扩展点在一个文件</td>
</tr>
<tr>
<td>获取某个固定的实现</td>
<td>不支持，只能按顺序获取所有实现</td>
<td>有“别名”的概念，可以通过名称获取扩展点的某个固定实现，配合Dubbo SPI的注解很方便</td>
<td>不支持，只能按顺序获取所有实现。但由于Spring Boot ClassLoader会优先加载用户代码中的文件，所以可以保证用户自定义的spring.factoires文件在第一个，通过获取第一个factory的方式就可以固定获取自定义的扩展</td>
</tr>
<tr>
<td>其他</td>
<td>无</td>
<td>支持Dubbo内部的依赖注入，通过目录来区分Dubbo 内置SPI和外部SPI，优先加载内部，保证内部的优先级最高</td>
<td>无</td>
</tr>
<tr>
<td>文档完整度</td>
<td>文章 &amp; 三方资料足够丰富</td>
<td>文档 &amp; 三方资料足够丰富</td>
<td>文档不够丰富，但由于功能少，使用非常简单</td>
</tr>
<tr>
<td>IDE支持</td>
<td>无</td>
<td>无</td>
<td>IDEA 完美支持，有语法提示</td>
</tr>
</tbody></table>
<p>三种 SPI 机制对比之下，JDK 内置的机制是最弱鸡的，但是由于是 JDK 内置，所以还是有一定应用场景，毕竟不用额外的依赖；Dubbo 的功能最丰富，但机制有点复杂了，而且只能配合 Dubbo 使用，不能完全算是一个独立的模块；Spring 的功能和JDK的相差无几，最大的区别是所有扩展点写在一个 spring.factories 文件中，也算是一个改进，并且 IDEA 完美支持语法提示。</p>
]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>日常生活</tag>
        <tag>杂文</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
</search>
