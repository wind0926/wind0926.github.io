<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>7种实现web实时消息推送的方案</title>
    <url>/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="7种实现web实时消息推送的方案"><a href="#7种实现web实时消息推送的方案" class="headerlink" title="7种实现web实时消息推送的方案"></a>7种实现web实时消息推送的方案</h1><p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/1.png" alt="图片"></p>
<h3 id="什么是消息推送（push）"><a href="#什么是消息推送（push）" class="headerlink" title="什么是消息推送（push）"></a><strong>什么是消息推送（push）</strong></h3><p>推送的场景比较多，比如有人关注我的公众号，这时我就会收到一条推送消息，以此来吸引我点击打开应用。</p>
<p>消息推送(push)通常是指网站的运营工作等人员，通过某种工具对用户当前网页或移动设备APP进行的主动消息推送。</p>
<p>消息推送一般又分为web端消息推送和移动端消息推送。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/2.png" alt="图片"></p>
<p>上边的这种属于移动端消息推送，web端消息推送常见的诸如站内信、未读邮件数量、监控报警数量等，应用的也非常广泛。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/3.png" alt="图片"></p>
<p>在具体实现之前，咱们再来分析一下前边的需求，其实功能很简单，只要触发某个事件（主动分享了资源或者后台主动推送消息），web页面的通知小红点就会实时的+1就可以了。</p>
<p>通常在服务端会有若干张消息推送表，用来记录用户触发不同事件所推送不同类型的消息，前端主动查询（拉）或者被动接收（推）用户所有未读的消息数。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/4.png" alt="图片"></p>
<p>消息推送无非是推（push）和拉（pull）两种形式，下边我们逐个了解下。</p>
<h3 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询"></a><strong>短轮询</strong></h3><hr>
<p>轮询(polling)应该是实现消息推送方案中最简单的一种，这里我们暂且将轮询分为短轮询和长轮询。</p>
<p>短轮询很好理解，指定的时间间隔，由浏览器向服务器发出HTTP请求，服务器实时返回未读消息数据给客户端，浏览器再做渲染显示。</p>
<p>一个简单的JS定时器就可以搞定，每秒钟请求一次未读消息数接口，返回的数据展示即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setInterval(() =&gt; &#123;</span><br><span class="line">  // 方法请求</span><br><span class="line">  messageCount().then((res) =&gt; &#123;</span><br><span class="line">      if (res.code === 200) &#123;</span><br><span class="line">          this.messageCount = res.data</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>



<p>效果还是可以的，短轮询实现固然简单，缺点也是显而易见，由于推送数据并不会频繁变更，无论后端此时是否有新的消息产生，客户端都会进行请求，势必会对服务端造成很大压力，浪费带宽和服务器资源。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/5.jpg" alt="图片"></p>
<h3 id><a href="#" class="headerlink" title></a></h3><h3 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a><strong>长轮询</strong></h3><hr>
<p>长轮询是对上边短轮询的一种改进版本，在尽可能减少对服务器资源浪费的同时，保证消息的相对实时性。长轮询在中间件中应用的很广泛，比如Nacos和apollo配置中心，消息队列kafka、RocketMQ中都有用到长轮询。</p>
<p>Nacos配置中心交互模型是push还是pull？一文中我详细介绍过Nacos长轮询的实现原理，感兴趣的小伙伴可以瞅瞅。</p>
<p>文章链接：<a href="https://mp.weixin.qq.com/s/94ftESkDoZI9gAGflLiGwg">https://mp.weixin.qq.com/s/94ftESkDoZI9gAGflLiGwg</a></p>
<p>这次我使用apollo配置中心实现长轮询的方式，应用了一个类DeferredResult，它是在servelet3.0后经过Spring封装提供的一种异步请求机制，直意就是延迟结果。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/6.png" alt="图片"></p>
<p>DeferredResult可以允许容器线程快速释放占用的资源，不阻塞请求线程，以此接受更多的请求提升系统的吞吐量，然后启动异步工作线程处理真正的业务逻辑，处理完成调用DeferredResult.setResult(200)提交响应结果。</p>
<p>下边我们用长轮询来实现消息推送。</p>
<p>因为一个ID可能会被多个长轮询请求监听，所以我采用了guava包提供的Multimap结构存放长轮询，一个key可以对应多个value。一旦监听到key发生变化，对应的所有长轮询都会响应。前端得到非请求超时的状态码，知晓数据变更，主动查询未读消息数接口，更新页面数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/polling&quot;)</span><br><span class="line">public class PollingController &#123;</span><br><span class="line"></span><br><span class="line">    // 存放监听某个Id的长轮询集合</span><br><span class="line">    // 线程同步结构</span><br><span class="line">    public static Multimap&lt;String, DeferredResult&lt;String&gt;&gt; watchRequests = Multimaps.synchronizedMultimap(HashMultimap.create());</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 公众号：程序员小富</span><br><span class="line">     * 设置监听</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(path = &quot;watch/&#123;id&#125;&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public DeferredResult&lt;String&gt; watch(@PathVariable String id) &#123;</span><br><span class="line">        // 延迟对象设置超时时间</span><br><span class="line">        DeferredResult&lt;String&gt; deferredResult = new DeferredResult&lt;&gt;(TIME_OUT);</span><br><span class="line">        // 异步请求完成时移除 key，防止内存溢出</span><br><span class="line">        deferredResult.onCompletion(() -&gt; &#123;</span><br><span class="line">            watchRequests.remove(id, deferredResult);</span><br><span class="line">        &#125;);</span><br><span class="line">        // 注册长轮询请求</span><br><span class="line">        watchRequests.put(id, deferredResult);</span><br><span class="line">        return deferredResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 公众号：程序员小富</span><br><span class="line">     * 变更数据</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(path = &quot;publish/&#123;id&#125;&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String publish(@PathVariable String id) &#123;</span><br><span class="line">        // 数据变更 取出监听ID的所有长轮询请求，并一一响应处理</span><br><span class="line">        if (watchRequests.containsKey(id)) &#123;</span><br><span class="line">            Collection&lt;DeferredResult&lt;String&gt;&gt; deferredResults = watchRequests.get(id);</span><br><span class="line">            for (DeferredResult&lt;String&gt; deferredResult : deferredResults) &#123;</span><br><span class="line">                deferredResult.setResult(&quot;我更新了&quot; + new Date());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>当请求超过设置的超时时间，会抛出AsyncRequestTimeoutException异常，这里直接用@ControllerAdvice全局捕获统一返回即可，前端获取约定好的状态码后再次发起长轮询请求，如此往复调用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ControllerAdvice</span><br><span class="line">public class AsyncRequestTimeoutHandler &#123;</span><br><span class="line"></span><br><span class="line">    @ResponseStatus(HttpStatus.NOT_MODIFIED)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    @ExceptionHandler(AsyncRequestTimeoutException.class)</span><br><span class="line">    public String asyncRequestTimeoutHandler(AsyncRequestTimeoutException e) &#123;</span><br><span class="line">        System.out.println(&quot;异步请求超时&quot;);</span><br><span class="line">        return &quot;304&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们来测试一下，首先页面发起长轮询请求&#x2F;polling&#x2F;watch&#x2F;10086监听消息更变，请求被挂起，不变更数据直至超时，再次发起了长轮询请求；紧接着手动变更数据&#x2F;polling&#x2F;publish&#x2F;10086，长轮询得到响应，前端处理业务逻辑完成后再次发起请求，如此循环往复。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/7.jpg" alt="图片"></p>
<p>长轮询相比于短轮询在性能上提升了很多，但依然会产生较多的请求，这是它的一点不完美的地方。</p>
<h3 id="iframe流"><a href="#iframe流" class="headerlink" title="iframe流"></a><strong>iframe流</strong></h3><hr>
<p>iframe流就是在页面中插入一个隐藏的<iframe>标签，通过在src中请求消息数量API接口，由此在服务端和客户端之间创建一条长连接，服务端持续向iframe传输数据。</iframe></p>
<p>传输的数据通常是HTML、或是内嵌的javascript脚本，来达到实时更新页面的效果。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/8.png" alt="图片"></p>
<p>这种方式实现简单，前端只要一个<iframe>标签搞定了。</iframe></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe src=&quot;/iframe/message&quot; style=&quot;display:none&quot;&gt;&lt;/iframe&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>服务端直接组装html、js脚本数据向response写入就行了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/iframe&quot;)</span><br><span class="line">public class IframeController &#123;</span><br><span class="line">    @GetMapping(path = &quot;message&quot;)</span><br><span class="line">    public void message(HttpServletResponse response) throws IOException, InterruptedException &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);</span><br><span class="line">            response.setDateHeader(&quot;Expires&quot;, 0);</span><br><span class="line">            response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache,no-store&quot;);</span><br><span class="line">            response.setStatus(HttpServletResponse.SC_OK);</span><br><span class="line">            response.getWriter().print(&quot; &lt;script type=\&quot;text/javascript\&quot;&gt;\n&quot; +</span><br><span class="line">                    &quot;parent.document.getElementById(&#x27;clock&#x27;).innerHTML = \&quot;&quot; + count.get() + &quot;\&quot;;&quot; +</span><br><span class="line">                    &quot;parent.document.getElementById(&#x27;count&#x27;).innerHTML = \&quot;&quot; + count.get() + &quot;\&quot;;&quot; +</span><br><span class="line">                    &quot;&lt;/script&gt;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>但我个人不推荐，因为它在浏览器上会显示请求未加载完，图标会不停旋转，简直是强迫症杀手。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/9.jpg" alt="图片"></p>
<h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><h3 id="SSE-我的方式"><a href="#SSE-我的方式" class="headerlink" title="SSE (我的方式)"></a><strong>SSE (我的方式)</strong></h3><hr>
<p>很多人可能不知道，服务端向客户端推送消息，其实除了可以用WebSocket这种耳熟能详的机制外，还有一种服务器发送事件(Server-sent events)，简称SSE。</p>
<p>SSE它是基于HTTP协议的，我们知道一般意义上的HTTP协议是无法做到服务端主动向客户端推送消息的，但SSE是个例外，它变换了一种思路。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/10.png" alt="图片"></p>
<p>SSE在服务器和客户端之间打开一个单向通道，服务端响应的不再是一次性的数据包而是text&#x2F;event-stream类型的数据流信息，在有数据变更时从服务器流式传输到客户端。</p>
<p>整体的实现思路有点类似于在线视频播放，视频流会连续不断的推送到浏览器，你也可以理解成，客户端在完成一次用时很长（网络不畅）的下载。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/11.png" alt="图片"></p>
<p>SSE与WebSocket作用相似，都可以建立服务端与浏览器之间的通信，实现服务端向客户端推送消息，但还是有些许不同：</p>
<ul>
<li>SSE 是基于HTTP协议的，它们不需要特殊的协议或服务器实现即可工作；WebSocket需单独服务器来处理协议。</li>
<li>SSE 单向通信，只能由服务端向客户端单向通信；webSocket全双工通信，即通信的双方可以同时发送和接受信息。</li>
<li>SSE 实现简单开发成本低，无需引入其他组件；WebSocket传输数据需做二次解析，开发门槛高一些。</li>
<li>SSE 默认支持断线重连；WebSocket则需要自己实现。</li>
<li>SSE 只能传送文本消息，二进制数据需要经过编码后传送；WebSocket默认支持传送二进制数据。</li>
</ul>
<p><strong>SSE 与 WebSocket 该如何选择？</strong></p>
<p>技术并没有好坏之分，只有哪个更合适。</p>
<p>SSE好像一直不被大家所熟知，一部分原因是出现了WebSockets，这个提供了更丰富的协议来执行双向、全双工通信。对于游戏、即时通信以及需要双向近乎实时更新的场景，拥有双向通道更具吸引力。</p>
<p>但是，在某些情况下，不需要从客户端发送数据。而你只需要一些服务器操作的更新。比如：站内信、未读消息数、状态更新、股票行情、监控数量等场景，SEE不管是从实现的难易和成本上都更加有优势。此外，SSE 具有WebSockets在设计上缺乏的多种功能，例如：自动重新连接、事件ID和发送任意事件的能力。</p>
<p>前端只需进行一次HTTP请求，带上唯一ID，打开事件流，监听服务端推送的事件就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    let source = null;</span><br><span class="line">    let userId = 7777</span><br><span class="line">    if (window.EventSource) &#123;</span><br><span class="line">        // 建立连接</span><br><span class="line">        source = new EventSource(&#x27;http://localhost:7777/sse/sub/&#x27;+userId);</span><br><span class="line">        setMessageInnerHTML(&quot;连接用户=&quot; + userId);</span><br><span class="line">        /**</span><br><span class="line">         * 连接一旦建立，就会触发open事件</span><br><span class="line">         * 另一种写法：source.onopen = function (event) &#123;&#125;</span><br><span class="line">         */</span><br><span class="line">        source.addEventListener(&#x27;open&#x27;, function (e) &#123;</span><br><span class="line">            setMessageInnerHTML(&quot;建立连接。。。&quot;);</span><br><span class="line">        &#125;, false);</span><br><span class="line">        /**</span><br><span class="line">         * 客户端收到服务器发来的数据</span><br><span class="line">         * 另一种写法：source.onmessage = function (event) &#123;&#125;</span><br><span class="line">         */</span><br><span class="line">        source.addEventListener(&#x27;message&#x27;, function (e) &#123;</span><br><span class="line">            setMessageInnerHTML(e.data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        setMessageInnerHTML(&quot;你的浏览器不支持SSE&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p>服务端的实现更简单，创建一个SseEmitter对象放入sseEmitterMap进行管理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static Map&lt;String, SseEmitter&gt; sseEmitterMap = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 创建连接</span><br><span class="line"> *</span><br><span class="line"> * @date: 2022/7/12 14:51</span><br><span class="line"> * @auther: 公众号：程序员小富</span><br><span class="line"> */</span><br><span class="line">public static SseEmitter connect(String userId) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 设置超时时间，0表示不过期。默认30秒</span><br><span class="line">        SseEmitter sseEmitter = new SseEmitter(0L);</span><br><span class="line">        // 注册回调</span><br><span class="line">        sseEmitter.onCompletion(completionCallBack(userId));</span><br><span class="line">        sseEmitter.onError(errorCallBack(userId));</span><br><span class="line">        sseEmitter.onTimeout(timeoutCallBack(userId));</span><br><span class="line">        sseEmitterMap.put(userId, sseEmitter);</span><br><span class="line">        count.getAndIncrement();</span><br><span class="line">        return sseEmitter;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        log.info(&quot;创建新的sse连接异常，当前用户：&#123;&#125;&quot;, userId);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 给指定用户发送消息</span><br><span class="line"> *</span><br><span class="line"> * @date: 2022/7/12 14:51</span><br><span class="line"> * @auther: 公众号：程序员小富</span><br><span class="line"> */</span><br><span class="line">public static void sendMessage(String userId, String message) &#123;</span><br><span class="line"></span><br><span class="line">    if (sseEmitterMap.containsKey(userId)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            sseEmitterMap.get(userId).send(message);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            log.error(&quot;用户[&#123;&#125;]推送异常:&#123;&#125;&quot;, userId, e.getMessage());</span><br><span class="line">            removeUser(userId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们模拟服务端推送消息，看下客户端收到了消息，和我们预期的效果一致。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/12.jpg" alt="图片"></p>
<p>注意： SSE不支持IE浏览器，对其他主流浏览器兼容性做的还不错。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/13.png" alt="图片"></p>
<h3 id="-2"><a href="#-2" class="headerlink" title></a></h3><h3 id="MQTT"><a href="#MQTT" class="headerlink" title="MQTT"></a><strong>MQTT</strong></h3><hr>
<p>什么是 MQTT协议？</p>
<p>MQTT 全称(Message Queue Telemetry Transport)：一种基于发布&#x2F;订阅（publish&#x2F;subscribe）模式的轻量级通讯协议，通过订阅相应的主题来获取消息，是物联网（Internet of Thing）中的一个标准传输协议。</p>
<p>该协议将消息的发布者（publisher）与订阅者（subscriber）进行分离，因此可以在不可靠的网络环境中，为远程连接的设备提供可靠的消息服务，使用方式与传统的MQ有点类似。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/14.png" alt="图片"></p>
<p>TCP协议位于传输层，MQTT 协议位于应用层，MQTT 协议构建于TCP&#x2F;IP协议上，也就是说只要支持TCP&#x2F;IP协议栈的地方，都可以使用MQTT协议。</p>
<p><strong>为什么要用 MQTT协议？</strong></p>
<p>MQTT协议为什么在物联网（IOT）中如此受偏爱？而不是其它协议，比如我们更为熟悉的 HTTP协议呢？</p>
<ul>
<li>首先HTTP协议它是一种同步协议，客户端请求后需要等待服务器的响应。而在物联网（IOT）环境中，设备会很受制于环境的影响，比如带宽低、网络延迟高、网络通信不稳定等，显然异步消息协议更为适合IOT应用程序。</li>
<li>HTTP是单向的，如果要获取消息客户端必须发起连接，而在物联网（IOT）应用程序中，设备或传感器往往都是客户端，这意味着它们无法被动地接收来自网络的命令。</li>
<li>通常需要将一条命令或者消息，发送到网络上的所有设备上。HTTP要实现这样的功能不但很困难，而且成本极高。</li>
</ul>
<p>具体的MQTT协议介绍和实践，这里我就不再赘述了，大家可以参考我之前的两篇文章，里边写的也都很详细了。</p>
<p>MQTT协议的介绍：<a href="https://mp.weixin.qq.com/s/udFE6k9pPetIWsa6KeErrA">https://mp.weixin.qq.com/s/udFE6k9pPetIWsa6KeErrA</a></p>
<p>MQTT实现消息推送：<a href="https://mp.weixin.qq.com/s/U-fUGr9i1MVa4PoVyiDFCg">https://mp.weixin.qq.com/s/U-fUGr9i1MVa4PoVyiDFCg</a></p>
<h3 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a><strong>Websocket</strong></h3><hr>
<p>websocket应该是大家都比较熟悉的一种实现消息推送的方式，上边我们在讲SSE的时候也和websocket进行过比较。</p>
<p>WebSocket是一种在TCP连接上进行全双工通信的协议，建立客户端和服务器之间的通信渠道。浏览器和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/15.png" alt="图片"></p>
<p>springboot整合websocket，先引入websocket相关的工具包，和SSE相比额外的开发成本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 引入websocket --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>





<p>服务端使用@ServerEndpoint注解标注当前类为一个websocket服务器，客户端可以通过ws:&#x2F;&#x2F;localhost:7777&#x2F;webSocket&#x2F;10086来连接到WebSocket服务器端。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">@ServerEndpoint(&quot;/websocket/&#123;userId&#125;&quot;)</span><br><span class="line">public class WebSocketServer &#123;</span><br><span class="line">    //与某个客户端的连接会话，需要通过它来给客户端发送数据</span><br><span class="line">    private Session session;</span><br><span class="line">    private static final CopyOnWriteArraySet&lt;WebSocketServer&gt; webSockets = new CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line">    // 用来存在线连接数</span><br><span class="line">    private static final Map&lt;String, Session&gt; sessionPool = new HashMap&lt;String, Session&gt;();</span><br><span class="line">    /**</span><br><span class="line">     * 公众号：程序员小富</span><br><span class="line">     * 链接成功调用的方法</span><br><span class="line">     */</span><br><span class="line">    @OnOpen</span><br><span class="line">    public void onOpen(Session session, @PathParam(value = &quot;userId&quot;) String userId) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.session = session;</span><br><span class="line">            webSockets.add(this);</span><br><span class="line">            sessionPool.put(userId, session);</span><br><span class="line">            log.info(&quot;websocket消息: 有新的连接，总数为:&quot; + webSockets.size());</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 公众号：程序员小富</span><br><span class="line">     * 收到客户端消息后调用的方法</span><br><span class="line">     */</span><br><span class="line">    @OnMessage</span><br><span class="line">    public void onMessage(String message) &#123;</span><br><span class="line">        log.info(&quot;websocket消息: 收到客户端消息:&quot; + message);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 公众号：程序员小富</span><br><span class="line">     * 此为单点消息</span><br><span class="line">     */</span><br><span class="line">    public void sendOneMessage(String userId, String message) &#123;</span><br><span class="line">        Session session = sessionPool.get(userId);</span><br><span class="line">        if (session != null &amp;&amp; session.isOpen()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                log.info(&quot;websocket消: 单点消息:&quot; + message);</span><br><span class="line">                session.getAsyncRemote().sendText(message);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>前端初始化打开WebSocket连接，并监听连接状态，接收服务端数据或向服务端发送数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var ws = new WebSocket(&#x27;ws://localhost:7777/webSocket/10086&#x27;);</span><br><span class="line">    // 获取连接状态</span><br><span class="line">    console.log(&#x27;ws连接状态：&#x27; + ws.readyState);</span><br><span class="line">    //监听是否连接成功</span><br><span class="line">    ws.onopen = function () &#123;</span><br><span class="line">        console.log(&#x27;ws连接状态：&#x27; + ws.readyState);</span><br><span class="line">        //连接成功则发送一个数据</span><br><span class="line">        ws.send(&#x27;test1&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 接听服务器发回的信息并处理展示</span><br><span class="line">    ws.onmessage = function (data) &#123;</span><br><span class="line">        console.log(&#x27;接收到来自服务器的消息：&#x27;);</span><br><span class="line">        console.log(data);</span><br><span class="line">        //完成通信后关闭WebSocket连接</span><br><span class="line">        ws.close();</span><br><span class="line">    &#125;</span><br><span class="line">    // 监听连接关闭事件</span><br><span class="line">    ws.onclose = function () &#123;</span><br><span class="line">        // 监听整个过程中websocket的状态</span><br><span class="line">        console.log(&#x27;ws连接状态：&#x27; + ws.readyState);</span><br><span class="line">    &#125;</span><br><span class="line">    // 监听并处理error事件</span><br><span class="line">    ws.onerror = function (error) &#123;</span><br><span class="line">        console.log(error);</span><br><span class="line">    &#125;</span><br><span class="line">    function sendMessage() &#123;</span><br><span class="line">        var content = $(&quot;#message&quot;).val();</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: &#x27;/socket/publish?userId=10086&amp;message=&#x27; + content,</span><br><span class="line">            type: &#x27;GET&#x27;,</span><br><span class="line">            data: &#123; &quot;id&quot;: &quot;7777&quot;, &quot;content&quot;: content &#125;,</span><br><span class="line">            success: function (data) &#123;</span><br><span class="line">                console.log(data)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>





<p>页面初始化建立websocket连接，之后就可以进行双向通信了，效果还不错。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/20.png" alt="图片"></p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/16.jpg" alt="图片"></p>
<h3 id="-3"><a href="#-3" class="headerlink" title></a></h3><h3 id="自定义推送"><a href="#自定义推送" class="headerlink" title="自定义推送"></a><strong>自定义推送</strong></h3><hr>
<p>上边我们给我出了6种方案的原理和代码实现，但在实际业务开发过程中，不能盲目的直接拿过来用，还是要结合自身系统业务的特点和实际场景来选择合适的方案。</p>
<p>推送最直接的方式就是使用第三推送平台，毕竟钱能解决的需求都不是问题，无需复杂的开发运维，直接可以使用，省时、省力、省心，像goEasy、极光推送都是很不错的三方服务商。</p>
<p>一般大型公司都有自研的消息推送平台，像我们本次实现的web站内信只是平台上的一个触点而已，短信、邮件、微信公众号、小程序凡是可以触达到用户的渠道都可以接入进来。</p>
<p><img src="/2022/10/22/7%E7%A7%8D%E5%AE%9E%E7%8E%B0web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%9A%84%E6%96%B9%E6%A1%88/17.png" alt="图片"></p>
<p>消息推送系统内部是相当复杂的，诸如消息内容的维护审核、圈定推送人群、触达过滤拦截（推送的规则频次、时段、数量、黑白名单、关键词等等）、推送失败补偿非常多的模块，技术上涉及到大数据量、高并发的场景也很多。所以我们今天的实现方式在这个庞大的系统面前只是小打小闹。</p>
<h3 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a><strong>Github地址</strong></h3><hr>
<p>文中所提到的案例我都一一的做了实现，整理放在了Github上，觉得有用就 Star 一下吧！</p>
<p>传送门：<a href="https://github.com/chengxy-nds/Springboot-Notebook/tree/master/springboot-realtime-data">https://github.com/chengxy-nds/Springboot-Notebook/tree/master/springboot-realtime-data</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>DDD-如何避免写流水账代码</title>
    <url>/2022/10/24/DDD-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%99%E6%B5%81%E6%B0%B4%E8%B4%A6%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h1 id="1-案例简介"><a href="#1-案例简介" class="headerlink" title="1. 案例简介"></a>1. 案例简介</h1><p>这里举一个简单的常见案例：下单链路。假设我们在做一个checkout接口，需要做各种校验、查询商品信息、调用库存服务扣库存、然后生成订单：</p>
<p><img src="/2022/10/24/DDD-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%99%E6%B5%81%E6%B0%B4%E8%B4%A6%E4%BB%A3%E7%A0%81/1.png" alt="image.png"></p>
<p>一个比较典型的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckoutController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ItemService itemService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> InventoryService inventoryService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OrderRepository orderRepository;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;checkout&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;OrderDO&gt; <span class="title function_">checkout</span><span class="params">(Long itemId, Integer quantity)</span> &#123;</span><br><span class="line">        <span class="comment">// 1) Session管理</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> SessionUtils.getLoggedInUserId();</span><br><span class="line">        <span class="keyword">if</span> (userId &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;Not Logged In&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="comment">// 2）参数校验</span></span><br><span class="line">        <span class="keyword">if</span> (itemId &lt;= <span class="number">0</span> || quantity &lt;= <span class="number">0</span> || quantity &gt;= <span class="number">1000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;Invalid Args&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3）外部数据补全</span></span><br><span class="line">        <span class="type">ItemDO</span> <span class="variable">item</span> <span class="operator">=</span> itemService.getItem(itemId);</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;Item Not Found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4）调用外部服务</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">withholdSuccess</span> <span class="operator">=</span> inventoryService.withhold(itemId, quantity);</span><br><span class="line">        <span class="keyword">if</span> (!withholdSuccess) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;Inventory not enough&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 5）领域计算</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">cost</span> <span class="operator">=</span> item.getPriceInCents() * quantity;</span><br><span class="line">        <span class="comment">// 6）领域对象操作</span></span><br><span class="line">        <span class="type">OrderDO</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderDO</span>();</span><br><span class="line">        order.setItemId(itemId);</span><br><span class="line">        order.setBuyerId(userId);</span><br><span class="line">        order.setSellerId(item.getSellerId());</span><br><span class="line">        order.setCount(quantity);</span><br><span class="line">        order.setTotalCost(cost);</span><br><span class="line">        <span class="comment">// 7）数据持久化</span></span><br><span class="line">        orderRepository.createOrder(order);</span><br><span class="line">        <span class="comment">// 8）返回</span></span><br><span class="line">        <span class="keyword">return</span> Result.success(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么这种典型的流水账代码在实际应用中会有问题呢？其本质问题是违背了SRP（Single Responsbility Principle）单一职责原则。这段代码里混杂了业务计算、校验逻辑、基础设施、和通信协议等，在未来无论哪一部分的逻辑变更都会直接影响到这段代码，长期当后人不断的在上面叠加新的逻辑时，会造成代码复杂度增加、逻辑分支越来越多，最终造成bug或者没人敢重构的历史包袱。</p>
<p>所以我们才需要用DDD的分层思想去重构一下以上的代码，通过不同的代码分层和规范，拆分出逻辑清晰，职责明确的分层和模块，也便于一些通用能力的沉淀。</p>
<p>主要的几个步骤分为：</p>
<ol>
<li>分离出独立的Interface接口层，负责处理网络协议相关的逻辑</li>
<li>从真实业务场景中，找出具体用例（Use Cases），然后将具体用例通过专用的Command指令、Query查询、和Event事件对象来承接</li>
<li>分离出独立的Application应用层，负责业务流程的编排，响应Command、Query和Event。每个应用层的方法应该代表整个业务流程中的一个节点</li>
<li>处理一些跨层的横切关注点，如鉴权、异常处理、校验、缓存、日志等</li>
</ol>
<p>下面会针对每个点做详细的解释。</p>
<h1 id="2-Interface接口层"><a href="#2-Interface接口层" class="headerlink" title="2. Interface接口层"></a>2. Interface接口层</h1><p>随着REST和MVC架构的普及，经常能看到开发同学直接在Controller中写业务逻辑，如上面的典型案例，但实际上MVC Controller不是唯一的重灾区。以下的几种常见的代码写法通常都可能包含了同样的问题：</p>
<ul>
<li>HTTP 框架：如Spring MVC框架，Spring Cloud等</li>
<li>RPC 框架：如Dubbo、HSF、gRPC等</li>
<li>消息队列MQ的“消费者”：比如JMS的 onMessage，RocketMQ的MessageListener等</li>
<li>Socket通信：Socket通信的receive、WebSocket的onMessage等</li>
<li>文件系统：WatcherService等</li>
<li>分布式任务调度：SchedulerX等</li>
</ul>
<p>这些的方法都有一个共同的点就是都有自己的网络协议，而如果我们的业务代码和网络协议混杂在一起，则会直接导致代码跟网络协议绑定，无法被复用。</p>
<p>所以，在DDD的分层架构中，我们单独会抽取出来Interface接口层，作为所有对外的门户，将网络协议和业务逻辑解耦。</p>
<h2 id="2-1-接口层的组成"><a href="#2-1-接口层的组成" class="headerlink" title="2.1 接口层的组成"></a>2.1 接口层的组成</h2><p>接口层主要由以下几个功能组成：</p>
<ol>
<li>网络协议的转化：通常这个已经由各种框架给封装掉了，我们需要构建的类要么是被注解的bean，要么是继承了某个接口的bean。</li>
<li>统一鉴权：比如在一些需要AppKey+Secret的场景，需要针对某个租户做鉴权的，包括一些加密串的校验</li>
<li>Session管理：一般在面向用户的接口或者有登陆态的，通过Session或者RPC上下文可以拿到当前调用的用户，以便传递给下游服务。</li>
<li>限流配置：对接口做限流避免大流量打到下游服务</li>
<li>前置缓存：针对变更不是很频繁的只读场景，可以前置结果缓存到接口层</li>
<li>异常处理：通常在接口层要避免将异常直接暴露给调用端，所以需要在接口层做统一的异常捕获，转化为调用端可以理解的数据格式</li>
<li>日志：在接口层打调用日志，用来做统计和debug等。一般微服务框架可能都直接包含了这些功能。</li>
</ol>
<p>当然，如果有一个独立的网关设施&#x2F;应用，则可以抽离出鉴权、Session、限流、日志等逻辑，但是目前来看API网关也只能解决一部分的功能，即使在有API网关的场景下，应用里独立的接口层还是有必要的。</p>
<p>在interface层，鉴权、Session、限流、缓存、日志等都比较直接，只有一个异常处理的点需要重点说下。</p>
<h2 id="2-2-返回值和异常处理规范，Result-vs-Exception"><a href="#2-2-返回值和异常处理规范，Result-vs-Exception" class="headerlink" title="2.2 返回值和异常处理规范，Result vs Exception"></a>2.2 返回值和异常处理规范，Result vs Exception</h2><p><em>注：这部分主要还是面向REST和RPC接口，其他的协议需要根据协议的规范产生返回值。</em></p>
<p>在我见过的一些代码里，接口的返回值比较多样化，有些直接返回DTO甚至DO，另一些返回Result。</p>
<p>接口层的核心价值是对外，所以如果只是返回DTO或DO会不可避免的面临异常和错误栈泄漏到使用方的情况，包括错误栈被序列化反序列化的消耗。所以，这里提出一个规范：</p>
<blockquote>
<p>规范：Interface层的HTTP和RPC接口，返回值为Result，捕捉所有异常</p>
<p>规范：Application层的所有接口返回值为DTO，不负责处理异常</p>
</blockquote>
<p>Application层的具体规范等下再讲，在这里先展示Interface层的逻辑。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;checkout&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;OrderDTO&gt; <span class="title function_">checkout</span><span class="params">(Long itemId, Integer quantity)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="type">CheckoutCommand</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CheckoutCommand</span>();</span><br><span class="line">                <span class="type">OrderDTO</span> <span class="variable">orderDTO</span> <span class="operator">=</span> checkoutService.checkout(cmd);    </span><br><span class="line">                <span class="keyword">return</span> Result.success(orderDTO);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ConstraintViolationException cve) &#123;</span><br><span class="line">        <span class="comment">// 捕捉一些特殊异常，比如Validation异常</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(cve.getMessage());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 兜底异常捕获</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，每个接口都要写异常处理逻辑会比较烦，所以可以用AOP做个注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ResultHandler &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResultAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(ResultHandler)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">logExecutionTime</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            proceed = joinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ConstraintViolationException cve) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(cve.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后最终代码则简化为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;checkout&quot;)</span></span><br><span class="line"><span class="meta">@ResultHandler</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;OrderDTO&gt; <span class="title function_">checkout</span><span class="params">(Long itemId, Integer quantity)</span> &#123;</span><br><span class="line">    <span class="type">CheckoutCommand</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CheckoutCommand</span>();</span><br><span class="line">    <span class="type">OrderDTO</span> <span class="variable">orderDTO</span> <span class="operator">=</span> checkoutService.checkout(cmd);</span><br><span class="line">    <span class="keyword">return</span> Result.success(orderDTO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-接口层的接口的数量和业务间的隔离"><a href="#2-3-接口层的接口的数量和业务间的隔离" class="headerlink" title="2.3 接口层的接口的数量和业务间的隔离"></a>2.3 接口层的接口的数量和业务间的隔离</h2><p>在传统REST和RPC的接口规范中，通常一个领域的接口，无论是REST的Resource资源的GET&#x2F;POST&#x2F;DELETE，还是RPC的方法，是<strong>追求相对固定的，统一的</strong>，而且会追求统一个领域的方法放在一个领域的服务或Controller中。</p>
<p>但是我发现在实际做业务的过程中，特别是当支撑的上游业务比较多时，刻意去追求接口的统一通常会导致方法中的参数膨胀，或者导致方法的膨胀。举个例子：假设有一个宠物卡和一个亲子卡的业务公用一个开卡服务，但是宠物需要传入宠物类型，亲子的需要传入宝宝年龄。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以是RPC Provider 或者 Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CardService</span> &#123;</span><br><span class="line">    <span class="comment">// 1）统一接口，参数膨胀</span></span><br><span class="line">    Result <span class="title function_">openCard</span><span class="params">(<span class="type">int</span> petType, <span class="type">int</span> babyAge)</span>;</span><br><span class="line">    <span class="comment">// 2）统一泛化接口，参数语意丢失</span></span><br><span class="line">    Result <span class="title function_">openCardV2</span><span class="params">(Map&lt;String, Object&gt; params)</span>;</span><br><span class="line">    <span class="comment">// 3）不泛化，同一个类里的接口膨胀</span></span><br><span class="line">    Result <span class="title function_">openPetCard</span><span class="params">(<span class="type">int</span> petType)</span>;</span><br><span class="line">    Result <span class="title function_">openBabyCard</span><span class="params">(<span class="type">int</span> babyAge)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出来，无论是怎么操作，都有可能导致CardService这个服务未来越来越难以维护，方法越来越多，一个业务的变更有可能会导致整个服务&#x2F;Controller的变更，最终变得无法维护。我曾经参与过的一个服务，提供了几十个方法，上万行代码，可想而知无论是使用方对接口的理解成本还是对代码的维护成本都是极高的。</p>
<p>所以，这里提出另一个规范：</p>
<blockquote>
<p>规范：一个Interface层的类应该是“小而美”的，应该是面向“一个单一的业务”或“一类同样需求的业务”，需要尽量避免用同一个类承接不同类型业务的需求。</p>
</blockquote>
<p>基于上面的这个规范，可以发现宠物卡和亲子卡虽然看起来像是类似的需求，但并非是“同样需求”的，可以预见到在未来的某个时刻，这两个业务的需求和需要提供的接口会越走越远，所以需要将这两个接口类拆分开：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PetCardService</span> &#123;</span><br><span class="line">    Result <span class="title function_">openPetCard</span><span class="params">(<span class="type">int</span> petType)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BabyCardService</span> &#123;</span><br><span class="line">    Result <span class="title function_">openBabyCard</span><span class="params">(<span class="type">int</span> babyAge)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个的好处是符合了Single Responsibility Principle单一职责原则，也就是说一个接口类仅仅会因为一个（或一类）业务的变化而变化。<strong>一个建议是当一个现有的接口类过度膨胀时，可以考虑对接口类做拆分，拆分原则和SRP一致。</strong></p>
<p>也许会有人问，如果按照这种做法，会不会产生大量的接口类，导致代码逻辑重复？答案是不会，因为在DDD分层架构里，接口类的核心作用仅仅是协议层，每类业务的协议可以是不同的，而真实的业务逻辑会沉淀到应用层。也就是说Interface和Application的关系是多对多的：</p>
<p><img src="/2022/10/24/DDD-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%99%E6%B5%81%E6%B0%B4%E8%B4%A6%E4%BB%A3%E7%A0%81/2.png" alt="image.png"></p>
<p>因为业务需求是快速变化的，所以接口层也要跟着快速变化，通过独立的接口层可以避免业务间相互影响，但我们希望相对稳定的是Application层的逻辑。所以我们接下来看一下Application层的一些规范。</p>
<h1 id="3-Application层"><a href="#3-Application层" class="headerlink" title="3. Application层"></a>3. Application层</h1><h2 id="3-1-Application层的组成部分"><a href="#3-1-Application层的组成部分" class="headerlink" title="3.1 Application层的组成部分"></a>3.1 Application层的组成部分</h2><p>Application层的几个核心类：</p>
<ul>
<li>ApplicationService应用服务：最核心的类，负责业务流程的编排，但本身不负责任何业务逻辑</li>
<li>DTO Assembler：负责将内部领域模型转化为可对外的DTO</li>
<li>Command、Query、Event对象：作为ApplicationService的入参</li>
<li>返回的DTO：作为ApplicationService的出参</li>
</ul>
<p>Application层最核心的对象是ApplicationService，它的核心功能是承接“业务流程“。但是在讲ApplicationService的规范之前，必须要先重点的讲几个特殊类型的对象，即Command、Query和Event。</p>
<h2 id="3-2-Command、Query、Event对象"><a href="#3-2-Command、Query、Event对象" class="headerlink" title="3.2 Command、Query、Event对象"></a>3.2 Command、Query、Event对象</h2><p>从本质上来看，这几种对象都是Value Object，但是从语义上来看有比较大的差异：</p>
<ul>
<li>Command指令：指调用方明确想让系统操作的指令，其预期是对一个系统有影响，也就是写操作。通常来讲指令需要有一个明确的返回值（如同步的操作结果，或异步的指令已经被接受）。</li>
<li>Query查询：指调用方明确想查询的东西，包括查询参数、过滤、分页等条件，其预期是对一个系统的数据完全不影响的，也就是只读操作。</li>
<li>Event事件：指一件已经发生过的既有事实，需要系统根据这个事实作出改变或者响应的，通常事件处理都会有一定的写操作。事件处理器不会有返回值。这里需要注意一下的是，Application层的Event概念和Domain层的DomainEvent是类似的概念，但不一定是同一回事，这里的Event更多是外部一种通知机制而已。</li>
</ul>
<p>简单总结下：</p>
<table>
<thead>
<tr>
<th></th>
<th>Command</th>
<th>Query</th>
<th>Event</th>
</tr>
</thead>
<tbody><tr>
<td>语意</td>
<td>”希望“能触发的操作</td>
<td>各种条件的查询</td>
<td>已经发生过的事情</td>
</tr>
<tr>
<td>读&#x2F;写</td>
<td>写</td>
<td>只读</td>
<td>通常是写</td>
</tr>
<tr>
<td>返回值</td>
<td>DTO 或 Boolean</td>
<td>DTO 或 Collection</td>
<td>Void</td>
</tr>
</tbody></table>
<p><strong>为什么要用CQE对象？</strong></p>
<p>通常在很多代码里，能看到接口上有多个参数，比如上文中的案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Result&lt;OrderDO&gt; <span class="title function_">checkout</span><span class="params">(Long itemId, Integer quantity)</span>;</span><br></pre></td></tr></table></figure>

<p>如果需要在接口上增加参数，考虑到向前兼容，则需要增加一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Result&lt;OrderDO&gt; <span class="title function_">checkout</span><span class="params">(Long itemId, Integer quantity)</span>;</span><br><span class="line">Result&lt;OrderDO&gt; <span class="title function_">checkout</span><span class="params">(Long itemId, Integer quantity, Integer channel)</span>;</span><br></pre></td></tr></table></figure>

<p>或者常见的查询方法，由于条件的不同导致多个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;OrderDO&gt; <span class="title function_">queryByItemId</span><span class="params">(Long itemId)</span>;</span><br><span class="line">List&lt;OrderDO&gt; <span class="title function_">queryBySellerId</span><span class="params">(Long sellerId)</span>;</span><br><span class="line">List&lt;OrderDO&gt; <span class="title function_">queryBySellerIdWithPage</span><span class="params">(Long sellerId, <span class="type">int</span> currentPage, <span class="type">int</span> pageSize)</span>;</span><br></pre></td></tr></table></figure>



<p>可以看出来，传统的接口写法有几个问题：</p>
<ol>
<li>接口膨胀：一个查询条件一个方法</li>
<li>难以扩展：每新增一个参数都有可能需要调用方升级</li>
<li>难以测试：接口一多，职责随之变得繁杂，业务场景各异，测试用例难以维护</li>
</ol>
<p>但是另外一个最重要的问题是：这种类型的参数罗列，本身没有任何业务上的”语意“，只是一堆参数而已，无法明确的表达出来意图。</p>
<p><strong>CQE的规范：</strong></p>
<p>所以在Application层的接口里，强力建议的一个规范是：</p>
<blockquote>
<p>规范：ApplicationService的接口入参只能是一个Command、Query或Event对象，CQE对象需要能代表当前方法的语意。唯一可以的例外是根据单一ID查询的情况，可以省略掉一个Query对象的创建</p>
</blockquote>
<p>按照上面的规范，实现案例是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CheckoutService</span> &#123;</span><br><span class="line">    OrderDTO <span class="title function_">checkout</span><span class="params">(<span class="meta">@Valid</span> CheckoutCommand cmd)</span>;</span><br><span class="line">    List&lt;OrderDTO&gt; <span class="title function_">query</span><span class="params">(OrderQuery query)</span>;</span><br><span class="line">    OrderDTO <span class="title function_">getOrder</span><span class="params">(Long orderId)</span>; <span class="comment">// 注意单一ID查询可以不用Query</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckoutCommand</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line">    <span class="keyword">private</span> Long itemId;</span><br><span class="line">    <span class="keyword">private</span> Integer quantity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderQuery</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long sellerId;</span><br><span class="line">    <span class="keyword">private</span> Long itemId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> currentPage;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> pageSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个规范的好处是：提升了接口的稳定性、降低低级的重复，并且让接口入参更加语意化。</p>
<p><strong>CQE vs DTO</strong></p>
<p>从上面的代码能看出来，ApplicationService的入参是CQE对象，但是出参却是一个DTO，从代码格式上来看都是简单的POJO对象，那么他们之间有什么区别呢？</p>
<ul>
<li>CQE：CQE对象是ApplicationService的输入，是有明确的”意图“的，所以这个对象必须保证其”正确性“。</li>
<li>DTO：DTO对象只是数据容器，只是为了和外部交互，所以本身不包含任何逻辑，只是贫血对象。</li>
</ul>
<p>但可能最重要的一点：因为CQE是”意图“，所以CQE对象在理论上可以有”无限“个，每个代表不同的意图；但是DTO作为模型数据容器，和模型一一对应，所以是有限的。</p>
<p><strong>CQE的校验</strong></p>
<p>CQE作为ApplicationService的输入，必须保证其正确性，那么这个校验是放在哪里呢？</p>
<p>在最早的代码里，曾经有这样的校验逻辑，当时写在了服务里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (itemId &lt;= <span class="number">0</span> || quantity &lt;= <span class="number">0</span> || quantity &gt;= <span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;Invalid Args&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种代码在日常非常常见，但其最大的问题就是大量的非业务代码混杂在业务代码中，很明显的违背了单一职责原则。但因为当时入参仅仅是简单的int，所以这个逻辑只能出现在服务里。现在当入参改为了CQE之后，我们可以利用java标准JSR303或JSR380的Bean Validation来前置这个校验逻辑。</p>
<blockquote>
<p>规范：CQE对象的校验应该前置，避免在ApplicationService里做参数的校验。可以通过JSR303&#x2F;380和Spring Validation来实现</p>
</blockquote>
<p>前面的例子可以改造为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Validated</span> <span class="comment">// Spring的注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckoutServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">CheckoutService</span> &#123;</span><br><span class="line">    OrderDTO <span class="title function_">checkout</span><span class="params">(<span class="meta">@Valid</span> CheckoutCommand cmd)</span> &#123; <span class="comment">// 这里@Valid是JSR-303/380的注解</span></span><br><span class="line">        <span class="comment">// 如果校验失败会抛异常，在interface层被捕捉</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckoutCommand</span> &#123;</span><br><span class="line">    <span class="meta">@NotNull(message = &quot;用户未登陆&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Positive(message = &quot;需要是合法的itemId&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long itemId;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Min(value = 1, message = &quot;最少1件&quot;)</span></span><br><span class="line">    <span class="meta">@Max(value = 1000, message = &quot;最多不能超过1000件&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer quantity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种做法的好处是，让ApplicationService更加清爽，同时各种错误信息可以通过Bean Validation的API做各种个性化定制。</p>
<p><strong>避免复用CQE</strong></p>
<p>因为CQE是有“意图”和“语意”的，我们需要尽量避免CQE对象的复用，哪怕所有的参数都一样，只要他们的语意不同，尽量还是要用不同的对象。</p>
<blockquote>
<p>规范：针对于不同语意的指令，要避免CQE对象的复用</p>
</blockquote>
<p>❌ 反例：一个常见的场景是“Create创建”和“Update更新”，一般来说这两种类型的对象唯一的区别是一个ID，创建没有ID，而更新则有。所以经常能看见有的同学用同一个对象来作为两个方法的入参，唯一区别是ID是否赋值。这个是错误的用法，因为这两个操作的语意完全不一样，他们的校验条件可能也完全不一样，所以不应该复用同一个对象。正确的做法是产出两个对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CheckoutService</span> &#123;</span><br><span class="line">    OrderDTO <span class="title function_">checkout</span><span class="params">(<span class="meta">@Valid</span> CheckoutCommand cmd)</span>;</span><br><span class="line">    OrderDTO <span class="title function_">updateOrder</span><span class="params">(<span class="meta">@Valid</span> UpdateOrderCommand cmd)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UpdateOrderCommand</span> &#123;</span><br><span class="line">    <span class="meta">@NotNull(message = &quot;用户未登陆&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line">    <span class="meta">@NotNull(message = &quot;必须要有OrderID&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long orderId;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Positive(message = &quot;需要是合法的itemId&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long itemId;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Min(value = 1, message = &quot;最少1件&quot;)</span></span><br><span class="line">    <span class="meta">@Max(value = 1000, message = &quot;最多不能超过1000件&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer quantity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-ApplicationService"><a href="#3-3-ApplicationService" class="headerlink" title="3.3 ApplicationService"></a>3.3 ApplicationService</h2><p>ApplicationService负责了业务流程的编排，是将原有业务流水账代码剥离了校验逻辑、领域计算、持久化等逻辑之后剩余的流程，是“胶水层”代码。</p>
<p>参考一个简易的交易流程：</p>
<p><img src="/2022/10/24/DDD-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%99%E6%B5%81%E6%B0%B4%E8%B4%A6%E4%BB%A3%E7%A0%81/3.png" alt="image.png"></p>
<p>在这个案例里可以看出来，交易这个领域一共有5个用例：下单、支付成功、支付失败关单、物流信息更新、关闭订单。这5个用例可以用5个Command&#x2F;Event对象代替，也就是对应了5个方法。</p>
<p>我见过3种ApplicationService的组织形态：</p>
<ol>
<li>一个ApplicationService类是一个完整的业务流程，其中每个方法负责处理一个Use Case。这种的好处是可以完整的收敛整个业务逻辑，从接口类即可对业务逻辑有一定的掌握，适合相对简单的业务流程。坏处就是对于复杂的业务流程会导致一个类的方法过多，有可能代码量过大。这种类型的具体案例如：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CheckoutService</span> &#123;</span><br><span class="line">    <span class="comment">// 下单</span></span><br><span class="line">    OrderDTO <span class="title function_">checkout</span><span class="params">(<span class="meta">@Valid</span> CheckoutCommand cmd)</span>;</span><br><span class="line">    <span class="comment">// 支付成功</span></span><br><span class="line">    OrderDTO <span class="title function_">payReceived</span><span class="params">(<span class="meta">@Valid</span> PaymentReceivedEvent event)</span>;</span><br><span class="line">    <span class="comment">// 支付取消</span></span><br><span class="line">    OrderDTO <span class="title function_">payCanceled</span><span class="params">(<span class="meta">@Valid</span> PaymentCanceledEvent event)</span>;</span><br><span class="line">    <span class="comment">// 发货</span></span><br><span class="line">    OrderDTO <span class="title function_">packageSent</span><span class="params">(<span class="meta">@Valid</span> PackageSentEvent event)</span>;</span><br><span class="line">    <span class="comment">// 收货</span></span><br><span class="line">    OrderDTO <span class="title function_">delivered</span><span class="params">(<span class="meta">@Valid</span> DeliveredEvent event)</span>;</span><br><span class="line">    <span class="comment">// 批量查询</span></span><br><span class="line">    List&lt;OrderDTO&gt; <span class="title function_">query</span><span class="params">(OrderQuery query)</span>;</span><br><span class="line">    <span class="comment">// 单个查询</span></span><br><span class="line">    OrderDTO <span class="title function_">getOrder</span><span class="params">(Long orderId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>针对于比较复杂的业务流程，可以通过增加独立的CommandHandler、EventHandler来降低一个类中的代码量：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckoutCommandHandler</span> <span class="keyword">implements</span> <span class="title class_">CommandHandler</span>&lt;CheckoutCommand, OrderDTO&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> OrderDTO <span class="title function_">handle</span><span class="params">(CheckoutCommand cmd)</span> &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckoutServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">CheckoutService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">        <span class="keyword">private</span> CheckoutCommandHandler checkoutCommandHandler;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> OrderDTO <span class="title function_">checkout</span><span class="params">(<span class="meta">@Valid</span> CheckoutCommand cmd)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> checkoutCommandHandler.handle(cmd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>比较激进一点，通过CommandBus、EventBus，直接将指令或事件抛给对应的Handler，EventBus比较常见。具体案例代码如下，通过消息队列收到MQ消息后，生成Event，然后由EventBus做路由到对应的Handler：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Application层</span></span><br><span class="line"><span class="comment">// 在这里框架通常可以根据接口识别到这个负责处理PaymentReceivedEvent</span></span><br><span class="line"><span class="comment">// 也可以通过增加注解识别</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentReceivedHandler</span> <span class="keyword">implements</span> <span class="title class_">EventHandler</span>&lt;PaymentReceivedEvent&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(PaymentReceivedEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Interface层，这个是RocketMQ的Listener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderMessageListener</span> <span class="keyword">implements</span> <span class="title class_">MessageListenerOrderly</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> EventBus eventBus;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ConsumeOrderlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">PaymentReceivedEvent</span> <span class="variable">event</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PaymentReceivedEvent</span>();</span><br><span class="line">        eventBus.dispatch(event); <span class="comment">// 不需要指定消费者</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>⚠️ 不建议：这种做法可以实现Interface层和某个具体的ApplicationService或Handler的完全静态解藕，在运行时动态dispatch，做的比较好的框架如AxonFramework。虽然看起来很便利，但是根据我们自己业务的实践和踩坑发现，当代码中的CQE对象越来越多，handler越来越复杂时，运行时的dispatch缺乏了静态代码间的关联关系，导致代码很难读懂，特别是当你需要trace一个复杂调用链路时，因为dispatch是运行时的，很难摸清楚具体调用到的对象。所以我们虽然曾经有过这种尝试，但现在已经不建议这么做了。</p>
<p><strong>Application Service 是业务流程的封装，不处理业务逻辑</strong></p>
<p>虽然之前曾经无数次重复ApplicationService只负责业务流程串联，不负责业务逻辑，但如何判断一段代码到底是业务流程还是逻辑呢？</p>
<p>举个之前的例子，最初的代码重构后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckoutServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">CheckoutService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">OrderDtoAssembler</span> <span class="variable">orderDtoAssembler</span> <span class="operator">=</span> OrderDtoAssembler.INSTANCE;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ItemService itemService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> InventoryService inventoryService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OrderRepository orderRepository;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> OrderDTO <span class="title function_">checkout</span><span class="params">(<span class="meta">@Valid</span> CheckoutCommand cmd)</span> &#123;</span><br><span class="line">        <span class="type">ItemDO</span> <span class="variable">item</span> <span class="operator">=</span> itemService.getItem(cmd.getItemId());</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Item not found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">withholdSuccess</span> <span class="operator">=</span> inventoryService.withhold(cmd.getItemId(), cmd.getQuantity());</span><br><span class="line">        <span class="keyword">if</span> (!withholdSuccess) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Inventory not enough&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        order.setBuyerId(cmd.getUserId());</span><br><span class="line">        order.setSellerId(item.getSellerId());</span><br><span class="line">        order.setItemId(item.getItemId());</span><br><span class="line">        order.setItemTitle(item.getTitle());</span><br><span class="line">        order.setItemUnitPrice(item.getPriceInCents());</span><br><span class="line">        order.setCount(cmd.getQuantity());</span><br><span class="line">        <span class="type">Order</span> <span class="variable">savedOrder</span> <span class="operator">=</span> orderRepository.save(order);</span><br><span class="line">        <span class="keyword">return</span> orderDtoAssembler.orderToDTO(savedOrder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>判断是否业务流程的几个点：</strong></p>
<p>1、不要有if&#x2F;else分支逻辑：也就是说代码的Cyclomatic Complexity（循环复杂度）应该尽量等于1</p>
<p>通常有分支逻辑的，都代表一些业务判断，应该将逻辑封装到DomainService或者Entity里。但这不代表完全不能有if逻辑，比如，在这段代码里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">withholdSuccess</span> <span class="operator">=</span> inventoryService.withhold(cmd.getItemId(), cmd.getQuantity());</span><br><span class="line"><span class="keyword">if</span> (!withholdSuccess) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Inventory not enough&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>虽然CC &gt; 1，但是仅仅代表了中断条件，具体的业务逻辑处理并没有受影响。可以把它看作为Precondition。</p>
<p>2、不要有任何计算：</p>
<p>在最早的代码里有这个计算：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 5）领域计算</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">cost</span> <span class="operator">=</span> item.getPriceInCents() * quantity;</span><br><span class="line">order.setTotalCost(cost);</span><br></pre></td></tr></table></figure>



<p>通过将这个计算逻辑封装到实体里，避免在ApplicationService里做计算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long itemUnitPrice;</span><br><span class="line">    <span class="keyword">private</span> Integer count;</span><br><span class="line">    <span class="comment">// 把原来一个在ApplicationService的计算迁移到Entity里</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getTotalCost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> itemUnitPrice * count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">order.setItemUnitPrice(item.getPriceInCents());</span><br><span class="line">order.setCount(cmd.getQuantity());</span><br></pre></td></tr></table></figure>



<p>3、一些数据的转化可以交给其他对象来做：</p>
<p>比如DTO Assembler，将对象间转化的逻辑沉淀在单独的类中，降低ApplicationService的复杂度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">OrderDTO</span> <span class="variable">dto</span> <span class="operator">=</span> orderDtoAssembler.orderToDTO(savedOrder);</span><br></pre></td></tr></table></figure>



<p><strong>常用的ApplicationService“套路”</strong></p>
<p>我们可以看出来，ApplicationService的代码通常有类似的结构：AppService通常不做任何决策（Precondition除外），仅仅是把所有决策交给DomainService或Entity，把跟外部交互的交给Infrastructure接口，如Repository或防腐层。</p>
<p>一般的“套路”如下：</p>
<ul>
<li>准备数据：包括从外部服务或持久化源取出相对应的Entity、VO以及外部服务返回的DTO。</li>
<li>执行操作：包括新对象的创建、赋值，以及调用领域对象的方法对其进行操作。需要注意的是这个时候通常都是纯内存操作，非持久化。</li>
<li>持久化：将操作结果持久化，或操作外部系统产生相应的影响，包括发消息等异步操作。</li>
</ul>
<p>如果涉及到对多个外部系统（包括自身的DB）都有变更的情况，这个时候通常处在“分布式事务”的场景里，无论是用分布式TX、TCC、还是Saga模式，取决于具体场景的设计，在此处暂时略过。</p>
<h2 id="3-4-DTO-Assembler"><a href="#3-4-DTO-Assembler" class="headerlink" title="3.4 DTO Assembler"></a>3.4 DTO Assembler</h2><p>一个经常被忽视的问题是 ApplicationService应该返回 Entity 还是 DTO？这里提出一个规范，在DDD分层架构中：</p>
<blockquote>
<p>ApplicationService应该永远返回DTO而不是Entity</p>
</blockquote>
<p>为什么呢？</p>
<ol>
<li>构建领域边界：ApplicationService的入参是CQE对象，出参是DTO，这些基本上都属于简单的POJO，来确保Application层的内外互相不影响。</li>
<li>降低规则依赖：Entity里面通常会包含业务规则，如果ApplicationService返回Entity，则会导致调用方直接依赖业务规则。如果内部规则变更可能直接影响到外部。</li>
<li>通过DTO组合降低成本：Entity是有限的，DTO可以是多个Entity、VO的自由组合，一次性封装成复杂DTO，或者有选择的抽取部分参数封装成DTO可以降低对外的成本。</li>
</ol>
<p>因为我们操作的对象是Entity，但是输出的对象是DTO，这里就需要一个专属类型的对象叫<strong>DTO Assembler</strong>。DTO Assembler的唯一职责是将一个或多个Entity&#x2F;VO，转化为DTO。注意：DTO Assembler通常不建议有反操作，也就是不会从DTO到Entity，因为通常一个DTO转化为Entity时是无法保证Entity的准确性的。</p>
<p>通常，Entity转DTO是有成本的，无论是代码量还是运行时的操作。手写转换代码容易出错，为了节省代码量用Reflection会造成极大的性能损耗。所以这里我还是不遗余力的推荐MapStruct这个库。MapStruct通过静态编译时代码生成，通过写接口和配置注解就可以生成对应的代码，且因为生成的代码是直接赋值，其性能损耗基本可以忽略不计。</p>
<p>通过MapStruct，代码即可简化为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.mapstruct.Mapper;</span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderDtoAssembler</span> &#123;</span><br><span class="line">    <span class="type">OrderDtoAssembler</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> Mappers.getMapper(OrderDtoAssembler.class);</span><br><span class="line">    OrderDTO <span class="title function_">orderToDTO</span><span class="params">(Order order)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckoutServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">CheckoutService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">OrderDtoAssembler</span> <span class="variable">orderDtoAssembler</span> <span class="operator">=</span> OrderDtoAssembler.INSTANCE;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> OrderDTO <span class="title function_">checkout</span><span class="params">(<span class="meta">@Valid</span> CheckoutCommand cmd)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">          <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();    </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">savedOrder</span> <span class="operator">=</span> orderRepository.save(order);</span><br><span class="line">        <span class="keyword">return</span> orderDtoAssembler.orderToDTO(savedOrder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合之前的Data Mapper，DTO、Entity和DataObject之间的关系如下图：</p>
<p><img src="/2022/10/24/DDD-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%99%E6%B5%81%E6%B0%B4%E8%B4%A6%E4%BB%A3%E7%A0%81/4.png" alt="image.png"></p>
<h2 id="3-5-Result-vs-Exception"><a href="#3-5-Result-vs-Exception" class="headerlink" title="3.5 Result vs Exception"></a>3.5 Result vs Exception</h2><p>最后，上文曾经提及在Interface层应该返回Result，在Application层应该返回DTO，在这里再次重复提出规范：</p>
<p>Application层只返回DTO，可以直接抛异常，不用统一处理。所有调用到的服务也都可以直接抛异常，除非需要特殊处理，否则不需要刻意捕捉异常</p>
<p>异常的好处是能明确的知道错误的来源，堆栈等，在Interface层统一捕捉异常是为了避免异常堆栈信息泄漏到API之外，但是在Application层，异常机制仍然是信息量最大，代码结构最清晰的方法，避免了Result的一些常见且繁杂的Result.isSuccess判断。所以在Application层、Domain层，以及Infrastructure层，遇到错误直接抛异常是最合理的方法。</p>
<h2 id="3-6-简单讲一下Anti-Corruption-Layer防腐层"><a href="#3-6-简单讲一下Anti-Corruption-Layer防腐层" class="headerlink" title="3.6 简单讲一下Anti-Corruption Layer防腐层"></a>3.6 简单讲一下Anti-Corruption Layer防腐层</h2><p><em>本文仅仅简单描述一下ACL的原理和作用，具体的实施规范可能要等到另外一篇文章。</em></p>
<p>在ApplicationService中，经常会依赖外部服务，从代码层面对外部系统产生了依赖。比如上文中的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ItemDO</span> <span class="variable">item</span> <span class="operator">=</span> itemService.getItem(cmd.getItemId());</span><br><span class="line"><span class="type">boolean</span> <span class="variable">withholdSuccess</span> <span class="operator">=</span> inventoryService.withhold(cmd.getItemId(), cmd.getQuantity());</span><br></pre></td></tr></table></figure>

<p>会发现我们的ApplicationService会强依赖ItemService、InventoryService以及ItemDO这个对象。如果任何一个服务的方法变更，或者ItemDO字段变更，都会有可能影响到ApplicationService的代码。也就是说，我们自己的代码会因为强依赖了外部系统的变化而变更，这个在复杂系统中应该是尽量避免的。那么如何做到对外部系统的隔离呢？需要加入ACL防腐层。</p>
<p>ACL防腐层的简单原理如下：</p>
<ul>
<li>对于依赖的外部对象，我们抽取出所需要的字段，生成一个内部所需的VO或DTO类</li>
<li>构建一个新的Facade，在Facade中封装调用链路，将外部类转化为内部类</li>
<li>针对外部系统调用，同样的用Facade方法封装外部调用链路</li>
</ul>
<p>无防腐层的情况：</p>
<p><img src="/2022/10/24/DDD-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%99%E6%B5%81%E6%B0%B4%E8%B4%A6%E4%BB%A3%E7%A0%81/5.png" alt="image.png"></p>
<p>有防腐层的情况：</p>
<p><img src="/2022/10/24/DDD-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%99%E6%B5%81%E6%B0%B4%E8%B4%A6%E4%BB%A3%E7%A0%81/6.png" alt="image.png"></p>
<p>具体简单实现，假设所有外部依赖都命名为ExternalXXXService：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义的内部值类</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemDTO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long itemId;</span><br><span class="line">    <span class="keyword">private</span> Long sellerId;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> Long priceInCents;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 商品Facade接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ItemFacade</span> &#123;</span><br><span class="line">    ItemDTO <span class="title function_">getItem</span><span class="params">(Long itemId)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 商品facade实现</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemFacadeImpl</span> <span class="keyword">implements</span> <span class="title class_">ItemFacade</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ExternalItemService externalItemService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ItemDTO <span class="title function_">getItem</span><span class="params">(Long itemId)</span> &#123;</span><br><span class="line">        <span class="type">ItemDO</span> <span class="variable">itemDO</span> <span class="operator">=</span> externalItemService.getItem(itemId);</span><br><span class="line">        <span class="keyword">if</span> (itemDO != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ItemDTO</span> <span class="variable">dto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ItemDTO</span>();</span><br><span class="line">            dto.setItemId(itemDO.getItemId());</span><br><span class="line">            dto.setTitle(itemDO.getTitle());</span><br><span class="line">            dto.setPriceInCents(itemDO.getPriceInCents());</span><br><span class="line">            dto.setSellerId(itemDO.getSellerId());</span><br><span class="line">            <span class="keyword">return</span> dto;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 库存Facade</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InventoryFacade</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">withhold</span><span class="params">(Long itemId, Integer quantity)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InventoryFacadeImpl</span> <span class="keyword">implements</span> <span class="title class_">InventoryFacade</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ExternalInventoryService externalInventoryService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">withhold</span><span class="params">(Long itemId, Integer quantity)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> externalInventoryService.withhold(itemId, quantity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>通过ACL改造之后，我们ApplicationService的代码改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckoutServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">CheckoutService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ItemFacade itemFacade;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> InventoryFacade inventoryFacade;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> OrderDTO <span class="title function_">checkout</span><span class="params">(<span class="meta">@Valid</span> CheckoutCommand cmd)</span> &#123;</span><br><span class="line">        <span class="type">ItemDTO</span> <span class="variable">item</span> <span class="operator">=</span> itemFacade.getItem(cmd.getItemId());</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Item not found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">withholdSuccess</span> <span class="operator">=</span> inventoryFacade.withhold(cmd.getItemId(), cmd.getQuantity());</span><br><span class="line">        <span class="keyword">if</span> (!withholdSuccess) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Inventory not enough&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>很显然，这么做的好处是ApplicationService的代码已经完全不再直接依赖外部的类和方法，而是依赖了我们自己内部定义的值类和接口。如果未来外部服务有任何的变更，需要修改的是Facade类和数据转化逻辑，而不需要修改ApplicationService的逻辑。</p>
<p>Repository可以认为是一种特殊的ACL，屏蔽了具体数据操作的细节，即使底层数据库结构变更，数据库类型变更，或者加入其他的持久化方式，Repository的接口保持稳定，ApplicationService就能保持不变。</p>
<p>在一些理论框架里ACL Facade也被叫做Gateway，含义是一样的。</p>
<h1 id="4-Orchestration-vs-Choreography"><a href="#4-Orchestration-vs-Choreography" class="headerlink" title="4. Orchestration vs Choreography"></a>4. Orchestration vs Choreography</h1><p>在本文最后想聊一下复杂业务流程的设计规范。在复杂的业务流程里，我们通常面临两种模式：Orchestration 和 Choreography。很无奈，这两个英文单词的百度翻译&#x2F;谷歌翻译，都是“编排”，但实际上这两种模式是完全不一样的设计模式。Orchestration的编排（比如SOA&#x2F;微服务的服务编排Service Orchestration）是我们通常熟悉的用法，Choreography是最近出现了事件驱动架构EDA才慢慢流行起来。网上可能会有其他的翻译，比如编制、编舞、协作等，但感觉都没有真正的把英文单词的意思表达出来，所以为了避免误解，在下文我尽量还是用英文原词。如果谁有更好的翻译方法欢迎联系我。</p>
<h2 id="4-1-模式简介"><a href="#4-1-模式简介" class="headerlink" title="4.1 模式简介"></a>4.1 模式简介</h2><p>Orchestration：通常出现在脑海里的是一个交响乐团（Orchestra，注意这两个词的相似性），如下图。交响乐团的核心是一个唯一的指挥家Conductor，在一个交响乐中，所有的音乐家必须听从Conductor的指挥做操作，不可以独自发挥。所以在Orchestration模式中，所有的流程都是由一个节点或服务触发的。我们常见的业务流程代码，包括调用外部服务，就是Orchestration，由我们的服务统一触发。</p>
<p><img src="/2022/10/24/DDD-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%99%E6%B5%81%E6%B0%B4%E8%B4%A6%E4%BB%A3%E7%A0%81/7.png" alt="image.png"></p>
<p>图片来源：<a href="https://insights-images.thoughtworks.com/orchestrator20music_d80f70dfd1857ae9778fee2f8fa9a01d.png%E3%80%82">https://insights-images.thoughtworks.com/orchestrator20music_d80f70dfd1857ae9778fee2f8fa9a01d.png</a></p>
<p>Choreography：通常会出现在脑海的场景是一个舞剧（来自于希腊文的舞蹈，Choros），如下图。其中每个不同的舞蹈家都在做自己的事，但是没有一个中心化的指挥。通过协作配合，每个人做好自己的事，整个舞蹈可以展现出一个完整的、和谐的画面。所以在Choreography模式中，每个服务都是独立的个体，可能会响应外部的一些事件，但整个系统是一个整体。</p>
<p><img src="/2022/10/24/DDD-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%99%E6%B5%81%E6%B0%B4%E8%B4%A6%E4%BB%A3%E7%A0%81/8.png" alt="image.png"></p>
<p>图片来源：<a href="https://i.ytimg.com/vi/uQaQrO4hKPQ/maxresdefault.jpg%E3%80%82">https://i.ytimg.com/vi/uQaQrO4hKPQ/maxresdefault.jpg</a></p>
<h2 id="4-2-案例"><a href="#4-2-案例" class="headerlink" title="4.2 案例"></a>4.2 案例</h2><p>用一个常见的例子：下单后支付并发货</p>
<p>如果这个案例是Orchestration，则业务逻辑为：下单时从一个预存的账户里扣取资金，并且生成物流单发货，从图上看是这样的：</p>
<p><img src="/2022/10/24/DDD-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%99%E6%B5%81%E6%B0%B4%E8%B4%A6%E4%BB%A3%E7%A0%81/9.png" alt="image.png"></p>
<p>如果这个案例是Choreography，则业务逻辑为：下单，然后等支付成功事件，然后再发货，类似这样：</p>
<p><img src="/2022/10/24/DDD-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%99%E6%B5%81%E6%B0%B4%E8%B4%A6%E4%BB%A3%E7%A0%81/10.png" alt="image.png"></p>
<h2 id="4-3-模式的区别和选择"><a href="#4-3-模式的区别和选择" class="headerlink" title="4.3 模式的区别和选择"></a>4.3 模式的区别和选择</h2><p>虽然看起来这两种模式都能达到一样的业务目的，但是在实际开发中他们有巨大的差异：</p>
<p>从代码依赖关系来看：</p>
<ul>
<li>Orchestration：涉及到一个服务调用到另外的服务，对于调用方来说，是强依赖的服务提供方。</li>
<li>Choreography：每一个服务只是做好自己的事，然后通过事件触发其他的服务，服务之间没有直接调用上的依赖。但要注意的是下游还是会依赖上游的代码（比如事件类），所以可以认为是下游对上游有依赖。</li>
</ul>
<p>从代码灵活性来看：</p>
<ul>
<li>Orchestration：因为服务间的依赖关系是写死的，增加新的业务流程必然需要修改代码。</li>
<li>Choreography：因为服务间没有直接调用关系，可以增加或替换服务，而不需要改上游代码。</li>
</ul>
<p>从调用链路来看：</p>
<ul>
<li>Orchestration：是从一个服务主动调用另一个服务，所以是Command-Driven指令驱动的。</li>
<li>Choreography：是每个服务被动的被外部事件触发，所以是Event-Driven事件驱动的。</li>
</ul>
<p>从业务职责来看：</p>
<ul>
<li>Orchestration：有主动的调用方（比如：下单服务）。无论下游的依赖是谁，主动的调用方都需要为整个业务流程和结果负责。</li>
<li>Choreography：没有主动调用方，每个服务只关心自己的触发条件和结果，没有任何一个服务会为整个业务链路负责</li>
</ul>
<p>总结下来一个比较：</p>
<table>
<thead>
<tr>
<th></th>
<th>Orchestration</th>
<th>Choreography</th>
</tr>
</thead>
<tbody><tr>
<td>驱动力</td>
<td>指令驱动Command-Driven</td>
<td>事件驱动Event-Driven</td>
</tr>
<tr>
<td>调用依赖</td>
<td>上游强依赖下游</td>
<td>无直接调用依赖但是有代码依赖可以认为是下游依赖上游</td>
</tr>
<tr>
<td>灵活性</td>
<td>较差</td>
<td>较高</td>
</tr>
<tr>
<td>业务职责</td>
<td>上游为业务负责</td>
<td>无全局责任人</td>
</tr>
</tbody></table>
<p>另外需要重点明确的：“指令驱动”和“事件驱动”的区别不是“同步”和“异步”。指令可以是同步调用，也可以是异步消息触发（但异步指令不是事件）；反过来事件可以是异步消息，但也完全可以是进程内的同步调用。所以指令驱动和事件驱动差异的本质不在于调用方式，而是一件事情是否“已经”发生。</p>
<p><strong>所以在日常业务中当你碰到一个需求时，该如何选择是用Orchestration还是Choreography？</strong></p>
<p>这里给出两个判断方法：</p>
<ol>
<li>明确依赖的方向：</li>
</ol>
<p><img src="/2022/10/24/DDD-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%99%E6%B5%81%E6%B0%B4%E8%B4%A6%E4%BB%A3%E7%A0%81/11.png" alt="image.png"></p>
<p>在代码中的依赖是比较明确的：如果你是下游，上游对你无感知，则只能走事件驱动；如果上游必须要对你有感知，则可以走指令驱动。反过来，如果你是上游，需要对下游强依赖，则是指令驱动；如果下游是谁无所谓，则可以走事件驱动。</p>
<ol start="2">
<li>找出业务中的“负责人”：</li>
</ol>
<p><img src="/2022/10/24/DDD-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%99%E6%B5%81%E6%B0%B4%E8%B4%A6%E4%BB%A3%E7%A0%81/12.png" alt="image.png"></p>
<p>第二种方法是根据业务场景找出其中的“负责人”。比如，如果业务需要通知卖家，下单系统的单一职责不应该为消息通知负责，但订单管理系统需要根据订单状态的推进主动触发消息，所以是这个功能的负责人。</p>
<p>在一个复杂业务流程里，通常两个模式都要有，但也很容易设计错误。如果出现依赖关系很奇怪，或者代码里调用链路&#x2F;负责人梳理不清楚的情况，可以尝试转换一下模式，可能会好很多。</p>
<p><strong>哪个模式更好？</strong></p>
<p>很显然，没有最好的模式，只有最合适自己业务场景的模式。</p>
<p>❌ 反例：最近几年比较流行的Event-Driven Architecture（EDA）事件驱动架构，以及Reactive-Programming响应式编程（比如RxJava），虽然有很多创新，但在一定程度上是“当你有把锤子，所有问题都是钉子”的典型案例。他们对一些基于事件的、流处理的问题有奇效，但如果拿这些框架硬套指令驱动的业务，就会感到代码极其“不协调”，认知成本提高。所以在日常选型中，还是要先根据业务场景梳理出来是哪些流程中的部分是Orchestration，哪些是Choreography，然后再选择相对应的框架。</p>
<h2 id="4-4-跟DDD分层架构的关系"><a href="#4-4-跟DDD分层架构的关系" class="headerlink" title="4.4 跟DDD分层架构的关系"></a>4.4 跟DDD分层架构的关系</h2><p>最后，讲了这么多O vs C，跟DDD有啥关系？很简单：</p>
<ul>
<li>O&amp;C其实是Interface层的关注点，Orchestration &#x3D; 对外的API，而Choreography &#x3D; 消息或事件。当你决策了O还是C之后，需要在interface层承接这些“驱动力”。</li>
<li>无论O&amp;C如何设计，Application层都“无感知”，因为ApplicationService天生就可以处理Command、Query和Event，至于这些对象怎么来，是Interface层的决策。</li>
</ul>
<p>所以，虽然Orchestration 和 Choreography是两种完全不同的业务设计模式，但最终落到Application层的代码应该是一致的，这也是为什么Application层是“用例”而不是“接口”，是相对稳定的存在。</p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>只要是做业务的，一定会需要写业务流程和服务编排，但不代表这种代码一定质量差。通过DDD的分层架构里的Interface层和Application层的合理拆分，代码可以变得优雅、灵活，能更快的响应业务但同时又能更好的沉淀。本文主要介绍了一些代码的设计规范，帮助大家掌握一定的技巧。</p>
<p>Interface层：</p>
<ul>
<li>职责：主要负责承接网络协议的转化、Session管理等</li>
<li>接口数量：避免所谓的统一API，不必人为限制接口类的数量，每个&#x2F;每类业务对应一套接口即可，接口参数应该符合业务需求，避免大而全的入参</li>
<li>接口出参：统一返回Result</li>
<li>异常处理：应该捕捉所有异常，避免异常信息的泄漏。可以通过AOP统一处理，避免代码里有大量重复代码。</li>
</ul>
<p>Application层：</p>
<ul>
<li>入参：具像化Command、Query、Event对象作为ApplicationService的入参，唯一可以的例外是单ID查询的场景。</li>
<li>CQE的语意化：CQE对象有语意，不同用例之间语意不同，即使参数一样也要避免复用。</li>
<li>入参校验：基础校验通过Bean Validation api解决。Spring Validation自带Validation的AOP，也可以自己写AOP。</li>
<li>出参：统一返回DTO，而不是Entity或DO。</li>
<li>DTO转化：用DTO Assembler负责Entity&#x2F;VO到DTO的转化。</li>
<li>异常处理：不统一捕捉异常，可以随意抛异常。</li>
</ul>
<p>部分Infra层：</p>
<ul>
<li>用ACL防腐层将外部依赖转化为内部代码，隔离外部的影响</li>
</ul>
<p>业务流程设计模式：</p>
<ul>
<li>没有最好的模式，取决于业务场景、依赖关系、以及是否有业务“负责人”。避免拿着锤子找钉子。</li>
</ul>
]]></content>
      <categories>
        <category>DDD领域驱动设计</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>DDD-应用架构</title>
    <url>/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p><strong>简介：</strong> 应用架构，指软件系统中固定不变的代码结构、设计模式、规范和组件间的通信方式。在应用开发中架构之所以是最重要的第一步，因为一个好的架构能让系统安全、稳定、快速迭代。但是今天我们在做业务研发时，更多会关注一些宏观的架构，而忽略了应用内部的架构设计，希望能通过案例分析和重构，推演出一套高质量的DDD架构。</p>
<p>架构这个词源于英文里的“Architecture“，源头是土木工程里的“建筑”和“结构”，而架构里的”架“同时又包含了”架子“（scaffolding）的含义，意指能快速搭建起来的固定结构。而今天的应用架构，意指软件系统中固定不变的代码结构、设计模式、规范和组件间的通信方式。在应用开发中架构之所以是最重要的第一步，因为一个好的架构能让系统安全、稳定、快速迭代。在一个团队内通过规定一个固定的架构设计，可以让团队内能力参差不齐的同学们都能有一个统一的开发规范，降低沟通成本，提升效率和代码质量。</p>
<p>在做架构设计时，一个好的架构应该需要实现以下几个目标：</p>
<ul>
<li><strong>独立于框架：</strong>架构不应该依赖某个外部的库或框架，不应该被框架的结构所束缚。</li>
<li><strong>独立于UI：</strong>前台展示的样式可能会随时发生变化（今天可能是网页、明天可能变成console、后天是独立app），但是底层架构不应该随之而变化。</li>
<li><strong>独立于底层数据源：</strong>无论今天你用MySQL、Oracle还是MongoDB、CouchDB，甚至使用文件系统，软件架构不应该因为不同的底层数据储存方式而产生巨大改变。</li>
<li><strong>独立于外部依赖：</strong>无论外部依赖如何变更、升级，业务的核心逻辑不应该随之而大幅变化。</li>
<li><strong>可测试：</strong>无论外部依赖了什么数据库、硬件、UI或者服务，业务的逻辑应该都能够快速被验证正确性。</li>
</ul>
<p>这就好像是建筑中的楼宇，一个好的楼宇，无论内部承载了什么人、有什么样的活动、还是外部有什么风雨，一栋楼都应该屹立不倒，而且可以确保它不会倒。但是今天我们在做业务研发时，更多的会去关注一些宏观的架构，比如SOA架构、微服务架构，而忽略了应用内部的架构设计，很容易导致代码逻辑混乱，很难维护，容易产生bug而且很难发现。今天，我希望能够通过案例的分析和重构，来推演出一套高质量的DDD架构。</p>
<h1 id="1、案例分析"><a href="#1、案例分析" class="headerlink" title="1、案例分析"></a>1、案例分析</h1><p>我们先看一个简单的案例需求如下：</p>
<p>用户可以通过银行网页转账给另一个账号，支持跨币种转账。</p>
<p>同时因为监管和对账需求，需要记录本次转账活动。</p>
<p>拿到这个需求之后，一个开发可能会经历一些技术选型，最终可能拆解需求如下：</p>
<p>1、从MySql数据库中找到转出和转入的账户，选择用 MyBatis 的 mapper 实现 DAO；2、从 Yahoo（或其他渠道）提供的汇率服务获取转账的汇率信息（底层是 http 开放接口）；</p>
<p>3、计算需要转出的金额，确保账户有足够余额，并且没超出每日转账上限；</p>
<p>4、实现转入和转出操作，扣除手续费，保存数据库；</p>
<p>5、发送 Kafka 审计消息，以便审计和对账用；</p>
<p>而一个简单的代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransferController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TransferService transferService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Boolean&gt; <span class="title function_">transfer</span><span class="params">(String targetAccountNumber, BigDecimal amount, HttpSession session)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> (Long) session.getAttribute(<span class="string">&quot;userId&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> transferService.transfer(userId, targetAccountNumber, amount, <span class="string">&quot;CNY&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransferServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">TransferService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TOPIC_AUDIT_LOG</span> <span class="operator">=</span> <span class="string">&quot;TOPIC_AUDIT_LOG&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountDAO;</span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line">    <span class="keyword">private</span> YahooForexService yahooForex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Boolean&gt; <span class="title function_">transfer</span><span class="params">(Long sourceUserId, String targetAccountNumber, BigDecimal targetAmount, String targetCurrency)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 从数据库读取数据，忽略所有校验逻辑如账号是否存在等</span></span><br><span class="line">        <span class="type">AccountDO</span> <span class="variable">sourceAccountDO</span> <span class="operator">=</span> accountDAO.selectByUserId(sourceUserId);</span><br><span class="line">        <span class="type">AccountDO</span> <span class="variable">targetAccountDO</span> <span class="operator">=</span> accountDAO.selectByAccountNumber(targetAccountNumber);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 业务参数校验</span></span><br><span class="line">        <span class="keyword">if</span> (!targetAccountDO.getCurrency().equals(targetCurrency)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidCurrencyException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 获取外部数据，并且包含一定的业务逻辑</span></span><br><span class="line">        <span class="comment">// exchange rate = 1 source currency = X target currency</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">exchangeRate</span> <span class="operator">=</span> BigDecimal.ONE;</span><br><span class="line">        <span class="keyword">if</span> (sourceAccountDO.getCurrency().equals(targetCurrency)) &#123;</span><br><span class="line">            exchangeRate = yahooForex.getExchangeRate(sourceAccountDO.getCurrency(), targetCurrency);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">sourceAmount</span> <span class="operator">=</span> targetAmount.divide(exchangeRate, RoundingMode.DOWN);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 业务参数校验</span></span><br><span class="line">        <span class="keyword">if</span> (sourceAccountDO.getAvailable().compareTo(sourceAmount) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InsufficientFundsException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sourceAccountDO.getDailyLimit().compareTo(sourceAmount) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DailyLimitExceededException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 计算新值，并且更新字段</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">newSource</span> <span class="operator">=</span> sourceAccountDO.getAvailable().subtract(sourceAmount);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">newTarget</span> <span class="operator">=</span> targetAccountDO.getAvailable().add(targetAmount);</span><br><span class="line">        sourceAccountDO.setAvailable(newSource);</span><br><span class="line">        targetAccountDO.setAvailable(newTarget);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 更新到数据库</span></span><br><span class="line">        accountDAO.update(sourceAccountDO);</span><br><span class="line">        accountDAO.update(targetAccountDO);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 发送审计消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> sourceUserId + <span class="string">&quot;,&quot;</span> + targetAccountNumber + <span class="string">&quot;,&quot;</span> + targetAmount + <span class="string">&quot;,&quot;</span> + targetCurrency;</span><br><span class="line">        kafkaTemplate.send(TOPIC_AUDIT_LOG, message);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，一段业务代码里经常包含了参数校验、数据读取存储、业务计算、调用外部服务、发送消息等多种逻辑。在这个案例里虽然是写在了同一个方法里，在真实代码中经常会被拆分成多个子方法，但实际效果是一样的，而在我们日常的工作中，绝大部分代码都或多或少的接近于此类结构。在Martin Fowler的 P of EAA书中，这种很常见的代码样式被叫做Transaction Script（事务脚本）。虽然这种类似于脚本的写法在功能上没有什么问题，但是长久来看，他有以下几个很大的问题：可维护性差、可扩展性差、可测试性差。</p>
<p><strong>问题1-可维护性能差</strong></p>
<p>一个应用最大的成本一般都不是来自于开发阶段，而是应用整个生命周期的总维护成本，所以代码的可维护性代表了最终成本。</p>
<p><strong>可维护性 &#x3D; 当依赖变化时，有多少代码需要随之改变</strong><br>参考以上的案例代码，事务脚本类的代码很难维护因为以下几点：</p>
<ul>
<li><strong>数据结构的不稳定性：</strong>AccountDO类是一个纯数据结构，映射了数据库中的一个表。这里的问题是数据库的表结构和设计是应用的外部依赖，长远来看都有可能会改变，比如数据库要做Sharding，或者换一个表设计，或者改变字段名。</li>
<li><strong>依赖库的升级：</strong>AccountMapper依赖MyBatis的实现，如果MyBatis未来升级版本，可能会造成用法的不同（可以参考iBatis升级到基于注解的MyBatis的迁移成本）。同样的，如果未来换一个ORM体系，迁移成本也是巨大的。</li>
<li><strong>第三方服务依赖的不确定性</strong>：第三方服务，比如Yahoo的汇率服务未来很有可能会有变化：轻则API签名变化，重则服务不可用需要寻找其他可替代的服务。在这些情况下改造和迁移成本都是巨大的。同时，外部依赖的兜底、限流、熔断等方案都需要随之改变。</li>
<li><strong>第三方服务API的接口变化：</strong>YahooForexService.getExchangeRate返回的结果是小数点还是百分比？入参是（source, target）还是（target, source）？谁能保证未来接口不会改变？如果改变了，核心的金额计算逻辑必须跟着改，否则会造成资损。</li>
<li><strong>中间件更换：</strong>今天我们用Kafka发消息，明天如果要上阿里云用RocketMQ该怎么办？后天如果消息的序列化方式从String改为Binary该怎么办？如果需要消息分片该怎么改？</li>
</ul>
<p>我们发现案例里的代码对于任何外部依赖的改变都会有比较大的影响。如果你的应用里有大量的此类代码，你每一天的时间基本上会被各种库升级、依赖服务升级、中间件升级、jar包冲突占满，最终这个应用变成了一个不敢升级、不敢部署、不敢写新功能、并且随时会爆发的炸弹，终有一天会给你带来惊喜。</p>
<p><strong>问题2-可拓展性差</strong></p>
<p>事务脚本式代码的第二大缺陷是：虽然写单个用例的代码非常高效简单，但是当用例多起来时，其扩展性会变得越来越差。</p>
<p><strong>可扩展性 &#x3D; 做新需求或改逻辑时，需要新增&#x2F;修改多少代码</strong></p>
<p>参考以上的代码，如果今天需要增加一个跨行转账的能力，你会发现基本上需要重新开发，基本上没有任何的可复用性：</p>
<ul>
<li><strong>数据来源被固定、数据格式不兼容：</strong>原有的AccountDO是从本地获取的，而跨行转账的数据可能需要从一个第三方服务获取，而服务之间数据格式不太可能是兼容的，导致从数据校验、数据读写、到异常处理、金额计算等逻辑都要重写。</li>
<li><strong>业务逻辑无法复用：</strong>数据格式不兼容的问题会导致核心业务逻辑无法复用。每个用例都是特殊逻辑的后果是最终会造成大量的if-else语句，而这种分支多的逻辑会让分析代码非常困难，容易错过边界情况，造成bug。</li>
<li><strong>逻辑和数据存储的相互依赖：</strong>当业务逻辑增加变得越来越复杂时，新加入的逻辑很有可能需要对数据库schema或消息格式做变更。而变更了数据格式后会导致原有的其他逻辑需要一起跟着动。在最极端的场景下，一个新功能的增加会导致所有原有功能的重构，成本巨大。</li>
</ul>
<p>在事务脚本式的架构下，一般做第一个需求都非常的快，但是做第N个需求时需要的时间很有可能是呈指数级上升的，绝大部分时间花费在老功能的重构和兼容上，最终你的创新速度会跌为0，促使老应用被推翻重构。</p>
<p><strong>问题3-可测试性能差</strong></p>
<p>除了部分工具类、框架类和中间件类的代码有比较高的测试覆盖之外，我们在日常工作中很难看到业务代码有比较好的测试覆盖，而绝大部分的上线前的测试属于人肉的“集成测试”。低测试率导致我们对代码质量很难有把控，容易错过边界条件，异常case只有线上爆发了才被动发现。而低测试覆盖率的主要原因是业务代码的可测试性比较差。</p>
<p><strong>可测试性 &#x3D; 运行每个测试用例所花费的时间 * 每个需求所需要增加的测试用例数量</strong></p>
<p>参考以上的一段代码，这种代码有极低的可测试性：</p>
<ul>
<li>设施搭建困难：当代码中强依赖了数据库、第三方服务、中间件等外部依赖之后，想要完整跑通一个测试用例需要确保所有依赖都能跑起来，这个在项目早期是及其困难的。在项目后期也会由于各种系统的不稳定性而导致测试无法通过。</li>
<li>运行耗时长：大多数的外部依赖调用都是I&#x2F;O密集型，如跨网络调用、磁盘调用等，而这种I&#x2F;O调用在测试时需要耗时很久。另一个经常依赖的是笨重的框架如Spring，启动Spring容器通常需要很久。当一个测试用例需要花超过10秒钟才能跑通时，绝大部分开发都不会很频繁的测试。</li>
<li>耦合度高：假如一段脚本中有A、B、C三个子步骤，而每个步骤有N个可能的状态，当多个子步骤耦合度高时，为了完整覆盖所有用例，最多需要有N <em>N</em> N个测试用例。当耦合的子步骤越多时，需要的测试用例呈指数级增长。</li>
</ul>
<p>在事务脚本模式下，当测试用例复杂度远大于真实代码复杂度，当运行测试用例的耗时超出人肉测试时，绝大部分人会选择不写完整的测试覆盖，而这种情况通常就是bug很难被早点发现的原因。</p>
<p><strong>总结分析</strong></p>
<p>我们重新来分析一下为什么以上的问题会出现？因为以上的代码违背了至少以下几个软件设计的原则：</p>
<ul>
<li><strong>单一性原则（Single Responsibility Principle）：</strong>单一性原则要求一个对象&#x2F;类应该只有一个变更的原因。但是在这个案例里，代码可能会因为任意一个外部依赖或计算逻辑的改变而改变。</li>
<li><strong>依赖反转原则（Dependency Inversion Principle）：</strong>依赖反转原则要求在代码中依赖抽象，而不是具体的实现。在这个案例里外部依赖都是具体的实现，比如YahooForexService虽然是一个接口类，但是它对应的是依赖了Yahoo提供的具体服务，所以也算是依赖了实现。同样的KafkaTemplate、MyBatis的DAO实现都属于具体实现。</li>
<li><strong>开放封闭原则（Open Closed Principle）：</strong>开放封闭原则指开放扩展，但是封闭修改。在这个案例里的金额计算属于可能会被修改的代码，这个时候该逻辑应该需要被包装成为不可修改的计算类，新功能通过计算类的拓展实现。</li>
</ul>
<p>我们需要对代码重构才能解决这些问题。</p>
<h1 id="2、重构方案"><a href="#2、重构方案" class="headerlink" title="2、重构方案"></a>2、重构方案</h1><p>在重构之前，我们先画一张流程图，描述当前代码在做的每个步骤：</p>
<p><img src="/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/1.png" alt="image.png"></p>
<p>这是一个传统的三层分层结构：UI层、业务层、和基础设施层。上层对于下层有直接的依赖关系，导致耦合度过高。在业务层中对于下层的基础设施有强依赖，耦合度高。我们需要对这张图上的每个节点做抽象和整理，来降低对外部依赖的耦合度。</p>
<p><strong>2.1 - 抽象数据存储层</strong></p>
<p>第一步常见的操作是将Data Access层做抽象，降低系统对数据库的直接依赖。具体的方法如下：</p>
<ul>
<li>新建Account实体对象：一个实体（Entity）是拥有ID的域对象，除了拥有数据之外，同时拥有行为。Entity和数据库储存格式无关，在设计中要以该领域的通用严谨语言（Ubiquitous Language）为依据。</li>
<li>新建对象储存接口类AccountRepository：Repository只负责Entity对象的存储和读取，而Repository的实现类完成数据库存储的细节。通过加入Repository接口，底层的数据库连接可以通过不同的实现类而替换。</li>
</ul>
<p>具体的简单代码实现如下：</p>
<p>Account实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AccountId id;</span><br><span class="line">    <span class="keyword">private</span> AccountNumber accountNumber;</span><br><span class="line">    <span class="keyword">private</span> UserId userId;</span><br><span class="line">    <span class="keyword">private</span> Money available;</span><br><span class="line">    <span class="keyword">private</span> Money dailyLimit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Money money)</span> &#123;</span><br><span class="line">        <span class="comment">// 转出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(Money money)</span> &#123;</span><br><span class="line">        <span class="comment">// 转入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和AccountRepository及MyBatis实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountRepository</span> &#123;</span><br><span class="line">    Account <span class="title function_">find</span><span class="params">(AccountId id)</span>;</span><br><span class="line">    Account <span class="title function_">find</span><span class="params">(AccountNumber accountNumber)</span>;</span><br><span class="line">    Account <span class="title function_">find</span><span class="params">(UserId userId)</span>;</span><br><span class="line">    Account <span class="title function_">save</span><span class="params">(Account account)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountRepositoryImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountRepository</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountDAO;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountBuilder accountBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">find</span><span class="params">(AccountId id)</span> &#123;</span><br><span class="line">        <span class="type">AccountDO</span> <span class="variable">accountDO</span> <span class="operator">=</span> accountDAO.selectById(id.getValue());</span><br><span class="line">        <span class="keyword">return</span> accountBuilder.toAccount(accountDO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">find</span><span class="params">(AccountNumber accountNumber)</span> &#123;</span><br><span class="line">        <span class="type">AccountDO</span> <span class="variable">accountDO</span> <span class="operator">=</span> accountDAO.selectByAccountNumber(accountNumber.getValue());</span><br><span class="line">        <span class="keyword">return</span> accountBuilder.toAccount(accountDO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">find</span><span class="params">(UserId userId)</span> &#123;</span><br><span class="line">        <span class="type">AccountDO</span> <span class="variable">accountDO</span> <span class="operator">=</span> accountDAO.selectByUserId(userId.getId());</span><br><span class="line">        <span class="keyword">return</span> accountBuilder.toAccount(accountDO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">save</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">        <span class="type">AccountDO</span> <span class="variable">accountDO</span> <span class="operator">=</span> accountBuilder.fromAccount(account);</span><br><span class="line">        <span class="keyword">if</span> (accountDO.getId() == <span class="literal">null</span>) &#123;</span><br><span class="line">            accountDAO.insert(accountDO);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            accountDAO.update(accountDO);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> accountBuilder.toAccount(accountDO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Account实体类和AccountDO数据类的对比如下：</p>
<ul>
<li><strong>Data Object数据类：</strong>AccountDO是单纯的和数据库表的映射关系，每个字段对应数据库表的一个column，这种对象叫Data Object。DO只有数据，没有行为。AccountDO的作用是对数据库做快速映射，避免直接在代码里写SQL。无论你用的是MyBatis还是Hibernate这种ORM，从数据库来的都应该先直接映射到DO上，但是代码里应该完全避免直接操作 DO。</li>
<li><strong>Entity实体类：</strong>Account 是基于领域逻辑的实体类，它的字段和数据库储存不需要有必然的联系。Entity包含数据，同时也应该包含行为。在 Account 里，字段也不仅仅是String等基础类型，而应该尽可能用上一讲的 Domain Primitive 代替，可以避免大量的校验代码。</li>
</ul>
<p>DAO 和 Repository 类的对比如下：</p>
<ul>
<li>DAO对应的是一个特定的数据库类型的操作，相当于SQL的封装。所有操作的对象都是DO类，所有接口都可以根据数据库实现的不同而改变。比如，insert 和 update 属于数据库专属的操作。</li>
<li>Repository对应的是Entity对象读取储存的抽象，在接口层面做统一，不关注底层实现。比如，通过 save 保存一个Entity对象，但至于具体是 insert 还是 update 并不关心。Repository的具体实现类通过调用DAO来实现各种操作，通过Builder&#x2F;Factory对象实现AccountDO 到 Account之间的转化</li>
</ul>
<p><em>2.1.1 Repository和Entity</em></p>
<ul>
<li>通过Account对象，避免了其他业务逻辑代码和数据库的直接耦合，避免了当数据库字段变化时，大量业务逻辑也跟着变的问题。</li>
<li>通过Repository，改变业务代码的思维方式，让业务逻辑不再面向数据库编程，而是面向领域模型编程。</li>
<li>Account属于一个完整的内存中对象，可以比较容易的做完整的测试覆盖，包含其行为。</li>
<li>Repository作为一个接口类，可以比较容易的实现Mock或Stub，可以很容易测试。</li>
<li>AccountRepositoryImpl实现类，由于其职责被单一出来，只需要关注Account到AccountDO的映射关系和Repository方法到DAO方法之间的映射关系，相对于来说更容易测试。</li>
</ul>
<p><img src="/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/2.png" alt="image.png"></p>
<p><strong>2.2 - 抽象第三方服务</strong></p>
<p>类似对于数据库的抽象，所有第三方服务也需要通过抽象解决第三方服务不可控，入参出参强耦合的问题。在这个例子里我们抽象出 ExchangeRateService 的服务，和一个ExchangeRate的Domain Primitive类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ExchangeRateService</span> &#123;</span><br><span class="line">    ExchangeRate <span class="title function_">getExchangeRate</span><span class="params">(Currency source, Currency target)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExchangeRateServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">ExchangeRateService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> YahooForexService yahooForexService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ExchangeRate <span class="title function_">getExchangeRate</span><span class="params">(Currency source, Currency target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (source.equals(target)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExchangeRate</span>(BigDecimal.ONE, source, target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">forex</span> <span class="operator">=</span> yahooForexService.getExchangeRate(source.getValue(), target.getValue());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExchangeRate</span>(forex, source, target);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><em>2.2.1 防腐层（ACL）</em></p>
<p>这种常见的设计模式叫做Anti-Corruption Layer（防腐层或ACL）。很多时候我们的系统会去依赖其他的系统，而被依赖的系统可能包含不合理的数据结构、API、协议或技术实现，如果对外部系统强依赖，会导致我们的系统被”腐蚀“。这个时候，通过在系统间加入一个防腐层，能够有效的隔离外部依赖和内部逻辑，无论外部如何变更，内部代码可以尽可能的保持不变。</p>
<p><img src="/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/3.png" alt="image.png"></p>
<p>ACL 不仅仅只是多了一层调用，在实际开发中ACL能够提供更多强大的功能：</p>
<ul>
<li><strong>适配器：</strong>很多时候外部依赖的数据、接口和协议并不符合内部规范，通过适配器模式，可以将数据转化逻辑封装到ACL内部，降低对业务代码的侵入。在这个案例里，我们通过封装了ExchangeRate和Currency对象，转化了对方的入参和出参，让入参出参更符合我们的标准。</li>
<li><strong>缓存：</strong>对于频繁调用且数据变更不频繁的外部依赖，通过在ACL里嵌入缓存逻辑，能够有效的降低对于外部依赖的请求压力。同时，很多时候缓存逻辑是写在业务代码里的，通过将缓存逻辑嵌入ACL，能够降低业务代码的复杂度。</li>
<li><strong>兜底：</strong>如果外部依赖的稳定性较差，一个能够有效提升我们系统稳定性的策略是通过ACL起到兜底的作用，比如当外部依赖出问题后，返回最近一次成功的缓存或业务兜底数据。这种兜底逻辑一般都比较复杂，如果散落在核心业务代码中会很难维护，通过集中在ACL中，更加容易被测试和修改。</li>
<li><strong>易于测试：</strong>类似于之前的Repository，ACL的接口类能够很容易的实现Mock或Stub，以便于单元测试。</li>
<li><strong>功能开关：</strong>有些时候我们希望能在某些场景下开放或关闭某个接口的功能，或者让某个接口返回一个特定的值，我们可以在ACL配置功能开关来实现，而不会对真实业务代码造成影响。同时，使用功能开关也能让我们容易的实现Monkey测试，而不需要真正物理性的关闭外部依赖。</li>
</ul>
<p><img src="/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/4.png" alt="image.png"></p>
<p><strong>2.3 - 抽象中间件</strong></p>
<p>类似于2.2的第三方服务的抽象，对各种中间件的抽象的目的是让业务代码不再依赖中间件的实现逻辑。因为中间件通常需要有通用型，中间件的接口通常是String或Byte[] 类型的，导致序列化&#x2F;反序列化逻辑通常和业务逻辑混杂在一起，造成胶水代码。通过中间件的ACL抽象，减少重复胶水代码。</p>
<p>在这个案例里，我们通过封装一个抽象的AuditMessageProducer和AuditMessage DP对象，实现对底层kafka实现的隔离：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuditMessage</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserId userId;</span><br><span class="line">    <span class="keyword">private</span> AccountNumber source;</span><br><span class="line">    <span class="keyword">private</span> AccountNumber target;</span><br><span class="line">    <span class="keyword">private</span> Money money;</span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userId + <span class="string">&quot;,&quot;</span> + source + <span class="string">&quot;,&quot;</span> + target + <span class="string">&quot;,&quot;</span> + money + <span class="string">&quot;,&quot;</span> + date;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AuditMessage <span class="title function_">deserialize</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuditMessageProducer</span> &#123;</span><br><span class="line">    SendResult <span class="title function_">send</span><span class="params">(AuditMessage message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuditMessageProducerImpl</span> <span class="keyword">implements</span> <span class="title class_">AuditMessageProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TOPIC_AUDIT_LOG</span> <span class="operator">=</span> <span class="string">&quot;TOPIC_AUDIT_LOG&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> SendResult <span class="title function_">send</span><span class="params">(AuditMessage message)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">messageBody</span> <span class="operator">=</span> message.serialize();</span><br><span class="line">        kafkaTemplate.send(TOPIC_AUDIT_LOG, messageBody);</span><br><span class="line">        <span class="keyword">return</span> SendResult.success();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的分析和2.2类似，在此略过。</p>
<p><img src="/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/5.png" alt="image.png"></p>
<p><strong>2.4 - 封装业务逻辑</strong></p>
<p>在这个案例里，有很多业务逻辑是跟外部依赖的代码混合的，包括金额计算、账户余额的校验、转账限制、金额增减等。这种逻辑混淆导致了核心计算逻辑无法被有效的测试和复用。在这里，我们的解法是通过Entity、Domain Primitive和Domain Service封装所有的业务逻辑：</p>
<p><em>2.4.1 - 用Domain Primitive封装跟实体无关的无状态计算逻辑</em></p>
<p>在这个案例里使用ExchangeRate来封装汇率计算逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">exchangeRate</span> <span class="operator">=</span> BigDecimal.ONE;</span><br><span class="line"><span class="keyword">if</span> (sourceAccountDO.getCurrency().equals(targetCurrency)) &#123;</span><br><span class="line">    exchangeRate = yahooForex.getExchangeRate(sourceAccountDO.getCurrency(), targetCurrency);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">sourceAmount</span> <span class="operator">=</span> targetAmount.divide(exchangeRate, RoundingMode.DOWN);</span><br></pre></td></tr></table></figure>

<p>变为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExchangeRate</span> <span class="variable">exchangeRate</span> <span class="operator">=</span> exchangeRateService.getExchangeRate(sourceAccount.getCurrency(), targetMoney.getCurrency());</span><br><span class="line"><span class="type">Money</span> <span class="variable">sourceMoney</span> <span class="operator">=</span> exchangeRate.exchangeTo(targetMoney);</span><br></pre></td></tr></table></figure>

<p><em>2.4.2 - 用Entity封装单对象的有状态的行为，包括业务校验</em></p>
<p>用Account实体类封装所有Account的行为，包括业务校验如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AccountId id;</span><br><span class="line">    <span class="keyword">private</span> AccountNumber accountNumber;</span><br><span class="line">    <span class="keyword">private</span> UserId userId;</span><br><span class="line">    <span class="keyword">private</span> Money available;</span><br><span class="line">    <span class="keyword">private</span> Money dailyLimit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Currency <span class="title function_">getCurrency</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.available.getCurrency();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(Money money)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.getCurrency().equals(money.getCurrency())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidCurrencyException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.available = <span class="built_in">this</span>.available.add(money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Money money)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.available.compareTo(money) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InsufficientFundsException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.dailyLimit.compareTo(money) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DailyLimitExceededException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.available = <span class="built_in">this</span>.available.subtract(money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原有的业务代码则可以简化为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sourceAccount.deposit(sourceMoney);</span><br><span class="line">targetAccount.withdraw(targetMoney);</span><br></pre></td></tr></table></figure>

<p><strong>2.4.3 - 用Domain Service封装多对象逻辑</strong></p>
<p>在这个案例里，我们发现这两个账号的转出和转入实际上是一体的，也就是说这种行为应该被封装到一个对象中去。特别是考虑到未来这个逻辑可能会产生变化：比如增加一个扣手续费的逻辑。这个时候在原有的TransferService中做并不合适，在任何一个Entity或者Domain Primitive里也不合适，需要有一个新的类去包含跨域对象的行为。这种对象叫做Domain Service。</p>
<p>我们创建一个AccountTransferService的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountTransferService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account sourceAccount, Account targetAccount, Money targetMoney, ExchangeRate exchangeRate)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountTransferServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountTransferService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ExchangeRateService exchangeRateService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account sourceAccount, Account targetAccount, Money targetMoney, ExchangeRate exchangeRate)</span> &#123;</span><br><span class="line">        <span class="type">Money</span> <span class="variable">sourceMoney</span> <span class="operator">=</span> exchangeRate.exchangeTo(targetMoney);</span><br><span class="line">        sourceAccount.deposit(sourceMoney);</span><br><span class="line">        targetAccount.withdraw(targetMoney);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而原始代码则简化为一行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">accountTransferService.transfer(sourceAccount, targetAccount, targetMoney, exchangeRate);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/6.png" alt="image.png"></p>
<p><strong>2.5 - 重构后结果分析</strong></p>
<p>这个案例重构后的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransferServiceImplNew</span> <span class="keyword">implements</span> <span class="title class_">TransferService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AccountRepository accountRepository;</span><br><span class="line">    <span class="keyword">private</span> AuditMessageProducer auditMessageProducer;</span><br><span class="line">    <span class="keyword">private</span> ExchangeRateService exchangeRateService;</span><br><span class="line">    <span class="keyword">private</span> AccountTransferService accountTransferService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Boolean&gt; <span class="title function_">transfer</span><span class="params">(Long sourceUserId, String targetAccountNumber, BigDecimal targetAmount, String targetCurrency)</span> &#123;</span><br><span class="line">        <span class="comment">// 参数校验</span></span><br><span class="line">        <span class="type">Money</span> <span class="variable">targetMoney</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Money</span>(targetAmount, <span class="keyword">new</span> <span class="title class_">Currency</span>(targetCurrency));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读数据</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">sourceAccount</span> <span class="operator">=</span> accountRepository.find(<span class="keyword">new</span> <span class="title class_">UserId</span>(sourceUserId));</span><br><span class="line">        <span class="type">Account</span> <span class="variable">targetAccount</span> <span class="operator">=</span> accountRepository.find(<span class="keyword">new</span> <span class="title class_">AccountNumber</span>(targetAccountNumber));</span><br><span class="line">        <span class="type">ExchangeRate</span> <span class="variable">exchangeRate</span> <span class="operator">=</span> exchangeRateService.getExchangeRate(sourceAccount.getCurrency(), targetMoney.getCurrency());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">        accountTransferService.transfer(sourceAccount, targetAccount, targetMoney, exchangeRate);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存数据</span></span><br><span class="line">        accountRepository.save(sourceAccount);</span><br><span class="line">        accountRepository.save(targetAccount);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送审计消息</span></span><br><span class="line">        <span class="type">AuditMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuditMessage</span>(sourceAccount, targetAccount, targetMoney);</span><br><span class="line">        auditMessageProducer.send(message);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出来，经过重构后的代码有以下几个特征：</p>
<ul>
<li>业务逻辑清晰，数据存储和业务逻辑完全分隔。</li>
<li>Entity、Domain Primitive、Domain Service都是独立的对象，没有任何外部依赖，但是却包含了所有核心业务逻辑，可以单独完整测试。</li>
<li>原有的TransferService不再包括任何计算逻辑，仅仅作为组件编排，所有逻辑均delegate到其他组件。这种仅包含Orchestration（编排）的服务叫做Application Service（应用服务）。</li>
</ul>
<p>我们可以根据新的结构重新画一张图：</p>
<p><img src="/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/7.png" alt="image.png"></p>
<p>然后通过重新编排后该图变为：</p>
<p><img src="/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/8.png" alt="image.png"></p>
<p>我们可以发现，通过对外部依赖的抽象和内部逻辑的封装重构，应用整体的依赖关系变了：</p>
<ul>
<li>最底层不再是数据库，而是Entity、Domain Primitive和Domain Service。这些对象不依赖任何外部服务和框架，而是纯内存中的数据和操作。这些对象我们打包为Domain Layer（领域层）。领域层没有任何外部依赖关系。</li>
<li>再其次的是负责组件编排的Application Service，但是这些服务仅仅依赖了一些抽象出来的ACL类和Repository类，而其具体实现类是通过依赖注入注进来的。Application Service、Repository、ACL等我们统称为Application Layer（应用层）。应用层 依赖 领域层，但不依赖具体实现。</li>
<li>最后是ACL，Repository等的具体实现，这些实现通常依赖外部具体的技术实现和框架，所以统称为Infrastructure Layer（基础设施层）。Web框架里的对象如Controller之类的通常也属于基础设施层。</li>
</ul>
<p>如果今天能够重新写这段代码，考虑到最终的依赖关系，我们可能先写Domain层的业务逻辑，然后再写Application层的组件编排，最后才写每个外部依赖的具体实现。这种架构思路和代码组织结构就叫做Domain-Driven Design（领域驱动设计，或DDD）。所以DDD不是一个特殊的架构设计，而是所有Transction Script代码经过合理重构后一定会抵达的终点。</p>
<h1 id="3、DDD的六边形架构"><a href="#3、DDD的六边形架构" class="headerlink" title="3、DDD的六边形架构"></a>3、DDD的六边形架构</h1><p>在我们传统的代码里，我们一般都很注重每个外部依赖的实现细节和规范，但是今天我们需要敢于抛弃掉原有的理念，重新审视代码结构。在上面重构的代码里，如果抛弃掉所有Repository、ACL、Producer等的具体实现细节，我们会发现每一个对外部的抽象类其实就是输入或输出，类似于计算机系统中的I&#x2F;O节点。这个观点在CQRS架构中也同样适用，将所有接口分为Command（输入）和Query（输出）两种。除了I&#x2F;O之外其他的内部逻辑，就是应用业务的核心逻辑。基于这个基础，Alistair Cockburn在2005年提出了Hexagonal Architecture（六边形架构），又被称之为Ports and Adapters（端口和适配器架构）。</p>
<p><img src="/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/9.png" alt="image.png"></p>
<p>在这张图中：</p>
<ul>
<li>I&#x2F;O的具体实现在模型的最外层</li>
<li>每个I&#x2F;O的适配器在灰色地带</li>
<li>每个Hex的边是一个端口</li>
<li>Hex的中央是应用的核心领域模型</li>
</ul>
<p>在Hex中，架构的组织关系第一次变成了一个二维的内外关系，而不是传统一维的上下关系。同时在Hex架构中我们第一次发现UI层、DB层、和各种中间件层实际上是没有本质上区别的，都只是数据的输入和输出，而不是在传统架构中的最上层和最下层。</p>
<p>除了2005年的Hex架构，2008年 Jeffery Palermo的Onion Architecture（洋葱架构）和2017年 Robert Martin的Clean Architecture（干净架构），都是极为类似的思想。除了命名不一样、切入点不一样之外，其他的整体架构都是基于一个二维的内外关系。这也说明了基于DDD的架构最终的形态都是类似的。Herberto Graca有一个很全面的图包含了绝大部分现实中的端口类，值得借鉴。</p>
<p><img src="/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/10.png" alt="image.png"></p>
<p><strong>3.1 - 代码组织结构</strong></p>
<p>为了有效的组织代码结构，避免下层代码依赖到上层实现的情况，在Java中我们可以通过POM Module和POM依赖来处理相互的关系。通过Spring&#x2F;SpringBoot的容器来解决运行时动态注入具体实现的依赖的问题。一个简单的依赖关系图如下：</p>
<p><img src="/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/11.png" alt="image.png"><br><img src="/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/12.png" alt="image.png"></p>
<p><em>3.1.1 - Types 模块</em></p>
<p>Types模块是保存可以对外暴露的Domain Primitives的地方。Domain Primitives因为是无状态的逻辑，可以对外暴露，所以经常被包含在对外的API接口中，需要单独成为模块。Types模块不依赖任何类库，纯 POJO 。</p>
<p><img src="/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/13.png" alt="image.png"></p>
<p><em>3.1.2 - Domain 模块</em></p>
<p>Domain 模块是核心业务逻辑的集中地，包含有状态的Entity、领域服务Domain Service、以及各种外部依赖的接口类（如Repository、ACL、中间件等。Domain模块仅依赖Types模块，也是纯 POJO 。</p>
<p><img src="/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/14.png" alt="image.png"></p>
<p><em>3.1.3 - Application模块</em></p>
<p>Application模块主要包含Application Service和一些相关的类。Application模块依赖Domain模块。还是不依赖任何框架，纯POJO。</p>
<p><img src="/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/15.png" alt="image.png"></p>
<p><em>3.1.4 - Infrastructure模块</em></p>
<p>Infrastructure模块包含了Persistence、Messaging、External等模块。比如：Persistence模块包含数据库DAO的实现，包含Data Object、ORM Mapper、Entity到DO的转化类等。Persistence模块要依赖具体的ORM类库，比如MyBatis。如果需要用Spring-Mybatis提供的注解方案，则需要依赖Spring。</p>
<p><img src="/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/16.png" alt="image.png"></p>
<p><em>3.1.5 - Web模块</em></p>
<p>Web模块包含Controller等相关代码。如果用SpringMVC则需要依赖Spring。</p>
<p><img src="/2022/10/24/DDD-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/17.png" alt="image.png"></p>
<p><em>3.1.6 - Start模块</em></p>
<p>Start模块是SpringBoot的启动类。</p>
<p><strong>3.2 - 测试</strong></p>
<ul>
<li>Types，Domain模块都属于无外部依赖的纯POJO，基本上都可以100%的被单元测试覆盖。</li>
<li>Application模块的代码依赖外部抽象类，需要通过测试框架去Mock所有外部依赖，但仍然可以100%被单元测试。</li>
<li>Infrastructure的每个模块的代码相对独立，接口数量比较少，相对比较容易写单测。但是由于依赖了外部I&#x2F;O，速度上不可能很快，但好在模块的变动不会很频繁，属于一劳永逸。</li>
<li>Web模块有两种测试方法：通过Spring的MockMVC测试，或者通过HttpClient调用接口测试。但是在测试时最好把Controller依赖的服务类都Mock掉。一般来说当你把Controller的逻辑都后置到Application Service中时，Controller的逻辑变得极为简单，很容易100%覆盖。</li>
<li>Start模块：通常应用的集成测试写在start里。当其他模块的单元测试都能100%覆盖后，集成测试用来验证整体链路的真实性。</li>
</ul>
<p><strong>3.3 - 代码的演进&#x2F;变化速度</strong></p>
<p>在传统架构中，代码从上到下的变化速度基本上是一致的，改个需求需要从接口、到业务逻辑、到数据库全量变更，而第三方变更可能会导致整个代码的重写。但是在DDD中不同模块的代码的演进速度是不一样的：</p>
<ul>
<li>Domain层属于核心业务逻辑，属于经常被修改的地方。比如：原来不需要扣手续费，现在需要了之类的。通过Entity能够解决基于单个对象的逻辑变更，通过Domain Service解决多个对象间的业务逻辑变更。</li>
<li>Application层属于Use Case（业务用例）。业务用例一般都是描述比较大方向的需求，接口相对稳定，特别是对外的接口一般不会频繁变更。添加业务用例可以通过新增Application Service或者新增接口实现功能的扩展。</li>
<li>Infrastructure层属于最低频变更的。一般这个层的模块只有在外部依赖变更了之后才会跟着升级，而外部依赖的变更频率一般远低于业务逻辑的变更频率。</li>
</ul>
<p>所以在DDD架构中，能明显看出越外层的代码越稳定，越内层的代码演进越快，真正体现了领域“驱动”的核心思想。</p>
<h1 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h1><p>DDD不是一个什么特殊的架构，而是任何传统代码经过合理的重构之后最终一定会抵达的终点。DDD的架构能够有效的解决传统架构中的问题：</p>
<ul>
<li><strong>高可维护性：</strong>当外部依赖变更时，内部代码只用变更跟外部对接的模块，其他业务逻辑不变。</li>
<li><strong>高可扩展性：</strong>做新功能时，绝大部分的代码都能复用，仅需要增加核心业务逻辑即可。</li>
<li><strong>高可测试性：</strong>每个拆分出来的模块都符合单一性原则，绝大部分不依赖框架，可以快速的单元测试，做到100%覆盖。</li>
<li><strong>代码结构清晰：</strong>通过POM module可以解决模块间的依赖关系， 所有外接模块都可以单独独立成Jar包被复用。当团队形成规范后，可以快速的定位到相关代码。</li>
</ul>
]]></content>
      <categories>
        <category>DDD领域驱动设计</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>DDD整合分层架构和微服务设计</title>
    <url>/2022/10/25/DDD%E6%95%B4%E5%90%88%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E5%92%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>p8-DDD整合分层架构和微服务设计</p>
<div class="pdf-container" data-target="./p8-DDD整合分层架构和微服务设计.pdf" data-height="1000px"></div>]]></content>
      <categories>
        <category>DDD领域驱动设计</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>去哪儿网DDD系列公开课</tag>
      </tags>
  </entry>
  <entry>
    <title>DDD领域驱动设计</title>
    <url>/2022/10/24/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="从遇到问题开始"><a href="#从遇到问题开始" class="headerlink" title="从遇到问题开始"></a>从遇到问题开始</h2><p>当人们要做一个软件系统时，一般总是因为遇到了什么问题，然后希望通过一个软件系统来解决。</p>
<p>比如，我是一家企业，然后我觉得我现在线下销售自己的产品还不够，我希望能够在线上也能销售自己的产品。所以，自然而然就想到要做一个普通电商系统，用于实现在线销售自己企业产品的目的。</p>
<p>再比如，我是一家互联网公司，公司有很多系统对外提供服务，面向很多客户端设备。但是最近由于各种原因，导致服务经常出故障。所以，我们希望通过各种措施提高服务的质量和稳定性。其中的一个措施就是希望能做一个灰度发布的平台，这个平台可以提供灰度发布的服务。然后，当某个业务系统做了一些修改并需要发布时，可以使用我们的灰度发布平台来非常方便的实现灰度发布的功能。比如在灰度发布平台上方便的定制允许哪些特定的客户端才会访问新服务，哪些客户端继续使用老服务。灰度发布平台可以提供各种灰度的策略。有了这样的灰度发布机制，那即便系统的新逻辑有什么问题，受影响的面也不会很大，在可控范围内。所以，如果公司里的所有对外提供服务的系统都接入了灰度平台，那这些系统的发布环节就可以更加有保障了。</p>
<p>总之，我们做任何一个软件系统，都是有原因的，否则就没必要做这个系统，而这个原因就是我们遇到的问题。所以，通过问题，我们就知道了我们需要一个什么样的系统，这个系统解决什么样的问题。最后，我们就很自然的得出了一个目标，即知道了自己要什么。比如我要做一个论坛、一个博客系统、一个电商平台、一个灰度发布系统、一个IDE、一个分布式消息队列、一个通信框架，等等。</p>
<h2 id="DDD切入点1-理解概念"><a href="#DDD切入点1-理解概念" class="headerlink" title="DDD切入点1 - 理解概念"></a>DDD切入点1 - 理解概念</h2><p>DDD的全称为Domain-driven Design，即领域驱动设计。下面我从领域、问题域、领域模型、设计、驱动这几个词语的含义和联系的角度去阐述DDD是如何融入到我们平时的软件开发初期阶段的。要理解什么是领域驱动设计，首先要理解什么是领域，什么是设计，还有驱动是什么意思，什么驱动什么。</p>
<h2 id="什么是领域（Domain）？"><a href="#什么是领域（Domain）？" class="headerlink" title="什么是领域（Domain）？"></a>什么是领域（Domain）？</h2><p>前面我们已经清楚的知道我们现在要做一个什么样的系统，这个系统需要解决什么问题。我认为任何一个系统都会属于某个特定的领域，比如论坛是一个领域，只要你想做一个论坛，那这个论坛的核心业务是确定的，比如都有用户发帖、回帖等核心基本功能。比如电商平台、普通电商系统，这种都属于网上电商领域，只要是这个领域的系统，那都有商品浏览、购物车、下单、减库存、付款交易等核心环节。所以，同一个领域的系统都具有相同的核心业务，因为他们要解决的问题的本质是类似的。</p>
<p>因此，我们可以推断出，一个领域本质上可以理解为就是一个问题域，只要是同一个领域，那问题域就相同。所以，只要我们确定了系统所属的领域，那这个系统的核心业务，即要解决的关键问题、问题的范围边界就基本确定了。通常我们说，要成为一个领域的专家，必须要在这个领域深入研究很多年才行。因为只有你研究了很多年，你才会遇到非常多的该领域的问题，同时你解决这个领域中的问题的经验也非常丰富。很多时候，领域专家比技术专家更加吃香，比如金融领域的专家。</p>
<h2 id="什么是设计（Design）？"><a href="#什么是设计（Design）？" class="headerlink" title="什么是设计（Design）？"></a>什么是设计（Design）？</h2><p>DDD中的设计主要指领域模型的设计。为什么是领域模型的设计而不是架构设计或其他的什么设计呢？因为DDD是一种基于模型驱动开发的软件开发思想，强调领域模型是整个系统的核心，领域模型也是整个系统的核心价值所在。每一个领域，都有一个对应的领域模型，领域模型能够很好的帮我们解决复杂的业务问题。</p>
<p>从领域和代码实现的角度来理解，领域模型绑定了领域和代码实现，确保了最终的代码实现就一定是解决了领域中的核心问题的。因为：1）领域驱动领域模型设计；2）领域模型驱动代码实现。我们只要保证领域模型的设计是正确的，就能确定领域模型可以解决领域中的核心问题；同理，我们只要保证代码实现是严格按照领域模型的意图来落地的，那就能保证最后出来的代码能够解决领域的核心问题的。这个思路，和传统的分析、设计、编码这几个阶段被割裂（并且每个阶段的产物也不同）的软件开发方法学形成鲜明的对比。</p>
<h2 id="什么是驱动（Driven）？"><a href="#什么是驱动（Driven）？" class="headerlink" title="什么是驱动（Driven）？"></a>什么是驱动（Driven）？</h2><p>上面其实已经提到了，就是：1）领域驱动领域模型设计；2）领域模型驱动代码实现。这个就和我们传统的数据库驱动开发的思路形成对比了。DDD中，我们总是以领域为边界，分析领域中的核心问题（核心关注点），然后设计对应的领域模型，再通过领域模型驱动代码实现。而像数据库设计、持久化技术等这些都不是DDD的核心，而是外围的东西。</p>
<p>领域驱动设计（DDD）告诉我们的最大价值我觉得是：当我们要开发一个系统时，应该尽量先把领域模型想清楚，然后再开始动手编码，这样的系统后期才会很好维护。但是，很多项目（尤其是互联网项目，为了赶工）都是一开始模型没想清楚，一上来就开始建表写代码，代码写的非常冗余，完全是过程是的思考方式，最后导致系统非常难以维护。而且更糟糕的是，出来混总是要还的，前期的领域模型设计的不好，不够抽象，如果你的系统会长期需要维护和适应业务变化，那后面你一定会遇到各种问题维护上的困难，比如数据结构设计不合理，代码到处冗余，改BUG到处引入新的BUG，新人对这种代码上手困难，等。而那时如果你再想重构模型，那要付出的代价会比一开始重新开发还要大，因为你还要考虑兼容历史的数据，数据迁移，如何平滑发布等各种头疼的问题。所以，就导致我们最后天天加班。</p>
<p>虽然，我们都知道这个道理，但是我也明白，人的习惯很难改变的，大部分人都很难从面向过程式的想到哪里写到哪里的思想转变为基于系统化的模型驱动的思维。我想，这或许是DDD很难在中国或国外流行起来的原因吧。但是，我想这不应该成为我们放弃学习DDD的原因，对吧！</p>
<h2 id="概念总结："><a href="#概念总结：" class="headerlink" title="概念总结："></a>概念总结：</h2><p>领域就是问题域，有边界，领域中有很多问题；<br>任何一个系统要解决的那个大问题都对应一个领域；<br>通过建立领域模型来解决领域中的核心问题，模型驱动的思想；<br>领域建模的目标针对我们在领域中所关心的问题，即只针对核心关注点，而不是整个领域中的所有问题；<br>领域模型在设计时应考虑一定的抽象性、通用性，以及复用价值；<br>通过领域模型驱动代码的实现，确保代码让领域模型落地，代码最终能解决问题；<br>领域模型是系统的核心，是领域内的业务的直接沉淀，具有非常大的业务价值；<br>技术架构设计或数据存储等是在领域模型的外围，帮助领域模型进行落地；</p>
<h2 id="DDD切入点2-理解领域、拆分领域、细化领域"><a href="#DDD切入点2-理解领域、拆分领域、细化领域" class="headerlink" title="DDD切入点2 - 理解领域、拆分领域、细化领域"></a>DDD切入点2 - 理解领域、拆分领域、细化领域</h2><h3 id="理解领域知识是基础"><a href="#理解领域知识是基础" class="headerlink" title="理解领域知识是基础"></a>理解领域知识是基础</h3><p>上面我们通过第一步，虽然我们明确了要做一个什么样的系统，该系统主要解决什么问题，但是就这样我们还无法开始进行实际的需求分析和模型设计，我们还必须将我们的问题进行拆分，需求进行细化。有些时候，需求方，即提出问题的人，很可能自己不清楚具体想要什么。他只知道一个概念，一个大的目标。比如他只知道要做一个股票交易系统，一个灰度发布系统，一个电商平台，一个开发工具，等。但是他不清楚这些系统应该具体做成什么样子。这个时候，我认为领域专家就非常重要了，DDD也非常强调领域专家的重要性。因为领域专家对这个领域非常了解，对领域内的各种业务场景和各种业务规则也非常清楚，总之，对这个领域内的一切业务相关的知识都非常了解。所以，他们自然就有能力表达出系统该做成什么样子。所以，要知道一个系统到底该做成什么样子，到底哪些是核心业务关注点，只能靠沉淀领域内的各种知识，别无他法。因此，假设你现在打算做一个电商平台，但是你对这个领域没什么了解，那你一定得先去了解下该领域内主流的电商平台，比如淘宝、天猫、京东、亚马逊等。这个了解的过程就是你沉淀领域知识的过程。如果你不了解，就算你领域建模的能力再强，各种技术架构能力再强也是使不上力。领域专家不是某个固定的角色，而是某一类人，这类人对这个领域非常了解。比如，一个开发人员也可以是一个领域专家。假设你在一个公司开发和维护一个系统已经好几年了，但是这个系统的产品经理（PD）可能已经换过好几任了，这种情况下，我相信这几任产品经理都没有比你更熟悉这个领域。</p>
<h3 id="拆分领域"><a href="#拆分领域" class="headerlink" title="拆分领域"></a>拆分领域</h3><p>上面我们明白了，领域建模的基础是要先理解领域，让自己成为领域专家。如果做到了这点，我们就打好了坚实的基础了。但是，有时一个领域往往太复杂，涉及到的领域概念、业务规则、交互流程太多，导致我们没办法直接针对这个大的领域进行领域建模。所以，我们需要将领域进行拆分，本质上就是把大问题拆分为小问题，然后各个击破的思路。然后既然把一个大的领域划分为了多个小的领域（子域），那最关键的就是要理清每个子域的边界；然后要搞清楚哪些子域是核心子域，哪些是非核心子域，哪些是公共支撑子域；然后，还要思考子域之间的联系是什么。那么，我们该如何划分子域呢？我的个人看法是从业务相关性的角度去思考，也就是我们平时说的按业务功能为出发点进行划分。还是拿经典的电商系统来分析，通常一个电商系统都会包含好几个大块，比如：</p>
<p>会员中心：负责用户账号登录、用户信息的管理；<br>商品中心：负责商品的展示、导航、维护；<br>订单中心：负责订单的生成和生命周期管理；<br>交易中心：负责交易相关的业务；<br>库存中心：负责维护商品的库存；<br>促销中心：负责各种促销活动的支持；<br>上面这些中心看起来很自然，因为大家对电子商务的这个领域都已经非常熟悉了，所以都没什么疑问，好像很自然的样子。所以，领域划分是不是就是没什么挑战了呢？显然不是。之所以我们觉得子域划分很简单，是因为我们对整个大领域非常了解了。如果我们遇到一个冷门的领域，就没办法这么容易的去划分子域了。这就需要我们先去努力理解领域内的知识。所以，我个人从来不相信什么子域划分的技巧什么的东西，因为我觉得这个工作没有任何诀窍可以使用。当我们不了解一个东西的时候，如何去拆解它？当我们对整个领域有一定的熟悉了，了解了领域内的相关业务的本质和关系，我们就自然而然的能划分出合理的子域了。不过并不是所有的系统都需要划分子域的，有些系统只是解决一个小问题，这个问题不复杂，可能只有一两个核心概念。所以，这种系统完全不需要再划分子域。但不是绝对的，当一个领域，我们的关注点越来越多，每个关注点我们关注的信息越来越多的时候，我们会不由自主的去进一步的划分子域。比如，也许我们一开始将商品和商品的库存都放在商品中心里，但是后来由于库存的维护越来越复杂，导致揉在一起对我们的系统维护带来一定的困难时，我们就会考虑将两者进行拆分，这个就是所谓的业务垂直分割。</p>
<h3 id="细化子域"><a href="#细化子域" class="headerlink" title="细化子域"></a>细化子域</h3><p>通过上面的两步，我们了解了领域里的知识，也对领域进行了子域划分。但这样还不够，凭这些我们还无法进行后续的领域模型设计。我们还必须再进一步细化每个子域，进一步明确每个子域的核心关注点，即需求细化。我觉得我们需要细化的方面有以下几点：</p>
<p>梳理领域概念：梳理出领域内我们关注的概念、概念的关系，并统一交流词汇，形成统一语言；<br>梳理业务规则：梳理出领域内我们关注的各种业务规则，DDD中叫不变性（invariants），比如唯一性规则，余额不能小于零等；<br>梳理业务场景：梳理出领域内的核心业务场景，比如电商平台中的加入购物车、提交订单、发起付款等核心业务场景；<br>梳理业务流程：梳理出领域内的关键业务流程，比如订单处理流程，退款流程等；<br>从上面这4个方面，我们从领域概念、业务规则、交互场景、业务流程等维度梳理了我们到底要什么，整理了整个系统应该具备的功能。这个工作我觉得是一个非常具有创造性和有难度的工作。我们一方面会主观的定义我们想要什么；另一方面，我们还会思考我们要的东西的合理性。我认为这个就是产品经理的工作，产品经理必须要负起职责，把他的产品充分设计好，从各个方面去考虑，如何设计一个产品，才能更好的解决用户的核心诉求，即领域内的核心问题。如果对领域不够了解，如果想不清楚用户到底要什么，如果思考问题不够全面，谈何设计出一个合理的产品呢？</p>
<p>关于领域概念的梳理，我觉得可以采用四色原型分析法，这个分析法通过系统的方法，将概念划分为不同的种类，为不同种类的概念标注不同的颜色。然后将这些概念有机的组合起来，从而让我们可以清晰的分析出概念和概念之间的关系。有兴趣的同学可以在网上搜索下<a href="https://www.cnblogs.com/netfocus/archive/2011/03/05/1971899.html">四色原型</a>。</p>
<p><strong>注意：上面我说的这四点，重点是梳理出我们要什么功能，而不是思考如何实现这些功能，如何实现是软件设计人员的职责。</strong></p>
<h2 id="DDD切入点3-领域模型设计"><a href="#DDD切入点3-领域模型设计" class="headerlink" title="DDD切入点3 - 领域模型设计"></a>DDD切入点3 - 领域模型设计</h2><p>这部分内容，我想学习DDD的人都很熟悉了。DDD原著中提出了很多实用的建模工具：聚合、实体、值对象、工厂、仓储、领域服务、领域事件。我们可以使用这些工具，来设计每一个子域的领域模型。最终通过领域模型图将设计沉淀下来。要使用这些工具，首先就要理解每个工具的含义和使用场景。不要以为很简单哦，比如聚合的划分就是一个非常具有艺术的活。同一个系统，不同的人设计出来的聚合是完全不同的。而且很有可能高手之间的最后设计出来的差别反而更大，实际上我认为是世界观的相互碰撞，呵呵。所以，要领域建模，我觉得每个人都应该去学学哲学知识，这有助于我们更好的认识世界，更好的理解事物的本质。</p>
<p>关于这些建模工具的概念和如何运用我就不多展开了，我博客里也有很多这方面的介绍。下面我再讲一下我认为比较重要的东西，比如到底该如何领域建模？步骤应该是怎么样的？</p>
<h3 id="领域建模的方法"><a href="#领域建模的方法" class="headerlink" title="领域建模的方法"></a>领域建模的方法</h3><p>通过上面我介绍的细化子域的内容，现在再来谈该如何领域建模，我觉得就方便很多了。我的主要方法是：</p>
<p>划分好边界上下文，通常每个子域（sub domain）对应一个边界上下文（bounded context），同一个边界上下文中的概念是明确的，没有任何歧义；<br>在每个边界上下文中设计领域模型，具体的领域模型设计方法有很多种，如以场景为出发点的<a href="https://www.cnblogs.com/netfocus/archive/2011/03/05/1971899.html">四色原型</a>分析法，或者我早期写的这篇<a href="https://www.cnblogs.com/netfocus/archive/2011/09/18/2180656.html">文章</a>；这个步骤最核心的就是找出聚合根，并找出每个聚合根包含的信息；关于如何设计聚合，可以看一下我写的<a href="https://www.cnblogs.com/netfocus/p/3307971.html">这篇文章</a>；<br>画出领域模型图，圈出每个模型中的聚合边界；<br>设计领域模型时，要考虑该领域模型是否满足业务规则，同时还要综合考虑技术实现等问题，比如并发问题；领域模型不是概念模型，概念模型不关注技术实现，领域模型关心；所以领域模型才能直接指导编码实现；<br>思考领域模型是如何在业务场景中发挥作用的，以及是如何参与到业务流程的每个环节的；<br>场景走查，确认领域模型是否能满足领域中的业务场景和业务流程；<br>模型持续重构、完善、精炼；</p>
<h3 id="领域模型的核心作用："><a href="#领域模型的核心作用：" class="headerlink" title="领域模型的核心作用："></a>领域模型的核心作用：</h3><p>1.抽象了领域内的核心概念，并建立概念之间的关系；<br>2.领域模型承担了领域内的状态的维护；<br>3.领域模型维护了领域内的数据之间的业务规则，数据一致性；<br>下图是我最近做个一个普通电商系统的商品中心的领域模型图，给大家参考：<br><img src="https://img-blog.csdnimg.cn/20210427163137281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="领域模型设计只是软件设计中的一小部分"><a href="#领域模型设计只是软件设计中的一小部分" class="headerlink" title="领域模型设计只是软件设计中的一小部分"></a>领域模型设计只是软件设计中的一小部分</h3><p>需要特别注意的是，领域模型设计只是整个软件设计中的很小一部分。除了领域模型设计之外，要落地一个系统，我们还有非常多的其他设计要做，比如：</p>
<p>容量规划<br>架构设计<br>数据库设计<br>缓存设计<br>框架选型<br>发布方案<br>数据迁移、同步方案<br>分库分表方案<br>回滚方案<br>高并发解决方案<br>一致性选型<br>性能压测方案<br>监控报警方案<br>等等。上面这些都需要我们平时的大量学习和积累。作为一个合格的开发人员或架构师，我觉得除了要会DDD领域驱动设计，还要会上面这么多的技术能力，确实是非常不容易的。所以，千万不要以为会DDD了就以为自己很牛逼，实际上你会的只是软件设计中的冰山一角而已。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文的重点是基于我个人对DDD的一些理解，希望能整理出一些自己总结出来的一些感悟和经验，并分享给大家。我相信很多人已经看过太多DDD书上的东西，我总是感觉书上的东西看似都太”正规“，很多时候我们读了之后很难消化，就算理解了书里的内容，当我们想要运用到实践中时，总是感觉无从下手。本文希望通过通俗易懂的文字，介绍了一部分我对DDD的学习感悟和实践心得，希望能给大家一些启发和帮助。</p>
]]></content>
      <categories>
        <category>DDD领域驱动设计</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>ES知识点</title>
    <url>/2022/10/24/ES%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>Elasticsearch基础知识点总结</p>
<div class="pdf-container" data-target="./1-尚硅谷项目课程系列之Elasticsearch.pdf" data-height="1000px"></div>

]]></content>
      <categories>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>Gossip协议</title>
    <url>/2022/10/24/Gossip%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>我是一个小病毒，其他病毒都叫我小 B，我长得就是下图这个样子了。</p>
<p><img src="/2022/10/24/Gossip%E5%8D%8F%E8%AE%AE/1.png" alt="图片">冠状病毒</p>
<p>我现在已经有 100 nm 大小了，我还有很多触角，人类把我的触角称为<code>冠</code>，所以给我起了个学术名：<code>冠状病毒</code>。对于这个学术名，我一直不满意，怎么能用外貌来取名呢，这是<code>以貌取毒</code>。</p>
<p>我出生在一个蝙蝠身上，每到晚上，这只动物就到处觅食，它最喜欢的就是在森林中觅食，但最近森林的范围急剧减少，它不得不到人类居住的城市来觅食，看着五颜六色的灯光，我如痴如醉。</p>
<p><img src="/2022/10/24/Gossip%E5%8D%8F%E8%AE%AE/2.png" alt="图片">出生在一只蝙蝠身上</p>
<p>这只蝙蝠携带了 100 多种病毒，比如<code>埃博拉</code>病毒、<code>MERS</code> 病毒，我每天和这些病毒一起嬉戏游玩。<code>SARS 病毒</code>是我的近亲，2002 年的时候，它还造成了一次不小的传染病疫情，轰动了整个病毒界，人类称它为<code>非典</code>。</p>
<p><img src="/2022/10/24/Gossip%E5%8D%8F%E8%AE%AE/3.png" alt="图片">蝙蝠携带的病毒</p>
<h2 id="二、意外"><a href="#二、意外" class="headerlink" title="二、意外"></a>二、意外</h2><p>这天晚上，乌云密布，空气混浊，蝙蝠飞到了密林深处，突然浑身被一股电流击中，猝然倒地，一只大网将其捕获，随之而来的是穿着一袭黑色大衣的人类把蝙蝠关进了笼子里面。</p>
<p><img src="/2022/10/24/Gossip%E5%8D%8F%E8%AE%AE/4.png" alt="图片">被抓住了（图片来源于网络）</p>
<p>随后的几天，蝙蝠一直被关在笼子里面，直到有一天，蝙蝠被带到了一个随处可见野生动物的地方，但这些动物要么是被粗绳绑起来了，要么是被关在铁笼里。一个肥头大耳的人类走进了蝙蝠，他将手里攒着的一大叠<code>钞票</code>给了黑衣人后，带走了蝙蝠。</p>
<p>蝙蝠可能与肥头大耳的人类走得太近，我被传到了人类的的<code>手</code>上，随后又通过他接触的<code>食物</code>进入到了他的<code>口</code>中，进而进入到了他的体内。</p>
<h2 id="三、种子节点"><a href="#三、种子节点" class="headerlink" title="三、种子节点"></a>三、种子节点</h2><p>进入到人体中后，我欺骗了人类的<code>免疫系统</code>，顺利进入到人体细胞中，释放自己的 <code>RNA</code>，通过正常细胞的 <code>RNA 聚合酶</code>来复制自己的 RNA，从而<code>复制</code>出更多的病毒，进而<code>攻击</code>人体肺部器官。</p>
<p>过了几天后，这名人类出现了<code>发烧</code>现象，同时伴有<code>咳嗽</code>症状，而我的同伴也通过<code>喷嚏</code>传到了其他人体中，同样开始<code>大量复制</code>自己。</p>
<p><strong>一传十，十传百，这个地级市已有数千名人类被病毒感染</strong>。而我就被称作<code>种子节点</code>，而那名人类被称作<code>零号病人</code>。</p>
<h2 id="四、Gossip-协议"><a href="#四、Gossip-协议" class="headerlink" title="四、Gossip 协议"></a>四、Gossip 协议</h2><p>人体内的正常细胞对我的传染性非常感兴趣。</p>
<blockquote>
<p>“</p>
<p><strong>正常细胞</strong>：“冠状大哥，你是怎么这么快进行传播的啊？”</p>
<p><strong>我</strong>：“其实我是利用了 <code>Gossip</code> 协议。”</p>
<p><strong>我</strong>：Gossip 主要有三大功能，直接邮寄、反熵、谣言传播。</p>
<p>”</p>
</blockquote>
<p>Gossip 的中文意思就是<code>流言蜚语</code>，该协议就像流言蜚语一样，利用一种<code>随机</code>、带有<code>传染性</code>的方式，将信息传播到整个网络中，并在一定时间内，使得系统内的<code>所有节点数据一致</code>。这个就是实现了<code>最终一致性</code>的协议。</p>
<h3 id="4-1-直接邮寄"><a href="#4-1-直接邮寄" class="headerlink" title="4.1  直接邮寄"></a>4.1  直接邮寄</h3><p>直接发送需要更新的数据到其他节点，当数据<code>发送失败</code>时，将数据<code>缓存</code>下来，然后<code>重传</code>。如下图所示，人类 A 直接将病毒传染给了 C 和 E，而 B 和 D 没有被感染到，需要重新传染。</p>
<p><img src="/2022/10/24/Gossip%E5%8D%8F%E8%AE%AE/5.png" alt="图片">直接邮寄</p>
<p><strong>优点</strong>：实现容易，数据同步及时。</p>
<p><strong>缺点</strong>：可能会因为重试的缓存队列满了而丢数据。无法实现最终一致性。</p>
<p>那如何实现最终一致性呢？那就要用到第二种功能了：<code>反熵</code>。</p>
<h3 id="4-2-反熵"><a href="#4-2-反熵" class="headerlink" title="4.2 反熵"></a>4.2 反熵</h3><p><code>反熵</code>这个名词怎么理解呢？</p>
<p><code>熵</code>指混乱程度，<code>反熵</code>就是<code>消除</code>不同节点间数据的<code>差异</code>，<code>提升</code>节点间数据的<code>相似度</code>。</p>
<p>反熵的过程：</p>
<ul>
<li>（1）集群中的节点，每隔段时间就随机选择某个其他节点。</li>
<li>（2）互相交换自己的所有数据来消除两者之间的差异。</li>
<li>（3）实现数据的最终一致性。</li>
</ul>
<p>下面举个病毒传染的例子来说明反熵。</p>
<p>首先人类 A 被感染了两种病毒，分别是病毒 T 和病毒 R，如下图所示：</p>
<p><img src="/2022/10/24/Gossip%E5%8D%8F%E8%AE%AE/6.png" alt="图片">人类 A 感染了两种病毒</p>
<p>人类  E 被感染了三种病毒，分别是病毒 T、病毒 S、病毒 Y，如下图所示：</p>
<p><img src="/2022/10/24/Gossip%E5%8D%8F%E8%AE%AE/7.png" alt="图片">人类 E 被感染了四种病毒</p>
<p>人类 A 将携带的病毒 T 和 R 传染给了人类 E，而 E 本来就携带了病毒 T，所以最后会被传染四种病毒：T、S、Y、R。也就是说通过反熵的方式，修复了人类 E 中缺失的病毒 R。如下图所示：</p>
<p><img src="/2022/10/24/Gossip%E5%8D%8F%E8%AE%AE/8.png" alt="图片">人类 E 被感染了四种病毒</p>
<p>其实，反熵主要有三种方式：<code>推、拉、推和拉</code>。</p>
<h4 id="4-2-1-推"><a href="#4-2-1-推" class="headerlink" title="4.2.1 推"></a>4.2.1 推</h4><p><strong>推</strong>：将自己的副本数据推给对象，修复对方副本中的熵。</p>
<p>如下图所示，人类 A 将病毒 R 传染（<code>推</code>）给了人类 E，E 中就包含所有 A 的病毒了。</p>
<p><img src="/2022/10/24/Gossip%E5%8D%8F%E8%AE%AE/9.png" alt="图片">推</p>
<h4 id="4-2-2-拉"><a href="#4-2-2-拉" class="headerlink" title="4.2.2 拉"></a>4.2.2 拉</h4><p><strong>拉</strong>：拉取对方中的所有副本数据，修复自己副本中的熵。</p>
<p>如下图所示：人类 A 只有病毒 T 和 R，经过主动<code>拉</code>方式后，将人类 E 的病毒 S 和 病毒 Y 同步到人类 A 身上了，最后，人类 A 携带四种病毒：T、R、S、Y。</p>
<p><img src="/2022/10/24/Gossip%E5%8D%8F%E8%AE%AE/10.png" alt="图片">拉方式</p>
<h4 id="4-2-3-推拉"><a href="#4-2-3-推拉" class="headerlink" title="4.2.3 推拉"></a>4.2.3 推拉</h4><p><strong>推拉</strong>：同时修复自己副本和对象副本中的熵。</p>
<p>如下图所示：人类 A 和 人类 E 通过推拉的方式最后都被感染了相同的四种病毒：T、R、S、Y。</p>
<p><img src="/2022/10/24/Gossip%E5%8D%8F%E8%AE%AE/11.png" alt="图片">推拉</p>
<h4 id="4-2-4-反熵的缺点"><a href="#4-2-4-反熵的缺点" class="headerlink" title="4.2.4 反熵的缺点"></a>4.2.4 反熵的缺点</h4><p>（1）通过上面推、拉、推拉的方式，我们可以主要到，反熵是需要节点两两交换和比对自己所有的数据，这样来看的话，通讯成本是很高的，所以不建议实际场景中频繁地执行反熵。</p>
<p><strong>那有没有办法来减少反熵的次数呢？</strong></p>
<p>答案是有的，我们可以通过引入校验和等机制来降低需要对比的数据量和通讯信息。</p>
<p>（2）执行反熵时，相关节点都是已知的，且节点数量不能太多。如果节点动态变化或节点数过多，反熵就不合适。</p>
<p><strong>那有没有办法来解决动态、多节点的最终一致性呢？</strong></p>
<p>答案是有的，那就要用到 Gossip 协议的第三种传播功能了，谣言传播或者叫流行病传播。</p>
<h3 id="4-3-流行病传播"><a href="#4-3-流行病传播" class="headerlink" title="4.3 流行病传播"></a>4.3 流行病传播</h3><h4 id="4-3-1-过程"><a href="#4-3-1-过程" class="headerlink" title="4.3.1 过程"></a>4.3.1 过程</h4><p>Gossip 协议的第三种传播功能，流行病传播，也就是广泛地散播病毒。</p>
<p>如下图所示：A 传染给了 B 和 E，B 传染给了 C 和 D，D 传染给了 F 和 G。最后 ABCDEFG 都被感染了。</p>
<p><img src="/2022/10/24/Gossip%E5%8D%8F%E8%AE%AE/12.png" alt="图片">流行病传播过程</p>
<p>在分布式系统中，当一个节点有了新数据后，这个节点变成活跃状态，并周期性地联系其他节点向其发送新数据，直到所有节点都存储了该数据，可以理解为之前讲的反熵中的<code>推</code>的方式。如下图所示：</p>
<p><img src="/2022/10/24/Gossip%E5%8D%8F%E8%AE%AE/13.png" alt="图片">流行病传播方式&amp;图片来源于网络</p>
<h4 id="4-3-2-缺点"><a href="#4-3-2-缺点" class="headerlink" title="4.3.2 缺点"></a>4.3.2 缺点</h4><p>流行病传播的方式有如下缺点：</p>
<ul>
<li><strong>时间随机</strong>：所有节点达到一致性是一个随机性的概率。可以改进反熵的流程：使用闭环修复。</li>
<li><strong>消息冗余</strong>：同一节点会多次接收同一消息，增加消息处理的压力，每一次通信都会对网络带宽、CPU 资源造成负载，进而影响达到最终一致性的时间。</li>
<li><strong>拜占庭问题</strong>：如果有恶意节点出现，那么其他节点也会出问题。所以需要先修复故障节点。</li>
</ul>
<h4 id="4-3-3-优点"><a href="#4-3-3-优点" class="headerlink" title="4.3.3 优点"></a>4.3.3 优点</h4><ul>
<li><strong>支持动态、多节点</strong>：允许动态增加或减少节点，支持非常多的节点。</li>
<li><strong>大多数节点</strong>：不需要大多数节点正常运行也能达到最终一致性</li>
<li><strong>容错</strong>：任何节点重启或宕机都不会影响 Gossip 协议的运行，天然的分布式系统容错特性。</li>
<li><strong>去中心化</strong>：节点都是对等的，没有特殊节点。任何节点出现问题都不会阻止其他节点继续执行反熵。</li>
<li><strong>速度快</strong>：因为每个节点都可以进行传播，所以速度是指数级的，就像现在的新冠病毒一样。</li>
</ul>
<p>因为 Gossip 协议是一个带冗余的容错算法，为了保证最终一致性的算法。虽然所有节点达到一致的时间点不明确，但也可以通过改进反熵的执行过程来达到可预测，比如闭环反熵（不在本文展开论述）。</p>
<h3 id><a href="#" class="headerlink" title></a></h3><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本文通过一个携带冠状病毒的蝙蝠传染人类的故事来讲解了 Gossip 协议。</p>
<ul>
<li>Gossip 协议是一种<code>异步修复</code>、实现<code>最终一致性</code>的协议。优先考虑反熵。</li>
<li>反熵在<code>存储组件</code>中用得比较多。比如 Cassandra、InfluxDB。</li>
<li>谣言传播（流行病传播）具有传染性，节点之间<code>相互传染</code>。适合<code>动态变化</code>的<code>分布式系统</code>。比如 Cassandra 动态管理集群的节点状态。</li>
<li>实际场景，<code>直接邮寄</code>一定要实现，性能损耗最低。通过发送更新数据或缓存重传就能修复数据的不一致。</li>
<li>在存储组件中，节点已知，采用<code>反熵</code>修复数据副本的不一致。</li>
<li>集群节点变化时，或节点较多时，采用<code>谣言传播</code>方式，来同步更新多节点的数据，来实现最终一致性。</li>
<li>Gossip 的三种功能其实都是为了实现反熵，第一种用消息队列，第二种用推拉消息，第三种用散播谣言。</li>
<li>如果节点出现<code>故障</code>，需要先修复故障节点。</li>
</ul>
]]></content>
      <categories>
        <category>分布式一致性协议</category>
      </categories>
      <tags>
        <tag>分布式一致性协议</tag>
        <tag>Gossip协议</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK/Dubbo/Spring 三种 SPI 机制，谁更好？</title>
    <url>/2022/10/21/JDKDubboSpring%20%E4%B8%89%E7%A7%8D%20SPI%20%E6%9C%BA%E5%88%B6%EF%BC%8C%E8%B0%81%E6%9B%B4%E5%A5%BD/</url>
    <content><![CDATA[<h1 id="JDK-x2F-Dubbo-x2F-Spring-三种-SPI-机制，谁更好？"><a href="#JDK-x2F-Dubbo-x2F-Spring-三种-SPI-机制，谁更好？" class="headerlink" title="JDK&#x2F;Dubbo&#x2F;Spring 三种 SPI 机制，谁更好？"></a>JDK&#x2F;Dubbo&#x2F;Spring 三种 SPI 机制，谁更好？</h1><blockquote>
<p>SPI 全称为 Service Provider Interface，是一种服务发现机制。SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。正因此特性，我们可以很容易的通过 SPI 机制为我们的程序提供拓展功能。</p>
</blockquote>
<p>本文主要是特性 &amp; 用法介绍，不涉及源码解析（源码都很简单，相信你一定一看就懂）</p>
<h2 id="SPI-有什么用？"><a href="#SPI-有什么用？" class="headerlink" title="SPI 有什么用？"></a>SPI 有什么用？</h2><p>举个栗子，现在我们设计了一款全新的日志框架：<strong>super-logger</strong>。默认以XML文件作为我们这款日志的配置文件，并设计了一个配置文件解析的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.kongwu.spisamples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SuperLoggerConfiguration</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(String configFile)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后来一个默认的XML实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.kongwu.spisamples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XMLConfiguration</span> <span class="keyword">implements</span> <span class="title class_">SuperLoggerConfiguration</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(String configFile)</span>&#123;</span><br><span class="line">    	......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么我们在初始化，解析配置时，只需要调用这个XMLConfiguration来解析XML配置文件即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.kongwu.spisamples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">SuperLoggerConfiguration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLConfiguration</span>();</span><br><span class="line">		configuration.configure(configFile);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">getLogger</span><span class="params">(Class clazz)</span>&#123;</span><br><span class="line">    	......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样就完成了一个基础的模型，看起来也没什么问题。不过扩展性不太好，因为如果想定制&#x2F;扩展&#x2F;重写解析功能的话，我还得重新定义入口的代码，LoggerFactory 也得重写，不够灵活，侵入性太强了。</p>
<p>比如现在用户&#x2F;使用方想增加一个 yml 文件的方式，作为日志配置文件，那么只需要新建一个YAMLConfiguration，实现 SuperLoggerConfiguration 就可以。但是……怎么注入呢，怎么让 LoggerFactory中使用新建的这个 YAMLConfiguration ？难不成连 LoggerFactory 也重写了？</p>
<p>如果借助SPI机制的话，这个事情就很简单了，可以很方便的完成这个入口的扩展功能。</p>
<p>下面就先来看看，利用JDK 的 SPI 机制怎么解决上面的扩展性问题。</p>
<h2 id="JDK-SPI"><a href="#JDK-SPI" class="headerlink" title="JDK SPI"></a>JDK SPI</h2><p>JDK 中 提供了一个 SPI 的功能，核心类是 java.util.ServiceLoader。其作用就是，可以通过类名获取在”META-INF&#x2F;services&#x2F;“下的多个配置实现文件。</p>
<p>为了解决上面的扩展问题，现在我们在<code>META-INF/services/</code>下创建一个<code>com.github.kongwu.spisamples.SuperLoggerConfiguration</code>文件（没有后缀）。文件中只有一行代码，那就是我们默认的<code>com.github.kongwu.spisamples.XMLConfiguration</code>（注意，一个文件里也可以写多个实现，回车分隔）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">META-INF/services/com.github.kongwu.spisamples.SuperLoggerConfiguration:</span><br><span class="line"></span><br><span class="line">com.github.kongwu.spisamples.XMLConfiguration</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后通过 ServiceLoader 获取我们的 SPI 机制配置的实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServiceLoader&lt;SuperLoggerConfiguration&gt; serviceLoader = ServiceLoader.load(SuperLoggerConfiguration.class);</span><br><span class="line">Iterator&lt;SuperLoggerConfiguration&gt; iterator = serviceLoader.iterator();</span><br><span class="line">SuperLoggerConfiguration configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">    <span class="comment">//加载并初始化实现类</span></span><br><span class="line">	configuration = iterator.next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对最后一个configuration类调用configure方法</span></span><br><span class="line">configuration.configure(configFile);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后在调整LoggerFactory中初始化配置的方式为现在的SPI方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.kongwu.spisamples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">        ServiceLoader&lt;SuperLoggerConfiguration&gt; serviceLoader = ServiceLoader.load(SuperLoggerConfiguration.class);</span><br><span class="line">        Iterator&lt;SuperLoggerConfiguration&gt; iterator = serviceLoader.iterator();</span><br><span class="line">        SuperLoggerConfiguration configuration;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">            configuration = iterator.next();<span class="comment">//加载并初始化实现类</span></span><br><span class="line">        &#125;</span><br><span class="line">        configuration.configure(configFile);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">getLogger</span><span class="params">(Class clazz)</span>&#123;</span><br><span class="line">    	......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>等等，这里为什么是用 iterator ? 而不是get之类的只获取一个实例的方法？</strong></p>
<p>试想一下，如果是一个固定的get方法，那么get到的是一个固定的实例，SPI 还有什么意义呢？</p>
<p>SPI 的目的，就是增强扩展性。将固定的配置提取出来，通过 SPI 机制来配置。那既然如此，一般都会有一个默认的配置，然后通过 SPI 的文件配置不同的实现，这样就会存在一个接口多个实现的问题。要是找到多个实现的话，用哪个实现作为最后的实例呢？</p>
<p>所以这里使用iterator来获取所有的实现类配置。刚才已经在我们这个 <strong>super-logger</strong> 包里增加了默认的SuperLoggerConfiguration 实现。</p>
<p>为了支持 YAML 配置，现在在使用方&#x2F;用户的代码里，增加一个YAMLConfiguration的 SPI 配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">META-INF/services/com.github.kongwu.spisamples.SuperLoggerConfiguration:</span><br><span class="line"></span><br><span class="line">com.github.kongwu.spisamples.ext.YAMLConfiguration</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>此时通过iterator方法，就会获取到默认的XMLConfiguration和我们扩展的这个YAMLConfiguration两个配置实现类了。</p>
<p>在上面那段加载的代码里，我们遍历iterator，遍历到最后，我们使用最后一个实现配置作为最终的实例。</p>
<p><strong>再等等？最后一个？怎么算最后一个？</strong></p>
<p>使用方&#x2F;用户自定义的的这个 YAMLConfiguration 一定是最后一个吗？</p>
<p>这个真的不一定，取决于我们运行时的 ClassPath 配置，在前面加载的jar自然在前，最后的jar里的自然当然也在后面。所以<strong>如果用户的包在ClassPath中的顺序比super-logger的包更靠后，才会处于最后一个位置；如果用户的包位置在前，那么所谓的最后一个仍然是默认的XMLConfiguration。</strong></p>
<p>举个栗子，如果我们程序的启动脚本为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -<span class="built_in">cp</span> super-logger.jar:a.jar:b.jar:main.jar example.Main</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>默认的XMLConfiguration SPI配置在<code>super-logger.jar</code>，扩展的YAMLConfiguration SPI配置文件在<code>main.jar</code>，那么iterator获取的最后一个元素一定为YAMLConfiguration。</p>
<p>但这个classpath顺序如果反了呢？main.jar 在前，super-logger.jar 在后</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -<span class="built_in">cp</span> main.jar:super-logger.jar:a.jar:b.jar example.Main</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>这样一来，iterator 获取的最后一个元素又变成了默认的XMLConfiguration，我们使用 JDK SPI 没啥意义了，获取的又是第一个，还是默认的XMLConfiguration。</p>
<p>由于这个加载顺序（classpath）是由用户指定的，所以无论我们加载第一个还是最后一个，都有可能会导致加载不到用户自定义的那个配置。</p>
<p><strong>所以这也是JDK SPI机制的一个劣势，无法确认具体加载哪一个实现，也无法加载某个指定的实现，仅靠ClassPath的顺序是一个非常不严谨的方式</strong></p>
<h2 id="Dubbo-SPI"><a href="#Dubbo-SPI" class="headerlink" title="Dubbo SPI"></a>Dubbo SPI</h2><blockquote>
<p>Dubbo 就是通过 SPI 机制加载所有的组件。不过，Dubbo 并未使用 Java 原生的 SPI 机制，而是对其进行了增强，使其能够更好的满足需求。在 Dubbo 中，SPI 是一个非常重要的模块。基于 SPI，我们可以很容易的对 Dubbo 进行拓展。如果大家想要学习 Dubbo 的源码，SPI 机制务必弄懂。接下来，我们先来了解一下 Java SPI 与 Dubbo SPI 的用法，然后再来分析 Dubbo SPI 的源码。</p>
</blockquote>
<p>Dubbo 中实现了一套新的 SPI 机制，功能更强大，也更复杂一些。相关逻辑被封装在了 ExtensionLoader 类中，通过 ExtensionLoader，我们可以加载指定的实现类。Dubbo SPI 所需的配置文件需放置在 META-INF&#x2F;dubbo 路径下，配置内容如下（以下demo来自dubbo官方文档）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">optimusPrime = org.apache.spi.OptimusPrime</span><br><span class="line">bumblebee = org.apache.spi.Bumblebee</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>与 Java SPI 实现类配置不同，Dubbo SPI 是通过键值对的方式进行配置，这样我们可以按需加载指定的实现类。另外在使用时还需要在接口上标注 @SPI 注解。下面来演示 Dubbo SPI 的用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Robot</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptimusPrime</span> <span class="keyword">implements</span> <span class="title class_">Robot</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I am Optimus Prime.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bumblebee</span> <span class="keyword">implements</span> <span class="title class_">Robot</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I am Bumblebee.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DubboSPITest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ExtensionLoader&lt;Robot&gt; extensionLoader = </span><br><span class="line">            ExtensionLoader.getExtensionLoader(Robot.class);</span><br><span class="line">        <span class="type">Robot</span> <span class="variable">optimusPrime</span> <span class="operator">=</span> extensionLoader.getExtension(<span class="string">&quot;optimusPrime&quot;</span>);</span><br><span class="line">        optimusPrime.sayHello();</span><br><span class="line">        <span class="type">Robot</span> <span class="variable">bumblebee</span> <span class="operator">=</span> extensionLoader.getExtension(<span class="string">&quot;bumblebee&quot;</span>);</span><br><span class="line">        bumblebee.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p><strong>Dubbo SPI 和 JDK SPI 最大的区别就在于支持“别名”</strong>，可以通过某个扩展点的别名来获取固定的扩展点。就像上面的例子中，我可以获取 Robot 多个 SPI 实现中别名为“optimusPrime”的实现，也可以获取别名为“bumblebee”的实现，这个功能非常有用！</p>
<p>通过 @SPI 注解的 value 属性，还可以默认一个“别名”的实现。比如在Dubbo 中，默认的是Dubbo 私有协议：<strong>dubbo protocol - dubbo:&#x2F;&#x2F;</strong> ** 来看看Dubbo中协议的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;dubbo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Protocol</span> &#123;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>在 Protocol 接口上，增加了一个 @SPI 注解，而注解的 value 值为 Dubbo ，通过 SPI 获取实现时就会获取 Protocol SPI 配置中别名为dubbo的那个实现，<code>com.alibaba.dubbo.rpc.Protocol</code>文件如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">filter=com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper</span><br><span class="line">listener=com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper</span><br><span class="line">mock=com.alibaba.dubbo.rpc.support.MockProtocol</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">injvm=com.alibaba.dubbo.rpc.protocol.injvm.InjvmProtocol</span><br><span class="line">rmi=com.alibaba.dubbo.rpc.protocol.rmi.RmiProtocol</span><br><span class="line">hessian=com.alibaba.dubbo.rpc.protocol.hessian.HessianProtocol</span><br><span class="line">com.alibaba.dubbo.rpc.protocol.http.HttpProtocol</span><br><span class="line">com.alibaba.dubbo.rpc.protocol.webservice.WebServiceProtocol</span><br><span class="line">thrift=com.alibaba.dubbo.rpc.protocol.thrift.ThriftProtocol</span><br><span class="line">memcached=com.alibaba.dubbo.rpc.protocol.memcached.MemcachedProtocol</span><br><span class="line">redis=com.alibaba.dubbo.rpc.protocol.redis.RedisProtocol</span><br><span class="line">rest=com.alibaba.dubbo.rpc.protocol.rest.RestProtocol</span><br><span class="line">registry=com.alibaba.dubbo.registry.integration.RegistryProtocol</span><br><span class="line">qos=com.alibaba.dubbo.qos.protocol.QosProtocolWrapper</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>然后只需要通过getDefaultExtension，就可以获取到 @SPI 注解上value对应的那个扩展实现了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Protocol</span> <span class="variable">protocol</span> <span class="operator">=</span> ExtensionLoader.getExtensionLoader(Protocol.class).getDefaultExtension();</span><br><span class="line"><span class="comment">//protocol: DubboProtocol</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>还有一个 Adaptive 的机制，虽然非常灵活，但……用法并不是很“优雅”，这里就不介绍了</p>
<p>Dubbo 的 SPI 中还有一个“加载优先级”，优先加载内置（internal）的，然后加载外部的（external），按优先级顺序加载，<strong>如果遇到重复就跳过不会加载</strong>了。</p>
<p>所以如果想靠classpath加载顺序去覆盖内置的扩展，也是个不太理智的做法，原因同上 - 加载顺序不严谨</p>
<h2 id="Spring-SPI"><a href="#Spring-SPI" class="headerlink" title="Spring SPI"></a>Spring SPI</h2><p>Spring 的 SPI 配置文件是一个固定的文件 - <code>META-INF/spring.factories</code>，功能上和 JDK 的类似，每个接口可以有多个扩展实现，使用起来非常简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取所有factories文件中配置的LoggingSystemFactory</span></span><br><span class="line">List&lt;LoggingSystemFactory&gt;&gt; factories = </span><br><span class="line">    SpringFactoriesLoader.loadFactories(LoggingSystemFactory.class, classLoader);</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>下面是一段 Spring Boot 中 spring.factories 的配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Logging Systems</span><br><span class="line">org.springframework.boot.logging.LoggingSystemFactory=\</span><br><span class="line">org.springframework.boot.logging.logback.LogbackLoggingSystem.Factory,\</span><br><span class="line">org.springframework.boot.logging.log4j2.Log4J2LoggingSystem.Factory,\</span><br><span class="line">org.springframework.boot.logging.java.JavaLoggingSystem.Factory</span><br><span class="line"></span><br><span class="line"># PropertySource Loaders</span><br><span class="line">org.springframework.boot.env.PropertySourceLoader=\</span><br><span class="line">org.springframework.boot.env.PropertiesPropertySourceLoader,\</span><br><span class="line">org.springframework.boot.env.YamlPropertySourceLoader</span><br><span class="line"></span><br><span class="line"># ConfigData Location Resolvers</span><br><span class="line">org.springframework.boot.context.config.ConfigDataLocationResolver=\</span><br><span class="line">org.springframework.boot.context.config.ConfigTreeConfigDataLocationResolver,\</span><br><span class="line">org.springframework.boot.context.config.StandardConfigDataLocationResolver</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>Spring SPI 中，将所有的配置放到一个固定的文件中，省去了配置一大堆文件的麻烦。至于多个接口的扩展配置，是用一个文件好，还是每个单独一个文件好这个，这个问题就见仁见智了（个人喜欢 Spring 这种，干净利落）。</p>
<p>Spring的SPI 虽然属于spring-framework(core)，但是目前主要用在spring boot中……</p>
<p>和前面两种 SPI 机制一样，Spring 也是支持 ClassPath 中存在多个 spring.factories 文件的，加载时会按照 classpath 的顺序依次加载这些 spring.factories 文件，添加到一个 ArrayList 中。由于没有别名，所以也没有去重的概念，有多少就添加多少。</p>
<p>但由于 Spring 的 SPI 主要用在 Spring Boot 中，而 Spring Boot 中的 ClassLoader 会优先加载项目中的文件，而不是依赖包中的文件。所以如果在你的项目中定义个spring.factories文件，那么你项目中的文件会被第一个加载，得到的Factories中，项目中spring.factories里配置的那个实现类也会排在第一个</p>
<p>如果我们要扩展某个接口的话，只需要在你的项目（spring boot）里新建一个<code>META-INF/spring.factories</code>文件，<strong>只添加你要的那个配置，不要完整的复制一遍 Spring Boot 的 spring.factories 文件然后修改</strong> 比如我只想添加一个新的 LoggingSystemFactory 实现，那么我只需要新建一个<code>META-INF/spring.factories</code>文件，而不是完整的复制+修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.logging.LoggingSystemFactory=\</span><br><span class="line">com.example.log4j2demo.Log4J2LoggingSystem.Factory</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><table>
<thead>
<tr>
<th></th>
<th>JDK SPI</th>
<th>DUBBO SPI</th>
<th>Spring SPI</th>
</tr>
</thead>
<tbody><tr>
<td>文件方式</td>
<td>每个扩展点单独一个文件</td>
<td>每个扩展点单独一个文件</td>
<td>所有的扩展点在一个文件</td>
</tr>
<tr>
<td>获取某个固定的实现</td>
<td>不支持，只能按顺序获取所有实现</td>
<td>有“别名”的概念，可以通过名称获取扩展点的某个固定实现，配合Dubbo SPI的注解很方便</td>
<td>不支持，只能按顺序获取所有实现。但由于Spring Boot ClassLoader会优先加载用户代码中的文件，所以可以保证用户自定义的spring.factoires文件在第一个，通过获取第一个factory的方式就可以固定获取自定义的扩展</td>
</tr>
<tr>
<td>其他</td>
<td>无</td>
<td>支持Dubbo内部的依赖注入，通过目录来区分Dubbo 内置SPI和外部SPI，优先加载内部，保证内部的优先级最高</td>
<td>无</td>
</tr>
<tr>
<td>文档完整度</td>
<td>文章 &amp; 三方资料足够丰富</td>
<td>文档 &amp; 三方资料足够丰富</td>
<td>文档不够丰富，但由于功能少，使用非常简单</td>
</tr>
<tr>
<td>IDE支持</td>
<td>无</td>
<td>无</td>
<td>IDEA 完美支持，有语法提示</td>
</tr>
</tbody></table>
<p>三种 SPI 机制对比之下，JDK 内置的机制是最弱鸡的，但是由于是 JDK 内置，所以还是有一定应用场景，毕竟不用额外的依赖；Dubbo 的功能最丰富，但机制有点复杂了，而且只能配合 Dubbo 使用，不能完全算是一个独立的模块；Spring 的功能和JDK的相差无几，最大的区别是所有扩展点写在一个 spring.factories 文件中，也算是一个改进，并且 IDEA 完美支持语法提示。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>日常生活</tag>
        <tag>杂文</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM内部锁升级过程</title>
    <url>/2022/10/24/JVM%E5%86%85%E9%83%A8%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="谈谈JVM内部锁升级过程"><a href="#谈谈JVM内部锁升级过程" class="headerlink" title="谈谈JVM内部锁升级过程"></a>谈谈JVM内部锁升级过程</h2><p><strong>一 为什么讲这个？</strong></p>
<p>总结AQS之后，对这方面顺带的复习一下。本文从以下几个高频问题出发：</p>
<ul>
<li>对象在内存中的内存布局是什么样的？</li>
<li>描述synchronized和ReentrantLock的底层实现和重入的底层原理。</li>
<li>谈谈AQS，为什么AQS底层是CAS+volatile？</li>
<li>描述下锁的四种状态和锁升级过程？</li>
<li>Object  o &#x3D; new Object() 在内存中占用多少字节？</li>
<li>自旋锁是不是一定比重量级锁效率高？</li>
<li>打开偏向锁是否效率一定会提升？</li>
<li>重量级锁到底重在哪里？</li>
<li>重量级锁什么时候比轻量级锁效率高，同样反之呢？</li>
</ul>
<p><strong>二 加锁发生了什么？</strong></p>
<p>无意识中用到锁的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//System.out.println都加了锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(String x)</span> &#123;  </span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;    </span><br><span class="line">	print(x);    </span><br><span class="line">	newLine();  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>简单加锁发生了什么？</p>
<p>要弄清楚加锁之后到底发生了什么需要看一下对象创建之后再内存中的布局是个什么样的？</p>
<p>一个对象在new出来之后在内存中主要分为4个部分：</p>
<ul>
<li><p>markword这部分其实就是加锁的核心，同时还包含的对象的一些生命信息，例如是否GC、经过了几次Young GC还存活。</p>
</li>
<li><p>klass pointer记录了指向对象的class文件指针。</p>
</li>
<li><p>instance data记录了对象里面的变量数据。</p>
</li>
<li><p>padding作为对齐使用，对象在64位服务器版本中，规定对象内存必须要能被8字节整除，如果不能整除，那么就靠对齐来补。举个例子：new出了一个对象，内存只占用18字节，但是规定要能被8整除，所以padding&#x3D;6。</p>
</li>
</ul>
<p><img src="/2022/10/24/JVM%E5%86%85%E9%83%A8%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B/1.png" alt="图片"></p>
<p>知道了这4个部分之后，我们来验证一下底层。借助于第三方包 JOL  &#x3D; Java Object Layout java内存布局去看看。很简单的几行代码就可以看到内存布局的样式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JOLDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object  o;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>将结果打印出来：</p>
<p><img src="/2022/10/24/JVM%E5%86%85%E9%83%A8%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B/2.png" alt="图片"></p>
<p>从输出结果看：</p>
<p>1）对象头包含了12个字节分为3行，其中前2行其实就是markword，第三行就是klass指针。值得注意的是在加锁前后输出从001变成了000。Markword用处：8字节(64bit)的头记录一些信息，锁就是修改了markword的内容8字节(64bit)的头记录一些信息，锁就是修改了markword的内容字节(64bit)的头记录一些信息。从001无锁状态，变成了00轻量级锁状态。</p>
<p><img src="/2022/10/24/JVM%E5%86%85%E9%83%A8%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B/3.png" alt="图片"></p>
<p>2）New出一个object对象，占用16个字节。对象头占用12字节，由于Object中没有额外的变量，所以instance &#x3D; 0，考虑要对象内存大小要被8字节整除，那么padding&#x3D;4，最后new Object() 内存大小为16字节。</p>
<p>拓展：什么样的对象会进入老年代？很多场景例如对象太大了可以直接进入，但是这里想探讨的是为什么从Young GC的对象最多经历15次Young GC还存活就会进入Old区（年龄是可以调的，默认是15）。上图中hotspots的markword的图中，用了4个bit去表示分代年龄，那么能表示的最大范围就是0-15。所以这也就是为什么设置新生代的年龄不能超过15，工作中可以通过-XX:MaxTenuringThreshold去调整，但是一般我们不会动。</p>
<p><img src="/2022/10/24/JVM%E5%86%85%E9%83%A8%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B/4.png" alt="图片"></p>
<p><strong>三 锁的升级过程</strong></p>
<p>1 锁的升级验证</p>
<p>探讨锁的升级之前，先做个实验。两份代码，不同之处在于一个中途让它睡了5秒，一个没睡。看看是否有区别。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JOLDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object  o;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JOLDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object  o;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">5000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这两份代码会不会有什么区别？运行之后看看结果：</p>
<p><img src="/2022/10/24/JVM%E5%86%85%E9%83%A8%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B/5.png" alt="图片"></p>
<p><img src="/2022/10/24/JVM%E5%86%85%E9%83%A8%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B/6.png" alt="图片"></p>
<p>有点意思的是，让主线程睡了5s之后输出的内存布局跟没睡的输出结果居然不一样。</p>
<p>Syn锁升级之后，jdk1.8版本的一个底层默认设置4s之后偏向锁开启。也就是说在4s内是没有开启偏向锁的，加了锁就直接升级为轻量级锁了。</p>
<p>那么这里就有几个问题了？</p>
<ul>
<li><p>为什么要进行锁升级，以前不是默认syn就是重量级锁么？要么不用要么就用别的不行么？</p>
</li>
<li><p>既然4s内如果加了锁就直接到轻量级，那么能不能不要偏向锁，为什么要有偏向锁？</p>
</li>
<li><p>为什么要设置4s之后开始偏向锁？</p>
</li>
</ul>
<p><strong>问题1：为什么要进行锁升级？锁了就锁了，不就要加锁么？</strong></p>
<p>首先明确早起jdk1.2效率非常低。那时候syn就是重量级锁，申请锁必须要经过操作系统老大kernel进行系统调用，入队进行排序操作，操作完之后再返回给用户态。</p>
<p>内核态：用户态如果要做一些比较危险的操作直接访问硬件，很容易把硬件搞死（格式化，访问网卡，访问内存干掉、）操作系统为了系统安全分成两层，用户态和内核态 。申请锁资源的时候用户态要向操作系统老大内核态申请。Jdk1.2的时候用户需要跟内核态申请锁，然后内核态还会给用户态。这个过程是非常消耗时间的，导致早期效率特别低。有些jvm就可以处理的为什么还交给操作系统做去呢？能不能把jvm就可以完成的锁操作拉取出来提升效率，所以也就有了锁优化。</p>
<p><strong>问题2：为什么要有偏向锁？</strong></p>
<p>其实这本质上归根于一个概率问题，统计表示，在我们日常用的syn锁过程中70%-80%的情况下，一般都只有一个线程去拿锁，例如我们常使用的System.out.println、StringBuffer，虽然底层加了syn锁，但是基本没有多线程竞争的情况。那么这种情况下，没有必要升级到轻量级锁级别了。偏向的意义在于：第一个线程拿到锁，将自己的线程信息标记在锁上，下次进来就不需要在拿去拿锁验证了。如果超过1个线程去抢锁，那么偏向锁就会撤销，升级为轻量级锁，其实我认为严格意义上来讲偏向锁并不算一把真正的锁，因为只有一个线程去访问共享资源的时候才会有偏向锁这个情况。</p>
<p>无意使用到锁的场景：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***StringBuffer内部同步***/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println 无意识的使用锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(String x)</span> &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">     print(x);</span><br><span class="line">     newLine();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p><strong>问题3：为什么jdk8要在4s后开启偏向锁？</strong></p>
<p>其实这是一个妥协，明确知道在刚开始执行代码时，一定有好多线程来抢锁，如果开了偏向锁效率反而降低，所以上面程序在睡了5s之后偏向锁才开放。为什么加偏向锁效率会降低，因为中途多了几个额外的过程，上了偏向锁之后多个线程争抢共享资源的时候要进行锁升级到轻量级锁，这个过程还的把偏向锁进行撤销在进行升级，所以导致效率会降低。为什么是4s？这是一个统计的时间值。</p>
<p>当然我们是可以禁止偏向锁的，通过配置参数-XX:-UseBiasedLocking &#x3D; false来禁用偏向锁。jdk15之后默认已经禁用了偏向锁。本文是在jdk8的环境下做的锁升级验证。</p>
<p>2 锁的升级流程</p>
<p>上面已经验证了对象从创建出来之后进内存从无锁状态-&gt;偏向锁（如果开启了）-&gt;轻量级锁的过程。对于锁升级的流程继续往下，轻量级锁之后就会变成重量级锁。首先我们先理解什么叫做轻量级锁，从一个线程抢占资源（偏向锁）到多线程抢占资源升级为轻量级锁，线程如果没那么多的话，其实这里就可以理解为CAS，也就是我们说的Compare and Swap，比较并交换值。在并发编程中最简单的一个例子就是并发包下面的原子操作类AtomicInteger。在进行类似++操作的时候，底层其实就是CAS锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">   <span class="type">int</span> var5;</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">       var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">   &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>问题4：什么情况下轻量级锁要升级为重量级锁呢？</strong></p>
<p>首先我们可以思考的是多个线程的时候先开启轻量级锁，如果它carry不了的情况下才会升级为重量级。那么什么情况下轻量级锁会carry不住。1、如果线程数太多，比如上来就是10000个，那么这里CAS要转多久才可能交换值，同时CPU光在这10000个活着的线程中来回切换中就耗费了巨大的资源，这种情况下自然就升级为重量级锁，直接叫给操作系统入队管理，那么就算10000个线程那也是处理休眠的情况等待排队唤醒。2、CAS如果自旋10次依然没有获取到锁，那么也会升级为重量级。</p>
<p>总的来说2种情况会从轻量级升级为重量级，10次自旋或等待cpu调度的线程数超过cpu核数的一半，自动升级为重量级锁。看服务器CPU的核数怎么看，输入top指令，然后按1就可以看到。</p>
<p><strong>问题5：都说syn为重量级锁，那么到底重在哪里？</strong></p>
<p>JVM偷懒把任何跟线程有关的操作全部交给操作系统去做，例如调度锁的同步直接交给操作系统去执行，而在操作系统中要执行先要入队，另外操作系统启动一个线程时需要消耗很多资源，消耗资源比较重，重就重在这里。</p>
<p>整个锁升级过程如图所示：</p>
<p><img src="/2022/10/24/JVM%E5%86%85%E9%83%A8%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B/7.png" alt="图片"></p>
<p><strong>四 synchronized的底层实现</strong></p>
<p>上面我们对对象的内存布局有了一些了解之后，知道锁的状态主要存放在markword里面。这里我们看看底层实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RnEnterLockDemo</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对这段简单代码进行反解析看看什么情况。javap -c RnEnterLockDemo.class</p>
<p><img src="/2022/10/24/JVM%E5%86%85%E9%83%A8%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B/8.png" alt="图片"></p>
<p>首先我们能确定的是syn肯定是还有加锁的操作，看到的信息中出现了monitorenter和monitorexit，主观上就可以猜到这是跟加锁和解锁相关的指令。有意思的是1个monitorenter和2个monitorexit。为什么呢？正常来说应该就是一个加锁和一个释放锁啊。其实这里也体现了syn和lock的区别。syn是JVM层面的锁，如果异常了不用自己释放，jvm会自动帮助释放，这一步就取决于多出来的那个monitorexit。而lock异常需要我们手动补获并释放的。</p>
<p>关于这两条指令的作用，我们直接参考JVM规范中描述：</p>
<blockquote>
<p>monitorenter ：</p>
<p>Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows: • If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor. • If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count. • If another thread already owns the monitor associated with objectref, the thread blocks until the monitor’s entry count is zero, then tries again to gain ownership</p>
</blockquote>
<p>翻译一下：</p>
<p>每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</p>
<ul>
<li><p>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</p>
</li>
<li><p>如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1。</p>
</li>
<li><p>如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</p>
</li>
</ul>
<blockquote>
<p>monitorexit：　</p>
<p>The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref. The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.</p>
</blockquote>
<p>翻译一下：</p>
<p>执行monitorexit的线程必须是objectref所对应的monitor的所有者。指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor的所有权。 </p>
<p>通过这段话的描述，很清楚的看出Synchronized的实现原理，Synchronized底层通过一个monitor的对象来完成，wait&#x2F;notify等方法其实也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait&#x2F;notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常。</p>
<p>每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针。</p>
<p>当执行monitorenter时，如果目标对象的计数器为零，那么说明它没有被其他线程所持有，Java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加i。在目标锁对象的计数器不为零的情况下，如果锁对象的持有线程是当前线程，那么Java虚拟机可以将其计数器加1，否则需要等待，直至持有线程释放该锁。当执行monitorexit时，Java虚拟机则需将锁对象的计数器减1。计数器为零代表锁已被释放。</p>
<p><strong>总结</strong></p>
<p>以往的经验中，只要用到synchronized就以为它已经成为了重量级锁。在jdk1.2之前确实如此，后来发现太重了，消耗了太多操作系统资源，所以对synchronized进行了优化。以后可以直接用，至于锁的力度如何，JVM底层已经做好了我们直接用就行。</p>
<p>最后再看看开头的几个问题，是不是都理解了呢。带着问题去研究，往往会更加清晰。希望对大家有所帮助。</p>
]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>Java并发编程</tag>
        <tag>synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM知识点总结</title>
    <url>/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="java-程序编译和运行过程详解"><a href="#java-程序编译和运行过程详解" class="headerlink" title="java 程序编译和运行过程详解"></a>java 程序编译和运行过程详解</h2><p>java整个编译以及运行的过程相当繁琐，这里有个简单的例子。</p>
<h4 id="Java程序从源文件创建到程序运行要经过两大步骤："><a href="#Java程序从源文件创建到程序运行要经过两大步骤：" class="headerlink" title="Java程序从源文件创建到程序运行要经过两大步骤："></a>Java程序从源文件创建到程序运行要经过两大步骤：</h4><p>1、源文件由编译器编译成字节码（ByteCode）；<br>2、字节码由java虚拟机解释运行。因为java程序既要编译同时也要经过JVM的解释运行，所以说Java被称为半解释语言(“semi-interpreted” language)。</p>
<p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/1.png" alt="在这里插入图片描述"></p>
<h3 id="Java-程序运行过程"><a href="#Java-程序运行过程" class="headerlink" title="Java 程序运行过程"></a><strong>Java 程序运行过程</strong></h3><h3 id="第一步-编译过程"><a href="#第一步-编译过程" class="headerlink" title="第一步(编译过程)"></a>第一步(编译过程)</h3><p>创建完源文件之后，程序先要被JVM中的java编译器进行编译为.class文件。<br>1、java编译一个类时，如果这个类所依赖的类还没有被编译，编译器会自动的先编译这个所依赖的类，然后引用。<br>2、如果java编译器在指定的目录下找不到该类所依赖的类的 .class文件或者 .java源文件，就会报<br>        “Cant found sysbol”的异常错误。<br>3、编译后的字节码文件格式主要分为两部分：常量池和方法字节码。<br>常量池记录的是代码出现过的（常量、类名、成员变量等）以及符号引用（类引用、方法引用，成员变量引用等）；<br>方法字节码中放的是各个方法的字节码。</p>
<p>下面通过以下这个java程序，来说明java程序从编译到最后运行的整个流程。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java代码</span><br><span class="line"></span><br><span class="line"><span class="comment">//MainApp.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApp</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;Puppy&quot;</span>);</span><br><span class="line"></span><br><span class="line">animal.printName();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Animal.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printName</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Animal [&quot;</span>+name+<span class="string">&quot;]&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一步(编译): 创建完源文件之后，程序会先被编译为.class文件。Java编译一个类时，如果这个类所依赖的类还没有被编译，编译器就会先编译这个被依赖的类，然后引用，否则直接引用，这个有点象make。如果java编译器在指定目录下找不到该类所其依赖的类的.class文件或者.java源文件的话，编译器话报“cant find symbol”的错误。</p>
<p>编译后的字节码文件格式主要分为两部分：<strong>常量池和方法字节码</strong>。常量池记录的是代码出现过的所有token(类名，成员变量名等等)以及符号引用(方法引用，成员变量引用等等)；方法字节码放的是类中各个方法的字节码。下面是MainApp.class通过反汇编的结果，我们可以清楚看到.class文件的结构：</p>
<p> MainApp类常量池<br><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/2.png" alt="在这里插入图片描述"></p>
<p>MainApp类方法字节码<br><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/3.png" alt="在这里插入图片描述"></p>
<h3 id="第二步（运行阶段）"><a href="#第二步（运行阶段）" class="headerlink" title="第二步（运行阶段）"></a>第二步（运行阶段）</h3><p>JVM程序在第一次运行时主动使用类的时候，才会立即去加载。换言之，JVM并不是在运行时就会把所有使用到的类都加载到内存中，而是用到的时候，才加载进来，而且只加载一次！<br>java类运行的过程大概分为两个步骤：<br>（1）类的加载<br>（2）类的执行。<br>根据上面的程序，详解该程序运行的详细步骤：</p>
<h4 id="1、类的加载"><a href="#1、类的加载" class="headerlink" title="1、类的加载"></a>1、类的加载</h4><p>在类路径下找到编译好的 java 程序中；得到 Test.class 字节码文件后，在命令行上敲 java Test，系统就会启动一个 JVM 进程，JVM进程从classpath路径下找到一个名为Test.class的二进制文件，将Test.class文件中的类信息加载到运行时数据区的方法区中，这一过程叫做类的加载。（只有类信息在方法区中，才能创建对象，使用类中的成员变量）</p>
<h4 id="2、JVM-找到main方法的主函数入口"><a href="#2、JVM-找到main方法的主函数入口" class="headerlink" title="2、JVM 找到main方法的主函数入口"></a>2、JVM 找到main方法的主函数入口</h4><p>在主函数入口持有一个指向当前类(Test)常量池的指针，并且常量池中的第一项是发现是一个对Animal对象的符号引用。<br>并且main方法中第一条指令是Animal animal &#x3D; new Animal(“super_yc”)，就是让JVM创建一个Animal对象。<br>但是方法区中还没有Animal类的类信息，于是JVM就要马上的加载Animal类，将Animal类信息放入到方法区中。<br>于是JVM 以一个直接指向方法区 Animal类的指针替换了常量池中第一项的符号引用。(直接引用)</p>
<h4 id="3、实例化对象"><a href="#3、实例化对象" class="headerlink" title="3、实例化对象"></a>3、实例化对象</h4><p>加载完Animal类的信息以后，JVM虚拟机就会在堆内存中为一个Animal类实例分配内存，然后调用其构造函数初始化Animal实例，<br>这个实例持有指向方法区的Animal类的类型信息（其中包含有方法表，java动态绑定的底层实现）的引用。（animal指向了Animal对象的引用会自动的放在栈中，字符串常量”super_yc”会自动的放在方法区的常量池中，对象会自动的放入堆区）。</p>
<h4 id="4、程序运行"><a href="#4、程序运行" class="headerlink" title="4、程序运行"></a>4、程序运行</h4><p>当使用animal.printName()的时候，JVM根据栈中animal引用找到Animal对象，然后根据Animal对象持有的引用定位到方法区中Animal类的类型信息方法表，获得printName()函数的字节码地址，然后开始运行函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Animal animal = new Animal(&quot;super_yc&quot;);</span><br><span class="line">		animal.printName();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Animal&#123;</span><br><span class="line">	private String name;</span><br><span class="line">	public Animal(String name) &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void printName()&#123;</span><br><span class="line">		System.out.println(&quot;Animal = &quot; + this.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/4.png" alt="在这里插入图片描述"></p>
<h4 id="java-进程运行过程详解"><a href="#java-进程运行过程详解" class="headerlink" title="java 进程运行过程详解"></a>java 进程运行过程详解</h4><p>JVM常量池主要分为<strong>Class文件常量池、运行时常量池，全局字符串常量池，以及基本类型包装类对象常量池</strong>。</p>
<p><strong>0、Class文件常量池</strong></p>
<p>class文件是一组以字节为单位的二进制数据流，在java代码的编译期间，我们编写的java文件就被编译为.class文件格式的二进制数据存放在磁盘中，其中就包括class文件常量池。 class文件中存在常量池（非运行时常量池），其在编译阶段就已经确定，jvm规范对class文件结构有着严格的规范，必须符合此规范的class文件才能被jvm认识和装载。为了方便说明，我们写个简单的类</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">JavaBean</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> <span class="keyword">value</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> final <span class="keyword">static</span> <span class="built_in">int</span> f = <span class="number">0x101</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span>(<span class="params"><span class="built_in">int</span> v</span>)</span>&#123;</span><br><span class="line">        final <span class="built_in">int</span> temp = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">value</span> = temp + v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">getValue</span>()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过javac命令编译之后，用javap -v 命令查看编译后的文件:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">class JavaBasicKnowledge.JavaBean</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">1 = Methodref          <span class="comment">#6.#29         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">2 = Fieldref           <span class="comment">#5.#30         // JavaBasicKnowledge/JavaBean.valuI</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">3 = String             <span class="comment">#31            // abc</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">4 = Fieldref           <span class="comment">#5.#32         // JavaBasicKnowledge/JavaBean.s:Ljava/lang/String;</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">5 = Class              <span class="comment">#33            // JavaBasicKnowledge/JavaBean</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">6 = Class              <span class="comment">#34            // java/lang/Object</span></span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">7 = Utf8               value</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">8 = Utf8               I</span></span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">9 = Utf8               s</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">10 = Utf8               Ljava/lang/String;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">11 = Utf8               f</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">12 = Utf8               ConstantValue</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">13 = Integer            257</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">14 = Utf8               &lt;init&gt;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">15 = Utf8               ()V</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">16 = Utf8               Code</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">17 = Utf8               LineNumberTable</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">18 = Utf8               LocalVariableTable</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">19 = Utf8               this</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">20 = Utf8               LJavaBasicKnowledge/JavaBean;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">21 = Utf8               setValue</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">22 = Utf8               (I)V</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">23 = Utf8               v</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">24 = Utf8               temp</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">25 = Utf8               getValue</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">26 = Utf8               ()I</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">27 = Utf8               SourceFile</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">28 = Utf8               StringConstantPool.java</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">29 = NameAndType        <span class="comment">#14:#15        // &quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">30 = NameAndType        <span class="comment">#7:#8          // valuI</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">31 = Utf8               abc</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">32 = NameAndType        <span class="comment">#9:#10         // s:Ljava/lang/String;</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">33 = Utf8               JavaBasicKnowledge/JavaBean</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">34 = Utf8               java/lang/Object</span></span><br></pre></td></tr></table></figure>

<p>可以看到这个命令之后我们得到了该class文件的版本号、常量池、已经编译后的字节码（这里未列出）。既然是常量池，那么其中存放的肯定是常量，那么什么是“常量”呢？ class文件常量池主要存放两大常量：<strong>字面量和符号引用</strong>。</p>
<ol>
<li>字面量： 字面量接近java语言层面的常量概念，主要包括：</li>
</ol>
<ul>
<li><strong>文本字符串</strong>，也就是我们经常申明的： public String s &#x3D; “abc”;中的”abc”</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">9 = Utf8               s</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3 = String             <span class="comment">#31            // abc</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">31 = Utf8              abc</span></span><br></pre></td></tr></table></figure>

<ul>
<li>用final修饰的成员变量，包括静态变量、实例变量和局部变量</li>
</ul>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment">#11 = Utf8               f</span></span><br><span class="line"> <span class="comment">#12 = Utf8               ConstantValue</span></span><br><span class="line"> <span class="comment">#13 = Integer            257</span></span><br></pre></td></tr></table></figure>

<p>这里需要说明的一点，上面说的存在于常量池的字面量，指的是数据的值，也就是abc和0x101(257),通过上面对常量池的观察可知这两个字面量是确实存在于常量池的。</p>
<p><strong>而对于基本类型数据(甚至是方法中的局部变量)，也就是上面的private int value &#x3D; 1;常量池中只保留了他的的字段描述符I和字段的名称value，他们的字面量不会存在于常量池。</strong></p>
<p>**2) 符号引用</p>
<p>**符号引用主要设涉及编译原理方面的概念，包括下面三类常量:</p>
<ul>
<li>类和接口的全限定名，也就是java&#x2F;lang&#x2F;String;这样，将类名中原来的”.”替换为”&#x2F;“得到的，主要用于在运行时解析得到类的直接引用，像上面</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">5 = Class              <span class="comment">#33            // JavaBasicKnowledge/JavaBean</span></span></span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">33 = Utf8               JavaBasicKnowledge/JavaBean</span></span><br></pre></td></tr></table></figure>

<ul>
<li>字段的名称和描述符，字段也就是类或者接口中声明的变量，包括类级别变量和实例级的变量</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4 = Fieldref           <span class="comment">#5.#32         // JavaBasicKnowledge/JavaBean.valuI</span></span></span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">5 = Class              <span class="comment">#33            // JavaBasicKnowledge/JavaBean</span></span></span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">32 = NameAndType       <span class="comment">#7:#8          // valuI</span></span></span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">7 = Utf8               value</span></span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">8 = Utf8               I</span></span><br><span class="line"> //这两个是局部变量，只保留字段名称</span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">23 = Utf8               v</span></span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">24 = Utf8               temp</span></span><br></pre></td></tr></table></figure>

<p>可以看到，对于方法中的局部变量名，class文件的常量池仅仅保存字段名。</p>
<ul>
<li>方法中的名称和描述符，也即参数类型+返回值</li>
</ul>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment">#21 = Utf8               setValue</span></span><br><span class="line"> <span class="comment">#22 = Utf8               (I)V</span></span><br><span class="line"> <span class="comment">#25 = Utf8               getValue</span></span><br><span class="line"> <span class="comment">#26 = Utf8               ()I</span></span><br></pre></td></tr></table></figure>

<p><strong>1、运行时常量池</strong></p>
<p>运行时常量池是方法区的一部分，所以也是全局贡献的，我们知道，jvm在执行某个类的时候，必须经过<strong>加载、链接（验证、准备、解析）、初始化</strong>，在第一步加载的时候需要完成：</p>
<ul>
<li>通过一个类的全限定名来获取此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个类对象，代表加载的这个类，这个对象是java.lang.Class，它作为方法区这个类的各种数据访问的入口。</li>
</ul>
<p>类对象和普通对象是不同的，类对象是在类加载的时候完成的，是jvm创建的并且是单例的，作为这个类和外界交互的入口， 而普通的对象一般是在调用new之后创建。</p>
<p>上面的第二条，将class字节流代表的静态存储结构转化为方法区的运行时数据结构，其中就包含了class文件常量池进入运行时常量池的过程，这里需要强调一下<strong>不同的类共用一个运行时常量池</strong>，同时在进入运行时常量池的过程中，多个class文件中常量池相同的字符串，多个class文件中常量池中相同的字符串只会存在一份在运行时常量池，这也是一种优化。</p>
<p>运行时常量池的作用是存储java class文件常量池中的符号信息，运行时常量池中保存着一些class文件中描述的符号引用，同时在类的解析阶段还会将这些符号引用翻译出直接引用（直接指向实例对象的指针，内存地址），翻译出来的直接引用也是存储在运行时常量池中。</p>
<p>运行时常量池相对于class常量池一大特征就是具有动态性，java规范并不要求常量只能在运行时才产生，也就是说运行时常量池的内容并不全部来自class常量池，在运行时可以通过代码生成常量并将其放入运行时常量池中，这种特性被用的最多的就是String.intern()。</p>
<p><strong>2、全局字符串常量池</strong></p>
<p><strong>1）Java中创建字符串对象的两种方式</strong></p>
<p>一般有如下两种：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">String</span> s0 = <span class="string">&quot;hellow&quot;</span>;</span><br><span class="line"><span class="title class_">String</span> s1 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hellow&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>第一种方式声明的字面量hellow是在编译期就已经确定的，它会直接进入class文件常量池中；当运行期间在全局字符串常量池中会保存它的一个引用.实际上最终还是要在堆上创建一个”hellow”对象，这个后面会讲。</p>
<p>第二种方式方式使用了new String()，也就是调用了String类的构造函数，我们知道new指令是创建一个类的实例对象并完成加载初始化的，因此这个字符串对象是在运行期才能确定的，创建的字符串对象是在堆内存上。</p>
<p>因此此时调用System.out.println(s0 &#x3D;&#x3D; s1);返回的肯定是flase,因此&#x3D;&#x3D;符号比较的是两边元素的地址，s1和s0都存在于堆上，但是地址肯定不相同。</p>
<p>我们来看几个常见的题目：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">String</span> s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="title class_">String</span> s2 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="title class_">String</span> s3 = <span class="string">&quot;Hel&quot;</span> + <span class="string">&quot;lo&quot;</span>;</span><br><span class="line"><span class="title class_">String</span> s4 = <span class="string">&quot;Hel&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line"><span class="title class_">String</span> s5 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="title class_">String</span> s7 = <span class="string">&quot;H&quot;</span>;</span><br><span class="line"><span class="title class_">String</span> s8 = <span class="string">&quot;ello&quot;</span>;</span><br><span class="line"><span class="title class_">String</span> s9 = s7 + s8;</span><br><span class="line"><span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(s1 == s2);  <span class="comment">// true</span></span><br><span class="line"><span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(s1 == s3);  <span class="comment">// true</span></span><br><span class="line"><span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(s1 == s4);  <span class="comment">// false</span></span><br><span class="line"><span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(s1 == s9);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="String-s1-x3D-“Hello”，到底有没有在堆中创建对象？"><a href="#String-s1-x3D-“Hello”，到底有没有在堆中创建对象？" class="headerlink" title="String s1 &#x3D; “Hello”，到底有没有在堆中创建对象？"></a>String s1 &#x3D; “Hello”，到底有没有在堆中创建对象？</h4><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/5.png" alt="在这里插入图片描述"></p>
<p>这张图是我们理解的jvm运行时数据区的结构，但是还有不完整的地方，<br><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/6.png" alt="在这里插入图片描述"></p>
<p>这张图中，可以看到，方法区实际上是在一块叫“非堆”的区域包含——可以简单粗略的理解为非堆中包含了永生代，而永生代中又包含了方法区和字符串常量池。<br><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/7.png" alt="在这里插入图片描述"></p>
<p>其中的Interned String就是全局共享的“字符串常量池（String Pool）”，和运行时常量池不是一个概念。但我们在代码中申明String s1 &#x3D; “Hello”;这句代码后，在类加载的过程中，类的class文件的信息会被解析到内存的方法区里。</p>
<p>class文件里常量池里大部分数据会被加载到“运行时常量池”，包括String的字面量；但同时“Hello”字符串的一个引用会被存到同样在“非堆”区域的“字符串常量池”中，而”Hello”本体还是和所有对象一样，创建在Java堆中。</p>
<p>当主线程开始创建s1时，虚拟机会先去字符串池中找是否有equals(“Hello”)的String，如果相等就把在字符串池中“Hello”的引用复制给s1；如果找不到相等的字符串，就会在堆中新建一个对象，同时把引用驻留在字符串池，再把引用赋给str。</p>
<p>当用字面量赋值的方法创建字符串时，无论创建多少次，只要字符串的值相同，它们所指向的都是堆中的同一个对象。<br><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/8.png" alt="在这里插入图片描述"></p>
<p>区别：<code>String str1 = &quot;abc&quot;</code>直接str1存储的是常量池中的地址值<br><code>String str2 = new String(&quot;abc&quot;)</code> <code>str2</code>存储的是在堆中的 <code>new String()</code>的地址值<br><code>new String()</code>存放的是跟<code>str1</code>相同指向的常量池的地址值。</p>
<p><strong>2）字符串常量池的本质</strong></p>
<p>字符串常量池是JVM所维护的一个字符串实例的引用表，在HotSpot VM中，它是一个叫做StringTable的全局表。在字符串常量池中维护的是字符串实例的引用，底层C++实现就是一个Hashtable。这些被维护的引用所指的字符串实例，被称作”被驻留的字符串”或”interned string”或通常所说的”进入了字符串常量池的字符串”。  </p>
<p>强调一下：<strong>运行时常量池在方法区(Non-heap)，而JDK1.7后，字符串常量池被移到了heap区，因此两者根本就不是一个概念。</strong></p>
<h5 id="String”字面量”-是何时进入字符串常量池的"><a href="#String”字面量”-是何时进入字符串常量池的" class="headerlink" title="String”字面量” 是何时进入字符串常量池的?"></a>String”字面量” 是何时进入字符串常量池的?</h5><p>先说结论： 在执行ldc指令时，该指令表示int、float或String型常量从常量池推送至栈顶。</p>
<p>JVM规范里Class文件的常量池项的类型，有两种东西：</p>
<ul>
<li>CONSTANT_Utf8_info</li>
<li>CONSTANT_String_info</li>
</ul>
<p>在HotSpot VM中，运行时常量池里，CONSTANT_Utf8_info可以表示Class文件的方法、字段等等，其结构如下：</p>
<p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/9.png" alt="在这里插入图片描述"></p>
<p>首先是1个字节的tag,表示这是一个CONSTANT_Utf8_info结构的常量，然后是两个字节的length，表示要储存字节的长度，之后是一个字节的byte数组，表示真正的储存的length个长度的字符串。这里需要注意的是，一个字节只是代表这里有一个byte类型的数组，而这个数组的长度当然可以远远大于一个字节。当然，由于CONSTANT_Utf8_info结构只能用u2即两个字节来表示长度，因此长度的最大值为2byte，也就是65535。</p>
<p>CONSTANT_String_info是String常量的类型，但它并不直接持有String常量的内容，而是只持有一个index，这个index所指定的另一个常量池项必须是一个CONSTANT_Utf8类型的常量，这里才真正持有字符串的内容</p>
<p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/10.png" alt="在这里插入图片描述"></p>
<p>CONSTANT_Utf8会在类加载的过程中就全部创建出来，而CONSTANT_String则是lazy resolve的，在第一次引用该项的ldc指令被第一次执行到的时候才会resolve。在尚未resolve的时候，HotSpot VM把它的类型叫做JVM_CONSTANT_UnresolvedString，内容跟Class文件里一样只是一个index；等到resolve过后这个项的常量类型就会变成最终的JVM_CONSTANT_String。</p>
<p>也就是说，就HotSpot VM的实现来说，加载类的时候，那些字符串字面量会进入到当前类的运行时常量池，不会进入全局的字符串常量池（即在StringTable中并没有相应的引用，在堆中也没有对应的对象产生），在执行ldc指令时，触发lazy resolution这个动作。</p>
<p>ldc字节码在这里的执行语义是：到当前类的运行时常量池（runtime constant pool，HotSpot VM里是ConstantPool + ConstantPoolCache）去查找该index对应的项，如果该项尚未resolve则resolve之，并返回resolve后的内容。</p>
<p>在遇到String类型常量时，resolve的过程如果发现StringTable已经有了内容匹配的java.lang.String的引用，则直接返回这个引用，反之，如果StringTable里尚未有内容匹配的String实例的引用，则会在Java堆里创建一个对应内容的String对象，然后在StringTable记录下这个引用，并返回这个引用出去。</p>
<p>可见，ldc指令是否需要创建新的String实例，全看在第一次执行这一条ldc指令时，StringTable是否已经记录了一个对应内容的String的引用。</p>
<p><strong>3）String.intern()的用法</strong></p>
<p>String.intern()官方给的定义：</p>
<p>When the intern method is invoked, if the pool already contains a string equal to this String object as determined by the equals(Object) method, then the string from the pool is returned. Otherwise, this String object is added to the pool and a reference to this String object is returned.</p>
<p>实际上，就是去拿String的内容去Stringtable里查表，如果存在，则返回引用，不存在，就把该对象的”引用”存在Stringtable表里。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">         String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;计算机&quot;</span>).append(<span class="string">&quot;软件&quot;</span>).toString();</span><br><span class="line">         System.<span class="keyword">out</span>.println(str1.intern() == str1);</span><br><span class="line"></span><br><span class="line">         String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;ja&quot;</span>).append(<span class="string">&quot;va&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">         System.<span class="keyword">out</span>.println(str2.intern() == str2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码，在 JDK6 下执行结果为 false、false，在 JDK7 以上执行结果为 true、false。</p>
<p>首先我们调用StringBuilder创建了一个”计算机软件”String对象，因为调用了new关键字，因此是在运行时创建，之前JVM中是没有这个字符串的。</p>
<p>在 JDK6 下，intern()会把首次遇到的字符串实例复制到永久代中，返回的也是这个永久代中字符串实例的引用；而在JDK1.7开始，intern()方法不再复制字符串实例，String 的 intern 方法首先将尝试在常量池中查找该对象的引用，如果找到则直接返回该对象在常量池中的引用地址。</p>
<p>因此在1.7中，“计算机软件”这个字符串实例只存在一份，存在于java堆中！通过3中的分析，我们知道当String str1 &#x3D; new StringBuilder(“计算机”).append(“软件”).toString();这句代码执行完之后，已经在堆中创建了一个字符串对象，并且在全局字符串常量池中保留了这个字符串的引用，那么str1.intern()直接返回这个引用，这当然满足str1.intern() &#x3D;&#x3D; str1——都是他自己嘛；对于引用str2，因为JVM中已经有“java”这个字符串了，因此new StringBuilder(“ja”).append(“va”).toString()会重新创建一个新的“java”字符串对象，而intern()会返回首次遇到的常量的实例引用，因此他返回的是系统中的那个”java”字符串对象引用(首次)，因此会返回false。</p>
<p>在 JDK6 下 str1、str2 指向的是新创建的对象，该对象将在 Java Heap 中创建，所以 str1、str2 指向的是 Java Heap 中的内存地址；调用 intern 方法后将尝试在常量池中查找该对象，没找到后将其放入常量池并返回，所以此时 str1&#x2F;str2.intern() 指向的是常量池中的地址，JDK6常量池在永久代，与堆隔离，所以 s1.intern()和s1 的地址当然不同了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 首先设置 持久代最大和最小内存占用(限定为10M)</span></span><br><span class="line"><span class="comment">         * VM args: -XX:PermSize=10M -XX:MaxPremSize=10M</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        List&lt;String&gt; list  = <span class="keyword">new</span> <span class="built_in">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 无限循环 使用 list 对其引用保证 不被GC  intern 方法保证其加入到常量池中</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 此处永久执行，最多就是将整个 int 范围转化成字符串并放入常量池</span></span><br><span class="line">            list.<span class="built_in">add</span>(String.<span class="built_in">valueOf</span>(i++).<span class="built_in">intern</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码在 JDK6 下会出现 Perm 内存溢出，JDK7 or high 则没问题。</p>
<p>JDK6 常量池存在持久代，设置了持久代大小后，不断while循环必将撑满 Perm 导致内存溢出；JDK7 常量池被移动到 Native Heap(Java Heap,HotSpot VM中不区分native堆和Java堆)，所以即使设置了持久代大小，也不会对常量池产生影响；不断while循环在当前的代码中，所有int的字符串相加还不至于撑满 Heap 区，所以不会出现异常。</p>
<p><strong>3、JAVA 基本类型的封装类及对应常量池</strong></p>
<p>java中基本类型的包装类的大部分都实现了常量池技术，这些类是Byte,Short,Integer,Long,Character,Boolean,另外两种浮点数类型的包装类则没有实现。另外上面这5种整型的包装类也只是在对应值小于等于127时才可使用对象池，也即对象不负责创建和管理大于127的这些类的对象。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringConstantPool</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> static void main(String[] args)&#123;</span><br><span class="line">        <span class="comment">//5种整形的包装类Byte,Short,Integer,Long,Character的对象，</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//在值小于127时可以使用常量池</span></span><br><span class="line">        Integer i1=<span class="number">127</span>;</span><br><span class="line">        Integer i2=<span class="number">127</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.println(i1==i2);<span class="comment">//输出true</span></span><br><span class="line">        <span class="comment">//值大于127时，不会从常量池中取对象</span></span><br><span class="line">        Integer i3=<span class="number">128</span>;</span><br><span class="line">        Integer i4=<span class="number">128</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.println(i3==i4);<span class="comment">//输出false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Boolean类也实现了常量池技术</span></span><br><span class="line">        <span class="built_in">Boolean</span> bool1=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Boolean</span> bool2=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        System.<span class="keyword">out</span>.println(bool1==bool2);<span class="comment">//输出true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//浮点类型的包装类没有实现常量池技术</span></span><br><span class="line">        <span class="built_in">Double</span> d1=<span class="number">1.0</span>;</span><br><span class="line">        <span class="built_in">Double</span> d2=<span class="number">1.0</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.println(d1==d2); <span class="comment">//输出false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在JDK5.0之前是不允许直接将基本数据类型的数据直接赋值给其对应地包装类的，如：Integer i &#x3D; 5; 但是在JDK5.0中支持这种写法，因为编译器会自动将上面的代码转换成如下代码：Integer i&#x3D;Integer.valueOf(5);这就是Java的装箱.JDK5.0也提供了自动拆箱：Integer i &#x3D;5; int j &#x3D; i;</p>
<h1 id="一、运行时数据区域"><a href="#一、运行时数据区域" class="headerlink" title="一、运行时数据区域"></a>一、运行时数据区域</h1><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/11.png" alt="在这里插入图片描述"></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。</p>
<h2 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h2><p>每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p>
<p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/12.png" alt="在这里插入图片描述"></p>
<p>可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K，而在 JDK 1.5+ 默认为 1M：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -Xss2M HackTheJava</span><br></pre></td></tr></table></figure>

<p>该区域可能抛出以下异常：</p>
<ul>
<li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；</li>
<li>栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。</li>
</ul>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。</p>
<p>本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。</p>
<p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/13.png" alt="在这里插入图片描述"></p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>所有对象都在这里分配内存，是垃圾收集的主要区域（”GC 堆”）。</p>
<p>现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：</p>
<ul>
<li>新生代（Young Generation）</li>
<li>老年代（Old Generation）</li>
</ul>
<p>堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。</p>
<p>可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -Xms1M -Xmx2M HackTheJava</span><br></pre></td></tr></table></figure>

<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。</p>
<p>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。</p>
<p>HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。</p>
<p>方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和字符串常量池等放入堆中。<br><img src="https://img-blog.csdnimg.cn/20210411053700275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池是方法区的一部分。</p>
<p>Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。</p>
<p>除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。</p>
<p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/14.png" alt="在这里插入图片描述"></p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。</p>
<h1 id="二、垃圾收集"><a href="#二、垃圾收集" class="headerlink" title="二、垃圾收集"></a>二、垃圾收集</h1><p>垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。</p>
<h2 id="判断一个对象是否可被回收"><a href="#判断一个对象是否可被回收" class="headerlink" title="判断一个对象是否可被回收"></a>判断一个对象是否可被回收</h2><h3 id="1-引用计数算法"><a href="#1-引用计数算法" class="headerlink" title="1. 引用计数算法"></a>1. 引用计数算法</h3><p>为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</p>
<p>在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="type">Test</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        a.instance = b;</span><br><span class="line">        b.instance = a;</span><br><span class="line">        a = <span class="literal">null</span>;</span><br><span class="line">        b = <span class="literal">null</span>;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，a 与 b 引用的对象实例互相持有了对象的引用，因此当我们把对 a 对象与 b 对象的引用去除之后，由于两个对象还存在互相之间的引用，导致两个 Test 对象无法被回收。</p>
<h3 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2. 可达性分析算法"></a>2. 可达性分析算法</h3><p>以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。</p>
<p>Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：</p>
<ul>
<li>虚拟机栈中局部变量表中引用的对象</li>
<li>本地方法栈中 JNI 中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
</ul>
<p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/15.png" alt="在这里插入图片描述"></p>
<h3 id="3-方法区的回收"><a href="#3-方法区的回收" class="headerlink" title="3. 方法区的回收"></a>3. 方法区的回收</h3><p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。</p>
<p>主要是对常量池的回收和对类的卸载。</p>
<p>为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。</p>
<p>类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：</p>
<ul>
<li>该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li>
</ul>
<h3 id="4-finalize"><a href="#4-finalize" class="headerlink" title="4. finalize()"></a>4. finalize()</h3><p>类似 C++ 的析构函数，用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。</p>
<p>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。</p>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p>
<p>Java 提供了四种强度不同的引用类型。</p>
<h3 id="1-强引用"><a href="#1-强引用" class="headerlink" title="1. 强引用"></a>1. 强引用</h3><p>被强引用关联的对象不会被回收。</p>
<p>使用 new 一个新对象的方式来创建强引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<h3 id="2-软引用"><a href="#2-软引用" class="headerlink" title="2. 软引用"></a>2. 软引用</h3><p>被软引用关联的对象只有在内存不够的情况下才会被回收。</p>
<p>使用 SoftReference 类来创建软引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;  <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure>

<h3 id="3-弱引用"><a href="#3-弱引用" class="headerlink" title="3. 弱引用"></a>3. 弱引用</h3><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</p>
<p>使用 WeakReference 类来创建弱引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4-虚引用"><a href="#4-虚引用" class="headerlink" title="4. 虚引用"></a>4. 虚引用</h3><p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。</p>
<p>为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。</p>
<p>使用 PhantomReference 来创建虚引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;Object&gt;(obj, <span class="literal">null</span>);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="1-标记-清除"><a href="#1-标记-清除" class="headerlink" title="1. 标记 - 清除"></a>1. 标记 - 清除</h3><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/16.png" alt="在这里插入图片描述"></p>
<p>在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。</p>
<p>在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。</p>
<p>在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。</p>
<p>不足：</p>
<ul>
<li>标记和清除过程效率都不高；</li>
<li>会产生大量不连续的内存碎片，导致无法给大对象分配内存。</li>
</ul>
<h3 id="2-标记-整理"><a href="#2-标记-整理" class="headerlink" title="2. 标记 - 整理"></a>2. 标记 - 整理</h3><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/17.png" alt="在这里插入图片描述"></p>
<p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<p>优点:</p>
<ul>
<li>不会产生内存碎片</li>
</ul>
<p>不足:</p>
<ul>
<li>需要移动大量对象，处理效率比较低。</li>
</ul>
<h3 id="3-复制"><a href="#3-复制" class="headerlink" title="3. 复制"></a>3. 复制</h3><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/18.png" alt="在这里插入图片描述"></p>
<p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p>
<p>主要不足是只使用了内存的一半。</p>
<p>现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。</p>
<p>HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。</p>
<h3 id="4-分代收集"><a href="#4-分代收集" class="headerlink" title="4. 分代收集"></a>4. 分代收集</h3><p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p>
<p>一般将堆分为新生代和老年代。</p>
<ul>
<li>新生代使用：复制算法</li>
<li>老年代使用：标记 - 清除 或者 标记 - 整理 算法</li>
</ul>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/19.png" alt="在这里插入图片描述"></p>
<p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p>
<ul>
<li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；</li>
<li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li>
</ul>
<h3 id="1-Serial-收集器"><a href="#1-Serial-收集器" class="headerlink" title="1. Serial 收集器"></a>1. Serial 收集器</h3><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/20.png" alt="在这里插入图片描述"></p>
<p>Serial 翻译为串行，也就是说它以串行的方式执行。</p>
<p>它是单线程的收集器，只会使用一个线程进行垃圾收集工作。</p>
<p>它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p>
<p>它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。</p>
<h3 id="2-ParNew-收集器"><a href="#2-ParNew-收集器" class="headerlink" title="2. ParNew 收集器"></a>2. ParNew 收集器</h3><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/21.png" alt="在这里插入图片描述"></p>
<p>它是 Serial 收集器的多线程版本。</p>
<p>它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。</p>
<h3 id="3-Parallel-Scavenge-收集器"><a href="#3-Parallel-Scavenge-收集器" class="headerlink" title="3. Parallel Scavenge 收集器"></a>3. Parallel Scavenge 收集器</h3><p>与 ParNew 一样是多线程收集器。</p>
<p>其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。</p>
<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。</p>
<p>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p>
<p>可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p>
<h3 id="4-Serial-Old-收集器"><a href="#4-Serial-Old-收集器" class="headerlink" title="4. Serial Old 收集器"></a>4. Serial Old 收集器</h3><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/22.png" alt="在这里插入图片描述"></p>
<p>是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：</p>
<ul>
<li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li>
<li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li>
</ul>
<h3 id="5-Parallel-Old-收集器"><a href="#5-Parallel-Old-收集器" class="headerlink" title="5. Parallel Old 收集器"></a>5. Parallel Old 收集器</h3><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/23.png" alt="在这里插入图片描述"></p>
<p>是 Parallel Scavenge 收集器的老年代版本。</p>
<p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p>
<h3 id="6-CMS-收集器"><a href="#6-CMS-收集器" class="headerlink" title="6. CMS 收集器"></a>6. CMS 收集器</h3><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/24.png" alt="在这里插入图片描述"></p>
<p>CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。</p>
<p>分为以下四个流程：</p>
<ul>
<li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li>
<li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li>
<li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li>
<li>并发清除：不需要停顿。</li>
</ul>
<p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p>
<p>具有以下缺点：</p>
<ul>
<li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li>
<li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li>
<li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li>
</ul>
<h3 id="7-G1-收集器"><a href="#7-G1-收集器" class="headerlink" title="7. G1 收集器"></a>7. G1 收集器</h3><p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p>
<p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</p>
<p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/25.png" alt="在这里插入图片描述"></p>
<p>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。</p>
<p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/26.png" alt="在这里插入图片描述"></p>
<p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p>
<p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p>
<p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/27.png" alt="在这里插入图片描述"></p>
<p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li>
<li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li>
</ul>
<p>具备如下特点：</p>
<ul>
<li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li>
<li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li>
</ul>
<p>JDK1.8中默认使用的是Parallel Scavenge和Parallel Old收集器组合。</p>
<h1 id="三、内存分配与回收策略"><a href="#三、内存分配与回收策略" class="headerlink" title="三、内存分配与回收策略"></a>三、内存分配与回收策略</h1><h2 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h2><ul>
<li><p>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</p>
</li>
<li><p>Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</p>
</li>
</ul>
<h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><h3 id="1-对象优先在-Eden-分配"><a href="#1-对象优先在-Eden-分配" class="headerlink" title="1. 对象优先在 Eden 分配"></a>1. 对象优先在 Eden 分配</h3><p>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。</p>
<h3 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2. 大对象直接进入老年代"></a>2. 大对象直接进入老年代</h3><p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p>
<p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p>
<p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</p>
<h3 id="3-长期存活的对象进入老年代"><a href="#3-长期存活的对象进入老年代" class="headerlink" title="3. 长期存活的对象进入老年代"></a>3. 长期存活的对象进入老年代</h3><p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p>
<p>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</p>
<h3 id="4-动态对象年龄判定"><a href="#4-动态对象年龄判定" class="headerlink" title="4. 动态对象年龄判定"></a>4. 动态对象年龄判定</h3><p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p>
<h3 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5. 空间分配担保"></a>5. 空间分配担保</h3><p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</p>
<p>如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。</p>
<h2 id="Full-GC-的触发条件"><a href="#Full-GC-的触发条件" class="headerlink" title="Full GC 的触发条件"></a>Full GC 的触发条件</h2><p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：</p>
<h3 id="1-调用-System-gc"><a href="#1-调用-System-gc" class="headerlink" title="1. 调用 System.gc()"></a>1. 调用 System.gc()</h3><p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p>
<h3 id="2-老年代空间不足"><a href="#2-老年代空间不足" class="headerlink" title="2. 老年代空间不足"></a>2. 老年代空间不足</h3><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p>
<p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p>
<h3 id="3-空间分配担保失败"><a href="#3-空间分配担保失败" class="headerlink" title="3. 空间分配担保失败"></a>3. 空间分配担保失败</h3><p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第 5 小节。</p>
<h3 id="4-JDK-1-7-及以前的永久代空间不足"><a href="#4-JDK-1-7-及以前的永久代空间不足" class="headerlink" title="4. JDK 1.7 及以前的永久代空间不足"></a>4. JDK 1.7 及以前的永久代空间不足</h3><p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</p>
<p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p>
<p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p>
<h3 id="5-Concurrent-Mode-Failure"><a href="#5-Concurrent-Mode-Failure" class="headerlink" title="5. Concurrent Mode Failure"></a>5. Concurrent Mode Failure</h3><p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p>
<h1 id="四、类加载机制"><a href="#四、类加载机制" class="headerlink" title="四、类加载机制"></a>四、类加载机制</h1><p>类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。</p>
<h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/28.png" alt="在这里插入图片描述"></p>
<p>包括以下 7 个阶段：</p>
<ul>
<li><strong>加载（Loading）</strong>  </li>
<li><strong>验证（Verification）</strong>  </li>
<li><strong>准备（Preparation）</strong>  </li>
<li><strong>解析（Resolution）</strong>  </li>
<li><strong>初始化（Initialization）</strong>  </li>
<li>使用（Using）</li>
<li>卸载（Unloading）</li>
</ul>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>包含了加载、验证、准备、解析和初始化这 5 个阶段。</p>
<h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h3><p>加载是类加载的一个阶段，注意不要混淆。</p>
<p>加载过程完成以下三件事：</p>
<ul>
<li>通过类的完全限定名称获取定义该类的二进制字节流。</li>
<li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构。</li>
<li>在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。</li>
</ul>
<p>其中二进制字节流可以从以下方式中获取：</p>
<ul>
<li>从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。</li>
<li>从网络中获取，最典型的应用是 Applet。</li>
<li>运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。</li>
<li>由其他文件生成，例如由 JSP 文件生成对应的 Class 类。</li>
</ul>
<h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h3><p>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h3><p>类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。</p>
<p>实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。</p>
<p>初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4. 解析"></a>4. 解析</h3><p>将常量池的符号引用替换为直接引用的过程。</p>
<p>其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</p>
<div data="补充为什么可以支持动态绑定 --> <--"></div>

<h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5. 初始化"></a>5. 初始化</h3><div data="modify -->"></div>

<p>初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 &lt;clinit&gt;() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。</p>
<p>&lt;clinit&gt;() 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;                <span class="comment">// 给变量赋值可以正常编译通过</span></span><br><span class="line">        System.out.print(i);  <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于父类的 &lt;clinit&gt;() 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">A</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        A = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">B</span> <span class="operator">=</span> A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     System.out.println(Sub.B);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 &lt;clinit&gt;() 方法。但接口与类不同的是，执行接口的 &lt;clinit&gt;() 方法不需要先执行父接口的 &lt;clinit&gt;() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 &lt;clinit&gt;() 方法。</p>
<p>虚拟机会保证一个类的 &lt;clinit&gt;() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 &lt;clinit&gt;() 方法，其它线程都会阻塞等待，直到活动线程执行 &lt;clinit&gt;() 方法完毕。如果在一个类的 &lt;clinit&gt;() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。</p>
<h2 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h2><h3 id="1-主动引用"><a href="#1-主动引用" class="headerlink" title="1. 主动引用"></a>1. 主动引用</h3><p>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）：</p>
<ul>
<li><p>遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。</p>
</li>
<li><p>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。</p>
</li>
<li><p>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p>
</li>
<li><p>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；</p>
</li>
<li><p>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；</p>
</li>
</ul>
<h3 id="2-被动引用"><a href="#2-被动引用" class="headerlink" title="2. 被动引用"></a>2. 被动引用</h3><p>以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：</p>
<ul>
<li>通过子类引用父类的静态字段，不会导致子类初始化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(SubClass.value);  <span class="comment">// value 字段在 SuperClass 中定义</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SuperClass[] sca = <span class="keyword">new</span> <span class="title class_">SuperClass</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(ConstClass.HELLOWORLD);</span><br></pre></td></tr></table></figure>

<h2 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h2><p>两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。</p>
<p>这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。</p>
<h2 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h2><p>从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：</p>
<ul>
<li><p>启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分；</p>
</li>
<li><p>所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。</p>
</li>
</ul>
<p>从 Java 开发人员的角度看，类加载器可以划分得更细致一些：</p>
<ul>
<li><p>启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 &lt;JRE_HOME&gt;\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。</p>
</li>
<li><p>扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 &lt;JAVA_HOME&gt;&#x2F;lib&#x2F;ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。</p>
</li>
<li><p>应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
</li>
</ul>
<div data="modify <--"></div>

<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。</p>
<p>下图展示了类加载器之间的层次关系，称为双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。</p>
<p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/29.png" alt="在这里插入图片描述"></p>
<h3 id="1-工作过程"><a href="#1-工作过程" class="headerlink" title="1. 工作过程"></a>1. 工作过程</h3><p>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。</p>
<h3 id="2-好处"><a href="#2-好处" class="headerlink" title="2. 好处"></a>2. 好处</h3><p>使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。</p>
<p>例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。</p>
<h3 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h3><p>以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="comment">// The parent class loader for delegation</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义类加载器实现"><a href="#自定义类加载器实现" class="headerlink" title="自定义类加载器实现"></a>自定义类加载器实现</h2><p>以下代码中的 FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。</p>
<p>java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileSystemClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileSystemClassLoader</span><span class="params">(String rootDir)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rootDir = rootDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">byte</span>[] classData = getClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] getClassData(String className) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> classNameToPath(className);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path);</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">bufferSize</span> <span class="operator">=</span> <span class="number">4096</span>;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[bufferSize];</span><br><span class="line">            <span class="type">int</span> bytesNumRead;</span><br><span class="line">            <span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, bytesNumRead);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">classNameToPath</span><span class="params">(String className)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rootDir + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">&#x27;.&#x27;</span>, File.separatorChar) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、JVM常见的启动参数"><a href="#五、JVM常见的启动参数" class="headerlink" title="五、JVM常见的启动参数"></a>五、JVM常见的启动参数</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xms：初始大小内存，默认为物理内存1/64，等价于-XX:InitialHeapSize</span><br><span class="line">-Xmx：最大分配内存，默认为物理内存1/4，等价于-XX:MaxHeapSize</span><br><span class="line">-Xss：设置单个线程的大小，一般默认为512K~1024K，等价于-XX:ThreadStackSize</span><br><span class="line">-Xmn：设置年轻代大小</span><br><span class="line">-XX:MetaspaceSize：设置元空间大小，-Xms10m -Xmx10m -XX:MetaspaceSize=1024m -			XX:+PrintFlagsFinal</span><br><span class="line">-XX:+PrintGCDetails：输出详细GC收集日志信息</span><br></pre></td></tr></table></figure>

<h5 id="GC"><a href="#GC" class="headerlink" title="GC:"></a>GC:</h5><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/30.png" alt="在这里插入图片描述"></p>
<h5 id="FullGC"><a href="#FullGC" class="headerlink" title="FullGC:"></a>FullGC:</h5><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/31.png" alt="在这里插入图片描述"></p>
<h5 id="XX-SurvivoRatio"><a href="#XX-SurvivoRatio" class="headerlink" title="-XX:SurvivoRatio"></a>-XX:SurvivoRatio</h5><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/32.png" alt="在这里插入图片描述"></p>
<p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/33.png" alt="在这里插入图片描述"></p>
<h5 id="XX-NewRatio"><a href="#XX-NewRatio" class="headerlink" title="-XX:NewRatio"></a>-XX:NewRatio</h5><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/34.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:MaxTenuringThreshold：设置垃圾最大年龄</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/45.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -XX:+PrintFlagsInitial   查看初始默认值</span><br><span class="line">java -XX:+PrintCommandLineFlags -version 查看GC是哪个收集器</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如何查看一个正在运行中的java程序，它的某个JVM参数手否开启，具体值是多少？</span><br><span class="line">1.命令jps -l 在idea下的terminal窗口下得到类的进程号 ID；</span><br><span class="line">2.jinfo -flag PrintGCDetails ID //查看某一个正在运行的java程序是否开启打印GC收集细节</span><br></pre></td></tr></table></figure>



<h4 id="几种常用的内存调试工具"><a href="#几种常用的内存调试工具" class="headerlink" title="几种常用的内存调试工具"></a>几种常用的内存调试工具</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jps:查看虚拟机进程的状况，如进程ID；</span><br><span class="line">jmap: 用于生成堆转储快照文件(某一时刻的)。</span><br><span class="line">jhat: 对生成的堆转储快照文件进行分析。</span><br><span class="line">jstack: 用来生成线程快照(某一时刻的)。生成线程快照的主要目的是定位线程长时停顿的原因(如死锁,死循环,等待 			I/O 等), 通过查看各个线程的调用堆栈,就可以知道没有响应的线程在后台做了什么或者等待什么资源。 </span><br><span class="line">jstat: 虚拟机统计信息监视工具。如显示垃圾收集的情况,内存使用的情况。</span><br><span class="line">Jconsol 主要是内存监控和线程监控。内存监控:可以显示内存的使用情况。线程监控:遇到线程停顿时,可以使用这个			功能。</span><br></pre></td></tr></table></figure>

<h1 id="六、请谈谈你对ooM的认识"><a href="#六、请谈谈你对ooM的认识" class="headerlink" title="六、请谈谈你对ooM的认识"></a>六、请谈谈你对ooM的认识</h1><h5 id="1、Java-lang-StackOverflowError"><a href="#1、Java-lang-StackOverflowError" class="headerlink" title="1、Java.lang.StackOverflowError"></a>1、Java.lang.StackOverflowError</h5><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/36.png" alt="在这里插入图片描述"></p>
<h5 id="2-Java-lang-OutOfMemoryError-Java-heap-space"><a href="#2-Java-lang-OutOfMemoryError-Java-heap-space" class="headerlink" title="2.Java.lang.OutOfMemoryError:Java heap space"></a>2.Java.lang.OutOfMemoryError:Java heap space</h5><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/37.png" alt="在这里插入图片描述"></p>
<h5 id="3、Java-lang-OutOfMemeoryError-GC-overhead-limit-exceeded"><a href="#3、Java-lang-OutOfMemeoryError-GC-overhead-limit-exceeded" class="headerlink" title="3、Java.lang.OutOfMemeoryError:GC overhead limit exceeded"></a>3、Java.lang.OutOfMemeoryError:GC overhead limit exceeded</h5><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/38.png" alt="在这里插入图片描述"></p>
<h5 id="4、Java-lang-OutOfMemeoryError-Direct-buffer-memory"><a href="#4、Java-lang-OutOfMemeoryError-Direct-buffer-memory" class="headerlink" title="4、Java.lang.OutOfMemeoryError:Direct buffer memory"></a>4、Java.lang.OutOfMemeoryError:Direct buffer memory</h5><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/39.png" alt="在这里插入图片描述"></p>
<h5 id="5、Java-lang-OutOfMemeoryError-unable-to-create-new-native-thread"><a href="#5、Java-lang-OutOfMemeoryError-unable-to-create-new-native-thread" class="headerlink" title="5、Java.lang.OutOfMemeoryError:unable to create new native thread"></a>5、Java.lang.OutOfMemeoryError:unable to create new native thread</h5><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/41.png" alt="在这里插入图片描述"></p>
<h5 id="6、Java-lang-OutOfMemeoryError-Metaspace"><a href="#6、Java-lang-OutOfMemeoryError-Metaspace" class="headerlink" title="6、Java.lang.OutOfMemeoryError:Metaspace"></a>6、Java.lang.OutOfMemeoryError:Metaspace</h5><p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/42.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用Java -XX:+PrintFlagsInitial命令查看本机的初始化参数，-XX:MetaspaceSize为21810376B(约20M)</span><br></pre></td></tr></table></figure>



<h1 id="七、假如生产环境出现CPU占用过高，请谈谈你的分析思路和定位"><a href="#七、假如生产环境出现CPU占用过高，请谈谈你的分析思路和定位" class="headerlink" title="七、假如生产环境出现CPU占用过高，请谈谈你的分析思路和定位"></a>七、假如生产环境出现CPU占用过高，请谈谈你的分析思路和定位</h1><p>下面我写一个死循环的代码，然后演示一遍如何去定位问题</p>
<ul>
<li>这个案例为了演示cpu很高时候 如何快速定位</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CpuTest</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           System.out.println(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1010101010</span>));</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第一步、用top命令找出占cpu占比最高的 记录下PID</strong></p>
<p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/51.png" alt="在这里插入图片描述"></p>
<p><strong>二、采用 jps 进一步定位找到当前正在运行的进程号</strong></p>
<p><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/52.png" alt="在这里插入图片描述"></p>
<p><strong>三、定位到具体的线程或代码 ps -mp 进程 -o THREAD,tid,time   定位到了具体的线程</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-m 显示所有的线程</span><br><span class="line">-p pid进程使用cpu的时间</span><br><span class="line">-o 该参数后是用户自定义的格式</span><br></pre></td></tr></table></figure>

<p><strong>四、将需要的线程ID转换为16进制格式（英文小写格式）</strong><br><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/53.png" alt="在这里插入图片描述"></p>
<p><strong>五、jstack 进程号 | grep tid 线程号（16进制） -A60</strong><br><img src="/2022/10/24/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/54.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>问题排查</tag>
      </tags>
  </entry>
  <entry>
    <title>Java语言基础</title>
    <url>/2022/10/24/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h1><p><strong>数据类型分类:</strong><br>Java的数据类型分为两大类：<br>基本数据类型：包括 整数 、 浮点数 、 字符 、 布尔 。<br>引用数据类型：包括 类 、 数组 、 接口 。</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>四类八种基本数据类型：<br><img src="/2022/10/24/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/1.png" alt="在这里插入图片描述"></p>
<p>boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。</p>
<p><strong>自动转换：</strong> 将取值范围小的类型自动提升为取值范围大的类型。<br><strong>转换规则</strong><br>范围小的类型向范围大的类型提升， byte、short、char 运算时直接提升为 int。<br>byte、short、char‐‐&gt;int‐‐&gt;long‐‐&gt;float‐‐&gt;double<br><strong>强制转换:</strong><br>int i &#x3D; (int)1.5; &#x2F;&#x2F; double类型数据强制转成int类型，直接去掉小数点.</p>
<h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">2</span>;     <span class="comment">// 装箱 调用了 Integer.valueOf(2)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x;         <span class="comment">// 拆箱 调用了 X.intValue()</span></span><br></pre></td></tr></table></figure>

<h2 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h2><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p>
<ul>
<li>new Integer(123) 每次都会新建一个对象；</li>
<li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">z</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">k</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// high value may be configured by property</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span></span><br><span class="line">        sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (integerCacheHighPropValue != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parseInt(integerCacheHighPropValue);</span><br><span class="line">            i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">            <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">            <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    high = h;</span><br><span class="line"></span><br><span class="line">    cache = <span class="keyword">new</span> <span class="title class_">Integer</span>[(high - low) + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">        cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">    <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">System.out.println(m == n); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>基本类型对应的缓冲池如下：</p>
<ul>
<li>boolean values true and false</li>
<li>all byte values</li>
<li>short values between -128 and 127</li>
<li>int values between -128 and 127</li>
<li>char in the range \u0000 to \u007F</li>
</ul>
<p>在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。</p>
<p>在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax&#x3D;<size> 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。</size></p>
<h1 id="二、String"><a href="#二、String" class="headerlink" title="二、String"></a>二、String</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承）</p>
<p>在 Java 8 中，String 内部使用 char 数组存储数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The identifier of the encoding used to encode the bytes in &#123;<span class="doctag">@code</span> value&#125;. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span> coder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p>
<h2 id="不可变的好处"><a href="#不可变的好处" class="headerlink" title="不可变的好处"></a>不可变的好处</h2><p><strong>1. 可以缓存 hash 值</strong>  </p>
<p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p>
<p><strong>2. String Pool 的需要</strong>  </p>
<p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。<br><img src="/2022/10/24/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/2.png" alt="在这里插入图片描述"></p>
<p><strong>3. 安全性</strong>  </p>
<p>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p>
<p><strong>4. 线程安全</strong>  </p>
<p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p>
<h2 id="String-StringBuffer-and-StringBuilder"><a href="#String-StringBuffer-and-StringBuilder" class="headerlink" title="String, StringBuffer and StringBuilder"></a>String, StringBuffer and StringBuilder</h2><p><strong>1. 可变性</strong>  </p>
<ul>
<li>String 不可变</li>
<li>StringBuffer 和 StringBuilder 可变</li>
</ul>
<p><strong>2. 线程安全</strong>  </p>
<ul>
<li>String 不可变，因此是线程安全的</li>
<li>StringBuilder 不是线程安全的</li>
<li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li>
</ul>
<p>StringBuffer是线程安全的，支持并发操作，支持多线程；<br>StringBuilder是线程不安全的，不支持并发操作，支持单线程。<br>StringBuffer继承抽象类AbstractStringBuilder，StringBuffer可以给指定对象的实体初始化容量字符串长度再另外加16个字符串，<br>super(str.length+16),这是自动扩容，还有就是扩容算法：使用append（）方法在字符串后面追加东西的时候，如果超过了字符串存储空间大小就需要进行扩容，<br>传入一个方法：ensureCapacityInternal进行是否扩容判断，需要扩容就调用<strong>expendCapacity</strong>方法进行扩容。  </p>
<p>StringBuffer类可以创建可修改的字符串序列。该类有StringBuffer(),StringBuffer(int size),StringBuffer(String s)三个改造方法。</p>
<p>1.StringBuffer()的初始容量可以容纳16个字符，当该对象的实体存放的字符的长度大于16时，实体容量就自动增加。StringBuffer对象可以通过length()方法获取实体中存放的字符序列长度，通过capacity()方法来获取当前实体的实际容量。</p>
<p>2.StringBuffer(int size)可以指定分配给该对象的实体的初始容量参数为参数size指定的字符个数。当该对象的实体存放的字符序列的长度大于size个字符时，实体的容量就自动的增加。以便存放所增加的字符。 </p>
<p>3.StringBuffer(String s)可以指定给对象的实体的初始容量为参数字符串s的长度额外再加16个字符。当该对象的实体存放的字符序列长度大于size个字符时，实体的容量自动的增加，以便存放所增加的字符。 </p>
<p>接下来介绍StringBuffer()怎样扩容： </p>
<p>首先我们需要知道StringBuffer和StringBuilder类都继承了抽象类AbstractStringBuilder类；<br>源码都调用父类来进行初始化：<br><img src="/2022/10/24/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/3.png" alt="在这里插入图片描述"></p>
<p>StringBuffer(String s)的初始化：<br><img src="/2022/10/24/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/4.png" alt="在这里插入图片描述"></p>
<p>扩容算法：<br>使用append()方法在字符串后面追加东西的时候，如果长度超过了该字符串存储空间大小了就需要进行扩容：构建新的存储空间更大的字符串，将旧的复制过去；</p>
<p>再进行字符串append添加的时候，会先计算添加后字符串大小，传入一个方法：ensureCapacityInternal 这个方法进行是否扩容的判断，需要扩容就调用expandCapacity方法进行扩容：<br><img src="/2022/10/24/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/5.png" alt="在这里插入图片描述"></p>
<p>尝试将新容量扩为大小变成2倍+2   if 判断一下 容量如果不够，直接扩充到需要的容量大小。</p>
<h2 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h2><p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。</p>
<p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p>
<p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得同一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2);           <span class="comment">// false</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1.intern();</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1.intern();</span><br><span class="line">System.out.println(s3 == s4);           <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">System.out.println(s5 == s6);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p>
<h2 id="new-String-“abc”"><a href="#new-String-“abc”" class="headerlink" title="new String(“abc”)"></a>new String(“abc”)</h2><p>使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。</p>
<ul>
<li>“abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量；</li>
<li>而使用 new 的方式会在堆中创建一个字符串对象。</li>
</ul>
<p>创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewStringTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 javap -verbose 进行反编译，得到以下内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">Constant pool:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">   #<span class="number">2</span> = Class              #<span class="number">18</span>            <span class="comment">// java/lang/String</span></span><br><span class="line">   #<span class="number">3</span> = String             #<span class="number">19</span>            <span class="comment">// abc</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  #<span class="number">18</span> = Utf8               java/lang/String</span><br><span class="line">  #<span class="number">19</span> = Utf8               abc</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class java/lang/String</span></span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         <span class="number">4</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String abc</span></span><br><span class="line">         <span class="number">6</span>: invokespecial #<span class="number">4</span>                  <span class="comment">// Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="number">9</span>: astore_1</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>在 Constant Pool 中，#19 存储这字符串字面量 “abc”，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。</p>
<p>以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(String original)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = original.value;</span><br><span class="line">    <span class="built_in">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、运算"><a href="#三、运算" class="headerlink" title="三、运算"></a>三、运算</h1><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>Java 的参数是以值传递的形式传入方法中，而不是引用传递。</p>
<p>java中只有值传递，没有引用传递<br> 1.方法内如果传基本类型，传的是复印件，原件不动<br> 2.方法内如果传引用类型，传递的是引用（地址）<br>main方法在Java栈中，先进入栈底  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String personName;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String personName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.personName = personName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPersonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> personName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPersonName</span><span class="params">(String personName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.personName = personName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTransferValue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeValue1</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">       age=<span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeValue2</span><span class="params">(Person person)</span>&#123;</span><br><span class="line">        person.setPersonName(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeValue3</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        str=<span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">TestTransferValue</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestTransferValue</span>();</span><br><span class="line">        <span class="type">int</span> age=<span class="number">20</span>;</span><br><span class="line">        test.changeValue1(age);</span><br><span class="line">        System.out.println(<span class="string">&quot;age-----&quot;</span>+age);<span class="comment">//20</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        test.changeValue2(person);</span><br><span class="line">        System.out.println(<span class="string">&quot;personName----&quot;</span>+person.getPersonName());<span class="comment">//xxx</span></span><br><span class="line"></span><br><span class="line">        String str=<span class="string">&quot;abc&quot;</span>;<span class="comment">//在字符串常量池</span></span><br><span class="line">        <span class="comment">//如果字符串常量池中有直接复用，如果没有，新建</span></span><br><span class="line">        test.changeValue3(str);</span><br><span class="line">        System.out.println(<span class="string">&quot;String-----&quot;</span>+str);<span class="comment">//abc</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="float-与-double"><a href="#float-与-double" class="headerlink" title="float 与 double"></a>float 与 double</h2><p>Java 不能隐式执行向下转型，因为这会使得精度降低。</p>
<p>1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// float f = 1.1;</span></span><br></pre></td></tr></table></figure>

<p>1.1f 字面量才是 float 类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">1.1f</span>;</span><br></pre></td></tr></table></figure>

<h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// s1 = s1 + 1;</span></span><br></pre></td></tr></table></figure>

<p>但是使用 +&#x3D; 或者 ++ 运算符会执行隐式类型转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s1 += <span class="number">1</span>;</span><br><span class="line">s1++;</span><br></pre></td></tr></table></figure>

<p>上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s1 = (<span class="type">short</span>) (s1 + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>


<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;b&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数几个值的类型进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</p>
<h1 id="四、关键字"><a href="#四、关键字" class="headerlink" title="四、关键字"></a>四、关键字</h1><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>1.当用final去修饰一个类的时候，表示这个类不能被继承。<br>2.被final修饰的方法不能被重写.<br>  <strong>注意：</strong><br>  a. 一个类的private方法会隐式的被指定为final方法。<br>  b. 如果父类中有final修饰的方法，那么子类不能去重写。<br>3.修饰成员变量<br>  <strong>注意：</strong><br>  a. 必须要赋初始值，而且是只能初始化一次。<br>  b. 被fianl修饰的成员变量赋值，有两种方式：1、直接赋值 2、全部在构造方法中赋初值。<br>  c. 如果修饰的成员变量是基本类型，则表示这个变量的值不能改变。<br>  d. 如果修饰的成员变量是一个引用类型，则是说这个引用的地址的值不能修改，但是这个引用所指向的对象里面的内容还是可以改变的。<br>。</p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p><strong>1. 静态变量</strong>  </p>
<ul>
<li>静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。</li>
<li>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;         <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> y;  <span class="comment">// 静态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// int x = A.x;  // Non-static field &#x27;x&#x27; cannot be referenced from a static context</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> a.x;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> A.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 静态方法</strong>  </p>
<p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// public abstract static void func2();  // Illegal combination of modifiers: &#x27;abstract&#x27; and &#x27;static&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因此这两个关键字与具体对象关联。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="comment">// int b = y;  // Non-static field &#x27;y&#x27; cannot be referenced from a static context</span></span><br><span class="line">        <span class="comment">// int b = this.y;     // &#x27;A.this&#x27; cannot be referenced from a static context</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 静态语句块</strong>  </p>
<p>静态语句块在类初始化时运行一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">A</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure>

<p><strong>4. 静态内部类</strong>  </p>
<p>非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// InnerClass innerClass = new InnerClass(); // &#x27;OuterClass.this&#x27; cannot be referenced from a static context</span></span><br><span class="line">        <span class="type">OuterClass</span> <span class="variable">outerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">        <span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> outerClass.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        <span class="type">StaticInnerClass</span> <span class="variable">staticInnerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticInnerClass</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态内部类不能访问外部类的非静态的变量和方法。</p>
<p><strong>5. 静态导包</strong>  </p>
<p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.xxx.ClassName.*</span><br></pre></td></tr></table></figure>

<p><strong>6. 初始化顺序</strong>  </p>
<p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">staticField</span> <span class="operator">=</span> <span class="string">&quot;静态变量&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;静态语句块&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">String</span> <span class="variable">field</span> <span class="operator">=</span> <span class="string">&quot;实例变量&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;普通语句块&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后才是构造函数的初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InitialOrderTest</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;构造函数&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在继承的情况下，初始化顺序为：</p>
<ul>
<li>父类（静态变量、静态语句块）</li>
<li>子类（静态变量、静态语句块）</li>
<li>父类（实例变量、普通语句块）</li>
<li>父类（构造函数）</li>
<li>子类（实例变量、普通语句块）</li>
<li>子类（构造函数）</li>
</ul>
<h1 id="五、Object-通用方法"><a href="#五、Object-通用方法" class="headerlink" title="五、Object 通用方法"></a>五、Object 通用方法</h1><h2 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br></pre></td></tr></table></figure>

<h2 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h2><p><strong>1. 等价关系</strong>  </p>
<p>两个对象具有等价关系，需要满足以下五个条件：</p>
<p>Ⅰ 自反性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>Ⅱ 对称性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.equals(y) == y.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>Ⅲ 传递性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x.equals(y) &amp;&amp; y.equals(z))</span><br><span class="line">    x.equals(z); <span class="comment">// true;</span></span><br></pre></td></tr></table></figure>

<p>Ⅳ 一致性</p>
<p>多次调用 equals() 方法结果不变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.equals(y) == x.equals(y); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>Ⅴ 与 null 的比较</p>
<p>对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.equals(<span class="literal">null</span>); <span class="comment">// false;</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 等价与相等</strong>  </p>
<ul>
<li>对于基本类型，&#x3D;&#x3D; 判断两个值是否相等，基本类型没有 equals() 方法。</li>
<li>对于引用类型，&#x3D;&#x3D; 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x == y);      <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 实现</strong>  </p>
<ul>
<li>检查是否为同一个对象的引用，如果是直接返回 true；</li>
<li>检查是否是同一个类型，如果不是，直接返回 false；</li>
<li>将 Object 对象进行转型；</li>
<li>判断每个关键域是否相等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EqualExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EqualExample</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">        <span class="built_in">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">EqualExample</span> <span class="variable">that</span> <span class="operator">=</span> (EqualExample) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x != that.x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (y != that.y) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> z == that.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h2><p>hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。</p>
<p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等。</p>
<p>HashSet  和 HashMap 等集合类使用了 hashCode()  方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode()  方法。</p>
<p>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象。但是 EqualExample 没有实现 hashCode() 方法，因此这两个对象的哈希值是不同的，最终导致集合添加了两个等价的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">EqualExample</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EqualExample</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">EqualExample</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EqualExample</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(e1.equals(e2)); <span class="comment">// true</span></span><br><span class="line">HashSet&lt;EqualExample&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">set.add(e1);</span><br><span class="line">set.add(e2);</span><br><span class="line">System.out.println(set.size());   <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上。这就要求了哈希函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。</p>
<p>R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位，最左边的位丢失。并且一个数与 31 相乘可以转换成移位和减法：<code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">17</span>;</span><br><span class="line">    result = <span class="number">31</span> * result + x;</span><br><span class="line">    result = <span class="number">31</span> * result + y;</span><br><span class="line">    result = <span class="number">31</span> * result + z;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h2><p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToStringExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ToStringExample</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ToStringExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ToStringExample</span>(<span class="number">123</span>);</span><br><span class="line">System.out.println(example.toString());</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">ToStringExample@4554617c</span><br></pre></td></tr></table></figure>

<h2 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h2><p><strong>1. cloneable</strong>  </p>
<p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CloneExample</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CloneExample</span>();</span><br><span class="line"><span class="comment">// CloneExample e2 = e1.clone(); // &#x27;clone()&#x27; has protected access in &#x27;java.lang.Object&#x27;</span></span><br></pre></td></tr></table></figure>

<p>重写 clone() 得到以下实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CloneExample <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (CloneExample)<span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CloneExample</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CloneExample</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">CloneExample</span> <span class="variable">e2</span> <span class="operator">=</span> e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">java.lang.CloneNotSupportedException: CloneExample</span><br></pre></td></tr></table></figure>

<p>以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。</p>
<p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneExample</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 浅拷贝</strong>  </p>
<p>拷贝对象和原始对象的引用类型引用同一个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShallowCloneExample</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ShallowCloneExample</span><span class="params">()</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> ShallowCloneExample <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (ShallowCloneExample) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ShallowCloneExample</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShallowCloneExample</span>();</span><br><span class="line"><span class="type">ShallowCloneExample</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 222</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 深拷贝</strong>  </p>
<p>拷贝对象和原始对象的引用类型引用不同对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeepCloneExample</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DeepCloneExample</span><span class="params">()</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> DeepCloneExample <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">DeepCloneExample</span> <span class="variable">result</span> <span class="operator">=</span> (DeepCloneExample) <span class="built_in">super</span>.clone();</span><br><span class="line">        result.arr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            result.arr[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DeepCloneExample</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeepCloneExample</span>();</span><br><span class="line"><span class="type">DeepCloneExample</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><strong>4. clone() 的替代方案</strong>  </p>
<p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneConstructorExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CloneConstructorExample</span><span class="params">()</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CloneConstructorExample</span><span class="params">(CloneConstructorExample original)</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[original.arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; original.arr.length; i++) &#123;</span><br><span class="line">            arr[i] = original.arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CloneConstructorExample</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CloneConstructorExample</span>();</span><br><span class="line"><span class="type">CloneConstructorExample</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CloneConstructorExample</span>(e1);</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h1 id="六、继承"><a href="#六、继承" class="headerlink" title="六、继承"></a>六、继承</h1><h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><p><img src="/2022/10/24/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/6.png" alt="在这里插入图片描述"></p>
<h2 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h2><p><strong>1. 抽象类</strong>  </p>
<p>抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。</p>
<p>抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClassExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractExtendClassExample</span> <span class="keyword">extends</span> <span class="title class_">AbstractClassExample</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractClassExample ac1 = new AbstractClassExample(); // &#x27;AbstractClassExample&#x27; is abstract; cannot be instantiated</span></span><br><span class="line"><span class="type">AbstractClassExample</span> <span class="variable">ac2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AbstractExtendClassExample</span>();</span><br><span class="line">ac2.func1();</span><br></pre></td></tr></table></figure>

<p><strong>2. 接口</strong>  </p>
<p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p>
<p>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。</p>
<p>接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。</p>
<p>接口的字段默认都是 static 和 final 的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">func2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">    <span class="comment">// int y;               // Variable &#x27;y&#x27; might not have been initialized</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">0</span>;       <span class="comment">// Modifier &#x27;public&#x27; is redundant for interface fields</span></span><br><span class="line">    <span class="comment">// private int k = 0;   // Modifier &#x27;private&#x27; not allowed here</span></span><br><span class="line">    <span class="comment">// protected int l = 0; // Modifier &#x27;protected&#x27; not allowed here</span></span><br><span class="line">    <span class="comment">// private void fun3(); // Modifier &#x27;private&#x27; not allowed here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceImplementExample</span> <span class="keyword">implements</span> <span class="title class_">InterfaceExample</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// InterfaceExample ie1 = new InterfaceExample(); // &#x27;InterfaceExample&#x27; is abstract; cannot be instantiated</span></span><br><span class="line"><span class="type">InterfaceExample</span> <span class="variable">ie2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterfaceImplementExample</span>();</span><br><span class="line">ie2.func1();</span><br><span class="line">System.out.println(InterfaceExample.x);</span><br></pre></td></tr></table></figure>

<p><strong>3. 比较</strong><br>1.抽象类可以没有抽象方法，但接口中的方法必须是抽象方法；<br>2.抽象类中可以存在普通属性，方法，静态属性和方法；<br>3.接口中的变量必须是static final类型的，必须被初始化，只有常亮没有变量；<br>4.抽象类只能单继承，接口可以继承多个父接口。</p>
<p><strong>4. 使用选择</strong>  </p>
<p>如果准备为不相关的类创建一些提供共有功能的东西，请使用接口。<br>抽象类允许你为子类提供默认功能。<br>当创建一个可以被随意更改的独立项目时，使用优先于抽象类的接口，因为它提供更多的设计灵活性。<br>使用接口来引入多态行为而无需子类化并模拟多重继承 - 允许特定类型支持多种行为。</p>
<p>在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</p>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><ul>
<li>访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super() 函数。</li>
<li>访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SuperExample</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperExample.func()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperExtendExample</span> <span class="keyword">extends</span> <span class="title class_">SuperExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SuperExtendExample</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(x, y);</span><br><span class="line">        <span class="built_in">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.func();</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperExtendExample.func()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SuperExample</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuperExtendExample</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">e.func();</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">SuperExample.func()</span><br><span class="line">SuperExtendExample.func()</span><br></pre></td></tr></table></figure>


<h2 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h2><p><strong>1. 重写（Override）</strong>  </p>
<p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。</p>
<p>为了满足里式替换原则，重写有以下三个限制：</p>
<ul>
<li>子类方法的访问权限必须大于等于父类方法；</li>
<li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li>
<li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。</li>
</ul>
<p>使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。</p>
<p>下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中：</p>
<ul>
<li>子类方法访问权限为 public，大于父类的 protected。</li>
<li>子类的返回类型为 ArrayList<Integer>，是父类返回类型 List<Integer> 的子类。</Integer></Integer></li>
<li>子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。</li>
<li>子类重写方法使用 @Override 注解，从而让编译器自动检查是否满足限制条件。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;Integer&gt; <span class="title function_">func</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">func</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：</p>
<ul>
<li>this.func(this)</li>
<li>super.func(this)</li>
<li>this.func(super)</li>
<li>super.func(super)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    A</span></span><br><span class="line"><span class="comment">    |</span></span><br><span class="line"><span class="comment">    B</span></span><br><span class="line"><span class="comment">    |</span></span><br><span class="line"><span class="comment">    C</span></span><br><span class="line"><span class="comment">    |</span></span><br><span class="line"><span class="comment">    D</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(A obj)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A.show(A)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(C obj)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A.show(C)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(A obj)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B.show(A)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">C</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">    <span class="type">D</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">D</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 A 中存在 show(A obj)，直接调用</span></span><br><span class="line">    a.show(a); <span class="comment">// A.show(A)</span></span><br><span class="line">    <span class="comment">// 在 A 中不存在 show(B obj)，将 B 转型成其父类 A</span></span><br><span class="line">    a.show(b); <span class="comment">// A.show(A)</span></span><br><span class="line">    <span class="comment">// 在 B 中存在从 A 继承来的 show(C obj)，直接调用</span></span><br><span class="line">    b.show(c); <span class="comment">// A.show(C)</span></span><br><span class="line">    <span class="comment">// 在 B 中不存在 show(D obj)，但是存在从 A 继承来的 show(C obj)，将 D 转型成其父类 C</span></span><br><span class="line">    b.show(d); <span class="comment">// A.show(C)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用的还是 B 对象，所以 ba 和 b 的调用结果一样</span></span><br><span class="line">    <span class="type">A</span> <span class="variable">ba</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    ba.show(c); <span class="comment">// A.show(C)</span></span><br><span class="line">    ba.show(d); <span class="comment">// A.show(C)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 重载（Overload）</strong>  </p>
<p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。</p>
<p>应该注意的是，返回值不同，其它都相同不算是重载。</p>
<h1 id="七、java程序-编译-运行-Java程序编译和运行的过程"><a href="#七、java程序-编译-运行-Java程序编译和运行的过程" class="headerlink" title="七、java程序 编译 运行_Java程序编译和运行的过程"></a>七、java程序 编译 运行_Java程序编译和运行的过程</h1><p> Java整个编译以及运行的过程相当繁琐，本文通过一个简单的程序来简单的说明整个流程。    </p>
<p>首先两张图，描述编译和执行的过程：</p>
<p>Java代码编译是由Java源码编译器来完成，流程图如下所示：<br><img src="/2022/10/24/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/7.png" alt="在这里插入图片描述"></p>
<p>Java字节码的执行是由JVM执行引擎来完成，流程图如下所示：<br><img src="https://img-blog.csdnimg.cn/20210410013410761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<pre><code> 如上图，Java程序从源文件创建到程序运行要经过两大步骤：1、源文件由编译器编译成字节码（ByteCode）  2、字节码由java虚拟机解释运行。因为java程序既要编译同时也要经过JVM的解释运行，所以说Java被称为半解释语言（ &quot;semi-interpreted&quot; language）。
</code></pre>
<p>图1   java程序编译运行过程</p>
<p>下面通过以下这个java程序，来说明java程序从编译到最后运行的整个流程。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java代码</span><br><span class="line"></span><br><span class="line"><span class="comment">//MainApp.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApp</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;Puppy&quot;</span>);</span><br><span class="line"></span><br><span class="line">animal.printName();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Animal.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printName</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Animal [&quot;</span>+name+<span class="string">&quot;]&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一步(编译): 创建完源文件之后，程序会先被编译为.class文件。Java编译一个类时，如果这个类所依赖的类还没有被编译，编译器就会先编译这个被依赖的类，然后引用，否则直接引用，这个有点象make。如果java编译器在指定目录下找不到该类所其依赖的类的.class文件或者.java源文件的话，编译器话报“cant find symbol”的错误。</p>
<p>编译后的字节码文件格式主要分为两部分：<strong>常量池和方法字节码</strong>。常量池记录的是代码出现过的所有token(类名，成员变量名等等)以及符号引用(方法引用，成员变量引用等等)；方法字节码放的是类中各个方法的字节码。下面是MainApp.class通过反汇编的结果，我们可以清楚看到.class文件的结构：</p>
<p> MainApp类常量池<br><img src="/2022/10/24/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/8.png" alt="在这里插入图片描述"></p>
<p>MainApp类方法字节码<br><img src="/2022/10/24/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/9.png" alt="在这里插入图片描述"></p>
<p>第二步(运行)：java类运行的过程大概可分为两个过程：<strong>1、类的加载  2、类的执行。</strong>需要说明的是：JVM主要在程序第一次主动使用类的时候，才会去加载该类。也就是说，JVM并不是在一开始就把一个程序就所有的类都加载到内存中，而是到不得不用的时候才把它加载进来，而且只加载一次。</p>
<p>下面是程序运行的详细步骤：</p>
<p>在编译好java程序得到MainApp.class文件后，在命令行上敲java AppMain。系统就会启动一个jvm进程，jvm进程从classpath路径中找到一个名为AppMain.class的二进制文件，将MainApp的类信息加载到运行时数据区的方法区内，这个过程叫做MainApp类的加载。</p>
<p>然后JVM找到AppMain的主函数入口，开始执行main函数。</p>
<p>main函数的第一条命令是Animal  animal &#x3D; new Animal(“Puppy”);就是让JVM创建一个Animal对象，但是这时候方法区中没有Animal类的信息，所以JVM马上加载Animal类，把Animal类的类型信息放到方法区中。</p>
<p>加载完Animal类之后，Java虚拟机做的第一件事情就是在堆区中为一个新的Animal实例分配内存, 然后调用构造函数初始化Animal实例，这个Animal实例持有着指向方法区的Animal类的类型信息(其中包含有方法表，java动态绑定的底层实现)的引用。</p>
<p>当使用animal.printName()的时候，JVM根据animal引用找到Animal对象，然后根据Animal对象持有的引用定位到方法区中Animal类的类型信息的方法表，获得printName()函数的字节码的地址。</p>
<p>开始运行printName()函数。</p>
<p>java程序运行过程<br><img src="/2022/10/24/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/10.png" alt="在这里插入图片描述"></p>
<p>Java类中所有public和protected的实例方法都采用动态绑定机制，所有私有方法、静态方法、构造器及初始化方法都是采用静态绑定机制。而使用动态绑定机制的时候会用到方法表，静态绑定时并不会用到。</p>
<p>Java初始化一个类的时候可以用new 操作符来初始化,也可通过Class.forName的方式来得到一个Class类型的实例,然后通过这个Class类型的实例的newInstance来初始化.我们把前者叫做JAVA的静态加载,把后者叫做动态加载.。</p>
<h2 id="八、反射"><a href="#八、反射" class="headerlink" title="八、反射"></a>八、反射</h2><p>每个类都有一个 <strong>Class</strong> 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p>
<p>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p>
<p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p>
<p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p>
<ul>
<li><strong>Field</strong> ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li>
<li><strong>Method</strong> ：可以使用 invoke() 方法调用与 Method 对象关联的方法；</li>
<li><strong>Constructor</strong> ：可以用 Constructor 的 newInstance() 创建新的对象。</li>
</ul>
<p><strong>反射的优点：</strong></p>
<ul>
<li><strong>可扩展性</strong> ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。</li>
<li><strong>类浏览器和可视化开发环境</strong> ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。</li>
<li><strong>调试器和测试工具</strong> ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。</li>
</ul>
<p><strong>反射的缺点：</strong></p>
<p>尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。</p>
<ul>
<li><strong>性能开销</strong> ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。</li>
<li><strong>安全限制</strong> ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。</li>
<li><strong>内部暴露</strong> ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。</li>
</ul>
<h1 id="九、异常"><a href="#九、异常" class="headerlink" title="九、异常"></a>九、异常</h1><p>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： <strong>Error</strong> 和 <strong>Exception</strong>。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：</p>
<ul>
<li><strong>受检异常</strong> ：需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复；</li>
<li><strong>非受检异常</strong> ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。<br><img src="/2022/10/24/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/11.png" alt="在这里插入图片描述"></li>
</ul>
<p><img src="/2022/10/24/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/12.png" alt="在这里插入图片描述"></p>
<h1 id="十、泛型"><a href="#十、泛型" class="headerlink" title="十、泛型"></a>十、泛型</h1><ol>
<li>Java中的泛型是什么 ? 使用泛型的好处是什么?</li>
</ol>
<p>　　这是在各种Java泛型面试中，<strong>参数化类型</strong>，一开场你就会被问到的问题中的一个，主要集中在初级和中级面试中。那些拥有Java1.4或更早版本的开发背景的人都知道，在集合中存储对象并在使用前进行类型转换是多么的不方便。泛型防止了那种情况的发生。它提供了编译期的类型安全，确保你只能把正确类型的对象放入集合中，避免了在运行时出现ClassCastException。</p>
<ol start="2">
<li>Java的泛型是如何工作的 ? 什么是类型擦除 ?</li>
</ol>
<p>　　这是一道更好的泛型面试题。泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如List<String>在运行时仅用一个List来表示。这样做的目的，是确保能和Java 5之前的版本开发二进制类库进行兼容。你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型。</String></p>
<ol start="3">
<li>什么是泛型中的限定通配符和非限定通配符 ?</li>
</ol>
<p>　　这是另一个非常流行的Java泛型面试题。限定通配符对类型进行了限制。有两种限定通配符，一种是<? extends T>它通过确保类型必须是T的子类来设定类型的上界，另一种是<? super T>它通过确保类型必须是T的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。另一方面<?>表示了非限定通配符，因为&lt;?&gt;可以用任意类型来替代；</p>
<ol start="4">
<li>List&lt;? extends T&gt;和List &lt;? super T&gt;之间有什么区别 ?</li>
</ol>
<p>　　这和上一个面试题有联系，有时面试官会用这个问题来评估你对泛型的理解，而不是直接问你什么是限定通配符和非限定通配符。这两个List的声明都是限定通配符的例子，List&lt;? extends T&gt;可以接受任何继承自T的类型的List，而List&lt;? super T&gt;可以接受任何T的父类构成的List。例如List&lt;? extends Number&gt;可以接受List<Integer>或List<Float>。</Float></Integer></p>
<h1 id="十一、Java-与-C-的区别"><a href="#十一、Java-与-C-的区别" class="headerlink" title="十一、Java 与 C++ 的区别"></a>十一、Java 与 C++ 的区别</h1><ul>
<li>Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。</li>
<li>Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。</li>
<li>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。</li>
<li>Java 支持自动垃圾回收，而 C++ 需要手动回收。</li>
<li>Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。</li>
<li>Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。</li>
<li>Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。</li>
</ul>
<h1 id="十二、JRE-or-JDK"><a href="#十二、JRE-or-JDK" class="headerlink" title="十二、JRE or JDK"></a>十二、JRE or JDK</h1><ul>
<li>JRE：Java Runtime Environment，java运行环境的简称，为java的运行提供了所需的环境。主要包括了JVM的标准实现和一些java基本类库。</li>
<li>JDK：Java Development Kit，java开发工具包，提供了java的开发及运行环境。JDK是java开发的核心，集成了JRE以及一些其他的工具，比如编译 java 源码的编译器 javac等。</li>
<li>因此可以这样认为：JDK&gt;JRE&gt;JVM，JRE支持了java程序的运行，而JDK则同时支持了java程序的开发。</li>
</ul>
<h1 id="十三、标识符"><a href="#十三、标识符" class="headerlink" title="十三、标识符"></a>十三、标识符</h1><p>标识符可以包含 英文字母26个(区分大小写) 、 0-9数字 、 $（美元符号） 和 _（下划线） 。<br>标识符不能以数字开头。<br>标识符不能是关键字。</p>
<h1 id="十三、编码"><a href="#十三、编码" class="headerlink" title="十三、编码"></a>十三、编码</h1><p><strong>Java中汉字占几个字节？</strong><br>可能占2、3、4个字节，看编码格式  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UtfTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 第二个字符为BMP之外的字符，csdn编辑器无法显示该字符，可以在运行结果截图中看到</span></span><br><span class="line">        String[] strArr = &#123;<span class="string">&quot;中&quot;</span>, <span class="string">&quot;鼍&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;aa&quot;</span>&#125;;</span><br><span class="line">        String[] charsetArr = &#123;<span class="string">&quot;gbk&quot;</span>, <span class="string">&quot;utf-8&quot;</span>, <span class="string">&quot;utf-16&quot;</span>, <span class="string">&quot;gb2312&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(String str : strArr) &#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">            <span class="keyword">for</span>(String charset : charsetArr) &#123;</span><br><span class="line">                byteTest(str, charset);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;============================&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">byteTest</span><span class="params">(String str, String charset)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;编码：&quot;</span> + charset</span><br><span class="line">                + <span class="string">&quot;\t所占字节数：&quot;</span> + str.getBytes(charset).length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 中</span></span><br><span class="line"><span class="comment">编码：gbk	所占字节数：2</span></span><br><span class="line"><span class="comment">编码：utf-8	所占字节数：3</span></span><br><span class="line"><span class="comment">编码：utf-16	所占字节数：4</span></span><br><span class="line"><span class="comment">编码：gb2312	所占字节数：2</span></span><br><span class="line"><span class="comment">============================</span></span><br><span class="line"><span class="comment">鼍</span></span><br><span class="line"><span class="comment">编码：gbk	所占字节数：2</span></span><br><span class="line"><span class="comment">编码：utf-8	所占字节数：3</span></span><br><span class="line"><span class="comment">编码：utf-16	所占字节数：4</span></span><br><span class="line"><span class="comment">编码：gb2312	所占字节数：2</span></span><br><span class="line"><span class="comment">============================</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">编码：gbk	所占字节数：1</span></span><br><span class="line"><span class="comment">编码：utf-8	所占字节数：1</span></span><br><span class="line"><span class="comment">编码：utf-16	所占字节数：4</span></span><br><span class="line"><span class="comment">编码：gb2312	所占字节数：1</span></span><br><span class="line"><span class="comment">============================</span></span><br><span class="line"><span class="comment">aa</span></span><br><span class="line"><span class="comment">编码：gbk	所占字节数：2</span></span><br><span class="line"><span class="comment">编码：utf-8	所占字节数：2</span></span><br><span class="line"><span class="comment">编码：utf-16	所占字节数：6</span></span><br><span class="line"><span class="comment">编码：gb2312	所占字节数：2</span></span><br><span class="line"><span class="comment">============================</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure>

<h1 id="十四、内部类"><a href="#十四、内部类" class="headerlink" title="十四、内部类"></a>十四、内部类</h1><p>1.为什么使用内部类?<br>使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。<br>1.1.使用内部类最大的优点就在于它能够非常好的解决多重继承的问题,使用内部类还能够为我们带来如下特性:<br>(1)内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。<br>(2)在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。<br>(3)创建内部类对象的时刻并不依赖于外围类对象的创建。<br>(4)内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。<br>(5)内部类提供了更好的封装，除了该外围类，其他类都不能访问。  </p>
<h3 id="2-内部类分类"><a href="#2-内部类分类" class="headerlink" title="2.内部类分类:"></a>2.内部类分类:</h3><p><strong>(一).成员内部类:</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">	<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Coco&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Jayden&quot;</span>;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(Outer.<span class="built_in">this</span>.name);</span><br><span class="line">		System.out.println(name);</span><br><span class="line">		System.out.println(age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Inner <span class="title function_">getInnerClass</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	<span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">	<span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> o.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">	in.show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.Inner 类定义在 Outer 类的内部，相当于 Outer 类的一个成员变量的位置，Inner 类可以使用任意访问	控制符，如 public 、 protected 、 private 等；<br>2.Inner 类中定义的 show() 方法可以直接访问 Outer 类中的数据，而不受访问控制符的影响，如直接访问 Outer 类中的私有属性age；<br>3.定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去 new 一个内部类对象，即：内部类 对象名 &#x3D; 外部类对象.new 内部类( );<br>4.编译上面的程序后，会发现产生了两个 .class 文件: Outer.class,Outer$Inner.class{}<br>5.成员内部类中不能存在任何 static 的变量和方法,可以定义常量:<br>   (1)因为非静态内部类是要依赖于外部类的实例,而静态变量和方法是不依赖于对象的,仅与类相关,<br>    简而言之:在加载静态域时,根本没有外部类,所在在非静态内部类中不能定义静态域或方法,编译不通过;<br>   非静态内部类的作用域是实例级别；<br>   (2)常量是在编译器就确定的,放到所谓的常量池了；<br><strong>★★友情提示:</strong><br>1.外部类是不能直接使用内部类的成员和方法的，可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法;<br>2.如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量,可以使用 this 关键字,如:Outer.this.name  </p>
<p><strong>(二).静态内部类: 是 static 修饰的内部类</strong><br>1.静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问;<br>2.如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员,如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员;<br>3.创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名 &#x3D; new 内部类();  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Coco&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Jayden&quot;</span>;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">			System.out.println(Outer.name);</span><br><span class="line">			System.out.println(name); </span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	<span class="type">Inner</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">	i.show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(三).方法内部类：</strong><br>其作用域仅限于方法内，方法外部无法访问该内部类<br>(1)局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的；<br>(2)只能访问方法中定义的 final 类型的局部变量,因为:<br>  当方法被调用运行完毕之后，局部变量就已消亡了。但内部类对象可能还存在,直到没有被引用时才会消亡。此时就会出现一种情况，就是内部类要访问一个不存在的局部变量;<br>&#x3D;&#x3D;&gt;使用final修饰符不仅会保持对象的引用不会改变,而且编译器还会持续维护这个对象在回调方法中的生命周期.<br>局部内部类并不是直接调用方法传进来的参数，而是内部类将传进来的参数通过自己的构造器备份到了自己的内部，自己内部的方法调用的实际是自己的属性而不是外部类方法的参数;<br>防止被篡改数据,而导致内部类得到的值不一致<br>   &#x2F;*<br>使用的形参为何要为 final???<br> 在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，也就是说在内部类中我对属性的改变并不会影响到外部的形参，而然这从程序员的角度来看这是不可行的， 毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定使用 final 来避免形参的不改变<br> *&#x2F;    </p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">25</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">13</span>;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;访问外部类:&quot;</span> + a);</span><br><span class="line">	System.out.println(<span class="string">&quot;访问内部类:&quot;</span> + c);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Inner</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">i.print();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">  <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">   o.show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>(3).注意:在JDK8版本之中,方法内部类中调用方法中的局部变量,可以不需要修饰为 final,匿名内部类也是一样的，主要是JDK8之后增加了 Effectively final 功能</p>
<p><a href="http://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html">http://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html</a>  </p>
<p>反编译jdk8编译之后的class文件,发现内部类引用外部的局部变量都是 final 修饰的  </p>
<p><strong>(四).匿名内部类:</strong> </p>
<p>(1).匿名内部类是直接使用 new 来生成一个对象的引用;<br>(2).对于匿名内部类的使用它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例,该类的定义会立即消失，所以匿名内部类是不能够被重复使用;<br>(3).使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口;<br>(4).匿名内部类中是不能定义构造函数的,匿名内部类中不能存在任何的静态成员变量和静态方法;<br>(5).匿名内部类中不能存在任何的静态成员变量和静态方法,匿名内部类不能是抽象的,它必须要实现继承的类或者实现的接口的所有抽象方法<br>(6).匿名内部类初始化:使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">          <span class="keyword">public</span> InnerClass <span class="title function_">getInnerClass</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span>   num,String str2)</span>&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InnerClass</span>()&#123;</span><br><span class="line">                  <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> num + <span class="number">3</span>;</span><br><span class="line">                  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span>&#123;</span><br><span class="line">                      <span class="keyword">return</span> number;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;;        <span class="comment">/* 注意：分号不能省 */</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">              <span class="type">OuterClass</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">              <span class="type">InnerClass</span> <span class="variable">inner</span> <span class="operator">=</span> out.getInnerClass(<span class="number">2</span>, <span class="string">&quot;chenssy&quot;</span>);</span><br><span class="line">              System.out.println(inner.getNumber());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">interface</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">          <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span>;</span><br><span class="line">      &#125;   </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="十五、Comparable和Comparator"><a href="#十五、Comparable和Comparator" class="headerlink" title="十五、Comparable和Comparator"></a>十五、Comparable和Comparator</h1><p>Comparable的代码如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T o)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Comparator的代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jdk1.8 后的方法</span></span><br><span class="line">    <span class="keyword">default</span> Comparator&lt;T&gt; <span class="title function_">reversed</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.reverseOrder(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Comparable和Comparator的主要区别在于：</p>
<p>　　(1).Comparator 和 Comparable都是Java中的内部比较器接口，都是用来实现对一个自定义的类进行排序</p>
<p>　　(2). 不同的是实现Comparable接口是定义在类的内部，比较代码需要嵌入类的内部结构中</p>
<p>　　(3).  Comparator 实现在类的外部，单独实现第一个比较器，不需要对原来的类进行结构上的变化，属于无侵入式的。<br>    (4).Comparator更加符合开闭原则，对修改关闭，对扩展开放</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Score</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Score&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> score;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTime</span><span class="params">(<span class="type">int</span> time)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.time = time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Score</span><span class="params">(<span class="type">int</span> score, <span class="type">int</span> time)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">        <span class="built_in">this</span>.time = time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Score o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.time&gt;o.time) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.time==o.time) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Score&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;score=&quot;</span> + score +</span><br><span class="line">                <span class="string">&quot;, time=&quot;</span> + time +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScoreComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Score&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Score o1, Score o2)</span> &#123;</span><br><span class="line">       <span class="comment">/* if(o1.time&gt;o2.time) return 1;</span></span><br><span class="line"><span class="comment">        else if(o1.time==o2.time) return 0;</span></span><br><span class="line"><span class="comment">        else return -1;*/</span></span><br><span class="line">       <span class="keyword">return</span> o1.score-o2.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScoreTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Score</span> <span class="variable">score</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Score</span>(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="type">Score</span> <span class="variable">score1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Score</span>(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">        <span class="type">Score</span> <span class="variable">score2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Score</span>(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">        <span class="type">Score</span> <span class="variable">score3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Score</span>(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="type">Score</span> <span class="variable">score4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Score</span>(<span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line">        Score[] help=<span class="keyword">new</span> <span class="title class_">Score</span>[]&#123;score,score1,score2,score3,score4&#125;;</span><br><span class="line">        Arrays.sort(help,<span class="keyword">new</span> <span class="title class_">ScoreComparator</span>());</span><br><span class="line">        System.out.println(Arrays.toString(help));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="十六、序列化和反序列化"><a href="#十六、序列化和反序列化" class="headerlink" title="十六、序列化和反序列化"></a>十六、序列化和反序列化</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User1</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User1&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializableDemo1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception, IOException &#123;</span><br><span class="line">        <span class="comment">//初始化对象</span></span><br><span class="line">        <span class="type">User1</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User1</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;tanglilei&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">23</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="comment">//序列化对象到文件中</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;template&quot;</span>));</span><br><span class="line">        oos.writeObject(user);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line"><span class="comment">//        File file = new File(&quot;template&quot;);</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;template&quot;</span>));</span><br><span class="line">        <span class="type">User1</span> <span class="variable">newUser</span> <span class="operator">=</span> (User1) ois.readObject();</span><br><span class="line">        System.out.println(newUser.toString());</span><br><span class="line"><span class="comment">/*        File file = new File(&quot;template&quot;);</span></span><br><span class="line"><span class="comment">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file));</span></span><br><span class="line"><span class="comment">        User1 newUser = (User1)ois.readObject();</span></span><br><span class="line"><span class="comment">        System.out.println(newUser.toString());*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程池实现原理及业务实践</title>
    <url>/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="线程池讲解"><a href="#线程池讲解" class="headerlink" title="线程池讲解"></a>线程池讲解</h2><p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/1.png" alt="图片"></p>
<p>我们知道，线程需要的时候要进行创建，不需要的时候需要进行销毁，但是线程的创建和销毁都是一个开销比较大的操作。</p>
<blockquote>
<p>为什么开销大呢？</p>
</blockquote>
<p>虽然我们程序员创建一个线程很容易，直接使用 new Thread() 创建就可以了，但是操作系统做的工作会多很多，它需要发出 <code>系统调用</code>，陷入内核，调用内核 API 创建线程，为线程分配资源等，这一些操作有很大的开销。</p>
<p>所以，在高并发大流量的情况下，频繁的创建和销毁线程会大大拖慢响应速度，那么有什么能够提高响应速度的方式吗？方式有很多，尽量避免线程的创建和销毁是一种提升性能的方式，也就是把线程 <code>复用</code> 起来，因为性能是我们日常最关注的因素。</p>
<p>线程池解决的核心问题就是资源管理问题。在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来以下若干问题：</p>
<ol>
<li>频繁申请&#x2F;销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。</li>
<li>对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。</li>
<li>系统无法合理管理内部的资源分布，会降低系统的稳定性。</li>
</ol>
<p>为解决资源分配这个问题，线程池采用了“池化”（Pooling）思想。池化，顾名思义，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。</p>
<p>本篇文章我们先来通过认识一下 Executor 框架、然后通过描述线程池的基本概念入手、逐步认识线程池的核心类，然后慢慢进入线程池的原理中，带你一步一步理解线程池。</p>
<p>在 Java 中可以通过线程池来达到这样的效果。今天我们就来详细讲解一下 Java 的<code>线程池</code>。</p>
<p>使用线程池可以带来一系列好处：</p>
<ul>
<li><strong>降低资源消耗</strong>：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。</li>
<li><strong>提高响应速度</strong>：任务到达时，无需等待线程创建即可立即执行。</li>
<li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。</li>
<li><strong>提供更多更强大的功能</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</li>
</ul>
<h2 id="Executor-框架"><a href="#Executor-框架" class="headerlink" title="Executor 框架"></a>Executor 框架</h2><p>为什么要先说一下 Executor 呢？因为我认为 Executor 是线程池的一个驱动，我们平常创建并执行线程用的一般都是 new Thread().start() 这个方法，这个方法更多强调 <strong>创建一个线程并开始运行</strong>。而我们后面讲到创建线程池更多体现在<strong>驱动执行</strong>上。</p>
<p>Executor 的总体框架如下，我们下面会对 Executor 框架中的每个类进行介绍。</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/2.png" alt="图片"></p>
<p>我们首先来认识一下 Executor</p>
<h3 id="Executor-接口"><a href="#Executor-接口" class="headerlink" title="Executor 接口"></a>Executor 接口</h3><p>Executor 是 <code>java.util.concurrent</code> 的顶级接口，这个接口只有一个方法，那就是 <code>execute</code> 方法。我们平常创建并启动线程会使用 <code>new Thread().start()</code> ，而 Executor 中的 execute 方法替代了显示创建线程的方式。Executor 的设计初衷就是将任务提交和任务执行细节进行解藕。使用 Executor 框架，你可以使用如下的方式创建线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.xxx <span class="comment">// xxx 其实就是 Executor 的实现类，我们后面会说</span></span><br><span class="line">executor.execute(<span class="keyword">new</span> <span class="title class_">RunnableTask1</span>());</span><br><span class="line">executor.execute(<span class="keyword">new</span> <span class="title class_">RunnableTask2</span>());</span><br></pre></td></tr></table></figure>

<p>execute方法接收一个 <code>Runnable</code> 实例，它用来执行一个任务，而任务就是一个实现了 Runnable 接口的类，但是 execute 方法不能接收实现了 <code>Callable</code> 接口的类，也就是说，execute 方法不能接收具有返回值的任务。</p>
<p>execute 方法创建的线程是异步执行的，也就是说，你不用等待每个任务执行完毕后再执行下一个任务。</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/3.png" alt="图片"></p>
<p>比如下面就是一个简单的使用 Executor 创建并执行线程的示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor(); <span class="comment">// 你可能不太理解这是什么意思，我们后面会说。</span></span><br><span class="line">        executor.execute(<span class="keyword">new</span> <span class="title class_">RunnableTask</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Executor 就相当于是族长，大佬只发号令，族长让你异步执行你就得异步执行，族长说不用<code>汇报</code>任务你就不用回报，但是这个族长管的事情有点少，所以除了 Executor 之外，我们还需要认识其他管家，比如说管你这个线程啥时候终止，啥时候暂停，判断你这个线程当前的状态等，<code>ExecutorService</code> 就是一位大管家。</p>
<h3 id="ExecutorService-接口"><a href="#ExecutorService-接口" class="headerlink" title="ExecutorService 接口"></a>ExecutorService 接口</h3><p>ExecutorService 也是一个接口，它是 Executor 的拓展，提供了一些 Executor 中没有的方法，下面我们来介绍一下这些方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p><code>shutdown</code> 方法调用后，ExecutorService 会有序关闭正在执行的任务，但是不接受新任务。如果任务已经关闭，那么这个方法不会产生任何影响。</p>
<p>ExecutorService 还有一个和 shutdown 方法类似的方法是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p><code>shutdownNow</code> 会尝试停止关闭所有正在执行的任务，停止正在等待的任务，并返回正在等待执行的任务列表。</p>
<blockquote>
<p>既然 shutdown 和 shutdownNow 这么相似，那么二者有啥区别呢？</p>
<ul>
<li>shutdown 方法只是会将<code>线程池</code>的状态设置为 <code>SHUTWDOWN</code> ，正在执行的任务会继续执行下去，线程池会等待任务的执行完毕，而没有执行的线程则会中断。</li>
<li>shutdownNow 方法会将线程池的状态设置为 <code>STOP</code>，正在执行和等待的任务则被停止，返回等待执行的任务列表</li>
</ul>
</blockquote>
<p>ExecutorService 还有三个判断线程状态的方法，分别是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isShutdown</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isTerminated</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">awaitTermination</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>isShutdown</code> 方法表示执行器是否已经关闭，如果已经关闭，返回 true，否则返回 false。</li>
<li><code>isTerminated</code> 方法表示判断所有任务再关闭后是否已完成，如果完成返回 false，这个需要注意一点，除非首先调用 shutdown 或者 shutdownNow 方法，否则 isTerminated 方法永远不会为 true。</li>
<li><code>awaitTermination</code> 方法会阻塞，直到发出调用 shutdown 请求后所有的任务已经完成执行后才会解除。这个方法不是非常容易理解，下面通过一个小例子来看一下。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    executorService.submit(() -&gt; &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName());</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  executorService.shutdown();</span><br><span class="line">  System.out.println(<span class="string">&quot;Waiting...&quot;</span>);</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">isTermination</span> <span class="operator">=</span> executorService.awaitTermination(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">  System.out.println(<span class="string">&quot;Waiting...Done&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(isTermination)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;All Thread Done&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在调用 executorService.shutdown() 之后，所有线程完成任务，isTermination 返回 true，程序才会打印出 All Thread Done ，如果注释掉 executorService.shutdown() 或者在任务没有完成后 awaitTermination 就超时了，那么 isTermination 就会返回 false。</p>
<p>ExecutorService 当大管家还有一个原因是因为它不仅能够包容 Runnable 对象，还能够接纳 <code>Callable</code> 对象。在 ExecutorService 中，<code>submit</code> 方法扮演了这个角色。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span>;</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>

<p>submit 方法会返回一个 <code>Future</code>对象，<code>&lt;T&gt;</code> 表示范型，它是对 Callable 产生的返回值来说的，submit 方法提交的任务中的 call 方法如果返回 Integer，那么 submit 方法就返回 <code>Future&lt;Integer&gt;</code>，依此类推。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                                  <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>

<p><code>invokeAll</code> 方法用于执行给定的任务结合，执行完成后会返回一个任务列表，任务列表每一项是一个任务，每个任务会包括任务状态和执行结果，同样 invokeAll 方法也会返回 Future 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">&lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                    <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br></pre></td></tr></table></figure>

<p>invokeAny 会获得最先完成任务的结果，即<code>Callable&lt;T&gt;</code> 接口中的 call 的返回值，<strong>在获得结果时，会中断其他正在执行的任务</strong>，具有<code>阻塞性</code>。</p>
<p>大管家的职责相对于组长来说标准更多，管的事情也比较宽，但是大管家毕竟也是家族的中流砥柱，他不会做具体的活，他的下面有各个干将，干将是一个家族的核心，他负责完成大管家的工作。</p>
<h3 id="AbstractExecutorService-抽象类"><a href="#AbstractExecutorService-抽象类" class="headerlink" title="AbstractExecutorService 抽象类"></a>AbstractExecutorService 抽象类</h3><p>AbstractExecutorService 是一个抽象类，它实现了 ExecutorService 中的部分方法，它相当一个干将，会分析大管家有哪些要做的工作，然后针对大管家的要求做一些具体的规划，然后找他的得力助手 <code>ThreadPoolExecutor</code> 来完成目标。</p>
<p>AbstractExecutorService 这个抽象类主要实现了 <code>invokeAll</code> 和 <code>invokeAny</code> 方法，关于这两个方法的源码分析我们会在后面进行解释。</p>
<h3 id="ScheduledExecutorService-接口"><a href="#ScheduledExecutorService-接口" class="headerlink" title="ScheduledExecutorService 接口"></a>ScheduledExecutorService 接口</h3><p>ScheduledExecutorService 也是一个接口，它扩展了 ExecutorService 接口，提供了 ExecutorService 接口所没有的功能，ScheduledExecutorService 顾名思义就是一个<code>定时执行器</code>，定时执行器可以安排命令在一定延迟时间后运行或者定期执行。</p>
<p>它主要有三个接口方法，一个重载方法。下面我们先来看一下这两个重载方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class="line">                                       <span class="type">long</span> delay, TimeUnit unit);</span><br><span class="line"><span class="keyword">public</span> &lt;V&gt; ScheduledFuture&lt;V&gt; <span class="title function_">schedule</span><span class="params">(Callable&lt;V&gt; callable,</span></span><br><span class="line"><span class="params">                                           <span class="type">long</span> delay, TimeUnit unit)</span>;</span><br></pre></td></tr></table></figure>

<p><code>schedule</code> 方法能够延迟一定时间后执行任务，并且只能执行一次。可以看到，schedule 方法也返回了一个 <code>ScheduledFuture</code> 对象，ScheduledFuture 对象扩展了 Future 和 Delayed 接口，它表示异步延迟计算的结果。schedule 方法支持零延迟和负延迟，这两类值都被视为立即执行任务。</p>
<p>还有一点需要说明的是，schedule 方法能够接收相对的时间和周期作为参数，而不是固定的日期，你可以使用 <strong>date.getTime - System.currentTimeMillis()</strong> 来得到相对的时间间隔。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                                  <span class="type">long</span> initialDelay,</span><br><span class="line">                                                  <span class="type">long</span> period,</span><br><span class="line">                                                  TimeUnit unit);</span><br></pre></td></tr></table></figure>

<p>scheduleAtFixedRate 表示任务会根据固定的速率在时间 <code>initialDelay</code> 后不断地执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                     <span class="type">long</span> initialDelay,</span><br><span class="line">                                                     <span class="type">long</span> delay,</span><br><span class="line">                                                     TimeUnit unit);</span><br></pre></td></tr></table></figure>

<p>这个方法和上面的方法很类似，它表示的是以固定延迟时间的方式来执行任务。</p>
<blockquote>
<p>scheduleAtFixedRate 和 scheduleWithFixedDelay 这两个方法容易混淆，下面我们通过一个示例来说明一下这两个方法的区别。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">command</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">&quot;current timestamp = &quot;</span> + startTime);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">100</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;time spend = &quot;</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledExecutorService</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(command,<span class="number">100</span>,<span class="number">1000</span>,TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果大致如下</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/4.png" alt="图片"></p>
<p>可以看到，每次打印出来 current timestamp 的时间间隔大约等于 1000 毫秒，所以可以断定 <code>scheduleAtFixedRate</code> 是以恒定的速率来执行任务的。</p>
<p>然后我们再看一下 <code>scheduleWithFixedDelay</code> 方法，和上面测试类一样，只不过我们把 scheduleAtFixedRate 换为了 scheduleWithFixedDelay 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">scheduledExecutorService.scheduleWithFixedDelay(command,<span class="number">10</span>,<span class="number">1000</span>,TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>

<p>然后观察一下输出结果</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/5.png" alt="图片"></p>
<p>可以看到，两个 current timestamp 之间的间隔大约等于 1000(固定时间) + delay(time spend) 的总和，由此可以确定 <code>scheduleWithFixedDelay</code> 是以固定时延来执行的。</p>
<h2 id="线程池的描述"><a href="#线程池的描述" class="headerlink" title="线程池的描述"></a>线程池的描述</h2><p>下面我们先来认识一下什么是线程池，线程池从概念上来看就是一个<code>池子</code>，什么池子呢？是指管理同一组工作线程的池子，也就是说，线程池会统一管理内部的工作线程。</p>
<p>wiki 上说，线程池其实就是一种软件设计模式，这种设计模式用于实现计算机程序中的并发。</p>
<p>比如下面就是一个简单的线程池概念图。</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/6.png" alt="图片"></p>
<blockquote>
<p>注意：这个图只是一个概念模型，不是真正的线程池实现，希望读者不要混淆。</p>
</blockquote>
<p>可以看到，这种其实也相当于是<strong>生产者-消费者</strong>模型，任务队列中的线程会进入到线程池中，由线程池进行管理，线程池中的一个个线程就是工作线程，工作线程执行完毕后会放入完成队列中，代表已经完成的任务。</p>
<p>上图有个缺点，那就是队列中的线程执行完毕后就会销毁，销毁就会产生性能损耗，降低响应速度，而我们使用线程池的目的往往是需要把线程重用起来，提高程序性能。</p>
<p>所以我们应该把执行完成后的工作线程重新利用起来，等待下一次使用。</p>
<h3 id="线程池创建"><a href="#线程池创建" class="headerlink" title="线程池创建"></a>线程池创建</h3><p>我们上面大概聊了一下什么线程池的基本执行机制，你知道了线程是如何复用的，那么任何事物不可能是凭空出现的，线程也一样，那么它是如何创建出来的呢？下面就不得不提一个工具类，那就是 <code>Executors</code>。</p>
<p>Executors 也是<code>java.util.concurrent</code> 包下的成员，它是一个创建线程池的工厂，可以使用静态工厂方法来创建线程池，下面就是 Executors 所能够创建线程池的具体类型。</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/7.png" alt="图片"></p>
<ul>
<li><code>newFixedThreadPool</code>：newFixedThreadPool 将会创建固定数量的线程池，这个数量可以由程序员通过创建 <code>Executors.newFixedThreadPool(int nThreads)</code>时手动指定，每次提交一个任务就会创建一个线程，在任何时候，nThreads 的值是最多允许活动的线程。如果在所有线程都处于活跃状态时有额外的任务被创建，这些新创建的线程会进入等待队列等待线程调度。如果有任何线程由于执行期间出现意外导致<code>线程终止</code>，那么在执行后续任务时会使用等待队列中的线程进行替代。</li>
<li><code>newWorkStealingPool</code>：newWorkStealingPool 是 JDK1.8 新增加的线程池，它是基于 <code>fork-join</code> 机制的一种线程池实现，使用了 <code>Work-Stealing</code> 算法。newWorkStealingPool 会创建足够的线程来支持并行度，会使用多个队列来减少竞争。work-stealing pool 线程池不会保证提交任务的执行顺序。</li>
<li><code>newSingleThreadExecutor</code>：newSingleThreadExecutor 是一个单线程的执行器，它只会创建<code>单个</code>线程来执行任务，如果这个线程异常结束，则会创建另外一个线程来替代。newSingleThreadExecutor 会确保任务在任务队列中的执行次序，也就是说，任务的执行是 <code>有序的</code>。</li>
<li><code>newCachedThreadPool</code>：newCachedThreadPool 会根据实际需要创建一个可缓存的线程池。如果线程池的线程数量超过实际需要处理的任务，那么 newCachedThreadPool 将会回收多余的线程。如果实际需要处理的线程不能满足任务的数量，则回你添加新的线程到线程池中，线程池中线程的数量不存在任何限制。</li>
<li><code>newSingleThreadScheduledExecutor</code>：newSingleThreadScheduledExecutor 和 newSingleThreadExecutor 很类似，只不过带有 scheduled 的这个执行器哥们能够在一定延迟后执行或者定期执行任务。</li>
<li><code>newScheduledThreadPool</code>：这个线程池和上面的 scheduled 执行器类似，只不过 newSingleThreadScheduledExecutor 比 newScheduledThreadPool 多加了一个 <code>DelegatedScheduledExecutorService</code> 代理，这其实包装器设计模式的体现。</li>
</ul>
<p>上面这些线程池的底层实现都是由 ThreadPoolExecutor 来提供支持的，所以要理解这些线程池的工作原理，你就需要先把 ThreadPoolExecutor 搞明白，下面我们就来聊一聊 ThreadPoolExecutor。</p>
<h2 id="ThreadPoolExecutor-类"><a href="#ThreadPoolExecutor-类" class="headerlink" title="ThreadPoolExecutor 类"></a>ThreadPoolExecutor 类</h2><p><code>ThreadPoolExecutor</code> 位于 <code>java.util.concurrent</code> 工具类下，可以说它是线程池中最核心的一个类了。如果你要想把线程池理解透彻的话，就要首先了解一下这个类。</p>
<p>如果我们再拿上面家族举例子的话，ThreadPoolExecutor 就是一个家族的骨干人才，家族顶梁柱。ThreadPoolExecutor 做的工作真是太多太多了。</p>
<p>首先，ThreadPoolExecutor 提供了四个构造方法，然而前三个构造方法最终都会调用最后一个构造方法进行初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title class_">AbstractExecutorService</span> &#123;</span><br><span class="line">    .....</span><br><span class="line">      <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,<span class="type">int</span> maximumPoolSize,<span class="type">long</span> keepAliveTime,TimeUnit unit,</span></span><br><span class="line"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue)</span>;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,<span class="type">int</span> maximumPoolSize,<span class="type">long</span> keepAliveTime,TimeUnit unit,</span></span><br><span class="line"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory)</span>;</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,<span class="type">int</span> maximumPoolSize,<span class="type">long</span> keepAliveTime,TimeUnit unit,</span></span><br><span class="line"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler)</span>;</span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,<span class="type">int</span> maximumPoolSize,<span class="type">long</span> keepAliveTime,TimeUnit unit,</span></span><br><span class="line"><span class="params">        BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们直接就来看一波最后这个线程池，看看参数都有啥，如果我没数错的话，应该是有 7 个参数(小学数学水平。。。。。。)</p>
<ul>
<li>首先，一个非常重要的参数就是 <code>corePoolSize</code>，核心线程池的容量&#x2F;大小，你叫啥我觉得都没毛病。只不过你得理解这个参数的意义，<strong>它和线程池的实现原理有非常密切的关系</strong>。你刚开始创建了一个线程池，此时是没有任何线程的，这个很好理解，因为我现在没有任务可以执行啊，创建线程干啥啊？而且创建线程还有开销啊，所以等到任务过来时再创建线程也不晚。但是！我要说但是了，如果调用了 prestartAllCoreThreads 或者 prestartCoreThread 方法，就会在没有任务到来时创建线程，前者是创建 corePoolSize 个线程，后者是只创建一个线程。Lea 爷爷本来想让我们程序员当个<code>懒汉</code>，等任务来了再干；可是你非要当个<code>饿汉</code>，提前完成任务。如果我们想当个懒汉的话，在创建了线程池后，线程池中的线程数为 0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到 corePoolSize 后，就会把到达的任务放到<code>缓存队列</code>当中。</li>
</ul>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/8.png" alt="图片"></p>
<ul>
<li><code>maximumPoolSize</code> ：又来一个线程池的容量，只不过这个是线程池的最大容量，也就是线程池所能容纳最大的线程，而上面的 corePoolSize 只是核心线程容量。</li>
</ul>
<blockquote>
<p>我知道你此时会有疑问，那就是不知道如何核心线程的容量和线程最大容量的区别是吧？我们后面会解释这点。</p>
</blockquote>
<ul>
<li><p><code>keepAliveTime</code>：这个参数是线程池的<code>保活机制</code>，表示线程在没有任务执行的情况下保持多久会终止。在默认情况下，这个参数只在线程数量大于 corePoolSize 时才会生效。当线程数量大于 corePoolSize 时，如果任意一个空闲的线程的等待时间 &gt; keepAliveTime 后，那么这个线程会被剔除，直到线程数量等于 corePoolSize 为止。如果调用了 allowCoreThreadTimeOut 方法，线程数量在 corePoolSize 范围内也会生效，直到线程减为 0。</p>
</li>
<li><p><code>unit</code> ：这个参数好说，它就是一个 <code>TimeUnit</code> 的变量，unit 表示的是 keepAliveTime 的时间单位。unit 的类型有下面这几种</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TimeUnit.DAYS;               <span class="comment">//天</span></span><br><span class="line">TimeUnit.HOURS;             <span class="comment">//小时</span></span><br><span class="line">TimeUnit.MINUTES;           <span class="comment">//分钟</span></span><br><span class="line">TimeUnit.SECONDS;           <span class="comment">//秒</span></span><br><span class="line">TimeUnit.MILLISECONDS;      <span class="comment">//毫秒</span></span><br><span class="line">TimeUnit.MICROSECONDS;      <span class="comment">//微妙</span></span><br><span class="line">TimeUnit.NANOSECONDS;       <span class="comment">//纳秒</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>workQueue</code>：这个参数表示的概念就是等待队列，我们上面说过，如果核心线程 &gt; corePoolSize 的话，就会把任务放入等待队列，这个等待队列的选择也是一门学问。Lea 爷爷给我们展示了三种等待队列的选择</p>
</li>
<li><ul>
<li><code>SynchronousQueue</code>: 基于<code>阻塞队列(BlockingQueue)</code>的实现，它会直接将任务交给消费者，必须等队列中的添加元素被消费后才能继续添加新的元素。使用 SynchronousQueue 阻塞队列一般要求maximumPoolSizes 为无界，也就是 Integer.MAX_VALUE，避免线程拒绝执行操作。</li>
<li><code>LinkedBlockingQueue</code>：LinkedBlockingQueue 是一个无界缓存等待队列。当前执行的线程数量达到 corePoolSize 的数量时，剩余的元素会在阻塞队列里等待。</li>
<li><code>ArrayBlockingQueue</code>：ArrayBlockingQueue 是一个有界缓存等待队列，可以指定缓存队列的大小，当正在执行的线程数等于 corePoolSize 时，多余的元素缓存在 ArrayBlockingQueue 队列中等待有空闲的线程时继续执行，当 ArrayBlockingQueue 已满时，加入 ArrayBlockingQueue 失败，会开启新的线程去执行，当线程数已经达到最大的 maximumPoolSizes 时，再有新的元素尝试加入 ArrayBlockingQueue时会报错</li>
</ul>
</li>
<li><p><code>threadFactory</code>：线程工厂，这个参数主要用来创建线程；</p>
</li>
<li><p><code>handler</code> ：拒绝策略，拒绝策略主要有以下取值</p>
</li>
<li><ul>
<li><code>AbortPolicy</code>：丢弃任务并抛出 RejectedExecutionException 异常。</li>
<li><code>DiscardPolicy</code>: 直接丢弃任务，但是不抛出异常。</li>
<li><code>DiscardOldestPolicy</code>：直接丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）。</li>
<li><code>CallerRunsPolicy</code>：由调用线程处理该任务。</li>
</ul>
</li>
</ul>
<h2 id="深入理解线程池"><a href="#深入理解线程池" class="headerlink" title="深入理解线程池"></a>深入理解线程池</h2><p>上面我和你简单聊了一下线程池的基本构造，线程池有几个非常重要的参数可以细细品味，但是哥们醒醒，接下来才是刺激的地方。</p>
<h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><p>首先我们先来聊聊线程池状态，线程池状态是一个非常有趣的设计点，ThreadPoolExecutor 使用 <code>ctl</code> 来存储线程池状态，这些状态也叫做线程池的<code>生命周期</code>。想想也是，线程池作为一个存储管理线程的资源池，它自己也要有这些状态，以及状态之间的变更才能更好的满足我们的需求。ctl 其实就是一个 <code>AtomicInteger</code> 类型的变量，保证<code>原子性</code>。</p>
<p>ctl 除了存储线程池状态之外，它还存储 <code>workerCount</code> 这个概念，workerCount 指示的是有效线程数，workerCount 表示的是已经被允许启动但不允许停止的工作线程数量。workerCount 的值与实际活动线程的数量不同。</p>
<p><strong>ctl 高低位来判断是线程池状态还是工作线程数量，线程池状态位于高位</strong>。</p>
<blockquote>
<p>这里有个设计点，为什么使用 AtomicInteger 而不是存储上线更大的 AtomicLong 之类的呢？</p>
</blockquote>
<p>Lea 并非没有考虑过这个问题，为了表示 int 值，目前 workerCount 的大小是<strong>（2 ^ 29）-1（约 5 亿个线程），而不是（2 ^ 31）-1（20亿个）可表示的线程</strong>。如果将来有问题，可以将该变量更改为 AtomicLong。但是在需要之前，使用 int 可以使此代码更快，更简单，int 存储占用存储空间更小。</p>
<p>runState 具有如下几种状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>

<p>我们先上状态轮转图，然后根据状态轮转图做详细的解释。</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/9.png" alt="图片"></p>
<p>这几种状态的解释如下</p>
<ul>
<li><code>RUNNING</code>: 如果线程池处于 RUNNING 状态下的话，能够接收新任务，也能处理正在运行的任务。可以从 ctl 的初始化得知，线程池一旦创建出来就会处于 RUNNING 状态，并且线程池中的有效线程数为 0。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li><code>SHUTDOWN</code>: 在调用 shutdown 方法后，线程池的状态会由 RUNNING -&gt; SHUTDOWN 状态，位于 SHUTDOWN 状态的线程池能够处理正在运行的任务，但是不能接受新的任务，这和我们上面说的对于 shutdown 的描述一致。</li>
<li><code>STOP</code>: 和 shutdown 方法类似，在调用 shutdownNow 方法时，程序会从 RUNNING&#x2F;SHUTDOWN -&gt; STOP 状态，处于 STOP 状态的线程池，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。</li>
<li><code>TIDYING</code>：TIDYING 状态有个前置条件，分为两种：一种是是当线程池位于 SHUTDOWN 状态下，阻塞队列和线程池中的线程数量为空时，会由 SHUTDOWN -&gt; TIDYING；另一种是当线程池位于 STOP 状态下时，线程池中的数量为空时，会由 STOP -&gt; TIDYING 状态。转换为 TIDYING 的线程池会调用 <code>terminated</code>这个钩子方法，terminated 在 ThreadPoolExecutor 类中是空实现，若用户想在线程池变为 TIDYING 时，进行相应的处理，可以通过重载 terminated 函数来实现。</li>
<li><code>TERMINATED</code>：TERMINATED 状态是线程池的最后一个状态，线程池处在 TIDYING 状态时，执行完terminated 方法之后，就会由 TIDYING -&gt; TERMINATED 状态。此时表示线程池的彻底终止。</li>
</ul>
<h3 id="重要变量"><a href="#重要变量" class="headerlink" title="重要变量"></a>重要变量</h3><p>下面我们一起来了解一下线程池中的重要变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br></pre></td></tr></table></figure>

<p>阻塞队列，这个和我们上面说的阻塞队列的参数是一个意思，因为在构造 ThreadPoolExecutor 时，会把参数的值赋给 this.workQueue。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); </span><br></pre></td></tr></table></figure>

<p>线程池的主要<code>状态锁</code>，对线程池的状态(比如线程池大小、运行状态)的改变都需要使用到这个锁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();</span><br></pre></td></tr></table></figure>

<p>workers 持有线程池中所有线程的集合，只有持有上面 <code>mainLock</code> 的锁才能够访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">termination</span> <span class="operator">=</span> mainLock.newCondition();</span><br></pre></td></tr></table></figure>

<p>等待条件，用来支持 awaitTermination 方法。Condition 和 Lock 一起使用可以实现通知&#x2F;等待机制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> largestPoolSize;</span><br></pre></td></tr></table></figure>

<p>largestPoolSize 表示线程池中最大池的大小，只有持有 mainLock 才能访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> completedTaskCount;</span><br></pre></td></tr></table></figure>

<p>completedTaskCount 表示任务完成的计数，它仅仅在任务终止时更新，需要持有 mainLock 才能访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br></pre></td></tr></table></figure>

<p>threadFactory 是创建线程的工厂，所有的线程都会使用这个工厂，调用 <code>addWorker</code>方法创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br></pre></td></tr></table></figure>

<p>handler 表示拒绝策略，handler 会在线程饱和或者将要关闭的时候调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> keepAliveTime;</span><br></pre></td></tr></table></figure>

<p>保活时间，它指的是空闲线程等待工作的超时时间，当存在多个 corePoolSize 或 allowCoreThreadTimeOut 时，线程将使用这个超时时间。</p>
<p>下面是一些其他变量，这些变量比较简单，我就直接给出注释了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> allowCoreThreadTimeOut;   <span class="comment">//是否允许为核心线程设置存活时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span>   corePoolSize;     <span class="comment">//核心池的大小（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span>   maximumPoolSize;   <span class="comment">//线程池最大能容忍的线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RejectedExecutionHandler</span> <span class="variable">defaultHandler</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AbortPolicy</span>(); <span class="comment">// 默认的拒绝策略</span></span><br></pre></td></tr></table></figure>

<h3 id="任务提交"><a href="#任务提交" class="headerlink" title="任务提交"></a>任务提交</h3><p>现在我们知道了 ThreadPoolExecutor 创建出来就会处于运行状态，此时线程数量为 0 ，等任务到来时，线程池就会创建线程来执行任务，而下面我们的关注点就会放在<strong>任务提交</strong>这个过程上。</p>
<p>通常情况下，我们会使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">executor.execute() </span><br></pre></td></tr></table></figure>

<p>来执行任务，我在很多书和博客教程上都看到过这个执行过程，下面是一些书和博客教程所画的 ThreadPoolExecutor 的执行示意图和执行流程图</p>
<p>执行示意图</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/10.png" alt="图片"></p>
<p>处理流程图</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/11.png" alt="图片"></p>
<p>ThreadPoolExecutor 的执行 execute 的方法分为下面四种情况</p>
<ol>
<li>如果当前运行的工作线程少于 corePoolSize 的话，那么会创建新线程来执行任务 ，这一步需要获取 mainLock <code>全局锁</code>。</li>
<li>如果运行线程不小于 corePoolSize，则将任务加入 BlockingQueue 阻塞队列。</li>
<li>如果无法将任务加入 BlockingQueue 中，此时的现象就是队列已满，此时需要创建新的线程来处理任务，这一步同样需要获取 mainLock 全局锁。</li>
<li>如果创建新线程会使当前运行的线程超过 <code>maximumPoolSize</code> 的话，任务将被拒绝，并且使用 <code>RejectedExecutionHandler.rejectEExecution()</code> 方法拒绝新的任务。</li>
</ol>
<p>ThreadPoolExecutor 采取上面的整体设计思路，是为了在执行 execute 方法时，避免获取全局锁，因为频繁获取全局锁会是一个严重的<code>可伸缩瓶颈</code>，所以，几乎所有的 execute 方法调用都是通过执行步骤2。</p>
<p>上面指出了 execute 的运行过程，整体上来说这个执行过程把非常重要的点讲解出来了，但是不够细致，我查阅 ThreadPoolExecute 和部分源码分析文章后，发现这事其实没这么简单，先来看一下 execute 的源码，我已经给出了中文注释,Execute是提交任务的方法入口方法，根据核心线程池的数量、线程池的状态，任务队列大小、最大数量、分成不同情况，创建不同线程，存储到不同位置，或执行拒绝策略。</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/12.png" alt="图片"></p>
<p>下面是我根据源码画出的执行流程图</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/13.png" alt="图片"></p>
<p>下面我们针对 execute 流程进行分析，可能有点啰嗦，因为几个核心流程上面已经提过了，不过为了流程的完整性，我们再在这里重新提一下。</p>
<ol>
<li>如果线程池的核心数量少于 <code>corePoolSize</code>，那么就会使用 addWorker 创建新线程，addworker 的流程我们会在下面进行分析。如果创建成功，那么 execute 方法会直接返回。如果没创建成功，可能是由于线程池已经 shutdown，可能是由于并发情况下 workerCountOf(c) &lt; corePoolSize ，别的线程先创建了 worker 线程，导致 workerCoun t&gt;&#x3D; corePoolSize。</li>
<li>如果线程池还在 Running 状态，会将 task 加入阻塞队列，加入成功后会进行 <code>double-check</code> 双重校验，继续下面的步骤，如果加入失败，可能是由于队列线程已满，此时会判断是否能够加入线程池中，如果线程池也满了的话，就会直接执行拒绝策略，如果线程池能加入，execute 方法结束。</li>
<li>步骤 2 中的 double-check 主要是为了判断进入 workQueue 中的 task 是否能被执行：如果线程池已经不是 Running 状态，则应该拒绝添加任务，从 workQueue 队列中删除任务。如果线程池是 Running，但是从 workQueue 中删除失败了，此时的原因可能是由于其他线程执行了这个任务，此时会直接执行拒绝策略。</li>
<li>如果线程是 Running 状态，并且不能把任务从队列中移除，进而判断工作线程是否为 0 ，如果不为 0 ，execute 执行完毕，如果工作线程是 0 ，则会使用 addWorker 增加工作线程，execute 执行完毕。</li>
</ol>
<h3 id="添加-worker-线程"><a href="#添加-worker-线程" class="headerlink" title="添加 worker 线程"></a>添加 worker 线程</h3><p>增加线程是通过线程池中的addWorker方法，该方法的功能就是增加一个线程，该方法不考虑线程池是在哪个阶段增加的该线程，这个分配线程的策略是在上个步骤完成的，该步骤仅仅完成增加线程，并使它运行，最后返回是否成功这个结果。addWorker方法有两个参数：firstTask、core。firstTask参数用于指定新增的线程执行的第一个任务，该参数可以为空；core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">  <span class="comment">// retry 的用法相当于 goto</span></span><br><span class="line">  retry:</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">    <span class="comment">// 仅在必要时检查队列是否为空。</span></span><br><span class="line">    <span class="comment">// 线程池状态有五种，state 越小越是运行状态</span></span><br><span class="line">    <span class="comment">// rs &gt;= SHUTDOWN，表示此时线程池状态可能是 SHUTDOWN、STOP、TIDYING、TERMINATED</span></span><br><span class="line">    <span class="comment">// 默认 rs &gt;= SHUTDOWN，如果 rs = SHUTDOWN，直接返回 false</span></span><br><span class="line">    <span class="comment">// 默认 rs &lt; SHUTDOWN，是 RUNNING，如果任务不是空，返回 false</span></span><br><span class="line">    <span class="comment">// 默认 RUNNING，任务是空，如果工作队列为空，返回 false</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">        ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">           firstTask == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">           ! workQueue.isEmpty()))</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">// 统计工作线程数量</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">      <span class="comment">// 如果 worker 数量&gt;线程池最大上限 CAPACITY（即使用int低29位可以容纳的最大值）</span></span><br><span class="line">      <span class="comment">// 或者 worker数量 &gt; corePoolSize 或 worker数量&gt;maximumPoolSize )，即已经超过了给定的边界</span></span><br><span class="line">      <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">          wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 使用 CAS 增加 worker 数量，增加成功，跳出循环。</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">        <span class="keyword">break</span> retry;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检查 ctl</span></span><br><span class="line">      c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">      <span class="comment">// 如果状态不等于之前获取的 state，跳出内层循环，继续去外层循环判断</span></span><br><span class="line">      <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">        <span class="keyword">continue</span> retry;</span><br><span class="line">      <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">          worker数量+1成功的后续操作</span></span><br><span class="line"><span class="comment">        * 添加到 workers Set 集合，并启动 worker 线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">  <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 包装 Runnable 对象</span></span><br><span class="line">    <span class="comment">// 设置 firstTask 的值为 -1</span></span><br><span class="line">    <span class="comment">// 赋值给当前任务</span></span><br><span class="line">    <span class="comment">// 使用 worker 自身这个 runnable，调用 ThreadFactory 创建一个线程，并设置给worker的成员变量thread</span></span><br><span class="line">    w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">    	<span class="comment">//全局锁</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">      <span class="comment">//加独占锁，为了works同步，因为可能多个现场调用了线程池的execute方法。</span></span><br><span class="line">      mainLock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 重新检查持有锁的状态，为了避免获取锁前调用了shutdown接口</span></span><br><span class="line">        <span class="comment">// 如果 ThreadFactory 失败或在获得锁之前关闭，请回退。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果线程池处于运行状态，或者线程池关闭且任务线程为空</span></span><br><span class="line">        <span class="comment">// （可能是 workQueue 中仍有未执行完成的任务，创建没有初始任务的 worker 线程执行）</span></span><br><span class="line">        <span class="comment">//worker 数量 -1 的操作在 addWorkerFailed()</span></span><br><span class="line">        <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">            (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">          <span class="comment">//线程处于活跃状态，切线程已经开始执行或者还未死亡，正确的是线程在这里应该还未开始执行的</span></span><br><span class="line">          <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 添加任务，workers 就是一个 HashSet 集合</span></span><br><span class="line">          workers.add(w);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 设置最大的池大小 largestPoolSize，workerAdded 设置为true</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">          <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">            largestPoolSize = s;</span><br><span class="line">          workerAdded = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//添加成功则启动任务</span></span><br><span class="line">      <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">        t.start();</span><br><span class="line">        workerStarted = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果启动线程失败</span></span><br><span class="line">    <span class="comment">// worker 数量 -1</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">      addWorkerFailed(w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的执行流程图如下</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/14.png" alt="图片"></p>
<p>这里我们就不再文字描述了，但是上面流程图中有一个对象引起了我的注意，那就是 <code>worker</code> 对象，这个对象就代表了线程池中的工作线程，那么这个 worker 对象到底是啥呢？</p>
<h3 id="worker-对象"><a href="#worker-对象" class="headerlink" title="worker 对象"></a>worker 对象</h3><p>Worker 位于 <code>ThreadPoolExecutor</code> 内部，它继承了 AQS 类并且实现了 Runnable 接口。Worker 类主要维护了线程运行过程中的中断控制状态。它提供了锁的获取和释放操作。在 worker 的实现中，我们使用了非重入的互斥锁而不是使用重复锁，因为 Lea 觉得我们不应该在调用诸如 setCorePoolSize 之类的控制方法时能够重新获取锁。</p>
<p>worker 对象的源码比较简单和标准，这里我们只说一下 worker 对象的构造方法，也就是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">  setState(-<span class="number">1</span>); </span><br><span class="line">  <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">  <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造一个 worker 对象需要做三步操作：</p>
<ul>
<li>初始 AQS 状态为 -1，此时不允许中断 interrupt()，只有在 worker 线程启动了，执行了 runWorker() 方法后，将 state 置为0，才能进行中断。</li>
<li>将 firstTask 赋值给为当前类的全局变量</li>
<li>通过 <code>ThreadFactory</code> 创建一个新的线程。</li>
</ul>
<h3 id="任务运行"><a href="#任务运行" class="headerlink" title="任务运行"></a>任务运行</h3><p>我们前面的流程主要分析了线程池的 execute 方法的执行过程，这个执行过程相当于是任务提交过程，而我们下面要说的是<strong>从队列中获取任务并运行</strong>的这个工作流程。</p>
<p>一般情况下，我们会从初始任务开始运行，所以我们不需要获取第一个任务。否则，只要线程池还处于 Running 状态，我们会调用 <code>getTask</code> 方法获取任务。getTask 方法可能会返回 null，此时可能是由于线程池状态改变或者是配置参数更改而导致的退出。还有一种情况可能是由于 <code>异常</code> 而引发的，这个我们后面会细说。</p>
<p>下面来看一下 <code>runWorker</code> 方法的源码：</p>
<p>runWorker真正执行任务的地方，先执行第一个任务，再源源不断从任务队列中取任务来执行；如果线程池调用了shutDownNow，这里也会收到影响。</p>
<p>在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的执行过程如下：</p>
<ol>
<li>while循环不断地通过getTask()方法获取任务。</li>
<li>getTask()方法从阻塞队列中取任务。</li>
<li>如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态。</li>
<li>执行任务。</li>
<li>如果getTask结果为null则跳出循环，执行processWorkerExit()方法，销毁线程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">  <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">  <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">  w.firstTask = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 允许打断</span></span><br><span class="line">  <span class="comment">//  new Worker() 是 state==-1，此处是调用 Worker 类的 tryRelease() 方法，</span></span><br><span class="line">  <span class="comment">//  将 state 置为0</span></span><br><span class="line">  w.unlock();</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Work在执行任务完成后，还会循环获取任务队列中的任务执行，复用线程</span></span><br><span class="line">    <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 获取全局锁</span></span><br><span class="line">      w.lock();</span><br><span class="line">      <span class="comment">// 确保只有在线程 STOPING 时，才会被设置中断标志，否则清除中断标志。</span></span><br><span class="line">      <span class="comment">// 如果一开始判断线程池状态 &lt; STOPING，但 Thread.interrupted() 为 true，</span></span><br><span class="line">      <span class="comment">// 即线程已经被中断，又清除了中断标示，再次判断线程池状态是否 &gt;= stop</span></span><br><span class="line">      <span class="comment">// 是，再次设置中断标示，wt.interrupt()</span></span><br><span class="line">      <span class="comment">// 否，不做操作，清除中断标示后进行后续步骤</span></span><br><span class="line">      <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">           (Thread.interrupted() &amp;&amp;</span><br><span class="line">            runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">          !wt.isInterrupted())</span><br><span class="line">        wt.interrupt();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行前需要调用的方法，交给程序员自己来实现</span></span><br><span class="line">        beforeExecute(wt, task);</span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          task.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">          thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">          thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">          thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// 执行后需要调用的方法，交给程序员自己来实现</span></span><br><span class="line">          afterExecute(task, thrown);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 把 task 置为 null，完成任务数 + 1，并进行解锁</span></span><br><span class="line">        task = <span class="literal">null</span>;</span><br><span class="line">        w.completedTasks++;</span><br><span class="line">        w.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 最后处理 worker 的退出</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    processWorkerExit(w, completedAbruptly);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是 runWorker 的执行流程图</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/15.png" alt="图片"></p>
<p>这里需要注意一下最后的 <code>processWorkerExit</code> 方法，这里面其实也做了很多事情，包括判断 <code>completedAbruptly</code> 的布尔值来表示是否完成任务，获取锁，尝试从队列中移除 worker，然后尝试中断，接下来会判断一下中断状态，在线程池当前状态小于 STOP 的情况下会创建一个新的 worker 来替换被销毁的 worker。</p>
<h3 id="任务获取"><a href="#任务获取" class="headerlink" title="任务获取"></a>任务获取</h3><p>从队列取任务的地方，默认情况下，根据工作线程数量与核心数量的关系判断使用队列的poll()还是take()方法，keepAliveTime参数也是在这里使用的。</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/16.png" alt="图片"></p>
<p>getTask 方法的执行流程图如下</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/17.png" alt="图片"></p>
<h3 id="工作线程退出"><a href="#工作线程退出" class="headerlink" title="工作线程退出"></a>工作线程退出</h3><p>工作线程退出是 runWorker 的最后一步，这一步会判断工作线程是否突然终止，并且会尝试终止线程，以及是否需要增加线程来替换原工作线程。线程池中线程的销毁依赖JVM自动的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。Worker被创建出来后，就会不断地进行轮询，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务。当Worker无法获取到任务，也就是获取的任务为空时，循环会结束，Worker会主动消除自身在线程池内的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//执行任务</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  processWorkerExit(w, completedAbruptly);<span class="comment">//获取不到任务时，主动回收自己</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程回收的工作是在processWorkerExit方法完成的。</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/18.png" alt="图片"></p>
<p>事实上，在这个方法中，将线程引用移出线程池就已经结束了线程销毁的部分。但由于引起线程销毁的可能性有很多，线程池还要判断是什么引发了这次销毁，是否要改变线程池的现阶段状态，是否要根据新状态，重新分配线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processWorkerExit</span><span class="params">(Worker w, <span class="type">boolean</span> completedAbruptly)</span> &#123;</span><br><span class="line">  <span class="comment">// worker数量 -1</span></span><br><span class="line">  <span class="comment">// completedAbruptly 是 true，突然终止，说明是 task 执行时异常情况导致，即run()方法执行时发生了异常，那么正在工作的 worker 线程数量需要-1</span></span><br><span class="line">  <span class="comment">// completedAbruptly 是 false 是突然终止，说明是 worker 线程没有 task 可执行了，不用-1，因为已经在 getTask() 方法中-1了</span></span><br><span class="line">  <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">    decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从 Workers Set 中移除 worker</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">  mainLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    completedTaskCount += w.completedTasks;</span><br><span class="line">    workers.remove(w);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    mainLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 尝试终止线程，</span></span><br><span class="line">  tryTerminate();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否需要增加 worker 线程</span></span><br><span class="line">  <span class="comment">// 线程池状态是 running 或 shutdown</span></span><br><span class="line">  <span class="comment">// 如果当前线程是突然终止的，addWorker()</span></span><br><span class="line">  <span class="comment">// 如果当前线程不是突然终止的，但当前线程数量 &lt; 要维护的线程数量，addWorker()</span></span><br><span class="line">  <span class="comment">// 故如果调用线程池 shutdown()，直到workQueue为空前，线程池都会维持 corePoolSize 个线程，</span></span><br><span class="line">  <span class="comment">// 然后再逐渐销毁这 corePoolSize 个线程</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">  <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">      <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">        min = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">    &#125;</span><br><span class="line">    addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码搞的有点头大了，可能一时半会无法理解上面这些源码，不过你可以先把注释粘过去，等有时间了需要反复刺激，加深印象！</p>
<h2 id="其他线程池"><a href="#其他线程池" class="headerlink" title="其他线程池"></a>其他线程池</h2><p>下面我们来了解一下其他线程池的构造原理，主要涉及 <strong>FixedThreadPool、SingleThreadExecutor、CachedThreadPool</strong>。</p>
<h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>newFixedThreadPool 被称为可重用<code>固定线程数</code>的线程池，下面是 newFixedThreadPool 的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，newFixedThreadPool 的 corePoolSize 和 maximumPoolSize 都被设置为创建 FixedThreadPool 时指定的参数 <code>nThreads</code>，也就是说，在 newFiexedThreadPool 中，核心线程数就是最大线程数。</p>
<p>下面是 newFixedThreadPool 的执行示意图</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/19.png" alt="图片"></p>
<p>newFixedThreadPool 的工作流程如下</p>
<ul>
<li>如果当前运行的线程数少于 corePoolSize，则会创建新线程 addworker 来执行任务</li>
<li>如果当前线程的线程数等于 corePoolSize，会将任务直接加入到 <code>LinkedBlockingQueue</code> 无界阻塞队列中，LinkedBlockingQueue 的上限如果没有制定，默认为 Integer.MAX_VALUE 大小。</li>
<li>等到线程池中的任务执行完毕后，newFixedThreadPool 会反复从 LinkedBlockingQueue 中获取任务来执行。</li>
</ul>
<p>相较于 ThreadPoolExecutor，newFixedThreadPool 主要做了以下改变</p>
<ul>
<li>核心线程数等于最大线程数，因此 newFixedThreadPool 只有两个最大容量，一个是线程池的线程容量，还有一个是 LinkedBlockingQueue 无界阻塞队列的线程容量。</li>
<li>这里可以看到还有一个变化是 0L，也就是 keepAliveTime &#x3D; 0L，keepAliveTime 就是到达工作线程最大容量后的线程等待时间，0L 就意味着当线程池中的线程数大于 corePoolsize 时，空余的线程会被立即终止。</li>
<li>由于使用无界队列，运行中的 newFixedThreadPool 不会拒绝任务，也就是不会调用 RejectedExecutionHandler.rejectedExecution 方法。</li>
</ul>
<h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p>newSingleThreadExecutor 中只有单个工作线程，也就是说它是一个只有单个 worker 的 Executor。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">    (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                            <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                            threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在 newSingleThreadExecutor 中，corePoolSize 和 maximumPoolSize 都被设置为 1，也不存在超时情况，同样使用了 LinkedBlockingQueue 无界阻塞队列，除了 corePoolSize 和 maximumPoolSize 外，其他几乎和 newFixedThreadPool 一模一样。</p>
<p>下面是 newSingleThreadExecutor  的执行示意图</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/20.png" alt="图片"></p>
<p>newSingleThreadExecutor 的执行过程和 newFixedThreadPool 相同，只是 newSingleThreadExecutor 的工作线程数为 1。</p>
<h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><p>newCachedThreadPool 是一个根据需要创建工作线程的线程池，newCachedThreadPool 线程池最大数量是 Integer.MAX_VALUE，保活时间是 <code>60</code>秒，使用的是<code>SynchronousQueue</code> 无缓冲阻塞队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的执行示意图如下</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/21.png" alt="图片"></p>
<ul>
<li>首先会先执行 SynchronousQueue.offer 方法，如果当前 maximumPool 中有空闲线程正在执行 <code>SynchronousQueue.poll</code> ，就会把任务交给空闲线程来执行，execute 方法执行完毕，否则的话，继续向下执行。</li>
<li>如果 maximumPool 中没有线程执行 SynchronousQueue.poll 方法，这种情况下 newCachedThreadPool 会创建一个新线程执行任务，execute 方法执行完成。</li>
<li>执行完成的线程将执行 poll 操作，这个 poll 操作会让空闲线程最多在 SynchronousQueue 中等待 60 秒钟。如果 60 秒钟内提交了一个新任务，那么空闲线程会执行这个新提交的任务，否则空闲线程将会终止。</li>
</ul>
<p>这里的关键点在于 SynchronousQueue 队列，它是一个没有容量的阻塞队列。<strong>每个插入操作必须等待另一个线程对应的移除操作</strong>。这其实就是一种任务传递，如下图所示</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/22.png" alt="图片"></p>
<p>其实还有一个线程池 <code>ScheduledThreadPoolExecutor</code> ，就先不在此篇文章做详细赘述了。</p>
<h2 id="线程池实践考量因素"><a href="#线程池实践考量因素" class="headerlink" title="线程池实践考量因素"></a>线程池实践考量因素</h2><p>下面介绍几种在实践过程中使用线程池需要考虑的几个点</p>
<ul>
<li><strong>避免任务堆积</strong>，比如我们上面提到的 newFixedThreadPool，它是创建指定数目的线程，但是工作队列是无界的，这就导致如果工作队列线程太少，导致处理速度跟不上入队速度，这种情况下很可能会导致 OOM，诊断时可以使用 <code>jmap</code> 检查是否有大量任务入队。</li>
<li>生产实践中很可能由于逻辑不严谨或者工作线程不能及时释放导致 <strong>线程泄漏</strong>，这个时候最好检查一下线程栈</li>
<li>避免死锁等同步问题</li>
<li>尽量避免在使用线程池时操作 <code>ThreadLocal</code>，因为工作线程的生命周期可能会超过任务的生命周期。</li>
</ul>
<h2 id="线程池大小的设置"><a href="#线程池大小的设置" class="headerlink" title="线程池大小的设置"></a>线程池大小的设置</h2><p>线程池大小的设置也是面试官经常会考到的一个点，一般需要根据<code>任务类型</code>来配置线程池大小</p>
<ul>
<li>如果是 CPU 密集型任务，那么就意味着 CPU 是稀缺资源，这个时候我们通常不能通过增加线程数来提高计算能力，因为线程数量太多，会导致频繁的上下文切换，一般这种情况下，建议合理的线程数值是 <code>N(CPU)数 + 1</code>。</li>
<li>如果是 I&#x2F;O 密集型任务，就说明需要较多的等待，这个时候可以参考 Brain Goetz 的推荐方法 **线程数 &#x3D; CPU核数 × (1 + 平均等待时间&#x2F;平均工作时间)**。参考值可以是 N(CPU) 核数 * 2。</li>
</ul>
<p>当然，这只是一个参考值，具体的设置还需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整。</p>
<h2 id="线程池在业务中的实践"><a href="#线程池在业务中的实践" class="headerlink" title="线程池在业务中的实践"></a>线程池在业务中的实践</h2><p><strong>1.业务背景</strong></p>
<p>在当今的互联网业界，为了最大程度利用CPU的多核性能，并行运算的能力是不可或缺的。通过线程池管理线程获取并发性是一个非常基础的操作，让我们来看两个典型的使用线程池获取并发性的场景。</p>
<p><strong>场景1：快速响应用户请求</strong></p>
<p><strong>描述</strong>：用户发起的实时请求，服务追求响应时间。比如说用户要查看一个商品的信息，那么我们需要将商品维度的一系列信息如商品的价格、优惠、库存、图片等等聚合起来，展示给用户。</p>
<p><strong>分析</strong>：从用户体验角度看，这个结果响应的越快越好，如果一个页面半天都刷不出，用户可能就放弃查看这个商品了。而面向用户的功能聚合通常非常复杂，伴随着调用与调用之间的级联、多级级联等情况，业务开发同学往往会选择使用线程池这种简单的方式，将调用封装成任务并行的执行，缩短总体响应时间。另外，使用线程池也是有考量的，这种场景最重要的就是获取最大的响应速度去满足用户，所以应该不设置队列去缓冲并发任务，调高corePoolSize和maxPoolSize去尽可能创造多的线程快速执行任务。</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/23.png" alt="图片">图12 并行执行任务提升任务响应速度</p>
<p><strong>场景2：快速处理批量任务</strong></p>
<p><strong>描述</strong>：离线的大量计算任务，需要快速执行。比如说，统计某个报表，需要计算出全国各个门店中有哪些商品有某种属性，用于后续营销策略的分析，那么我们需要查询全国所有门店中的所有商品，并且记录具有某属性的商品，然后快速生成报表。</p>
<p><strong>分析</strong>：这种场景需要执行大量的任务，我们也会希望任务执行的越快越好。这种情况下，也应该使用多线程策略，并行计算。但与响应速度优先的场景区别在于，这类场景任务量巨大，并不需要瞬时的完成，而是关注如何使用有限的资源，尽可能在单位时间内处理更多的任务，也就是吞吐量优先的问题。所以应该设置队列去缓冲并发任务，调整合适的corePoolSize去设置处理任务的线程数。在这里，设置的线程数过多可能还会引发线程上下文切换频繁的问题，也会降低处理任务的速度，降低吞吐量。</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/24.png" alt="图片"><strong>实际问题及方案思考</strong></p>
<p>线程池使用面临的核心的问题在于：<strong>线程池的参数并不好配置</strong>。一方面线程池的运行机制不是很好理解，配置合理需要强依赖开发人员的个人经验和知识；另一方面，线程池执行的情况和任务类型相关性较大，IO密集型和CPU密集型的任务运行起来的情况差异非常大，这导致业界并没有一些成熟的经验策略帮助开发人员参考。</p>
<p>关于线程池配置不合理引发的故障，公司内部有较多记录，下面举一些例子：</p>
<p><strong>Case1</strong>：2018年XX页面展示接口大量调用降级。</p>
<p><strong>事故描述</strong>：XX页面展示接口产生大量调用降级，数量级在几十到上百。</p>
<p><strong>事故原因</strong>：该服务展示接口内部逻辑使用线程池做并行计算，由于没有预估好调用的流量，导致最大核心数设置偏小，大量抛出RejectedExecutionException，触发接口降级条件，示意图如下：</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/25.png" alt="图片">图14 线程数核心设置过小引发RejectExecutionException</p>
<p><strong>Case2</strong>：2018年XX业务服务不可用S2级故障。</p>
<p><strong>事故描述</strong>：XX业务提供的服务执行时间过长，作为上游服务整体超时，大量下游服务调用失败。</p>
<p><strong>事故原因</strong>：该服务处理请求内部逻辑使用线程池做资源隔离，由于队列设置过长，最大线程数设置失效，导致请求数量增加时，大量任务堆积在队列中，任务执行时间过长，最终导致下游服务的大量调用超时失败。示意图如下：</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/26.png" alt="图片"></p>
<p> 线程池队列长度设置过长、corePoolSize设置过小导致任务执行速度低</p>
<p>业务中要使用线程池，而使用不当又会导致故障，那么我们怎样才能更好地使用线程池呢？针对这个问题，我们下面延展几个方向：</p>
<p><strong>1. 能否不用线程池?</strong></p>
<p>回到最初的问题，业务使用线程池是为了获取并发性，对于获取并发性，是否可以有什么其他的方案呢替代？我们尝试进行了一些其他方案的调研：</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/27.png" alt="图片"></p>
<p>综合考虑，这些新的方案都能在某种情况下提升并行任务的性能，然而本次重点解决的问题是如何更简易、更安全地获得的并发性。另外，Actor模型的应用实际上甚少，只在Scala中使用广泛，协程框架在Java中维护的也不成熟。这三者现阶段都不是足够的易用，也并不能解决业务上现阶段的问题。</p>
<p><strong>2. 追求参数设置合理性？</strong></p>
<p>有没有一种计算公式，能够让开发同学很简易地计算出某种场景中的线程池应该是什么参数呢？</p>
<p>带着这样的疑问，我们调研了业界的一些线程池参数配置方案：</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/28.png" alt="图片"></p>
<p>调研了以上业界方案后，我们并没有得出通用的线程池计算方式。并发任务的执行情况和任务类型相关，IO密集型和CPU密集型的任务运行起来的情况差异非常大，但这种占比是较难合理预估的，这导致很难有一个简单有效的通用公式帮我们直接计算出结果。</p>
<p><strong>3. 线程池参数动态化？</strong></p>
<p>尽管经过谨慎的评估，仍然不能够保证一次计算出来合适的参数，那么我们是否可以将修改线程池参数的成本降下来，这样至少可以发生故障的时候可以快速调整从而缩短故障恢复的时间呢？基于这个思考，我们是否可以将线程池的参数从代码中迁移到分布式配置中心上，实现线程池参数可动态配置和即时生效，线程池参数动态化前后的参数修改流程对比如下：</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/29.png" alt="图片"></p>
<p>基于以上三个方向对比，我们可以看出参数动态化方向简单有效。</p>
<p><strong>3.3 动态化线程池</strong></p>
<p><strong>3.3.1 整体设计</strong></p>
<p>动态化线程池的核心设计包括以下三个方面：</p>
<ol>
<li><strong>简化线程池配置</strong>：线程池构造参数有8个，但是最核心的是3个：corePoolSize、maximumPoolSize，workQueue，它们最大程度地决定了线程池的任务分配和线程分配策略。考虑到在实际应用中我们获取并发性的场景主要是两种：（1）并行执行子任务，提高响应速度。这种情况下，应该使用同步队列，没有什么任务应该被缓存下来，而是应该立即执行。（2）并行执行大批次任务，提升吞吐量。这种情况下，应该使用有界队列，使用队列去缓冲大批量的任务，队列容量必须声明，防止任务无限制堆积。所以线程池只需要提供这三个关键参数的配置，并且提供两种队列的选择，就可以满足绝大多数的业务需求，Less is More。</li>
<li><strong>参数可动态修改</strong>：为了解决参数不好配，修改参数成本高等问题。在Java线程池留有高扩展性的基础上，封装线程池，允许线程池监听同步外部的消息，根据消息进行修改配置。将线程池的配置放置在平台侧，允许开发同学简单的查看、修改线程池配置。</li>
<li><strong>增加线程池监控</strong>：对某事物缺乏状态的观测，就对其改进无从下手。在线程池执行任务的生命周期添加监控能力，帮助开发同学了解线程池状态。</li>
</ol>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/30.png" alt="图片">图17 动态化线程池整体设计</p>
<p><strong>3.3.2 功能架构</strong></p>
<p>动态化线程池提供如下功能：</p>
<ul>
<li><strong>动态调参</strong>：支持线程池参数动态调整、界面化操作；包括修改线程池核心大小、最大核心大小、队列长度等；参数修改后及时生效。</li>
<li><strong>任务监控</strong>：支持应用粒度、线程池粒度、任务粒度的Transaction监控；可以看到线程池的任务执行情况、最大任务执行时间、平均任务执行时间、95&#x2F;99线等。</li>
<li><strong>负载告警</strong>：线程池队列任务积压到一定值的时候会通过大象（美团内部通讯工具）告知应用开发负责人；当线程池负载数达到一定阈值的时候会通过大象告知应用开发负责人。</li>
<li><strong>操作监控</strong>：创建&#x2F;修改和删除线程池都会通知到应用的开发负责人。</li>
<li><strong>操作日志</strong>：可以查看线程池参数的修改记录，谁在什么时候修改了线程池参数、修改前的参数值是什么。</li>
<li><strong>权限校验</strong>：只有应用开发负责人才能够修改应用的线程池参数。</li>
</ul>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/31.png" alt="图片"> 动态化线程池功能架构</p>
<p><strong>参数动态化</strong></p>
<p>JDK原生线程池ThreadPoolExecutor提供了如下几个public的setter方法，如下图所示：</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/32.png" alt="图片"> JDK 线程池参数设置接口</p>
<p>JDK允许线程池使用方通过ThreadPoolExecutor的实例来动态设置线程池的核心策略，以setCorePoolSize为方法例，在运行期线程池使用方调用此方法设置corePoolSize之后，线程池会直接覆盖原来的corePoolSize值，并且基于当前值和原始值的比较结果采取不同的处理策略。对于当前值小于当前工作线程数的情况，说明有多余的worker线程，此时会向当前idle的worker线程发起中断请求以实现回收，多余的worker在下次idle的时候也会被回收；对于当前值大于原始值且当前队列中有待执行任务，则线程池会创建新的worker线程来执行队列任务，setCorePoolSize具体流程如下：</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/33.png" alt="图片"> setCorePoolSize方法执行流程</p>
<p>线程池内部会处理好当前状态做到平滑修改，其他几个方法限于篇幅，这里不一一介绍。重点是基于这几个public方法，我们只需要维护ThreadPoolExecutor的实例，并且在需要修改的时候拿到实例修改其参数即可。基于以上的思路，我们实现了线程池参数的动态化、线程池参数在管理平台可配置可修改，其效果图如下图所示：</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/34.png" alt="图片"> 可动态修改线程池参数</p>
<p>用户可以在管理平台上通过线程池的名字找到指定的线程池，然后对其参数进行修改，保存后会实时生效。目前支持的动态参数包括核心数、最大值、队列长度等。除此之外，在界面中，我们还能看到用户可以配置是否开启告警、队列等待任务告警阈值、活跃度告警等等。关于监控和告警，我们下面一节会对齐进行介绍。</p>
<p><strong>线程池监控</strong></p>
<p>除了参数动态化之外，为了更好地使用线程池，我们需要对线程池的运行状况有感知，比如当前线程池的负载是怎么样的？分配的资源够不够用？任务的执行情况是怎么样的？是长任务还是短任务？</p>
<p>基于对这些问题的思考，动态化线程池提供了多个维度的监控和告警能力，包括：线程池活跃度、任务的执行Transaction（频率、耗时）、Reject异常、线程池内部统计信息等等，既能帮助用户从多个维度分析线程池的使用情况，又能在出现问题第一时间通知到用户，从而避免故障或加速故障恢复。</p>
<p><strong>1. 负载监控和告警</strong></p>
<p>线程池负载关注的核心问题是：基于当前线程池参数分配的资源够不够。对于这个问题，我们可以从事前和事中两个角度来看。事前，线程池定义了“活跃度”这个概念，来让用户在发生Reject异常之前能够感知线程池负载问题，线程池活跃度计算公式为：线程池活跃度 &#x3D; activeCount&#x2F;maximumPoolSize。这个公式代表当活跃线程数趋向于maximumPoolSize的时候，代表线程负载趋高。</p>
<p>事中，也可以从两方面来看线程池的过载判定条件，一个是发生了Reject异常，一个是队列中有等待任务（支持定制阈值）。以上两种情况发生了都会触发告警，告警信息会通过大象推送给服务所关联的负责人。</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/35.png" alt="图片"></p>
<p> 大象告警通知</p>
<p><strong>2. 任务级精细化监控</strong></p>
<p>在传统的线程池应用场景中，线程池中的任务执行情况对于用户来说是透明的。比如在一个具体的业务场景中，业务开发申请了一个线程池同时用于执行两种任务，一个是发消息任务、一个是发短信任务，这两类任务实际执行的频率和时长对于用户来说没有一个直观的感受，很可能这两类任务不适合共享一个线程池，但是由于用户无法感知，因此也无从优化。动态化线程池内部实现了任务级别的埋点，且允许为不同的业务任务指定具有业务含义的名称，线程池内部基于这个名称做Transaction打点，基于这个功能，用户可以看到线程池内部任务级别的执行情况，且区分业务，任务监控示意图如下图所示：</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/36.png" alt="图片"> 线程池任务执行监控</p>
<p><strong>3. 运行时状态实时查看</strong></p>
<p>用户基于JDK原生线程池ThreadPoolExecutor提供的几个public的getter方法，可以读取到当前线程池的运行状态以及参数，如下图所示：</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/37.png" alt="图片"> 线程池实时运行情况</p>
<p>动态化线程池基于这几个接口封装了运行时状态实时查看的功能，用户基于这个功能可以了解线程池的实时状态，比如当前有多少个工作线程，执行了多少个任务，队列中等待的任务数等等。效果如下图所示：</p>
<p><img src="/2022/10/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/38.png" alt="图片">图25 线程池实时运行情况</p>
<p><strong>3.4 实践总结</strong></p>
<p>面对业务中使用线程池遇到的实际问题，我们曾回到支持并发性问题本身来思考有没有取代线程池的方案，也曾尝试着去追求线程池参数设置的合理性，但面对业界方案具体落地的复杂性、可维护性以及真实运行环境的不确定性，我们在前两个方向上可谓“举步维艰”。</p>
<p>最终，我们回到线程池参数动态化方向上探索，得出一个且可以解决业务问题的方案，虽然本质上还是没有逃离使用线程池的范畴，但是在成本和收益之间，算是取得了一个很好的平衡。成本在于实现动态化以及监控成本不高，收益在于：在不颠覆原有线程池使用方式的基础之上，从降低线程池参数修改的成本以及多维度监控这两个方面降低了故障发生的概率。希望本文提供的动态化线程池思路能对大家有帮助。</p>
<p><strong>四、参考资料</strong></p>
<p>[1]JDK 1.8 源码</p>
<p>[2] <a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E6%B1%A0">维基百科-线程池</a></p>
<p>[3] <a href="https://my.oschina.net/andylucc/blog/648127">更好的使用Java线程池</a></p>
<p>[4] <a href="https://en.wikipedia.org/wiki/Pooling_(resource_management)">维基百科Pooling(Resource Management)</a></p>
<p>[5] <a href="http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/">深入理解Java线程池：ThreadPoolExecutor</a></p>
<p>[6]《Java并发编程实践》</p>
]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>线程池</tag>
        <tag>动态线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合</title>
    <url>/2022/10/24/Java%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="一、概览"><a href="#一、概览" class="headerlink" title="一、概览"></a>一、概览</h1><table>
<thead>
<tr>
<th>Collection</th>
<th></th>
<th>是否有序</th>
<th>是否允许元素重复</th>
<th>是否允许null值</th>
<th>实现</th>
<th>优点</th>
<th>缺点</th>
<th>默认容量</th>
<th>扩容因子</th>
<th>扩容</th>
</tr>
</thead>
<tbody><tr>
<td>List</td>
<td>ArrayList</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>数组实现</td>
<td>无容量限制，查询快，轻量级</td>
<td>增删慢，线程不安全</td>
<td>10</td>
<td>1</td>
<td>1.5倍</td>
</tr>
<tr>
<td></td>
<td>LinkedList</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>链表实现</td>
<td>增删快</td>
<td>查询慢，双向链表，线程不安全</td>
<td>10</td>
<td>1</td>
<td>1.5倍</td>
</tr>
<tr>
<td></td>
<td>Vector</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>数组实现</td>
<td>线程安全，查询快</td>
<td>重量级，存在性能问题，增删慢</td>
<td>10</td>
<td>1</td>
<td>2倍</td>
</tr>
<tr>
<td>Set</td>
<td>HashSet</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>基于HashMap实现</td>
<td>效率高</td>
<td>非线程安全</td>
<td>16</td>
<td>0.75</td>
<td>2倍</td>
</tr>
<tr>
<td></td>
<td>TreeSet</td>
<td>是（用二叉树实现排序）</td>
<td>否</td>
<td>否</td>
<td>基于TreeMap实现</td>
<td>可以指定比较方法进行排序</td>
<td>非线程安全</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>LinkedHashSet</td>
<td>是（用二叉树实现排序）</td>
<td>否</td>
<td>是</td>
<td>继承HashSet，底层使用LinkedHashMap</td>
<td>链表保证元素有序，hash表保证元素唯一</td>
<td>双重链接列表</td>
<td>16</td>
<td>0.75</td>
<td>2倍</td>
</tr>
<tr>
<td>Map</td>
<td>HashMap</td>
<td>否</td>
<td>使用key-value来映射和存储数据，key必须唯一，value可以重复</td>
<td>最多只允许一条记录的key为null</td>
<td>根据key的hashCode值存储数据</td>
<td>使用hash算法去重效率高</td>
<td>非线程安全</td>
<td>16</td>
<td>0.75</td>
<td>2倍</td>
</tr>
<tr>
<td></td>
<td>TreeMap</td>
<td>是（用二叉树排序）</td>
<td>同上</td>
<td>否</td>
<td>基于红黑树实现，继承AbstractMap，并且实现了NavigableMap接口</td>
<td>可以用指定比较方法进行排序</td>
<td>非线程安全</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>LinkedHashMap</td>
<td>是</td>
<td>同上</td>
<td>是</td>
<td>在HashMap基础上采用了双向链表</td>
<td>元素迭代顺序和插入顺序一致</td>
<td>双重链接链表，非同步，遍历比HashMap慢</td>
<td>16</td>
<td>0.75</td>
<td>2倍</td>
</tr>
<tr>
<td></td>
<td>WeakHashMap</td>
<td>否</td>
<td>同上</td>
<td>是</td>
<td>KV对存储，“弱键”自动GC回收删除，继承AbstractMap</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>HashTable</td>
<td>否</td>
<td>同上</td>
<td>否</td>
<td>在HashMap基础上加synchronized</td>
<td>线程安全</td>
<td>效率低</td>
<td>11</td>
<td>0.75</td>
<td>2倍+1</td>
</tr>
</tbody></table>
<p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。<br><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/1.png" alt="在这里插入图片描述"></p>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/2.png" alt="在这里插入图片描述"></p>
<h3 id="1-Set"><a href="#1-Set" class="headerlink" title="1. Set"></a>1. Set</h3><ul>
<li><p>TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</p>
</li>
<li><p>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</p>
</li>
<li><p>LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。</p>
</li>
</ul>
<h3 id="2-List"><a href="#2-List" class="headerlink" title="2. List"></a>2. List</h3><ul>
<li><p>ArrayList：基于动态数组实现，支持随机访问。</p>
</li>
<li><p>Vector：和 ArrayList 类似，但它是线程安全的。</p>
</li>
<li><p>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</p>
</li>
</ul>
<h3 id="3-Queue"><a href="#3-Queue" class="headerlink" title="3. Queue"></a>3. Queue</h3><ul>
<li><p>LinkedList：可以用它来实现双向队列。</p>
</li>
<li><p>PriorityQueue：基于堆结构实现，可以用它来实现优先队列</p>
</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/3.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>TreeMap：基于红黑树实现。</p>
</li>
<li><p>HashMap：基于哈希表实现。</p>
</li>
<li><p>HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</p>
</li>
<li><p>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</p>
</li>
</ul>
<h1 id="二、容器中的设计模式"><a href="#二、容器中的设计模式" class="headerlink" title="二、容器中的设计模式"></a>二、容器中的设计模式</h1><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/4.png" alt="在这里插入图片描述"></p>
<p>Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。</p>
<p>从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>java.util.Arrays#asList() 可以把数组类型转换为 List 类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">asList</span><span class="params">(T... a)</span></span><br></pre></td></tr></table></figure>

<p>应该注意的是 asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Arrays.asList(arr);</span><br></pre></td></tr></table></figure>

<p>也可以使用以下方式调用 asList()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h1 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h1><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="1-概览"><a href="#1-概览" class="headerlink" title="1. 概览"></a>1. 概览</h3><p>因为 ArrayList 是基于数组实现的，所以支持快速随机访问。RandomAccess 接口标识着该类支持快速随机访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>

<p>数组的默认大小为 10。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>创建了一个大小为0的数组，在后面用到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>声明一个数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure>

<p>(1)ArrayList的无参构造方法，将前面声明创建的大小为0的数组赋给elementData数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2)这是ArrayList的有参构造方法，传入一个int类型的变量，相当于我们在使用arrayList的时候指定list的大小。如果传入的参数大于0，则新建一个initialCapacity大小的数组。传入值等于0的话，将这个空数组给elementData。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-扩容"><a href="#2-扩容" class="headerlink" title="2. 扩容"></a>2. 扩容</h3><p>添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，也就是旧容量的 1.5 倍。</p>
<p>扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-删除元素"><a href="#3-删除元素" class="headerlink" title="3. 删除元素"></a>3. 删除元素</h3><p>需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-序列化"><a href="#4-序列化" class="headerlink" title="4. 序列化"></a>4. 序列化</h3><p>ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。</p>
<p>保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br></pre></td></tr></table></figure>

<p>ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> java.io.IOException&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file));</span><br><span class="line">oos.writeObject(list);</span><br></pre></td></tr></table></figure>

<h3 id="5-Fail-Fast"><a href="#5-Fail-Fast" class="headerlink" title="5. Fail-Fast"></a>5. Fail-Fast</h3><p>modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。</p>
<p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。代码参考上节序列化中的 writeObject() 方法。</p>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><h3 id="1-同步"><a href="#1-同步" class="headerlink" title="1. 同步"></a>1. 同步</h3><p>它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-扩容-1"><a href="#2-扩容-1" class="headerlink" title="2. 扩容"></a>2. 扩容</h3><p>Vector 的构造函数可以传入 capacityIncrement 参数，它的作用是在扩容时使容量 capacity 增长 capacityIncrement。如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的两倍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">int</span> capacityIncrement)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    <span class="built_in">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用没有 capacityIncrement 的构造函数时，capacityIncrement 值被设置为 0，也就是说默认情况下 Vector 每次扩容时容量都会翻倍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-与-ArrayList-的比较"><a href="#3-与-ArrayList-的比较" class="headerlink" title="3. 与 ArrayList 的比较"></a>3. 与 ArrayList 的比较</h3><ul>
<li>Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；</li>
<li>Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍。</li>
</ul>
<h3 id="4-替代方案"><a href="#4-替代方案" class="headerlink" title="4. 替代方案"></a>4. 替代方案</h3><p>可以使用 <code>Collections.synchronizedList();</code> 得到一个线程安全的 ArrayList。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; synList = Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure>

<p>也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><h3 id="1-读写分离"><a href="#1-读写分离" class="headerlink" title="1. 读写分离"></a>1. 读写分离</h3><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p>
<p>写操作需要加锁，防止并发写入时导致写入数据丢失。</p>
<p>写操作结束之后需要把原始数组指向新的复制数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setArray</span><span class="params">(Object[] a)</span> &#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">get</span><span class="params">(Object[] a, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2. 适用场景"></a>2. 适用场景</h3><p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p>
<p>但是 CopyOnWriteArrayList 有其缺陷：</p>
<ul>
<li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li>
<li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li>
</ul>
<p>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。</p>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><h3 id="1-概览-1"><a href="#1-概览-1" class="headerlink" title="1. 概览"></a>1. 概览</h3><p>基于双向链表实现，使用 Node 存储链表节点信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个链表存储了 first 和 last 指针：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/5.png" alt="在这里插入图片描述"></p>
<h3 id="2-与-ArrayList-的比较"><a href="#2-与-ArrayList-的比较" class="headerlink" title="2. 与 ArrayList 的比较"></a>2. 与 ArrayList 的比较</h3><p>ArrayList 基于动态数组实现，LinkedList 基于双向链表实现。ArrayList 和 LinkedList 的区别可以归结为数组和链表的区别：</p>
<ul>
<li>数组支持随机访问，但插入删除的代价很高，需要移动大量元素；</li>
<li>链表不支持随机访问，但插入删除只需要改变指针。</li>
</ul>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="JDK1-7分析"><a href="#JDK1-7分析" class="headerlink" title="JDK1.7分析"></a>JDK1.7分析</h3><h3 id="1-存储结构"><a href="#1-存储结构" class="headerlink" title="1. 存储结构"></a>1. 存储结构</h3><p>内部包含了一个 Entry 类型的数组 table。Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 Entry。<br><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/6.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Entry[] table;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="type">int</span> hash;</span><br><span class="line"></span><br><span class="line">    Entry(<span class="type">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Map.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> (Map.Entry)o;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">k1</span> <span class="operator">=</span> getKey();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">k2</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">        <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="literal">null</span> &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">v1</span> <span class="operator">=</span> getValue();</span><br><span class="line">            <span class="type">Object</span> <span class="variable">v2</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="literal">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getKey() + <span class="string">&quot;=&quot;</span> + getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-拉链法的工作原理"><a href="#2-拉链法的工作原理" class="headerlink" title="2. 拉链法的工作原理"></a>2. 拉链法的工作原理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;K1&quot;</span>, <span class="string">&quot;V1&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;K2&quot;</span>, <span class="string">&quot;V2&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;K3&quot;</span>, <span class="string">&quot;V3&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>新建一个 HashMap，默认大小为 16；</li>
<li>插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16&#x3D;3。</li>
<li>插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16&#x3D;6。</li>
<li>插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16&#x3D;6，插在 &lt;K2,V2&gt; 前面。</li>
</ul>
<p>应该注意到链表的插入是以头插法方式进行的，例如上面的 &lt;K3,V3&gt; 不是插在 &lt;K2,V2&gt; 后面，而是插入在链表头部。</p>
<p>查找需要分成两步进行：</p>
<ul>
<li>计算键值对所在的桶；</li>
<li>在链表上顺序查找，时间复杂度显然和链表的长度成正比。<br><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/7.png" alt="在这里插入图片描述"></li>
</ul>
<h3 id="3-put-操作"><a href="#3-put-操作" class="headerlink" title="3. put 操作"></a>3. put 操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 键为 null 单独处理</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="comment">// 确定桶下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 插入新键值对</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> V <span class="title function_">putForNullKey</span><span class="params">(V value)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(<span class="number">0</span>, <span class="literal">null</span>, value, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">// 头插法，链表头部指向新的键值对</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Entry(<span class="type">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">    value = v;</span><br><span class="line">    next = n;</span><br><span class="line">    key = k;</span><br><span class="line">    hash = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-确定桶下标"><a href="#4-确定桶下标" class="headerlink" title="4. 确定桶下标"></a>4. 确定桶下标</h3><p>很多操作都需要先确定一个键值对所在的桶下标。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br></pre></td></tr></table></figure>

<p><strong>4.1 计算 hash 值</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.2 取模</strong>  </p>
<p>令 x &#x3D; 1&lt;&lt;4，即 x 为 2 的 4 次方，它具有以下性质：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x   : 00010000</span><br><span class="line">x-1 : 00001111</span><br></pre></td></tr></table></figure>

<p>令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y       : 10110010</span><br><span class="line">x-1     : 00001111</span><br><span class="line">y&amp;(x-1) : 00000010</span><br></pre></td></tr></table></figure>

<p>这个性质和 y 对 x 取模效果是一样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y   : 10110010</span><br><span class="line">x   : 00010000</span><br><span class="line">y%x : 00000010</span><br></pre></td></tr></table></figure>

<p>我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。</p>
<p>确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-扩容-基本原理"><a href="#5-扩容-基本原理" class="headerlink" title="5. 扩容-基本原理"></a>5. 扩容-基本原理</h3><p>设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N&#x2F;M，因此查找的复杂度为 O(N&#x2F;M)。</p>
<p>为了让查找的成本降低，应该使 N&#x2F;M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。</p>
<p>和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">capacity</td>
<td align="left">table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。</td>
</tr>
<tr>
<td align="center">size</td>
<td align="left">键值对数量。</td>
</tr>
<tr>
<td align="center">threshold</td>
<td align="left">size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。</td>
</tr>
<tr>
<td align="center">loadFactor</td>
<td align="left">装载因子，table 能够使用的比例，threshold &#x3D; (int)(capacity* loadFactor)。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br></pre></td></tr></table></figure>

<p>从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的两倍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">    <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];</span><br><span class="line">    transfer(newTable);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="type">int</span>)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable)</span> &#123;</span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-扩容-重新计算桶下标"><a href="#6-扩容-重新计算桶下标" class="headerlink" title="6. 扩容-重新计算桶下标"></a>6. 扩容-重新计算桶下标</h3><p>在进行扩容时，需要把键值对重新计算桶下标，从而放到对应的桶上。在前面提到，HashMap 使用 hash%capacity 来确定桶下标。HashMap capacity 为 2 的 n 次方这一特点能够极大降低重新计算桶下标操作的复杂度。</p>
<p>假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">capacity     : 00010000</span><br><span class="line">new capacity : 00100000</span><br></pre></td></tr></table></figure>

<p>对于一个 Key，它的哈希值 hash 在第 5 位：</p>
<ul>
<li>为 0，那么 hash%00010000 &#x3D; hash%00100000，桶位置和原来一致；</li>
<li>为 1，hash%00010000 &#x3D; hash%00100000 + 16，桶位置是原位置 + 16。</li>
</ul>
<h3 id="7-计算数组容量"><a href="#7-计算数组容量" class="headerlink" title="7. 计算数组容量"></a>7. 计算数组容量</h3><p>HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。</p>
<p>先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mask |= mask &gt;&gt; 1    11011000</span><br><span class="line">mask |= mask &gt;&gt; 2    11111110</span><br><span class="line">mask |= mask &gt;&gt; 4    11111111</span><br></pre></td></tr></table></figure>

<p>mask+1 是大于原始数字的最小的 2 的 n 次方。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">num     10010000</span><br><span class="line">mask+1 100000000</span><br></pre></td></tr></table></figure>

<p>以下是 HashMap 中计算数组容量的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-链表转红黑树"><a href="#8-链表转红黑树" class="headerlink" title="8. 链表转红黑树"></a>8. 链表转红黑树</h3><p>从 JDK 1.8 开始，一个桶存储的链表长度大于等于 8 时会将链表转换为红黑树。</p>
<h3 id="9-与-Hashtable-的比较"><a href="#9-与-Hashtable-的比较" class="headerlink" title="9. 与 Hashtable 的比较"></a>9. 与 Hashtable 的比较</h3><ul>
<li>Hashtable 使用 synchronized 来进行同步。</li>
<li>HashMap 可以插入键为 null 的 Entry。</li>
<li>HashMap 的迭代器是 fail-fast 迭代器。</li>
<li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。</li>
</ul>
<p>Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null。</p>
<p>因为Hashtable在我们put 空值的时候会直接抛空指针异常，但是HashMap却做了特殊处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">  <span class="type">int</span> h;</span><br><span class="line">  <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null？</p>
<p>这是因为Hashtable使用的是<strong>安全失败机制（fail-safe）</strong>，这种机制会使你此次读到的数据不一定是最新的数据。</p>
<p>如果你使用null值，就会使得其无法判断对应的key是不存在还是为空，因为你无法再调用一次contain(key）来对key是否存在进行判断，ConcurrentHashMap同理。</p>
<blockquote>
<p><strong>fail-fast是啥？</strong></p>
</blockquote>
<p><strong>快速失败（fail—fast）</strong>是java集合中的一种机制， 在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。</p>
<blockquote>
<p>他的原理是啥？</p>
</blockquote>
<p>迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。</p>
<p>集合在被遍历期间如果内容发生变化，就会改变modCount的值。</p>
<p>每当迭代器使用hashNext()&#x2F;next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p>
<p><strong>Tip</strong>：这里异常的抛出条件是检测到 modCount！&#x3D;expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。</p>
<p>因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。</p>
<blockquote>
<p>说说他的场景？</p>
</blockquote>
<p>java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）算是一种安全机制吧。</p>
<p><strong>Tip</strong>：<strong>安全失败（fail—safe）</strong>大家也可以了解下，java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p>
<h3 id="10-HashMap默认加载因子为什么选择0-75？"><a href="#10-HashMap默认加载因子为什么选择0-75？" class="headerlink" title="10.HashMap默认加载因子为什么选择0.75？"></a>10.HashMap默认加载因子为什么选择0.75？</h3><p><strong>Hashtable 初始容量是11 ，扩容 方式为2N+1;</strong></p>
<p><strong>HashMap 初始容量是16,扩容方式为2N;</strong>　　</p>
<p>阿里的人突然问我为啥扩容因子是0.75，回来总结了一下； <strong>提高空间利用率和 减少查询成本的折中，主要是泊松分布，0.75的话碰撞最小，</strong></p>
<p>HashMap有两个参数影响其性能：初始容量和加载因子。容量是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。加载因子是哈希表在其容量自动扩容之前可以达到多满的一种度量。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行扩容、rehash操作（即重建内部数据结构），扩容后的哈希表将具有两倍的原容量。</p>
<p>通常，加载因子需要在时间和空间成本上寻求一种折衷。</p>
<p>加载因子过高，例如为1，虽然减少了空间开销，提高了空间利用率，但同时也增加了查询时间成本；</p>
<p><strong>加载因子过低，例如0.5，虽然可以减少查询时间成本，但是空间利用率很低，同时提高了rehash操作的次数</strong>。</p>
<p><strong>在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少rehash操作次数，所以，一般在使用HashMap时建议根据预估值设置初始容量，减少扩容操作。</strong></p>
<p><strong>选择0.75作为默认的加载因子，完全是时间和空间成本上寻求的一种折衷选择，</strong> </p>
<h3 id="JDK1-8分析（以面试官的形式提问分析）"><a href="#JDK1-8分析（以面试官的形式提问分析）" class="headerlink" title="JDK1.8分析（以面试官的形式提问分析）"></a>JDK1.8分析（以面试官的形式提问分析）</h3><p>数组里面每个地方都存了Key-Value这样的实例，在Java7叫Entry在Java8中叫Node。<br><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/8.png" alt="在这里插入图片描述"></p>
<p>因为他本身所有的位置都为null，在put插入的时候会根据key的hash去计算一个index值。  </p>
<p>就比如我put（”帅丙“，520），我插入了为”帅丙“的元素，这个时候我们会通过哈希函数计算出插入的位置，计算出来index是2那结果如下。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hash（“帅丙”）= <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/9.png" alt="在这里插入图片描述"></p>
<p><strong>问：你提到了还有链表，为啥需要链表，链表又是怎么样子的呢？</strong><br>我们都知道数组长度是有限的，在有限的长度里面我们使用哈希，哈希本身就存在概率性，就是”帅丙“和”丙帅“我们都去hash有一定的概率会一样，就像上面的情况我再次哈希”丙帅“极端情况也会hash到一个值上，那就形成了链表。<br><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/10.png" alt="在这里插入图片描述"></p>
<p>每一个节点都会保存自身的hash、key、value、以及下个节点，我们看Node的源码。<br><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/11.png" alt="在这里插入图片描述"></p>
<p><strong>问：说到链表我想问一下，你知道新的Entry节点在插入链表的时候，是怎么插入的么？</strong>  </p>
<p>java8之前是头插法，就是说新来的值会取代原有的值，原有的值就顺推到链表中去，就像上面的例子一样，因为写这个代码的作者认为后来的值被查找的可能性更大一点，提升查找的效率。<br>但是，在java8之后，都是所用尾部插入了。  </p>
<p><strong>问：为啥改为尾部插入呢？</strong>  </p>
<p>首先我们看下HashMap的扩容机制：<br>数组容量是有限的，数据多次插入的，到达一定的数量就会进行扩容，也就是resize。  </p>
<p><strong>问：什么时候resize呢？</strong>   </p>
<p>有两个因素：  </p>
<p>Capacity：HashMap当前长度。  </p>
<p>LoadFactor：负载因子，默认值0.75f。<br><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/12.png" alt="在这里插入图片描述"></p>
<p>怎么理解呢，就比如当前的容量大小为100，当你存进第76个的时候，判断发现需要进行resize了，那就进行扩容，但是HashMap的扩容也不是简单的扩大点容量这么简单的。  </p>
<p><strong>扩容？它是怎么扩容的呢？</strong><br>分为两步：  </p>
<p>扩容：创建一个新的Entry空数组，长度是原数组的2倍。  </p>
<p>ReHash：遍历原Entry数组，把所有的Entry重新Hash到新数组。  </p>
<p><strong>问：为什么要重新Hash呢，直接复制过去不香么？</strong><br>是因为长度扩大以后，Hash的规则也随之改变。  </p>
<p>Hash的公式—&gt; index &#x3D; HashCode（Key） &amp; （Length - 1）  </p>
<p>原来长度（Length）是8你位运算出来的值是2 ，新的长度是16你位运算出来的值明显不一样了。  </p>
<p>扩容前：<br><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/13.png" alt="在这里插入图片描述"></p>
<p>扩容后：<br><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/14.png" alt="在这里插入图片描述"></p>
<p><strong>问：说完扩容机制我们言归正传，为啥之前用头插法，java8之后改成尾插了呢？</strong><br>我先举个例子吧，我们现在往一个容量大小为2的put两个值，负载因子是0.75是不是我们在put第二个的时候就会进行resize？  </p>
<p>2*0.75 &#x3D; 1 所以插入第二个就要resize了<br><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/15.png" alt="在这里插入图片描述"></p>
<p>现在我们要在容量为2的容器里面用不同线程插入A，B，C，假如我们在resize之前打个短点，那意味着数据都插入了但是还没resize那扩容前可能是这样的。</p>
<p>我们可以看到链表的指向A-&gt;B-&gt;C  </p>
<p>Tip：A的下一个指针是指向B的  </p>
<p><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/16.png" alt="在这里插入图片描述"></p>
<p>因为resize的赋值方式，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置，在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p>
<p>就可能出现下面的情况，大家发现问题没有？</p>
<p>B的下一个指针指向了A  </p>
<p><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/17.png" alt="在这里插入图片描述"></p>
<p>一旦几个线程都调整完成，就可能出现环形链表  </p>
<p><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/18.png" alt="在这里插入图片描述"></p>
<p>如果这个时候去取值，悲剧就出现了——Infinite Loop。 </p>
<p><strong>问：头插是JDK1.7的那1.8的尾插是怎么样的呢？</strong><br>因为java8之后链表有红黑树的部分，大家可以看到代码已经多了很多if else的逻辑判断了，红黑树的引入巧妙的将原本O(n)的时间复杂度降低到了O(logn)。 </p>
<p>使用头插会改变链表的上的顺序，但是如果使用尾插，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了。</p>
<p>就是说原本是A-&gt;B，在扩容后那个链表还是A-&gt;B<br><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/19.png" alt="在这里插入图片描述"></p>
<p>Java7在多线程操作HashMap时可能引起死循环，原因是扩容转移后前后链表顺序倒置，在转移过程中修改了原来链表中节点的引用关系。</p>
<p>Java8在同样的前提下并不会引起死循环，原因是扩容转移后前后链表顺序不变，保持之前节点的引用关系。  </p>
<p><strong>问：那是不是意味着Java8就可以把HashMap用在多线程中呢？</strong><br>    即使不会出现死循环，但是通过源码看到put&#x2F;get方法都没有加同步锁，多线程情况最容易出现的就是：无法保证上一秒put的值，下一秒get的时候还是原值，所以线程安全还是无法保证。  </p>
<p><strong>问：HashMap的默认初始化长度是多少？</strong><br><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/20.png" alt="在这里插入图片描述"></p>
<p><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/21.png" alt="在这里插入图片描述"></p>
<p>位与运算比算数计算的效率高了很多，之所以选择16，是为了服务将Key映射到index的算法。<br>我前面说了所有的key我们都会拿到他的hash，但是我们怎么尽可能的得到一个均匀分布的hash呢？</p>
<p>是的我们通过Key的HashCode值去做位运算。</p>
<p>我打个比方，key为”帅丙“的十进制为766132那二进制就是 10111011000010110100<br><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/22.png" alt="在这里插入图片描述"></p>
<p>我们再看下index的计算公式：index &#x3D; HashCode（Key） &amp; （Length- 1）<br>15的的二进制是1111，那10111011000010110100 &amp;1111 十进制就是4<br><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/23.png" alt="在这里插入图片描述"></p>
<p>之所以用位与运算效果与取模一样，性能也提高了不少！  </p>
<p><strong>问：那为啥用16不用别的呢？</strong><br>因为在使用不是2的幂的数字的时候，Length-1的值是所有二进制位全为1，这种情况下，index的结果等同于HashCode后几位的值。</p>
<p>只要输入的HashCode本身分布均匀，Hash算法的结果就是均匀的。</p>
<p>这是为了实现均匀分布。  </p>
<p><strong>我们重写equals方法的时候需要重写hashCode方法呢？你能用HashMap给我举个例子么？</strong></p>
<p>因为在java中，所有的对象都是继承于Object类。Ojbect类中有两个方法equals、hashCode，这两个方法都是用来比较两个对象是否相等的。</p>
<p>在未重写equals方法我们是继承了object的equals方法，那里的 equals是比较两个对象的内存地址，显然我们new了2个对象内存地址肯定不一样</p>
<p>对于值对象，&#x3D;&#x3D;比较的是两个对象的值</p>
<p>对于引用对象，比较的是两个对象的地址</p>
<p>大家是否还记得我说的HashMap是通过key的hashCode去寻找index的，那index一样就形成链表了，也就是说”帅丙“和”丙帅“的index都可能是2，在一个链表上的。</p>
<p>我们去get的时候，他就是根据key去hash然后计算出index，找到了2，那我怎么找到具体的”帅丙“还是”丙帅“呢？</p>
<p>equals！是的，所以如果我们对equals方法进行了重写，建议一定要对hashCode方法重写，以保证相同的对象返回相同的hash值，不同的对象返回不同的hash值。</p>
<p>不然一个链表的对象，你哪里知道你要找的是哪个，到时候发现hashCode都一样，这不是完犊子嘛。  </p>
<p><strong>问：我记得你上面说过他是线程不安全的，那你能跟我聊聊你们是怎么处理HashMap在线程安全的场景么？</strong></p>
<p>面试官，在这样的场景，我们一般都会使用HashTable或者CurrentHashMap，但是因为前者的并发度的原因基本上没啥使用场景了，所以存在线程不安全的场景我们都使用的是CorruentHashMap。</p>
<p>HashTable我看过他的源码，很简单粗暴，直接在方法上锁，并发度很低，最多同时允许一个线程访问，currentHashMap就好很多了，1.7和1.8有较大的不同，不过并发度都比前者好太多了。<br><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/24.png" alt="在这里插入图片描述"></p>
<p><strong>问：那你能跟我聊聊CurrentHashMap么？</strong></p>
<p>往下看。。。。。。。。</p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="1-存储结构-1"><a href="#1-存储结构-1" class="headerlink" title="1. 存储结构"></a>1. 存储结构</h3><p><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/25.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HashEntry</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcurrentHashMap采用了二次hash的方式，第一次hash将key映射到对应的segment，而第二次hash则是映射到segment的不同桶(bucket)中。<br>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。</p>
<p>Segment 继承自 ReentrantLock。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Segment</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">2249069246763182397L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SCAN_RETRIES</span> <span class="operator">=</span></span><br><span class="line">        Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span> ? <span class="number">64</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br></pre></td></tr></table></figure>

<p>默认的并发级别为 16，也就是说默认创建 16 个 Segment。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CONCURRENCY_LEVEL</span> <span class="operator">=</span> <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<p>HashEntry跟HashMap差不多的，但是不同点是，他使用volatile去修饰了他的数据Value还有下一个节点next。</p>
<blockquote>
<p>volatile的特性是啥？</p>
</blockquote>
<ul>
<li><p>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。（实现<strong>可见性</strong>）</p>
</li>
<li><p>禁止进行指令重排序。（实现<strong>有序性</strong>）</p>
</li>
<li><p>volatile 只能保证对单次读&#x2F;写的原子性。i++ 这种操作不能保证<strong>原子性</strong>。</p>
</li>
</ul>
<h3 id="2-size-操作"><a href="#2-size-操作" class="headerlink" title="2. size 操作"></a>2. size 操作</h3><p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of elements. Accessed only either within locks</span></span><br><span class="line"><span class="comment"> * or among other volatile reads that maintain visibility.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> count;</span><br></pre></td></tr></table></figure>

<p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。</p>
<p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。</p>
<p>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。</p>
<p>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Number of unsynchronized retries in size and containsValue</span></span><br><span class="line"><span class="comment"> * methods before resorting to locking. This is used to avoid</span></span><br><span class="line"><span class="comment"> * unbounded retries if tables undergo continuous modification</span></span><br><span class="line"><span class="comment"> * which would make it impossible to obtain an accurate result.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RETRIES_BEFORE_LOCK</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">    <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="built_in">this</span>.segments;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">    <span class="type">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">last</span> <span class="operator">=</span> <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">retries</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// first iteration isn&#x27;t retry</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 超过尝试次数，则对每个 Segment 加锁</span></span><br><span class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="number">0L</span>;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            overflow = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="literal">null</span>) &#123;</span><br><span class="line">                    sum += seg.modCount;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> seg.count;</span><br><span class="line">                    <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                        overflow = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 连续两次得到的结果一致，则认为这个结果是正确的</span></span><br><span class="line">            <span class="keyword">if</span> (sum == last)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            last = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们看看他的put源代码，你就知道他是怎么做到线程安全的了，关键句子我注释了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">put</span><span class="params">(K key, <span class="type">int</span> hash, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">          <span class="comment">// 将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry</span></span><br><span class="line">            HashEntry&lt;K,V&gt; node = tryLock() ? <span class="literal">null</span> :</span><br><span class="line">                scanAndLockForPut(key, hash, value);</span><br><span class="line">            V oldValue;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">                HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                        K k;</span><br><span class="line"> <span class="comment">// 遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。</span></span><br><span class="line">                        <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                            (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                            oldValue = e.value;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                                e.value = value;</span><br><span class="line">                                ++modCount;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        e = e.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// 不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。</span></span><br><span class="line">                        <span class="keyword">if</span> (node != <span class="literal">null</span>)</span><br><span class="line">                            node.setNext(first);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            node = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> count + <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                            rehash(node);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            setEntryAt(tab, index, node);</span><br><span class="line">                        ++modCount;</span><br><span class="line">                        count = c;</span><br><span class="line">                        oldValue = <span class="literal">null</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="comment">//释放锁</span></span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>首先第一步的时候会尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 <code>scanAndLockForPut()</code> 自旋获取锁。</p>
<ol>
<li>尝试自旋获取锁。</li>
<li>如果重试的次数达到了 <code>MAX_SCAN_RETRIES</code> 则改为阻塞锁获取，保证能获取成功。</li>
</ol>
<blockquote>
<p>那他get的逻辑呢？</p>
</blockquote>
<p>get 逻辑比较简单，只需要将 Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上。</p>
<p>由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值。</p>
<p>ConcurrentHashMap 的 get 方法是非常高效的，<strong>因为整个过程都不需要加锁</strong>。</p>
<blockquote>
<p>你有没有发现1.7虽然可以支持每个Segment并发访问，但是还是存在一些问题？</p>
</blockquote>
<p>是的，因为基本上还是数组加链表的方式，我们去查询的时候，还得遍历链表，会导致效率很低，这个跟jdk1.7的HashMap是存在的一样问题，所以他在jdk1.8完全优化了。</p>
<h3 id="3-JDK-1-8-的改动"><a href="#3-JDK-1-8-的改动" class="headerlink" title="3. JDK 1.8 的改动"></a>3. JDK 1.8 的改动</h3><p>JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。</p>
<p>其中抛弃了原有的 Segment 分段锁，而采用了 <code>CAS + synchronized</code> 来保证并发安全性。并且 JDK 1.8 的实现也在链表过长时会转换为红黑树。</p>
<p>跟HashMap很像，也把之前的HashEntry改成了Node，但是作用不变，把值和next采用了volatile去修饰，保证了可见性，并且也引入了红黑树，在链表大于一定值的时候会转换（默认是8）。</p>
<blockquote>
<p>同样的，你能跟我聊一下他值的存取操作么？以及是怎么保证线程安全的？</p>
</blockquote>
<p>ConcurrentHashMap在进行put操作的还是比较复杂的，大致可以分为以下步骤：</p>
<ol>
<li>根据 key 计算出 hashcode 。</li>
<li>判断是否需要进行初始化。</li>
<li>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li>
<li>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</li>
<li>如果都不满足，则利用 synchronized 锁写入数据。</li>
<li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</li>
</ol>
<p><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/26.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>你在上面提到CAS是什么？自旋又是什么？</p>
</blockquote>
<p>CAS 是乐观锁的一种实现方式，是一种轻量级锁，JUC 中很多工具类的实现就是基于 CAS 的。</p>
<p>CAS 操作的流程如下图所示，线程在读取数据时不进行加锁，在准备写回数据时，比较原值是否修改，若未被其他线程修改则写回，若已被修改，则重新执行读取流程。</p>
<p>这是一种乐观策略，认为并发操作并不总会发生。<br><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/27.png" alt="在这里插入图片描述"></p>
<p>还是不明白？那我再说明下，乐观锁在实际开发场景中非常常见，大家还是要去理解。</p>
<p>就比如我现在要修改数据库的一条数据，修改之前我先拿到他原来的值，然后在SQL里面还会加个判断，原来的值和我手上拿到的他的原来的值是否一样，一样我们就可以去修改了，不一样就证明被别的线程修改了你就return错误就好了。</p>
<p>SQL伪代码大概如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">update a <span class="type">set</span> <span class="variable">value</span> <span class="operator">=</span> newValue <span class="type">where</span> <span class="variable">value</span> <span class="operator">=</span> #&#123;oldValue&#125;<span class="comment">//oldValue就是我们执行前查询出来的值 </span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>CAS就一定能保证数据没被别的线程修改过么？</p>
</blockquote>
<p>并不是的，比如很经典的ABA问题，CAS就无法判断了。</p>
<blockquote>
<p>什么是ABA？</p>
</blockquote>
<p>就是说来了一个线程把值改回了B，又来了一个线程把值又改回了A，对于这个时候判断的线程，就发现他的值还是A，所以他就不知道这个值到底有没有被人改过，其实很多场景如果只追求最后结果正确，这是没关系的。</p>
<p>但是实际过程中还是需要记录修改过程的，比如资金修改什么的，你每次修改的都应该有记录，方便回溯。</p>
<blockquote>
<p>那怎么解决ABA问题？</p>
</blockquote>
<p>用版本号去保证就好了，就比如说，我在修改前去查询他原来的值的时候再带一个版本号，每次判断就连值和版本号一起判断，判断成功就给版本号加1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">update a <span class="type">set</span> <span class="variable">value</span> <span class="operator">=</span> newValue ，vision = vision + <span class="number">1</span> <span class="type">where</span> <span class="variable">value</span> <span class="operator">=</span> #&#123;oldValue&#125; <span class="type">and</span> <span class="variable">vision</span> <span class="operator">=</span> #&#123;vision&#125; <span class="comment">// 判断原来的值和版本号是否匹配，中间有别的线程修改，值可能相等，但是版本号100%不一样</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>牛*，有点东西，除了版本号还有别的方法保证么？</p>
</blockquote>
<p>其实有很多方式，比如时间戳也可以，查询的时候把时间戳一起查出来，对的上才修改并且更新值的时候一起修改更新时间，这样也能保证，方法很多但是跟版本号都是异曲同工之妙，看场景大家想怎么设计吧。</p>
<blockquote>
<p>CAS性能很高，但是我知道synchronized性能可不咋地，为啥jdk1.8升级之后反而多了synchronized？</p>
</blockquote>
<p>synchronized之前一直都是重量级的锁，但是后来java官方是对他进行过升级的，他现在采用的是锁升级的方式去做的。</p>
<p>针对 synchronized 获取锁的方式，JVM 使用了锁升级的优化方式，就是先使用<strong>偏向锁</strong>优先同一线程然后再次获取锁，如果失败，就升级为 <strong>CAS 轻量级锁</strong>，如果失败就会短暂<strong>自旋</strong>，防止线程被系统挂起。最后如果以上都失败就升级为<strong>重量级锁</strong>。</p>
<p>所以是一步步升级上去的，最初也是通过很多轻量级的方式锁定的。</p>
<blockquote>
<p>🐂，那我们回归正题，ConcurrentHashMap的get操作又是怎么样子的呢？</p>
</blockquote>
<ul>
<li>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</li>
<li>如果是红黑树那就按照树的方式获取值。</li>
<li>就不满足那就按照链表的方式遍历获取值。<br><img src="/2022/10/24/Java%E9%9B%86%E5%90%88/28.png" alt="在这里插入图片描述"></li>
</ul>
<p>小结：1.8 在 1.7 的数据结构上做了大的改动，采用红黑树之后可以保证查询效率（<code>O(logn)</code>），甚至取消了 ReentrantLock 改为了 synchronized，这样可以看出在新版的 JDK 中对 synchronized 优化是很到位的。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka基础知识点</title>
    <url>/2022/10/25/Kafka%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>Kafka基础知识点PDF</p>
<div class="pdf-container" data-target="./01_尚硅谷大数据技术之Kafka.pdf" data-height="1000px"></div>]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>MQ</tag>
        <tag>消息队列</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis源码分析-插件机制</title>
    <url>/2022/10/25/MyBatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>一般情况下，开源框架都会提供插件或其他形式的拓展点，供开发者自行拓展。这样的好处是显而易见的，一是增加了框架的灵活性。二是开发者可以结合实际需求，对框架进行拓展，使其能够更好的工作。以 MyBatis 为例，我们可基于 MyBatis 插件机制实现分页、分表，监控等功能。由于插件和业务无关，业务也无法感知插件的存在。因此可以无感植入插件，在无形中增强功能。</p>
<p>开发 MyBatis 插件需要对 MyBatis 比较深了解才行，一般来说最好能够掌握 MyBatis 的源码，门槛相对较高。本篇文章在分析完 MyBatis 插件机制后，会手写一个简单的分页插件，以帮助大家更好的掌握 MyBatis 插件的编写。</p>
<h2 id="2-插件机制原理"><a href="#2-插件机制原理" class="headerlink" title="2. 插件机制原理"></a>2. 插件机制原理</h2><p>我们在编写插件时，除了需要让插件类实现 Interceptor 接口，还需要通过注解标注该插件的拦截点。所谓拦截点指的是插件所能拦截的方法，MyBatis 所允许拦截的方法如下：</p>
<ul>
<li>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</li>
<li>ParameterHandler (getParameterObject, setParameters)</li>
<li>ResultSetHandler (handleResultSets, handleOutputParameters)</li>
<li>StatementHandler (prepare, parameterize, batch, update, query)</li>
</ul>
<p>如果我们想要拦截 Executor 的 query 方法，那么可以这样定义插件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Intercepts(&#123;</span><br><span class="line">    @Signature(</span><br><span class="line">        type = Executor.class,</span><br><span class="line">        method = &quot;query&quot;,</span><br><span class="line">        args =&#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br><span class="line">public class ExamplePlugin implements Interceptor &#123;</span><br><span class="line">    // 省略逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，我们还需将插件配置到相关文件中。这样 MyBatis 在启动时可以加载插件，并保存插件实例到相关对象（InterceptorChain，拦截器链）中。待准备工作做完后，MyBatis 处于就绪状态。我们在执行 SQL 时，需要先通过 DefaultSqlSessionFactory 创建 SqlSession 。Executor 实例会在创建 SqlSession 的过程中被创建，Executor 实例创建完毕后，MyBatis 会通过 JDK 动态代理为实例生成代理类。这样，插件逻辑即可在 Executor 相关方法被调用前执行。</p>
<p>以上就是 MyBatis 插件机制的基本原理。接下来，我们来看一下原理背后对应的源码是怎样的。</p>
<h2 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3. 源码分析"></a>3. 源码分析</h2><h3 id="3-1-植入插件逻辑"><a href="#3-1-植入插件逻辑" class="headerlink" title="3.1 植入插件逻辑"></a>3.1 植入插件逻辑</h3><p>本节，我将以 Executor 为例，分析 MyBatis 是如何为 Executor 实例植入插件逻辑的。Executor 实例是在开启 SqlSession 时被创建的，因此，下面我们从源头进行分析。先来看一下 SqlSession 开启的过程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- DefaultSqlSessionFactory</span><br><span class="line">public SqlSession openSession() &#123;</span><br><span class="line">    return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) &#123;</span><br><span class="line">    Transaction tx = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 省略部分逻辑</span><br><span class="line">        </span><br><span class="line">        // 创建 Executor</span><br><span class="line">        final Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">        return new DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">    &#125; </span><br><span class="line">    catch (Exception e) &#123;...&#125; </span><br><span class="line">    finally &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Executor 的创建过程封装在 Configuration 中，我们跟进去看看看。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- Configuration</span><br><span class="line">public Executor newExecutor(Transaction transaction, ExecutorType executorType) &#123;</span><br><span class="line">    executorType = executorType == null ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == null ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    </span><br><span class="line">    // 根据 executorType 创建相应的 Executor 实例</span><br><span class="line">    if (ExecutorType.BATCH == executorType) &#123;...&#125; </span><br><span class="line">    else if (ExecutorType.REUSE == executorType) &#123;...&#125; </span><br><span class="line">    else &#123;</span><br><span class="line">        executor = new SimpleExecutor(this, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    if (cacheEnabled) &#123;</span><br><span class="line">        executor = new CachingExecutor(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 植入插件</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    return executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，newExecutor 方法在创建好 Executor 实例后，紧接着通过拦截器链 interceptorChain 为 Executor 实例植入代理逻辑。那下面我们看一下 InterceptorChain 的代码是怎样的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class InterceptorChain &#123;</span><br><span class="line"></span><br><span class="line">    private final List&lt;Interceptor&gt; interceptors = new ArrayList&lt;Interceptor&gt;();</span><br><span class="line"></span><br><span class="line">    public Object pluginAll(Object target) &#123;</span><br><span class="line">        // 遍历拦截器集合</span><br><span class="line">        for (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">            // 调用拦截器的 plugin 方法植入相应的插件逻辑</span><br><span class="line">            target = interceptor.plugin(target);</span><br><span class="line">        &#125;</span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** 添加插件实例到 interceptors 集合中 */</span><br><span class="line">    public void addInterceptor(Interceptor interceptor) &#123;</span><br><span class="line">        interceptors.add(interceptor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** 获取插件列表 */</span><br><span class="line">    public List&lt;Interceptor&gt; getInterceptors() &#123;</span><br><span class="line">        return Collections.unmodifiableList(interceptors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是 InterceptorChain 的全部代码，比较简单。它的 pluginAll 方法会调用具体插件的 plugin 方法植入相应的插件逻辑。如果有多个插件，则会多次调用 plugin 方法，最终生成一个层层嵌套的代理类。形如下面：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15352797020539.jpg" alt="img"></p>
<p>当 Executor 的某个方法被调用的时候，插件逻辑会先行执行。执行顺序由外而内，比如上图的执行顺序为 <code>plugin3 → plugin2 → Plugin1 → Executor</code>。</p>
<p>plugin 方法是由具体的插件类实现，不过该方法代码一般比较固定，所以下面找个示例分析一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- ExamplePlugin</span><br><span class="line">public Object plugin(Object target) &#123;</span><br><span class="line">    return Plugin.wrap(target, this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// -☆- Plugin</span><br><span class="line">public static Object wrap(Object target, Interceptor interceptor) &#123;</span><br><span class="line">    /*</span><br><span class="line">     * 获取插件类 @Signature 注解内容，并生成相应的映射结构。形如下面：</span><br><span class="line">     * &#123;</span><br><span class="line">     *     Executor.class : [query, update, commit],</span><br><span class="line">     *     ParameterHandler.class : [getParameterObject, setParameters]</span><br><span class="line">     * &#125;</span><br><span class="line">     */</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">    Class&lt;?&gt; type = target.getClass();</span><br><span class="line">    // 获取目标类实现的接口</span><br><span class="line">    Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">    if (interfaces.length &gt; 0) &#123;</span><br><span class="line">        // 通过 JDK 动态代理为目标类生成代理类</span><br><span class="line">        return Proxy.newProxyInstance(</span><br><span class="line">            type.getClassLoader(),</span><br><span class="line">            interfaces,</span><br><span class="line">            new Plugin(target, interceptor, signatureMap));</span><br><span class="line">    &#125;</span><br><span class="line">    return target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，plugin 方法在内部调用了 Plugin 类的 wrap 方法，用于为目标对象生成代理。Plugin 类实现了 InvocationHandler 接口，因此它可以作为参数传给 Proxy 的 newProxyInstance 方法。</p>
<p>到这里，关于插件植入的逻辑就分析完了。接下来，我们来看看插件逻辑是怎样执行的。</p>
<h3 id="3-2-执行插件逻辑"><a href="#3-2-执行插件逻辑" class="headerlink" title="3.2 执行插件逻辑"></a>3.2 执行插件逻辑</h3><p>Plugin 实现了 InvocationHandler 接口，因此它的 invoke 方法会拦截所有的方法调用。invoke 方法会对所拦截的方法进行检测，以决定是否执行插件逻辑。该方法的逻辑如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- Plugin</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        /*</span><br><span class="line">         * 获取被拦截方法列表，比如：</span><br><span class="line">         *    signatureMap.get(Executor.class)，可能返回 [query, update, commit]</span><br><span class="line">         */</span><br><span class="line">        Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());</span><br><span class="line">        // 检测方法列表是否包含被拦截的方法</span><br><span class="line">        if (methods != null &amp;&amp; methods.contains(method)) &#123;</span><br><span class="line">            // 执行插件逻辑</span><br><span class="line">            return interceptor.intercept(new Invocation(target, method, args));</span><br><span class="line">        &#125;</span><br><span class="line">        // 执行被拦截的方法</span><br><span class="line">        return method.invoke(target, args);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw ExceptionUtil.unwrapThrowable(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>invoke 方法的代码比较少，逻辑不难理解。首先，invoke 方法会检测被拦截方法是否配置在插件的 @Signature 注解中，若是，则执行插件逻辑，否则执行被拦截方法。插件逻辑封装在 intercept 中，该方法的参数类型为 Invocation。Invocation 主要用于存储目标类，方法以及方法参数列表。下面简单看一下该类的定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Invocation &#123;</span><br><span class="line"></span><br><span class="line">    private final Object target;</span><br><span class="line">    private final Method method;</span><br><span class="line">    private final Object[] args;</span><br><span class="line"></span><br><span class="line">    public Invocation(Object target, Method method, Object[] args) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">        this.method = method;</span><br><span class="line">        this.args = args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 省略部分代码</span><br><span class="line"></span><br><span class="line">    public Object proceed() throws InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        // 调用被拦截的方法</span><br><span class="line">        return method.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于插件的执行逻辑就分析到这，整个过程不难理解，大家简单看看即可。</p>
<h2 id="4-实现一个分页插件"><a href="#4-实现一个分页插件" class="headerlink" title="4. 实现一个分页插件"></a>4. 实现一个分页插件</h2><p>为了更好的向大家介绍 MyBatis 的插件机制，下面我将手写一个针对 MySQL 的分页插件。Talk is cheap. Show the code。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Intercepts(&#123;</span><br><span class="line">    @Signature(</span><br><span class="line">        type = Executor.class,    // 目标类</span><br><span class="line">        method = &quot;query&quot;,    // 目标方法</span><br><span class="line">        args =&#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br><span class="line">public class MySqlPagingPlugin implements Interceptor &#123;</span><br><span class="line"></span><br><span class="line">    private static final Integer MAPPED_STATEMENT_INDEX = 0;</span><br><span class="line">    private static final Integer PARAMETER_INDEX = 1;</span><br><span class="line">    private static final Integer ROW_BOUNDS_INDEX = 2;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line">        Object[] args = invocation.getArgs();</span><br><span class="line">        RowBounds rb = (RowBounds) args[ROW_BOUNDS_INDEX];</span><br><span class="line">        // 无需分页</span><br><span class="line">        if (rb == RowBounds.DEFAULT) &#123;</span><br><span class="line">            return invocation.proceed();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 将原 RowBounds 参数设为 RowBounds.DEFAULT，关闭 MyBatis 内置的分页机制</span><br><span class="line">        args[ROW_BOUNDS_INDEX] = RowBounds.DEFAULT;</span><br><span class="line"></span><br><span class="line">        MappedStatement ms = (MappedStatement) args[MAPPED_STATEMENT_INDEX];</span><br><span class="line">        BoundSql boundSql = ms.getBoundSql(args[PARAMETER_INDEX]);</span><br><span class="line"></span><br><span class="line">        // 获取 SQL 语句，拼接 limit 语句</span><br><span class="line">        String sql = boundSql.getSql();</span><br><span class="line">        String limit = String.format(&quot;LIMIT %d,%d&quot;, rb.getOffset(), rb.getLimit());</span><br><span class="line">        sql = sql + &quot; &quot; + limit;</span><br><span class="line"></span><br><span class="line">        // 创建一个 StaticSqlSource，并将拼接好的 sql 传入</span><br><span class="line">        SqlSource sqlSource = new StaticSqlSource(ms.getConfiguration(), sql, boundSql.getParameterMappings());</span><br><span class="line"></span><br><span class="line">        // 通过反射获取并设置 MappedStatement 的 sqlSource 字段</span><br><span class="line">        Field field = MappedStatement.class.getDeclaredField(&quot;sqlSource&quot;);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        field.set(ms, sqlSource);</span><br><span class="line">        </span><br><span class="line">        // 执行被拦截方法</span><br><span class="line">        return invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object plugin(Object target) &#123;</span><br><span class="line">        return Plugin.wrap(target, this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setProperties(Properties properties) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的分页插件通过 RowBounds 参数获取分页信息，并生成相应的 limit 语句。之后拼接 sql，并使用该 sql 作为参数创建 StaticSqlSource。最后通过反射替换 MappedStatement 对象中的 sqlSource 字段。以上代码中出现了一些大家不太熟悉的类，比如 BoundSql，MappedStatement 以及 StaticSqlSource，这里简单解释一下吧。BoundSql 包含了经过解析后的 sql 语句，以及使用者运行时传入的参数，这些参数最终会被设置到 sql 中。MappedStatement 与映射文件中的 <select>，<insert> 等节点对应，包含了节点的配置信息，比如 id，fetchSize 以及 SqlSource。StaticSqlSource 是 SqlSource 实现类之一，包含完全解析后的 sql 语句。所谓完全解析是指 sql 语句中不包含 ${xxx} 或 #{xxx} 等占位符，以及其他一些未解析的动态节点，比如 <if>，<where> 等。关于这些类就介绍这么多，如果大家还是不怎么理解的话，可以看看我之前写的文章。接下里，写点测试代码验证一下插件是否可以正常运行。先来看一下 Dao 接口与映射文件的定义：</where></if></insert></select></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface StudentDao &#123;</span><br><span class="line">    List&lt;Student&gt; findByPaging(@Param(&quot;id&quot;) Integer id, RowBounds rb);</span><br><span class="line">&#125;</span><br><span class="line">&lt;mapper namespace=&quot;xyz.coolblog.dao6.StudentDao&quot;&gt;</span><br><span class="line">    &lt;select id=&quot;findByPaging&quot; resultType=&quot;xyz.coolblog.model5.Student&quot;&gt;</span><br><span class="line">        SELECT</span><br><span class="line">            `id`, `name`, `age`</span><br><span class="line">        FROM</span><br><span class="line">            student</span><br><span class="line">        WHERE</span><br><span class="line">            id &gt; #&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>测试代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PluginTest &#123;</span><br><span class="line"></span><br><span class="line">    private SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    public void prepare() throws IOException &#123;</span><br><span class="line">        String resource = &quot;mybatis-plugin-config.xml&quot;;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testPlugin() &#123;</span><br><span class="line">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">        try &#123;</span><br><span class="line">            StudentDao studentDao = session.getMapper(StudentDao.class);</span><br><span class="line">            studentDao.findByPaging(1, new RowBounds(20, 10));</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            session.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码运行之后，会打印如下日志。</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15352145822059.jpg" alt="img"></p>
<p>在上面的输出中，SQL 语句中包含了 LIMIT 字样，这说明插件生效了。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>到此，关于 MyBatis 插件机制就分析完了。总体来说，MyBatis 插件机制比较简单。但实现一个插件却较为复杂，需要对 MyBatis 比较了解才行。因此，若想写出高效的插件，还需深入学习源码才行。</p>
<p>好了，本篇文章就先到这了。感谢大家的阅读。</p>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程总结</title>
    <url>/2022/10/24/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="1进程-x2F-线程是什么？"><a href="#1进程-x2F-线程是什么？" class="headerlink" title="1进程&#x2F;线程是什么？"></a>1进程&#x2F;线程是什么？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进程是“执行中的程序”，进行资源分配和调度的独立单位，线程是进程的实体，一个进程可以拥有多个线程，线程的上下文切换比进程要快，线程之间共享地址空间和其他资源。</span><br></pre></td></tr></table></figure>



<h3 id="2线程状态？"><a href="#2线程状态？" class="headerlink" title="2线程状态？"></a>2线程状态？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread 的源码中定义了6种状态：new（新建）、runnnable（可运行）、blocked（阻塞）、waiting（等待）、time waiting （定时等待）和 terminated（终止）。</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210411150209579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>线程状态转换如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411150228520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</p>
<p>对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">        B(A a) &#123;</span><br><span class="line">            <span class="built_in">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                a.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(a);</span><br><span class="line">        b.start();</span><br><span class="line">        a.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">JoinExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JoinExample</span>();</span><br><span class="line">    example.test();</span><br><span class="line">&#125;</span><br><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure>



<h4 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h4><p>对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    Thread.yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h4><p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I&#x2F;O 阻塞和 synchronized 锁阻塞。</p>
<p>对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread run&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread1.interrupt();</span><br><span class="line">    System.out.println(<span class="string">&quot;Main run&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at InterruptExample.lambda$main$<span class="number">0</span>(InterruptExample.java:<span class="number">5</span>)</span><br><span class="line">    at InterruptExample$$Lambda$<span class="number">1</span>/<span class="number">713338599.</span>run(Unknown Source)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br></pre></td></tr></table></figure>



<h4 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted()"></a>interrupted()</h4><p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。</p>
<p>但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!interrupted()) &#123;</span><br><span class="line">                <span class="comment">// ..</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread end&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line">    thread2.start();</span><br><span class="line">    thread2.interrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread end</span><br></pre></td></tr></table></figure>



<h3 id="3wait-x2F-sleep的区别？"><a href="#3wait-x2F-sleep的区别？" class="headerlink" title="3wait&#x2F;sleep的区别？"></a>3wait&#x2F;sleep的区别？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>sleep() 方法正在执行的线程主动让出 cpu（然后 cpu 就可以去执行其他任务），在sleep 指定时间后 cpu 再回到该线程继续往下执行（注意：sleep 方法只让出了cpu，而并不会释放同步资源锁）；</span><br><span class="line">  而 wait() 方法则是指当前线程让自己暂时退让出同步资源锁，以便其他正在等待该资源的线程得到该资源进而运行，只有调用了notify()方法，之前调用 wait() 的线程才会解除 wait 状态，可以去参与竞争同步资源锁，进而得到执行。（注意notify 的作用相当于叫醒睡着的人，而并不会给他分配任务，就是说 notify 只是让之前调用 wait 的线程有权利重新参与线程的调度）；</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>sleep() 方法可以在任何地方使用，而 wait() 方法则只能在同步方法或同步块中使用；</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>sleep() 是线程类（Thread）的方法，调用会暂停此线程指定的时间，但监控依然保持，不会释放对象锁，到时间自动恢复；wait() 是 Object 的方法，调用会放弃对象锁,进入等待队列，待调用 notify()/notifyAll() 唤醒指定的线程或者所有线程，才会进入竞争队列，再次获得对象锁才会进入运行状态。</span><br></pre></td></tr></table></figure>



<h3 id="4什么是并发？什么是并行？"><a href="#4什么是并发？什么是并行？" class="headerlink" title="4什么是并发？什么是并行？"></a>4什么是并发？什么是并行？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.解释一：并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。</span><br><span class="line"></span><br><span class="line">2.解释二：并行是在不同实体上的多个事件，并发是在同一实体上的多个事件.</span><br></pre></td></tr></table></figure>

<h1 id="2、Synchronized"><a href="#2、Synchronized" class="headerlink" title="2、Synchronized"></a>2、Synchronized</h1><p>我们知道并发编程会产生各种问题的源头是可见性，原子性，有序性。而synchronized能同时保证可见性，原子性，有序性。所以我们在解决并发问题的时候经常用synchronized，当然还有很多其他工具，如volatile。但是volatile只能保证可见性，有序性，不能保证原子性 .</p>
<p>synchronized可以用在如下地方</p>
<ol>
<li><p>修饰实例方法，对当前实例对象this加锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SynchronizedDemo <span class="keyword">synchronized</span>=<span class="keyword">new</span> <span class="title class_">SynchronizedDemo</span>();</span><br><span class="line"><span class="keyword">synchronized</span>.methodOne(); <span class="comment">//锁的是当前this对象，即synchronized,在此期间其他线程不能调用改方法中其他synchronized修饰的方法</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>修饰静态方法，对当前类的Class对象加锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SynchronizedDemo <span class="keyword">synchronized</span>=<span class="keyword">new</span> <span class="title class_">SynchronizedDemo</span>();</span><br><span class="line"><span class="keyword">synchronized</span>.methodTwo(); <span class="comment">//锁的是当前类的class对象，SynchronizedDemo.class 因为static修饰的方法是类方法</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>修饰代码块，指定加锁对象，对给定对象加锁</p>
</li>
</ol>
<p><strong>修饰实例方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">methodOne</span><span class="params">()</span> &#123;    </span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>修饰静态方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">methodTwo</span><span class="params">()</span> &#123; </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>修饰代码块</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodThree</span><span class="params">()</span> &#123;        </span><br><span class="line">        <span class="comment">// 对当前实例对象this加锁        </span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;   </span><br><span class="line">            </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodFour</span><span class="params">()</span> &#123;        </span><br><span class="line">        <span class="comment">// 对class对象加锁        </span></span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedDemo.class) &#123;        </span><br><span class="line">            </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第一章：并发编程中的三个问题"><a href="#第一章：并发编程中的三个问题" class="headerlink" title="第一章：并发编程中的三个问题"></a>第一章：并发编程中的三个问题</h2><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>学习什么是可见性问题 </p>
<h4 id="可见性概念"><a href="#可见性概念" class="headerlink" title="可见性概念"></a>可见性概念</h4><p>可见性（Visibility）：是指一个线程对共享变量进行修改，另一个先立即得到修改后的新值。 </p>
<h4 id="可见性演示"><a href="#可见性演示" class="headerlink" title="可见性演示"></a>可见性演示</h4><p>案例演示：一个线程根据boolean类型的标记ﬂag， while循环，另一个线程改变这个ﬂag变量的值，另 一个线程并不会停止循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.concurrent_problem;</span><br><span class="line"><span class="comment">/**    案例演示:        </span></span><br><span class="line"><span class="comment">		一个线程对共享变量的修改,另一个线程不能立即得到新值 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01Visibility</span> &#123;</span><br><span class="line">	<span class="comment">// 多个线程都会访问的数据，我们称为线程的共享数据    </span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">			<span class="keyword">while</span> (run) &#123;</span><br><span class="line">                </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		t1.start();</span><br><span class="line">        </span><br><span class="line">		Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        </span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">			run = <span class="literal">false</span>;</span><br><span class="line">			System.out.println(<span class="string">&quot;时间到，线程2设置为false&quot;</span>);</span><br><span class="line">		&#125;);</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>并发编程时，会出现可见性问题，当一个线程对共享变量进行了修改，另外的线程并没有立即看到修改后的最新值。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><h4 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h4><p>学习什么是原子性问题 </p>
<h4 id="原子性概念"><a href="#原子性概念" class="headerlink" title="原子性概念"></a>原子性概念</h4><p>原子性（Atomicity）：在一次或多次操作中，要么所有的操作都执行并且不会受其他因素干扰而中断，要么所有的操作都不执行。 </p>
<h4 id="原子性演示"><a href="#原子性演示" class="headerlink" title="原子性演示"></a>原子性演示</h4><p>案例演示:5个线程各执行1000次 i++;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo01_concurrent_problem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    目标:演示原子性问题</span></span><br><span class="line"><span class="comment">        1.定义一个共享变量number</span></span><br><span class="line"><span class="comment">        2.对number进行1000的++操作</span></span><br><span class="line"><span class="comment">        3.使用5个线程来进行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02Atomicity</span> &#123;</span><br><span class="line">    <span class="comment">// 1.定义一个共享变量number</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 2.对number进行1000的++操作</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">increment</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                number++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        List&lt;Thread&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 3.使用5个线程来进行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(increment);</span><br><span class="line">            t.start();</span><br><span class="line">            list.add(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread t : list) &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;number = &quot;</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用javap反汇编class文件，得到下面的字节码指令：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411150300410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>其中，对于 number++ 而言（number 为静态变量），实际会产生如下的 JVM 字节码指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">9: getstatic     #12                 // Field number:I </span><br><span class="line">12: iconst_1 </span><br><span class="line">13: iadd </span><br><span class="line">14: putstatic     #12                 // Field number:I</span><br></pre></td></tr></table></figure>

<p>由此可见number++是由多条语句组成，以上多条指令在一个线程的情况下是不会出问题的，但是在多 线程情况下就可能会出现问题。比如一个线程在执行13: iadd时，另一个线程又执行9: getstatic。会导 致两次number++，实际上只加了1。 </p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>并发编程时，会出现原子性问题，当一个线程对共享变量操作到一半时，另外的线程也有可能来操作共 享变量，干扰了前一个线程的操作。</p>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><h4 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h4><p>学习什么是有序性问题 </p>
<h4 id="有序性概念"><a href="#有序性概念" class="headerlink" title="有序性概念"></a>有序性概念</h4><p>有序性（Ordering）：是指程序中代码的执行顺序，Java在编译时和运行时会对代码进行优化，会导致 程序终的执行顺序不一定就是我们编写代码时的顺序。</p>
<h4 id="有序性演示"><a href="#有序性演示" class="headerlink" title="有序性演示"></a>有序性演示</h4><p>jcstress是java并发压测工具。<a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">https://wiki.openjdk.java.net/display/CodeTools/jcstress</a> 修改pom文件，添加依赖：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;   </span><br><span class="line"> &lt;groupId&gt;org.openjdk.jcstress&lt;/groupId&gt;    </span><br><span class="line">&lt;artifactId&gt;jcstress-core&lt;/artifactId&gt;    </span><br><span class="line">&lt;version&gt;$&#123;jcstress.version&#125;&lt;/version&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo01_concurrent_problem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.infra.results.I_Result;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@JCStressTest</span></span><br><span class="line"> <span class="meta">@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)</span></span><br><span class="line"> <span class="meta">@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;danger&quot;)</span></span><br><span class="line"> <span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03Ordering</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 线程1执行的代码</span></span><br><span class="line">    <span class="comment">// @Actor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ready) &#123;</span><br><span class="line">            r.r1 = num + num;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.r1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程2执行的代码</span></span><br><span class="line">    <span class="comment">// @Actor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>I_Result 是一个对象，有一个属性 r1 用来保存结果，在多线程情况下可能出现几种结果？</p>
<p>情况1：线 程1先执行actor1，这时ready &#x3D; false，所以进入else分支结果为1。</p>
<p>情况2：线程2执行到actor2，执行了num &#x3D; 2;和ready &#x3D; true，线程1执行，这回进入 if 分支，结果为 4。 </p>
<p>情况3：线程2先执行actor2，只执行num &#x3D; 2；但没来得及执行 ready &#x3D; true，线程1执行，还是进入 else分支，结果为1。<br>还有一种结果0。<br>运行测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn clean install </span><br><span class="line"></span><br><span class="line">java -jar target/jcstress.jar</span><br></pre></td></tr></table></figure>

<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>程序代码在执行过程中的先后顺序，由于Java在编译期以及运行期的优化，导致了代码的执行顺序未必 就是开发者编写代码时的顺序。</p>
<h2 id="第二章：Java内存模型-JMM"><a href="#第二章：Java内存模型-JMM" class="headerlink" title="第二章：Java内存模型(JMM)"></a>第二章：Java内存模型(JMM)</h2><p>在介绍Java内存模型之前，先来看一下到底什么是计算机内存模型。 </p>
<h3 id="计算机结构"><a href="#计算机结构" class="headerlink" title="计算机结构"></a>计算机结构</h3><h4 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a>目标</h4><p>学习计算机的主要组成<br>学习缓存的作用 </p>
<h4 id="计算机结构简介"><a href="#计算机结构简介" class="headerlink" title="计算机结构简介"></a>计算机结构简介</h4><p>冯诺依曼，提出计算机由五大组成部分，输入设备，输出设备存储器，控制器，运算器。</p>
<p><img src="https://img-blog.csdnimg.cn/20210411150313874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><p>中央处理器，是计算机的控制和运算的核心，我们的程序终都会变成指令让CPU去执行，处理程序中 的数据。<br><img src="https://img-blog.csdnimg.cn/20210411150326659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><p>我们的程序都是在内存中运行的，内存会保存程序运行时的数据，供CPU处理。</p>
<p><img src="https://img-blog.csdnimg.cn/20210411150338507.png#pic_center" alt="在这里插入图片描述"></p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>CPU的运算速度和内存的访问速度相差比较大。这就导致CPU每次操作内存都要耗费很多等待时间。内存的读写速度成为了计算机运行的瓶颈。于是就有了在CPU和主内存之间增加缓存的设计。靠近CPU 的缓存称为L1，然后依次是 L2，L3和主内存，CPU缓存模型如图下图所示。 </p>
<p><img src="https://img-blog.csdnimg.cn/20210411150352725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>CPU Cache分成了三个级别: L1， L2， L3。都集成在CPU中，级别越小越接近CPU，速度也更快，同时也代表着容量越 小。</p>
<ol>
<li>L1是接近CPU的，它容量小，例如32K，速度快，每个核上都有一个L1 Cache。 </li>
<li>L2 Cache 更大一些，例如256K，速度要慢一些，一般情况下每个核上都有一个独立的L2 Cache。 </li>
<li>L3 Cache是三级缓存中大的一级，例如12MB，同时也是缓存中慢的一级，在同一个CPU插槽 之间的核共享一个L3 Cache。<br><img src="https://img-blog.csdnimg.cn/20210411150406716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ol>
<p>Cache的出现是为了解决CPU直接访问内存效率低下问题的，程序在运行的过程中，CPU接收到指令 后，它会先向CPU中的一级缓存（L1 Cache）去寻找相关的数据，如果命中缓存，CPU进行计算时就 可以直接对CPU Cache中的数据进行读取和写人，当运算结束之后，再将CPUCache中的新数据刷新 到主内存当中，CPU通过直接访问Cache的方式替代直接访问主存的方式极大地提高了CPU 的吞吐能 力。但是由于一级缓存（L1 Cache）容量较小，所以不可能每次都命中。这时CPU会继续向下一级的二 级缓存（L2 Cache）寻找，同样的道理，当所需要的数据在二级缓存中也没有的话，会继续转向L3 Cache、内存(主存)和硬盘。</p>
<p>把CPU比做大脑  寄存器就像你正在思考的问题,而cahe就是你的记忆(临时的)</p>
<h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p>计算机的主要组成CPU，内存，输入设备，输出设备。</p>
<h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><h4 id="目标-4"><a href="#目标-4" class="headerlink" title="目标"></a>目标</h4><p>学习Java内存模型的概念和作用 Java内存模型的概念<br>Java Memory Molde (Java内存模型&#x2F;JMM)，千万不要和Java内存结构混淆 关于“Java内存模型”的权威解释，请参考 <a href="https://download.oracle.com/otn-pub/jcp/memory_model1.0-pfd-spec-oth-JSpec/memory_model-1_0-pfd-spec.pdf%E3%80%82">https://download.oracle.com/otn-pub/jcp/memory_model1.0-pfd-spec-oth-JSpec/memory_model-1_0-pfd-spec.pdf。</a><br>Java内存模型，是Java虚拟机规范中所定义的一种内存模型，Java内存模型是标准化的，屏蔽掉了底层 不同计算机的区别。<br>Java内存模型是一套规范，描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量 存储到内存和从内存中读取变量这样的底层细节，具体如下。</p>
<p><strong>主内存</strong> </p>
<p>主内存是所有线程都共享的，都能访问的。所有的共享变量都存储于主内存。 </p>
<p><strong>工作内存</strong> </p>
<p>每一个线程有自己的工作内存，工作内存只存储该线程对共享变量的副本。线程对变量的所有的操 作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量，不同线程之间也不能直接 访问对方工作内存中的变量。<br><img src="https://img-blog.csdnimg.cn/20210411150420196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="Java内存模型的作用"><a href="#Java内存模型的作用" class="headerlink" title="Java内存模型的作用"></a>Java内存模型的作用</h4><p>Java内存模型是一套在多线程读写共享数据时，对共享数据的可见性、有序性、和原子性的规则和保障。<br>synchronized,volatile </p>
<h4 id="CPU缓存，内存与Java内存模型的关系"><a href="#CPU缓存，内存与Java内存模型的关系" class="headerlink" title="CPU缓存，内存与Java内存模型的关系"></a>CPU缓存，内存与Java内存模型的关系</h4><p>通过对前面的CPU硬件内存架构、Java内存模型以及Java多线程的实现原理的了解，我们应该已经意识到，多线程的执行终都会映射到硬件处理器上进行执行。<br>但Java内存模型和硬件内存架构并不完全一致。对于硬件内存来说只有寄存器、缓存内存、主内存的概 念，并没有工作内存和主内存之分，也就是说Java内存模型对内存的划分对硬件内存并没有任何影响， 因为JMM只是一种抽象的概念，是一组规则，不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存中，当然也有可能存储到CPU缓存或者寄存器中，因此总体上来说， Java内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种抽象概念划分与真实物理硬件的交叉。</p>
<p>JMM内存模型与CPU硬件内存架构的关系：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411150432337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><p>Java内存模型是一套规范，描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节，Java内存模型是对共享数据的可见性、有序性、和原子性的规则和保障。</p>
<h3 id="主内存与工作内存之间的交互"><a href="#主内存与工作内存之间的交互" class="headerlink" title="主内存与工作内存之间的交互"></a>主内存与工作内存之间的交互</h3><p><img src="https://img-blog.csdnimg.cn/2021041115044483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="目标-5"><a href="#目标-5" class="headerlink" title="目标"></a>目标</h4><p>了解主内存与工作内存之间的数据交互过程<br>Java内存模型中定义了以下8种操作来完成，主内存与工作内存之间具体的交互协议，即一个变量如何 从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，虚拟机实现时必须保证下面 提及的每一种操作都是原子的、不可再分的。<br>对应如下的流程图：</p>
<p><strong>可见性：</strong></p>
<p>CPU和主内存通过总线进行数据交互，其中有8大原子操作<br><img src="https://img-blog.csdnimg.cn/20210411150523755.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>先了解CPU和内存之间如何实现缓存一致性以及有序性的</p>
<p><img src="https://img-blog.csdnimg.cn/20210411150543568.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>CPU和内存之间通过总线进行数据交互，其中通过缓存一致性协议（MESI）+CPU嗅探技术解决缓存一致性问题</p>
<p>当CPU修改了缓存值会通过原子操作锁机制（将主内存值锁定然后将最新的值刷新，再解锁）将最新的缓存值刷新到主内存，其中经过总线，其他CPU嗅探到后将自己缓存中的值设置为无效，这样会重新取主内存读取最新的值，</p>
<p><img src="https://img-blog.csdnimg.cn/20210411150558294.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>其中JMM内存模型Volatile关键值实现可见性底层就是通过上述方式，通过Lock前缀指令，锁定这块区域缓存（缓存行锁定）并写会到主内存</p>
<p><img src="https://img-blog.csdnimg.cn/2021041115061243.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>有序性：</strong></p>
<p>指令重排序：CPU在不影响单线程执行结果的前提下，计算机为了最大限度的发挥机器性能，会对机器指令重排序优化</p>
<p><img src="https://img-blog.csdnimg.cn/20210411150633315.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>as-if-serial</strong>:不管怎么重排序（编译期和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。</p>
<p><strong>happens-before原则：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">单线程happen-before原则：在同一个线程中，书写在前面的操作happen-before后面的操作。</span><br><span class="line"></span><br><span class="line">锁的happen-before原则：同一个锁的unlock操作happen-before此锁的lock操作。</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span>的happen-before原则：对一个<span class="keyword">volatile</span>变量的写操作happen-before对此变量的任意操作(当然也包括写操作了)。</span><br><span class="line"></span><br><span class="line">happen-before的传递性原则：如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作。</span><br><span class="line"></span><br><span class="line">线程启动的happen-before原则：同一个线程的start方法happen-before此线程的其它方法。</span><br><span class="line"></span><br><span class="line">线程中断的happen-before原则：对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。</span><br><span class="line"></span><br><span class="line">线程终结的happen-before原则：线程中的所有操作都happen-before线程的终止检测。</span><br><span class="line"></span><br><span class="line">对象创建的happen-before原则：一个对象的初始化完成先于他的finalize方法调用。</span><br></pre></td></tr></table></figure>

<p>JVM规范了内存屏障，为了实现有序性，其中Volatile需要实现内存屏障</p>
<p><img src="https://img-blog.csdnimg.cn/20210411150649314.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>CPU层面的内存屏障</p>
<p><img src="https://img-blog.csdnimg.cn/2021041115070589.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>因为指令重排序可能出现的问题：双重校验锁实现单例</strong>（不加volatile）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;  <span class="comment">// 禁止别的类使用该构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="comment">//类对象加锁 </span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123; </span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;  <span class="comment">// 进一步确保uniqueInstance为null才生成对象</span></span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先为什么需要两个if呢？原因是多个线程都一开始判断uniqueInstance &#x3D;&#x3D; null，然后有了一个线程获取了锁资源，其他线程等待，创建了uniqueInstance实例对象，然后它释放了锁，又有了新的线程获取到锁实例，如果这时候不判断uniqueInstance&#x3D;&#x3D;null ,那它就会又创建了一个实例对象。</p>
<p>那么为什么要加入volatile? </p>
<p><img src="https://img-blog.csdnimg.cn/20210411150721737.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>打印出字节码，加载、验证、准备、解析、初始化，加载阶段会先在堆内存分配内存，创建一个代表该类的class对象，作为方法区中该类各种数据的访问入口，然后准备阶段类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存，如果不是final修饰，赋值为0。          进行变量的初始化动作，初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 &lt;clinit&gt;() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源(即构造函数)</p>
<p>如果不加volatile,可能导致21行和24行互换顺序，初始化动作在把对象内存地址赋值给引用之后了，这时候引用可能拿到没执行构造方法的变量。</p>
<p><strong>总线风暴：</strong></p>
<p>在多核处理器架构上，所有的处理器是共用一条总线的，都是靠此总线来和主内存进行数据交互。当主内存的数据同时存在于多个处理的高速缓存中时，某一处理器更新了此共享数据后。会通过总线触发嗅探机制来通知其他处理器将自己高速缓存内的共享数据置为无效，在下次使用时重新从主内存加载最新数据。而这种通过总线来进行通信则称之为”缓存一致性流量“。</p>
<p>因为总线是固定的，所有相应可以接受的通信能力也就是固定的了，如果缓存一致性流量突然激增，必然会使总线的处理能力受到影响。而恰好CAS和volatile 会导致缓存一致性流量增大。如果很多线程都共享一个变量，当共享变量进行CAS等数据变更时，就有可能产生总线风暴。解决方法是部分使用synchronized。</p>
<h2 id="第四章：synchronized的特性"><a href="#第四章：synchronized的特性" class="headerlink" title="第四章：synchronized的特性"></a>第四章：synchronized的特性</h2><h3 id="可重入特性"><a href="#可重入特性" class="headerlink" title="可重入特性"></a>可重入特性</h3><h4 id="目标-6"><a href="#目标-6" class="headerlink" title="目标"></a>目标</h4><p>了解什么是可重入<br>了解可重入的原理 </p>
<h4 id="什么是可重入"><a href="#什么是可重入" class="headerlink" title="什么是可重入"></a>什么是可重入</h4><p>一个线程可以多次执行synchronized,重复获取同一把锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 演示可重入锁是什么意思，可重入，就是可以重复获取相同的锁，synchronized和ReentrantLock都是可重入的</span></span><br><span class="line"><span class="comment">// 可重入降低了编程复杂性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WhatReentrant</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				<span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;第1次获取锁，这个锁是：&quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">					<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">						<span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">							System.out.println(<span class="string">&quot;第&quot;</span> + (++index) + <span class="string">&quot;次获取锁，这个锁是：&quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">if</span> (index == <span class="number">10</span>) &#123;</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h4><p>synchronized的锁对象中有一个计数器（recursions变量）会记录线程获得几次锁. 可重入的好处 </p>
<ol>
<li>可以避免死锁 </li>
<li>可以让我们更好的来封装代码</li>
</ol>
<h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><p>synchronized是可重入锁，内部锁对象中会有一个计数器记录线程获取几次锁啦，在执行完同步代码块 时，计数器的数量会-1，知道计数器的数量为0，就释放这个锁。 </p>
<h3 id="不可中断特性"><a href="#不可中断特性" class="headerlink" title="不可中断特性"></a>不可中断特性</h3><h4 id="目标-7"><a href="#目标-7" class="headerlink" title="目标"></a>目标</h4><p>学习synchronized不可中断特性<br>学习Lock的可中断特性 </p>
<h4 id="什么是不可中断"><a href="#什么是不可中断" class="headerlink" title="什么是不可中断"></a>什么是不可中断</h4><p>一个线程获得锁后，另一个线程想要获得锁，必须处于阻塞或等待状态，如果第一个线程不释放锁，第 二个线程会一直阻塞或等待，不可被中断。 </p>
<h4 id="synchronized不可中断演示"><a href="#synchronized不可中断演示" class="headerlink" title="synchronized不可中断演示"></a>synchronized不可中断演示</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    目标:演示synchronized不可中断</span></span><br><span class="line"><span class="comment">        1.定义一个Runnable</span></span><br><span class="line"><span class="comment">        2.在Runnable定义同步代码块</span></span><br><span class="line"><span class="comment">        3.先开启一个线程来执行同步代码块,保证不退出同步代码块</span></span><br><span class="line"><span class="comment">        4.后开启一个线程来执行同步代码块(阻塞状态)</span></span><br><span class="line"><span class="comment">        5.停止第二个线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02_Uninterruptible</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1.定义一个Runnable</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">run</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="comment">// 2.在Runnable定义同步代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">                System.out.println(name + <span class="string">&quot;进入同步代码块&quot;</span>);</span><br><span class="line">                <span class="comment">// 保证不退出同步代码块</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">888888</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.先开启一个线程来执行同步代码块</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 4.后开启一个线程来执行同步代码块(阻塞状态)</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.停止第二个线程</span></span><br><span class="line">        System.out.println(<span class="string">&quot;停止线程前&quot;</span>);</span><br><span class="line">        t2.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;停止线程后&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(t1.getState());</span><br><span class="line">        System.out.println(t2.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ReentrantLock可中断演示"><a href="#ReentrantLock可中断演示" class="headerlink" title="ReentrantLock可中断演示"></a>ReentrantLock可中断演示</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    目标:演示Lock不可中断和可中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03_Interruptible</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">         test01();</span><br><span class="line"><span class="comment">//        test02();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示Lock可中断</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">run</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                b = lock.tryLock(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">                <span class="keyword">if</span> (b) &#123;</span><br><span class="line">                    System.out.println(name + <span class="string">&quot;获得锁,进入锁执行&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">88888</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(name + <span class="string">&quot;在指定时间没有得到锁做其他操作&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (b) &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                    System.out.println(name + <span class="string">&quot;释放锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">         System.out.println(<span class="string">&quot;停止t2线程前&quot;</span>);</span><br><span class="line">         t2.interrupt();</span><br><span class="line">         System.out.println(<span class="string">&quot;停止t2线程后&quot;</span>);</span><br><span class="line"></span><br><span class="line">         Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">         System.out.println(t1.getState());</span><br><span class="line">         System.out.println(t2.getState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示Lock不可中断</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">run</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(name + <span class="string">&quot;获得锁,进入锁执行&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">88888</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(name + <span class="string">&quot;释放锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;停止t2线程前&quot;</span>);</span><br><span class="line">        t2.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;停止t2线程后&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(t1.getState());</span><br><span class="line">        System.out.println(t2.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><p>不可中断是指，当一个线程获得锁后，另一个线程一直处于阻塞或等待状态，前一个线程不释放锁，后 一个线程会一直阻塞或等待，不可被中断。<br>synchronized属于不可被中断</p>
<p>Lock的lock方法是不可中断的 </p>
<p>Lock的tryLock方法是可中断的</p>
<h2 id="第五章：synchronized原理"><a href="#第五章：synchronized原理" class="headerlink" title="第五章：synchronized原理"></a>第五章：synchronized原理</h2><h3 id="javap-反汇编"><a href="#javap-反汇编" class="headerlink" title="javap 反汇编"></a>javap 反汇编</h3><h4 id="目标-8"><a href="#目标-8" class="headerlink" title="目标"></a>目标</h4><p>通过javap反汇编学习synchronized的原理   我们编写一个简单的synchronized代码，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们要看synchronized的原理，但是synchronized是一个关键字，看不到源码。我们可以将class文件 进行反汇编。</p>
<p>JDK自带的一个工具： javap ，对字节码进行反汇编，查看字节码指令。<br>在DOS命令行输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javap -p -v -c C:\Users\13666\IdeaProjects\HeiMa\Synchronized\target\classes\com\itheima\demo04 _synchronized_monitor\Increment.class</span><br></pre></td></tr></table></figure>

<p>反汇编后的效果如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411150823122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411150842113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021041115084227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="monitorenter"><a href="#monitorenter" class="headerlink" title="monitorenter"></a>monitorenter</h4><p>首先我们来看一下JVM规范中对于monitorenter的描述： <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorenter">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorenter</a></p>
<blockquote>
<p>Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref， as follows: • If the entry count of the monitor associated with objectref is zero， the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor. • If the thread already owns the monitor associated with objectref， it reenters the monitor， incrementing its entry count. • If another thread already owns the monitor associated with objectref， the thread blocks until the monitor’s entry count is zero， then tries again to gain ownership. </p>
</blockquote>
<p>翻译过来： 每一个对象都会和一个监视器monitor关联。监视器被占用时会被锁住，其他线程无法来获 取该monitor。 当JVM执行某个线程的某个方法内部的monitorenter时，它会尝试去获取当前对象对应 的monitor的所有权。其过程如下：</p>
<ol>
<li>若monior的进入数为0，线程可以进入monitor，并将monitor的进入数置为1。当前线程成为 monitor的owner（所有者） </li>
<li>若线程已拥有monitor的所有权，允许它重入monitor，则进入monitor的进入数加1</li>
<li>若其他线程已经占有monitor的所有权，那么当前尝试获取monitor的所有权的线程会被阻塞，直 到monitor的进入数变为0，才能重新尝试获取monitor的所有权。</li>
</ol>
<p>monitorenter小结:<br>synchronized的锁对象会关联一个monitor,这个monitor不是我们主动创建的,是JVM的线程执行到这个 同步代码块,发现锁对象没有monitor就会创建monitor,monitor内部有两个重要的成员变量owner:拥有 这把锁的线程,recursions会记录线程拥有锁的次数,当一个线程拥有monitor后其他线程只能等待 </p>
<h4 id="monitorexit"><a href="#monitorexit" class="headerlink" title="monitorexit"></a>monitorexit</h4><p>首先我们来看一下JVM规范中对于monitorexit的描述： <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit</a></p>
<blockquote>
<p>The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref. The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero， the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.</p>
</blockquote>
<p>翻译过来：</p>
<p> 1.能执行monitorexit指令的线程一定是拥有当前对象的monitor的所有权的线程。</p>
<pre><code>2. 执行monitorexit时会将monitor的进入数减1。当monitor的进入数减为0时，当前线程退出 monitor，不再拥有monitor的所有权，此时其他被这个monitor阻塞的线程可以尝试去获取这个 monitor的所有权
</code></pre>
<p>monitorexit释放锁。<br>monitorexit插入在方法结束处和异常处，JVM保证每个monitorenter必须有对应的monitorexit。  </p>
<p> 面试题synchroznied出现异常会释放锁吗?<br>会释放锁</p>
<h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10</a> 可以看到同步方法在反汇编后，会增加 ACC_SYNCHRONIZED 修饰。会隐式调用monitorenter和 monitorexit。在执行同步方法前会调用monitorenter，在执行完同步方法后会调用monitorexit。</p>
<h4 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h4><p>通过javap反汇编我们看到synchronized使用编程了monitorentor和monitorexit两个指令.每个锁对象 都会关联一个monitor(监视器,它才是真正的锁对象),它内部有两个重要的成员变量owner会保存获得锁 的线程,recursions会保存线程获得锁的次数,当执行到monitorexit时,recursions会-1,当计数器减到0时 这个线程就会释放锁</p>
<h4 id="面试题：synchronized与Lock的区别"><a href="#面试题：synchronized与Lock的区别" class="headerlink" title="面试题：synchronized与Lock的区别"></a>面试题：synchronized与Lock的区别</h4><ol>
<li>synchronized是关键字，而Lock是一个接口。</li>
<li>synchronized会自动释放锁，而Lock必须手动释放锁。</li>
<li>synchronized是不可中断的，Lock可以中断也可以不中断。</li>
<li>通过Lock可以知道线程有没有拿到锁，而synchronized不能。</li>
<li>synchronized能锁住方法和代码块，而Lock只能锁住代码块。</li>
<li>Lock可以使用读锁提高多线程读效率。</li>
<li>synchronized是非公平锁，ReentrantLock可以控制是否是公平锁。</li>
</ol>
<h3 id="深入JVM源码"><a href="#深入JVM源码" class="headerlink" title="深入JVM源码"></a>深入JVM源码</h3><h4 id><a href="#" class="headerlink" title></a></h4><p>通过JVM源码分析synchronized的原理   </p>
<h4 id="JVM源码下载"><a href="#JVM源码下载" class="headerlink" title="JVM源码下载"></a>JVM源码下载</h4><p><a href="http://openjdk.java.net/">http://openjdk.java.net/</a> –&gt; Mercurial –&gt; jdk8 –&gt; hotspot –&gt; zip </p>
<h4 id="IDE-Clion-下载"><a href="#IDE-Clion-下载" class="headerlink" title="IDE(Clion )下载"></a>IDE(Clion )下载</h4><p><a href="https://www.jetbrains.com/">https://www.jetbrains.com/</a></p>
<h4 id="monitor监视器锁"><a href="#monitor监视器锁" class="headerlink" title="monitor监视器锁"></a>monitor监视器锁</h4><p>可以看出无论是synchronized代码块还是synchronized方法，其线程安全的语义实现终依赖一个叫 monitor的东西，那么这个神秘的东西是什么呢？下面让我们来详细介绍一下。  </p>
<p>在HotSpot虚拟机中，monitor是由ObjectMonitor实现的。其源码是用c++来实现的，位于HotSpot虚 拟机源码ObjectMonitor.hpp文件中(src&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;objectMonitor.hpp)。ObjectMonitor主 要数据结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ObjectMonitor</span>() &#123;    </span><br><span class="line">	_header       = <span class="literal">NULL</span>;    </span><br><span class="line">	_count        = <span class="number">0</span>;   </span><br><span class="line">    _waiters      = <span class="number">0</span>，    </span><br><span class="line">    _recursions   = <span class="number">0</span>;  <span class="comment">// 线程的重入次数</span></span><br><span class="line">    _object       = <span class="literal">NULL</span>; <span class="comment">// 存储该monitor的对象    </span></span><br><span class="line">    _owner        = <span class="literal">NULL</span>; <span class="comment">// 标识拥有该monitor的线程    </span></span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>; <span class="comment">// 处于wait状态的线程，会被加入到_WaitSet    </span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;    </span><br><span class="line">    _Responsible  = <span class="literal">NULL</span>;    </span><br><span class="line">    _succ         = <span class="literal">NULL</span>;    </span><br><span class="line">    _cxq          = <span class="literal">NULL</span>; <span class="comment">// 多线程竞争锁时的单向列表    </span></span><br><span class="line">    FreeNext      = <span class="literal">NULL</span>;    </span><br><span class="line">    _EntryList    = <span class="literal">NULL</span>; <span class="comment">// 处于等待锁block状态的线程，会被加入到该列表   </span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span>;   </span><br><span class="line">    _SpinClock    = <span class="number">0</span>;    </span><br><span class="line">    OwnerIsThread = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>_owner：初始时为NULL。当有线程占有该monitor时，owner标记为该线程的唯一标识。当线程 释放monitor时，owner又恢复为NULL。owner是一个临界资源，JVM是通过CAS操作来保证其线 程安全的。</li>
<li>_ _cxq：竞争队列，所有请求锁的线程首先会被放在这个队列中（单向链接）。_cxq是一个临界资源，JVM通过CAS原子指令来修改_cxq队列。修改前_cxq的旧值填入了node的next字段，_cxq指 向新值（新线程）。因此_cxq是一个后进先出的stack（栈）。 </li>
<li>_EntryList：_cxq队列中有资格成为候选资源的线程会被移动到该队列中。 </li>
<li>_WaitSet：因为调用wait方法而被阻塞的线程会被放在该队列中。</li>
</ol>
<p>每一个Java对象都可以与一个监视器monitor关联，我们可以把它理解成为一把锁，当一个线程想要执 行一段被synchronized圈起来的同步方法或者代码块时，该线程得先获取到synchronized修饰的对象 对应的monitor。 我们的Java代码里不会显示地去创造这么一个monitor对象，我们也无需创建，事实上可以这么理解： monitor并不是随着对象创建而创建的。我们是通过synchronized修饰符告诉JVM需要为我们的某个对 象创建关联的monitor对象。每个线程都存在两个ObjectMonitor对象列表，分别为free和used列表。 同时JVM中也维护着global locklist。当线程需要ObjectMonitor对象时，首先从线程自身的free表中申请，若存在则使用，若不存在则从global list中申请。<br>  ObjectMonitor的数据结构中包含：_owner、_WaitSet和_EntryList，它们之间的关系转换可以用下图 表示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411150935274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210411150935225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>对象头保存对应的montor对象，其中_recursions会记录线程的重入次数，进入+1，离开-1，</p>
<p>_object会存储这个synchronized锁的实例对象，</p>
<p>_owner就保存抢到锁进来的线程，</p>
<p>_WaitSet是当有线程获取锁后调用obj.wait()方法，那么当前线程就会进入WaitSet队列，</p>
<p>_cxq是单向链表（指的是如果已经有t1线程获取到monitor对象拿到锁后_，t2和t3没有竞争到，t2、t3线程会进行到cxq队列，先自己尝试竞争锁，如果竞争不到则自旋再去挣扎一下获取锁，当t1执行完同步代码块，释放锁后，由t1、t2、t3再去争抢锁，如果t1再次抢到锁，那么t2、t3会进行到EntryList阻塞队列，如果此时又有t4、t5线程过来会被放到cxq队列，t2,t3,t4,t5，通过自旋尝试获取锁，如果还是没有获取到锁，则通过park将当 前线程挂起，等待被唤醒。如果t1被释放， 根据不同的策略（由QMode指定），从cxq或EntryList中获取头节点，通过 ObjectMonitor::ExitEpilog 方法唤醒该节点封装的线程，唤醒操作终由unpark完成，被唤醒的线程，继续执行monitor 的竞争。</p>
<p>当获取锁的线程释放后，EntryList中的线程和WaitSet中的线程被唤醒都可能去获取锁变成owner的拥有者。）</p>
<h4 id="monitor竞争"><a href="#monitor竞争" class="headerlink" title="monitor竞争"></a>monitor竞争</h4><ol>
<li>执行monitorenter时，会调用InterpreterRuntime.cpp (位于：src&#x2F;share&#x2F;vm&#x2F;interpreter&#x2F;interpreterRuntime.cpp) 的 InterpreterRuntime::monitorenter函 数。具体代码可参见HotSpot源码。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210411151015318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>   2.对于重量级锁，monitorenter函数中会调用 ObjectSynchronizer::slow_enter<br>   3.终调用 ObjectMonitor::enter（位于：src&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;objectMonitor.cpp），源码如下：<br><img src="https://img-blog.csdnimg.cn/20210411151041252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411151041274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411151041201.png#pic_center" alt="在这里插入图片描述"></p>
<p>   此处省略锁的自旋优化等操作，统一放在后面synchronzied优化中说。<br>   以上代码的具体流程概括如下：</p>
<pre><code>  1. 通过CAS尝试把monitor的owner字段设置为当前线程。 
  2. 如果设置之前的owner指向当前线程，说明当前线程再次进入monitor，即重入锁，执行 recursions ++ ，记录重入的次数。 
  3. 如果当前线程是第一次进入该monitor，设置recursions为1，_owner为当前线程，该线程成功获 得锁并返回。 
  4. 如果获取锁失败，则等待锁的释放。
</code></pre>
<h4 id="monitor等待"><a href="#monitor等待" class="headerlink" title="monitor等待"></a>monitor等待</h4><p>竞争失败等待调用的是ObjectMonitor对象的EnterI方法（位于： src&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;objectMonitor.cpp），源码如下所示：<br><img src="https://img-blog.csdnimg.cn/20210411151309797.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210411151309889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210411151309920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411151309823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>当该线程被唤醒时，会从挂起的点继续执行，通过 ObjectMonitor::TryLock 尝试获取锁，TryLock方 法实现如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411151507713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>以上代码的具体流程概括如下：</p>
<ol>
<li>当前线程被封装成ObjectWaiter对象node，状态设置成ObjectWaiter::TS_CXQ。 </li>
<li>在for循环中，通过CAS把node节点push到_cxq列表中，同一时刻可能有多个线程把自己的node 节点push到_cxq列表中。 </li>
<li>node节点push到_cxq列表之后，通过自旋尝试获取锁，如果还是没有获取到锁，则通过park将当 前线程挂起，等待被唤醒。 </li>
<li>当该线程被唤醒时，会从挂起的点继续执行，通过 ObjectMonitor::TryLock 尝试获取锁。</li>
</ol>
<h4 id="monitor释放"><a href="#monitor释放" class="headerlink" title="monitor释放"></a>monitor释放</h4><p>当某个持有锁的线程执行完同步代码块时，会进行锁的释放，给其它线程机会执行同步代码，在 HotSpot中，通过退出monitor的方式实现锁的释放，并通知被阻塞的线程，具体实现位于 ObjectMonitor的exit方法中。（位于：src&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;objectMonitor.cpp），源码如下所 示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411151522706.png#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411151536882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411151548250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411151600992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210411151613139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411151623814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ol>
<li>退出同步代码块时会让_recursions减1，当_recursions的值减为0时，说明线程释放了锁。 </li>
<li>根据不同的策略（由QMode指定），从cxq或EntryList中获取头节点，通过 ObjectMonitor::ExitEpilog 方法唤醒该节点封装的线程，唤醒操作终由unpark完成，实现 如下：</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210411151637957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>被唤醒的线程，会回到 void ATTR ObjectMonitor::EnterI (TRAPS) 的第600行，继续执行monitor 的竞争。<br><img src="https://img-blog.csdnimg.cn/20210411151650828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="monitor是重量级锁"><a href="#monitor是重量级锁" class="headerlink" title="monitor是重量级锁"></a>monitor是重量级锁</h4><p>可以看到ObjectMonitor的函数调用中会涉及到Atomic::cmpxchg_ptr，Atomic::inc_ptr等内核函数， 执行同步代码块，没有竞争到锁的对象会park()被挂起，竞争到锁的线程会unpark()唤醒。这个时候就 会存在操作系统用户态和内核态的转换，这种切换会消耗大量的系统资源。所以synchronized是Java语 言中是一个重量级(Heavyweight)的操作。 用户态和和内核态是什么东西呢？要想了解用户态和内核态还需要先了解一下Linux系统的体系架构：<br><img src="https://img-blog.csdnimg.cn/20210411151703407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>从上图可以看出，Linux操作系统的体系架构分为：用户空间（应用程序的活动空间）和内核。<br>内核：本质上可以理解为一种软件，控制计算机的硬件资源，并提供上层应用程序运行的环境。<br>用户空间：上层应用程序活动的空间。应用程序的执行必须依托于内核提供的资源，包括CPU资源、存 储资源、I&#x2F;O资源等。<br>系统调用：为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口：即系统调用。</p>
<p>所有进程初始都运行于用户空间，此时即为用户运行状态（简称：用户态）；但是当它调用系统调用执 行某些操作时，例如 I&#x2F;O调用，此时需要陷入内核中运行，我们就称进程处于内核运行态（或简称为内 核态）。 系统调用的过程可以简单理解为： </p>
<ol>
<li>用户态程序将一些数据值放在寄存器中， 或者使用参数创建一个堆栈， 以此表明需要操作系统提供的服务。 </li>
<li>用户态程序执行系统调用。 </li>
<li>CPU切换到内核态，并跳到位于内存指定位置的指令。 </li>
<li>系统调用处理器(system call handler)会读取程序放入内存的数据参数，并执行程序请求的服务。 </li>
<li>系统调用完成后，操作系统会重置CPU为用户态并返回系统调用的结果。<br>由此可见用户态切换至内核态需要传递许多变量，同时内核还需要保护好用户态在切换时的一些寄存器值、变量等，以备内核态切换回用户态。这种切换就带来了大量的系统资源消耗，这就是在 synchronized未优化之前，效率低的原因。</li>
</ol>
<h2 id="第六章：JDK6-synchronized优化"><a href="#第六章：JDK6-synchronized优化" class="headerlink" title="第六章：JDK6 synchronized优化"></a>第六章：JDK6 synchronized优化</h2><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><h4 id="目标-9"><a href="#目标-9" class="headerlink" title="目标"></a>目标</h4><p>学习CAS的作用 学习CAS的原理 </p>
<h4 id="CAS概述和作用"><a href="#CAS概述和作用" class="headerlink" title="CAS概述和作用"></a>CAS概述和作用</h4><p>CAS的全称是： Compare And Swap(比较相同再交换)。是现代CPU广泛支持的一种对内存中的共享数 据进行操作的一种特殊指令。<br>CAS的作用：CAS可以将比较和交换转换为原子操作，这个原子操作直接由CPU保证。CAS可以保证共 享变量赋值时的原子操作。CAS操作依赖3个值：内存中的值V，旧的预估值X，要修改的新值B，如果旧 的预估值X等于内存中的值V，就将新的值B保存到内存中。</p>
<h4 id="CAS和volatile实现无锁并发"><a href="#CAS和volatile实现无锁并发" class="headerlink" title="CAS和volatile实现无锁并发"></a>CAS和volatile实现无锁并发</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    目标:演示原子性问题</span></span><br><span class="line"><span class="comment">        1.定义一个共享变量number</span></span><br><span class="line"><span class="comment">        2.对number进行1000的++操作</span></span><br><span class="line"><span class="comment">        3.使用5个线程来进行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="comment">// 1.定义一个共享变量number</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 2.对number进行1000的++操作</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">increment</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                atomicInteger.incrementAndGet(); <span class="comment">// 变量赋值的原子性</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        List&lt;Thread&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 3.使用5个线程来进行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(increment);</span><br><span class="line">            t.start();</span><br><span class="line">            list.add(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread t : list) &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;atomicInteger = &quot;</span> + atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h4><p>通过刚才AtomicInteger的源码我们可以看到，Unsafe类提供了原子操作。 </p>
<h4 id="Unsafe类介绍"><a href="#Unsafe类介绍" class="headerlink" title="Unsafe类介绍"></a>Unsafe类介绍</h4><p>Unsafe类使Java拥有了像C语言的指针一样操作内存空间的能力，同时也带来了指针的问题。过度的使 用Unsafe类会使得出错的几率变大，因此Java官方并不建议使用的，官方文档也几乎没有。Unsafe对 象不能直接调用，只能通过反射获得。</p>
<p><img src="https://img-blog.csdnimg.cn/20210411151724567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="Unsafe实现CAS"><a href="#Unsafe实现CAS" class="headerlink" title="Unsafe实现CAS"></a>Unsafe实现CAS</h4><p><img src="https://img-blog.csdnimg.cn/2021041115173973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h4><p><strong>悲观锁</strong>从悲观的角度出发：<br>总是假设坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这 样别人想拿这个数据就会阻塞。因此synchronized我们也将其称之为悲观锁。JDK中的ReentrantLock 也是一种悲观锁。性能较差！<br><strong>乐观锁</strong>从乐观的角度出发:<br>总是假设好的情况，每次去拿数据的时候都认为别人不会修改，就算改了也没关系，再重试即可。所 以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去修改这个数据，如何没有人修改则更 新，如果有人修改则重试。<br>CAS这种机制我们也可以将其称之为乐观锁。综合性能较好！  </p>
<blockquote>
<p>CAS获取共享变量时，为了保证该变量的可见性，需要使用volatile修饰。结合CAS和volatile可以 实现无锁并发，适用于竞争不激烈、多核 CPU 的场景下。 1. 因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一。 2. 但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响。</p>
</blockquote>
<h4 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h4><p>CAS的作用? Compare And Swap，CAS可以将比较和交换转换为原子操作，这个原子操作直接由处理 器保证。<br>CAS的原理？CAS需要3个值:内存地址V，旧的预期值A，要修改的新值B，如果内存地址V和旧的预期值 A相等就修改内存地址值为B </p>
<h3 id="synchronized锁升级过程"><a href="#synchronized锁升级过程" class="headerlink" title="synchronized锁升级过程"></a>synchronized锁升级过程</h3><p>高效并发是从JDK 5到JDK 6的一个重要改进，HotSpot虛拟机开发团队在这个版本上花费了大量的精力 去实现各种锁优化技术，包括偏向锁( Biased Locking )、轻量级锁( Lightweight Locking )和如适应性 自旋(Adaptive Spinning)、锁消除( Lock Elimination)、锁粗化( Lock Coarsening )等，这些技术都是为 了在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">无锁--》偏向锁--》轻量级锁–》重量级锁</span><br></pre></td></tr></table></figure>



<h3 id="Java对象的布局"><a href="#Java对象的布局" class="headerlink" title="Java对象的布局"></a>Java对象的布局</h3><h4 id="目标-10"><a href="#目标-10" class="headerlink" title="目标"></a>目标</h4><p>学习Java对象的布局<br>术语参考: <a href="http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html">http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html</a> 在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411151752779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p>当一个线程尝试访问synchronized修饰的代码块时，它首先要获得锁，那么这个锁到底存在哪里呢？是 存在锁对象的对象头中的。<br>HotSpot采用instanceOopDesc和arrayOopDesc来描述对象头，arrayOopDesc对象用来描述数组类型。instanceOopDesc的定义的在Hotspot源码的 instanceOop.hpp 文件中，另外，arrayOopDesc 的定义对应 arrayOop.hpp 。</p>
<p><img src="https://img-blog.csdnimg.cn/20210411151803946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>从instanceOopDesc代码中可以看到 instanceOopDesc继承自oopDesc，oopDesc的定义载Hotspot 源码中的 oop.hpp 文件中。<br><img src="https://img-blog.csdnimg.cn/20210411151814950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411151825586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>在普通实例对象中，oopDesc的定义包含两个成员，分别是 _mark 和 _metadata</p>
<p>_mark 表示对象标记、属于markOop类型，也就是接下来要讲解的Mark World，它记录了对象和锁有关的信息</p>
<p>_metadata 表示类元信息，类元信息存储的是对象指向它的类元数据(Klass)的首地址，其中Klass表示 普通指针、 _compressed_klass 表示压缩类指针。</p>
<p>对象头由两部分组成，一部分用于存储自身的运行时数据，称之为 Mark Word，另外一部分是类型指 针，及对象指向它的类元数据的指针。</p>
<h5 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h5><p>Mark Word用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、 线程持有的锁、偏向线程ID、偏向时间戳等等，占用内存大小与虚拟机位长一致。Mark Word对应的类 型是 markOop 。源码位于 markOop.hpp 中。</p>
<p><img src="https://img-blog.csdnimg.cn/20210411151838118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411151847972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411151901531.png#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411151920218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>在64位虚拟机下，Mark Word是64bit大小的，其存储结构如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411151936532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>在32位虚拟机下，Mark Word是32bit大小的，其存储结构如下：</p>
<p><img src="https://img-blog.csdnimg.cn/2021041115195084.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="klass-pointer"><a href="#klass-pointer" class="headerlink" title="klass pointer"></a>klass pointer</h5><p>这一部分用于存储对象的类型指针，该指针指向它的类元数据，JVM通过这个指针确定对象是哪个类的 实例。该指针的位长度为JVM的一个字大小，即32位的JVM为32位，64位的JVM为64位。 如果应用的对 象过多，使用64位的指针将浪费大量内存，统计而言，64位的JVM将会比32位的JVM多耗费50%的内 存。为了节约内存可以使用选项**-XX:+UseCompressedOops** 开启指针压缩，其中，oop即ordinary object pointer普通对象指针。开启该选项后，下列指针将压缩至32位： </p>
<ol>
<li>每个Class的属性指针（即静态变量）</li>
<li>每个对象的属性指针（即对象变量） </li>
<li>普通对象数组的每个元素指针</li>
</ol>
<p>当然，也不是所有的指针都会压缩，一些特殊类型的指针JVM不会优化，比如指向PermGen的Class对 象指针(JDK8中指向元空间的Class对象指针)、本地变量、堆栈元素、入参、返回值和NULL指针等。   对象头 &#x3D; Mark Word + 类型指针（未开启指针压缩的情况下）<br>在32位系统中，Mark Word &#x3D; 4 bytes，类型指针 &#x3D; 4bytes，对象头 &#x3D; 8 bytes &#x3D; 64 bits；<br>在64位系统中，Mark Word &#x3D; 8 bytes，类型指针 &#x3D; 8bytes，对象头 &#x3D; 16 bytes &#x3D; 128bits；</p>
<h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><p>就是类中定义的成员变量。</p>
<h4 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h4><p>对齐填充并不是必然存在的，也没有什么特别的意义，他仅仅起着占位符的作用，由于HotSpot VM的 自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是<strong>8字节的 整数倍</strong>。而对象头正好是8字节的倍数，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充 来补全。</p>
<h4 id="查看Java对象布局"><a href="#查看Java对象布局" class="headerlink" title="查看Java对象布局"></a>查看Java对象布局</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;    </span><br><span class="line">	&lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;    </span><br><span class="line">	&lt;artifactId&gt;jol-core&lt;/artifactId&gt;    </span><br><span class="line">	&lt;version&gt;<span class="number">0.9</span>&lt;/version&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>示例：以64bit虚拟机为例展示（默认开启指针压缩）</p>
<p><img src="https://img-blog.csdnimg.cn/20210411152007784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>-XX:-UseCompressedOops</strong>关闭指针压缩</p>
<p><img src="https://img-blog.csdnimg.cn/20210411152018673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h4><p><strong>Java对象由3部分组成，对象头，实例数据，对齐数据</strong><br><strong>对象头分成两部分：Mark World + Klass pointer</strong> </p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><h4 id="目标-11"><a href="#目标-11" class="headerlink" title="目标"></a>目标</h4><p>学习偏向锁的原理和好处</p>
<h4 id="什么是偏向锁"><a href="#什么是偏向锁" class="headerlink" title="什么是偏向锁"></a>什么是偏向锁</h4><p>偏向锁是JDK 6中的重要引进，因为HotSpot作者经过研究实践发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低，引进了偏向锁。<br>偏向锁的“偏”，就是偏心的“偏”、偏袒的“偏”，它的意思是这个锁会偏向于第一个获得它的线程，会在对 象头存储锁偏向的线程ID，以后该线程进入和退出同步块时只需要检查是否为偏向锁、锁标志位以及 ThreadID即可。</p>
<p><img src="https://img-blog.csdnimg.cn/20210411152031158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>不过一旦出现多个线程竞争时必须撤销偏向锁，所以撤销偏向锁消耗的性能必须小于之前节省下来的 CAS原子操作的性能消耗，不然就得不偿失了。</p>
<h4 id="偏向锁原理"><a href="#偏向锁原理" class="headerlink" title="偏向锁原理"></a>偏向锁原理</h4><p>当线程第一次访问同步块并获取锁时，偏向锁处理流程如下：</p>
<blockquote>
<p>1.虚拟机将会把对象头中的标志位设为“01”，即偏向模式。</p>
<p>2.同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中 ，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作，偏向锁的效率高。</p>
</blockquote>
<h4 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h4><ol>
<li>暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态 </li>
<li>偏向锁的撤销动作必须等待全局安全点 </li>
<li><strong>撤销偏向锁，恢复到无锁（标志位为 01）或轻量级锁（标志位为 00）的状态</strong></li>
</ol>
<p>偏向锁在Java 6之后是默认启用的，但在应用程序启动几秒钟之后才激活，可以使用-XX:BiasedLockingStartupDelay&#x3D;0 参数关闭延迟，如果确定应用程序中所有锁通常情况下处于竞争 状态，可以通过 XX:-UseBiasedLocking&#x3D;false 参数关闭偏向锁。</p>
<h4 id="偏向锁好处"><a href="#偏向锁好处" class="headerlink" title="偏向锁好处"></a>偏向锁好处</h4><p>偏向锁是在只有一个线程执行同步块时进一步提高性能，适用于一个线程反复获得同一锁的情况。偏向 锁可以提高带有同步但无竞争的程序性能。<br>它同样是一个带有效益权衡性质的优化，也就是说，它并不一定总是对程序运行有利，如果程序中大多 数的锁总是被多个不同的线程访问比如线程池，那偏向模式就是多余的。</p>
<p>在JDK5中偏向锁默认是关闭的，而到了JDK6中偏向锁已经默认开启。但在应用程序启动几秒钟之后才 激活，可以使用-XX:BiasedLockingStartupDelay&#x3D;0 参数关闭延迟，如果确定应用程序中所有锁通常 情况下处于竞争状态，可以通过 XX:-UseBiasedLocking&#x3D;false 参数关闭偏向锁。 </p>
<h4 id="偏向锁的升级"><a href="#偏向锁的升级" class="headerlink" title="偏向锁的升级"></a>偏向锁的升级</h4><p>当线程1访问代码块并获取锁对象时，会在java对象头和栈帧中记录偏向的锁的threadID，因为<strong>偏向锁不会主动释放锁</strong>，因此以后线程1再次获取锁的时候，需要<strong>比较当前线程的threadID和Java对象头中的threadID是否一致</strong>，如果一致（还是线程1获取锁对象），则无需使用CAS来加锁、解锁；如果不一致（其他线程，如线程2要竞争锁对象，而偏向锁不会主动释放因此还是存储的线程1的threadID），那么需要<strong>查看Java对象头中记录的线程1是否存活</strong>，如果没有存活，那么锁对象被重置为无锁状态，其它线程（线程2）可以竞争将其设置为偏向锁；如果存活，那么立刻<strong>查找该线程（线程1）的栈帧信息，如果还是需要继续持有这个锁对象</strong>，那么暂停当前线程1，撤销偏向锁，然后线程1升级为轻量级锁，如果线程1 不再使用该锁对象，那么将锁对象状态设为无锁状态，重新偏向新的线程。</p>
<h4 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h4><p>偏向锁的原理是什么?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“<span class="number">01</span>”，即偏向模式。同时使用CAS操 作把获取到这个锁的线程的ID记录在对象的Mark Word之中 ，如果CAS操作成功，持有偏向锁的线程以后每 次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作，偏向锁的效率高。</span><br></pre></td></tr></table></figure>

<p>偏向锁的好处是什么?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">偏向锁是在只有一个线程执行同步块时进一步提高性能，适用于一个线程反复获得同一锁的情况。偏向锁可以 提高带有同步但无竞争的程序性能。</span><br></pre></td></tr></table></figure>





<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><h4 id="目标-12"><a href="#目标-12" class="headerlink" title="目标"></a>目标</h4><p>学习轻量级锁的原理和好处</p>
<h4 id="什么是轻量级锁"><a href="#什么是轻量级锁" class="headerlink" title="什么是轻量级锁"></a>什么是轻量级锁</h4><p>轻量级锁是JDK 6之中加入的新型锁机制，它名字中的“轻量级”是相对于使用monitor的传统锁而言的， 因此传统的锁机制就称为“重量级”锁。首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的。<br>引入轻量级锁的目的：在多线程交替执行同步块的情况下，尽量避免重量级锁引起的性能消耗，但是如 果多个线程在同一时刻进入临界区，会导致轻量级锁膨胀升级重量级锁，所以轻量级锁的出现并非是要 替代重量级锁。 </p>
<h4 id="轻量级锁原理"><a href="#轻量级锁原理" class="headerlink" title="轻量级锁原理"></a>轻量级锁原理</h4><p>当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁，其步 骤如下： <strong>获取锁</strong><br>当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式。同时使用CAS操 作把获取到这个锁的线程的ID记录在对象的Mark Word之中 ，如果CAS操作成功，持有偏向锁的线程以后每 次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作，偏向锁的效率高。<br>偏向锁是在只有一个线程执行同步块时进一步提高性能，适用于一个线程反复获得同一锁的情况。偏向锁可以 提高带有同步但无竞争的程序性能。</p>
<ol>
<li>判断当前对象是否处于无锁状态（hashcode、0、01），如果是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方 把这份拷贝加了一个Displaced前缀，即Displaced Mark Word），将对象的Mark Word复制到栈 帧中的Lock Record中，将Lock Reocrd中的owner指向当前对象。 </li>
<li>JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，如果成功表示竞争到锁，则将锁标志位变成00，执行同步操作。 </li>
<li>如果失败则判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持 有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210411152043810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411152056960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411152108466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="轻量级锁什么时候升级为重量级锁？"><a href="#轻量级锁什么时候升级为重量级锁？" class="headerlink" title="轻量级锁什么时候升级为重量级锁？"></a>轻量级锁什么时候升级为重量级锁？</h4><p>线程1获取轻量级锁时会先把锁对象的<strong>对象头MarkWord复制一份到线程1的栈帧中创建的用于存储锁记录的空间</strong>（称为DisplacedMarkWord），然后<strong>使用CAS把对象头中的内容替换为线程1存储的锁记录（</strong>DisplacedMarkWord<strong>）的地址</strong>；</p>
<p>如果在线程1复制对象头的同时（在线程1CAS之前），线程2也准备获取锁，复制了对象头到线程2的锁记录空间中，但是在线程2CAS的时候，发现线程1已经把对象头换了，<strong>线程2的CAS失败，那么线程2就尝试使用自旋锁来等待线程1释放锁</strong>。</p>
<p>但是如果自旋的时间太长也不行，因为自旋是要消耗CPU的，因此自旋的次数是有限制的，比如10次或者100次，如果<strong>自旋次数到了线程1还没有释放锁，或者线程1还在执行，线程2还在自旋等待，这时又有一个线程3过来竞争这个锁对象，那么这个时候轻量级锁就会膨胀为重量级锁。重量级锁把除了拥有锁的线程都阻塞，防止CPU空转。</strong></p>
<p><strong>注意</strong>：为了避免无用的自旋，轻量级锁一旦膨胀为重量级锁就不会再降级为轻量级锁了；偏向锁升级为轻量级锁也不能再降级为偏向锁。一句话就是锁可以升级不可以降级，但是偏向锁状态可以被重置为无锁状态。</p>
<p>写的方法进入栈中执行，一个进入栈中的方法就是栈帧。</p>
<h4 id="轻量级锁的释放"><a href="#轻量级锁的释放" class="headerlink" title="轻量级锁的释放"></a>轻量级锁的释放</h4><p>轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下：</p>
<ol>
<li>取出在获取轻量级锁保存在Displaced Mark Word中的数据。 </li>
<li>用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功。</li>
<li>如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要将轻量级锁需要膨胀升级为重量级 锁。</li>
</ol>
<p>对于轻量级锁，其性能提升的依据是“对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”，如 果打破这个依据则除了互斥的开销外，还有额外的CAS操作，因此在有多线程竞争的情况下，轻量级锁 比重量级锁更慢。</p>
<h4 id="轻量级锁好处"><a href="#轻量级锁好处" class="headerlink" title="轻量级锁好处"></a>轻量级锁好处</h4><p>在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。 小结 </p>
<h4 id="轻量级锁的原理是什么？"><a href="#轻量级锁的原理是什么？" class="headerlink" title="轻量级锁的原理是什么？"></a>轻量级锁的原理是什么？</h4><p>将对象的Mark Word复制到栈帧中的Lock Recod中。Mark Word更新为指向Lock Record的指针。<br>轻量级锁好处是什么？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗</span><br></pre></td></tr></table></figure>



<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><h4 id="目标-13"><a href="#目标-13" class="headerlink" title="目标"></a>目标</h4><p>学习自旋锁原理</p>
<h4 id="自旋锁原理"><a href="#自旋锁原理" class="headerlink" title="自旋锁原理"></a>自旋锁原理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (Demo01.class) &#123;  </span><br><span class="line">    ...    </span><br><span class="line">	System.out.println(<span class="string">&quot;aaa&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面我们讨论monitor实现锁的时候，知道monitor会阻塞和唤醒线程，线程的阻塞和唤醒需要CPU从 用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，这些操作给系统的并发性能 带来了很大的压力。同时，虚拟机的开发团队也注意到在许多应用上，共享数据的锁定状态只会持续很 短的一段时间，为了这段时间阻塞和唤醒线程并不值得。如果物理机器有一个以上的处理器，能让两个 或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行 时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环(自 旋) , 这项技术就是所谓的自旋锁。  </p>
<p>自旋锁在JDK 1.4.2中就已经引入 ，只不过默认是关闭的，可以使用-XX:+UseSpinning参数来开启，在 JDK 6中 就已经改为默认开启了。自旋等待不能代替阻塞，且先不说对处理器数量的要求，自旋等待本 身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果锁被占用的时间很短，自旋等 待的效果就会非常好，反之，如果锁被占用的时间很长。那么自旋的线程只会白白消耗处理器资源，而 不会做任何有用的工作，反而会带来性 能上的浪费。因此，自旋等待的时间必须要有一定的限度，如果在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。自旋次数的默认值 是10次，用户可以使用参数-XX : PreBlockSpin来更改。 </p>
<h4 id="适应性自旋锁"><a href="#适应性自旋锁" class="headerlink" title="适应性自旋锁"></a>适应性自旋锁</h4><p>在JDK 6中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上 的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持 有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持 续相对更长的时间，比如100次循环。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取 这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行和性能监控 信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确，虛拟机就会变得越来越“聪明”了。 </p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><h4 id="目标-14"><a href="#目标-14" class="headerlink" title="目标"></a>目标</h4><p>学习如何进行锁消除</p>
<p> 锁消除是指虚拟机即时编译器（JIT）在运行时，对一些代码上要求同步，但是被检测到不可能存在共享 数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码中， 堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们 是线程私有的，同步加锁自然就无须进行。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确 定，但是程序员自己应该是很清楚的，怎么会在明知道不存在数据争用的情况下要求同步呢?实际上有 许多同步措施并不是程序员自己加入的，同步的代码在Java程序中的普遍程度也许超过了大部分读者的 想象。下面这段非常简单的代码仅仅是输出3个字符串相加的结果，无论是源码字面上还是程序语义上 都没有同步。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        contactString(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">contactString</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>().append(s1).append(s2).append(s3).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StringBuﬀer的append ( ) 是一个同步方法，锁就是this也就是(new StringBuilder())。虚拟机发现它的 动态作用域被限制在concatString( )方法内部。也就是说, new StringBuilder()对象的引用永远不会“逃 逸”到concatString ( )方法之外，其他线程无法访问到它，因此，虽然这里有锁，但是可以被安全地消除 掉，在即时编译之后，这段代码就会忽略掉所有的同步而直接执行了。 </p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><h4 id="目标-15"><a href="#目标-15" class="headerlink" title="目标"></a>目标</h4><p>学习锁粗化的原理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// synchronized (Demo01.class) &#123;</span></span><br><span class="line">        <span class="comment">//     System.out.println(&quot;aaa&quot;);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，只在共享数据的实际作 用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线 程也能尽快拿到锁。大部分情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对 象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操 作也会导致不必要的性能损耗。</p>
<h4 id="小结-11"><a href="#小结-11" class="headerlink" title="小结"></a>小结</h4><p>什么是锁粗化？</p>
<p>JVM会探测到一连串细小的操作都使用同一个对象加锁，将同步代码块的范围放大，放到这串操作的外面，这样只需要加一次锁即可。</p>
<h3 id="平时写代码如何对synchronized优化"><a href="#平时写代码如何对synchronized优化" class="headerlink" title="平时写代码如何对synchronized优化"></a>平时写代码如何对synchronized优化</h3><h4 id="减少synchronized的范围"><a href="#减少synchronized的范围" class="headerlink" title="减少synchronized的范围"></a>减少synchronized的范围</h4><p>同步代码块中尽量短，减少同步代码块中代码的执行时间，减少锁的竞争。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (Demo01.class) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="降低synchronized锁的粒度"><a href="#降低synchronized锁的粒度" class="headerlink" title="降低synchronized锁的粒度"></a>降低synchronized锁的粒度</h4><p>将一个锁拆分为多个锁提高并发度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Hashtable</span> <span class="variable">hs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">    hs.put(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>);</span><br><span class="line">    hs.put(<span class="string">&quot;xx&quot;</span>, <span class="string">&quot;yy&quot;</span>);</span><br><span class="line">    hs.get(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    hs.remove(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210411152126270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411152140792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411152153408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><p>读取时不加锁，写入和删除时加锁<br>ConcurrentHashMap，CopyOnWriteArrayList和ConyOnWriteSet</p>
<h2 id="Lock接口的使用"><a href="#Lock接口的使用" class="headerlink" title="Lock接口的使用"></a>Lock接口的使用</h2><p>既然有了synchronized，为啥还要提供Lock接口呢？也许你会说Lock接口比synchronized性能高。在jdk1.5之前确实如此，但是在jdk1.6之后，两者性能差不多了。直接来看Lock接口的定义，看看比synchronized多了哪些功能？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 能够响应中断</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="comment">// 非阻塞获取锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 非阻塞超时获取锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 定义阻塞条件</span></span><br><span class="line">    Condition <span class="title function_">newCondition</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到Lock接口相比synchronized多了很多特性，详细解释一下方法</p>
<ol>
<li>lock()方法，用来获取锁，如果锁被其他线程获得则进行等待，需要和unlock方法配合主动释放锁。发生异常时，不会主动释放锁，所以释放锁的操作放在finally块中</li>
<li>lockInterruptibly()方法，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程</li>
<li>tryLock()方法，用来尝试获取锁，如果获取成功，则返回true。如果获取失败则返回false。也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待</li>
<li>tryLock(long time, TimeUnit unit)方法，和tryLock()类似。只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果一开始拿到锁或者在等待期间内拿到了锁，则返回true</li>
<li>unlock()方法，解锁</li>
<li>newCondition()方法，定义条件</li>
</ol>
<p>其余的应该都很好理解，演示一下lockInterruptibly()和newCondition()方法</p>
<p><strong>lockInterruptibly()方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">myLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">// 先获取一次锁，让后续获取锁的操作阻塞</span></span><br><span class="line">myLock.lock();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// myLock.lock();</span></span><br><span class="line">        myLock.lockInterruptibly();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 当使用myLock.lockInterruptibly()时</span></span><br><span class="line">        <span class="comment">// 会抛出java.lang.InterruptedException，打印over</span></span><br><span class="line">        <span class="comment">// 使用myLock.lock()，一直阻塞获取锁，不会打印over</span></span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">thread.interrupt();</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p><strong>Condition的使用</strong></p>
<p>synchronized与wait()和nitofy()&#x2F;notifyAll()方法相结合可以实现等待&#x2F;通知模型，ReentrantLock同样可以，但是需要借助Condition，且Condition有更好的灵活性，具体体现在</p>
<ol>
<li>一个Lock里面可以创建多个Condition实例，实现多路通知</li>
<li>notify()方法进行通知时，被通知的线程时Java虚拟机随机选择的，但是ReentrantLock结合Condition可以实现有选择性地通知</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotify</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">conditionA</span>  <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">conditionB</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">waitThreadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">WaitA</span>(), <span class="string">&quot;WaitThreadA&quot;</span>);</span><br><span class="line">        waitThreadA.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">waitThreadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">WaitB</span>(), <span class="string">&quot;WaitThreadB&quot;</span>);</span><br><span class="line">        waitThreadB.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conditionA.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WaitA</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot; begin await @ &quot;</span></span><br><span class="line">                        + <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">                conditionA.await();</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot; end await @ &quot;</span></span><br><span class="line">                        + <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WaitB</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot; begin await @ &quot;</span></span><br><span class="line">                        + <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">                conditionB.await();</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot; end await @ &quot;</span></span><br><span class="line">                        + <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Thread[WaitThreadA,<span class="number">5</span>,main] begin await @ <span class="number">00</span>:<span class="number">49</span>:<span class="number">57</span></span><br><span class="line">Thread[WaitThreadB,<span class="number">5</span>,main] begin await @ <span class="number">00</span>:<span class="number">49</span>:<span class="number">57</span></span><br><span class="line">Thread[WaitThreadA,<span class="number">5</span>,main] end await @ <span class="number">00</span>:<span class="number">49</span>:<span class="number">59</span></span><br></pre></td></tr></table></figure>

<p>WaitThreadB因为没有被通知，一直阻塞</p>
<p><strong>最后总结一波，synchronized和ReentrantLock的异同</strong></p>
<ol>
<li>ReentrantLock支持非阻塞的方式获取锁，能够响应中断，而synchronized不行</li>
<li>ReentrantLock必须手动获取和释放锁，而synchronized不需要</li>
<li>ReentrantLock可以是公平锁或者非公平锁，而synchronized只能是非公平锁</li>
<li>synchronized在发生异常的时候，会自动释放线程占有的锁，而ReentrantLock在发生异常时，如果没有通过unlock去释放锁，很有可能造成死锁，因此需要在finally块中释放锁</li>
<li>synchronized和ReentrantLock都是可重入锁</li>
</ol>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>在开始本篇文章的内容讲述前，先来回答我一个问题，为什么 JDK 提供一个 <code>synchronized</code> 关键字之后还要提供一个 Lock 锁，这不是多此一举吗？难道 JDK 设计人员都是沙雕吗？</p>
<p>我听过一句话非常的经典，也是我认为是每个人都应该了解的一句话：<code>你以为的并不是你以为的</code>。明白什么意思么？不明白的话，加我微信我告诉你。</p>
<h2 id="初识-ReentrantLock"><a href="#初识-ReentrantLock" class="headerlink" title="初识 ReentrantLock"></a>初识 ReentrantLock</h2><p>ReentrantLock 位于 <code>java.util.concurrent.locks</code> 包下，它实现了 <code>Lock</code> 接口和 <code>Serializable</code> 接口。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/34d61e26fb506eb7ec6e3017b0ef0cbc.png" alt="img"></p>
<p>ReentrantLock 是一把<code>可重入锁</code>和<code>互斥锁</code>，它具有与 synchronized 关键字相同的含有隐式监视器锁（monitor）的基本行为和语义，但是它比 synchronized 具有更多的方法和功能。</p>
<h2 id="ReentrantLock-基本方法"><a href="#ReentrantLock-基本方法" class="headerlink" title="ReentrantLock 基本方法"></a>ReentrantLock 基本方法</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>ReentrantLock 类中带有两个构造函数，一个是默认的构造函数，不带任何参数；一个是带有 fair 参数的构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">  sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">  sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个构造函数也是判断 ReentrantLock 是否是公平锁的条件，如果 fair 为 true，则会创建一个<code>公平锁</code>的实现，也就是 <code>new FairSync()</code>，如果 fair 为 false，则会创建一个 <code>非公平锁</code>的实现，也就是 <code>new NonfairSync()</code>，默认的情况下创建的是非公平锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建的是公平锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建的是非公平锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认创建非公平锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br></pre></td></tr></table></figure>

<p>FairSync 和 NonfairSync 都是 ReentrantLock 的内部类，继承于 <code>Sync</code> 类，下面来看一下它们的继承结构，便于梳理。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/973efa8f64b3b48f1b725891730bc90c.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;...&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>在多线程尝试加锁时，如果是公平锁，那么<strong>锁获取的机会是相同的</strong>。否则，如果是非公平锁，那么 ReentrantLock 则<strong>不会保证每个锁的访问顺序</strong>。</p>
<p>下面是一个<code>公平锁</code>的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFairLock</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fairLock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()  + <span class="string">&quot;正在持有锁&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()  + <span class="string">&quot;释放了锁&quot;</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyFairLock</span> <span class="variable">myFairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyFairLock</span>();</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;启动&quot;</span>);</span><br><span class="line">            myFairLock.fairLock();</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread[] thread = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">            thread[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">            thread[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不信？不信你输出试试啊！懒得输出？就知道你懒得输出，所以直接告诉你结论吧，结论就是<code>自己试</code>。</p>
<p>试完了吗？试完了我是不会让你休息的，过来再试一下非公平锁的测试和结论，知道怎么试吗？上面不是讲过要给 ReentrantLock 传递一个参数的吗？你想，传 true 的时候是公平锁，那么反过来不就是非公平锁了？其他代码还用改吗？不需要了啊。</p>
<p>明白了吧，再来测试一下非公平锁的流程，看看是不是你想要的结果。</p>
<h3 id="公平锁的加锁（lock）流程详解"><a href="#公平锁的加锁（lock）流程详解" class="headerlink" title="公平锁的加锁（lock）流程详解"></a>公平锁的加锁（lock）流程详解</h3><p>通常情况下，使用多线程访问公平锁的效率会<code>非常低</code>（通常情况下会慢很多），但是 ReentrantLock 会保证每个线程都会公平的持有锁，<code>线程饥饿的次数比较小</code>。锁的公平性并不能保证线程调度的公平性。</p>
<p>此时如果你想了解更多的话，那么我就从源码的角度跟你聊聊如何 ReentrantLock 是如何实现这两种锁的。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/3a31a563cfc1eb81b02c27464013f9b6.png" alt="img"></p>
<p>如上图所示，公平锁的加锁流程要比非公平锁的加锁流程简单，下面要聊一下具体的流程了，请小伙伴们备好板凳。</p>
<p>下面先看一张流程图，这张图是 acquire 方法的三条主要流程</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/08983b9c3ad0f3964d3e97bb5a350365.png" alt="img"></p>
<p><strong>首先是第一条路线</strong>，tryAcquire 方法，顾名思义尝试获取，也就是说可以成功获取锁，也可以获取锁失败。</p>
<p>使用 <code>ctrl+左键</code> 点进去是调用 AQS 的方法，但是 ReentrantLock 实现了 AQS 接口，所以调用的是 ReentrantLock 的 tryAcquire 方法；</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/accd500e60338ce36de9c49d36d42ccc.png" alt="img"></p>
<p>首先会取得当前线程，然后去读取当前锁的同步状态，还记得锁的四种状态吗？分别是 <code>无锁、偏向锁、轻量级锁和重量级锁</code>，如果你不是很明白的话，请参考博主这篇文章（<a href="https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&mid=2247484919&idx=1&sn=b36b9b84ad50559210b6f21901a882b9&chksm=fc45f804cb327112bb4301191d8f3a464244ca7cb93da73f3b1d8ff28821d6ac32e2512d66e0&token=1671614453&lang=zh_CN&scene=21#wechat_redirect"><strong>不懂什么是锁？看看这篇你就明白了</strong></a>），如果判断同步状态是 0 的话，就证明是无锁的，参考下面这幅图( 1bit 表示的是是否偏向锁 )</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6cb08686f27c02343840eb23d107ce3c.png" alt="img"></p>
<p>如果是无锁（也就是没有加锁），说明是第一次上锁，首先会先判断一下队列中是否有比当前线程等待时间更长的线程（hasQueuedPredecessors）；然后通过 <code>CAS</code> 方法原子性的更新锁的状态，CAS 方法更新的要求涉及三个变量，<code>currentValue(当前线程的值)，expectedValue(期望更新的值)，updateValue(更新的值)</code>，它们的更新如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(currentValue == expectedValue)&#123;</span><br><span class="line">  currentValue = updateValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CAS 通过 C 底层机制保证原子性，这个你不需要考虑它。如果既没有排队的线程而且使用 CAS 方法成功的把 0 -&gt; 1 （偏向锁），那么当前线程就会获得偏向锁，记录获取锁的线程为当前线程。</p>
<p>然后我们看 <code>else if</code> 逻辑，如果读取的同步状态是1，说明已经线程获取到了锁，那么就先判断当前线程是不是获取锁的线程，如果是的话，记录一下获取锁的次数 + 1，也就是说，只有同步状态为 0 的时候是无锁状态。如果当前线程不是获取锁的线程，直接返回 false。</p>
<p>acquire 方法会先查看同步状态是否获取成功，如果成功则方法结束返回，也就是 <code>!tryAcquire == false</code> ，若失败则先调用 addWaiter 方法再调用 acquireQueued 方法</p>
<p><strong>然后看一下第二条路线 addWaiter</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/3c5402d5a446dfd0924000f9fa5da927.png" alt="img"></p>
<p>这里首先把当前线程和 Node 的节点类型进行封装，Node 节点的类型有两种，<code>EXCLUSIVE</code> 和 <code>SHARED</code> ，前者为独占模式，后者为共享模式，具体的区别我们会在 AQS 源码讨论，这里读者只需要知道即可。</p>
<p>首先会进行 tail 节点的判断，有没有尾节点，其实没有头节点也就相当于没有尾节点，如果有尾节点，就会原子性的将当前节点插入同步队列中，再执行 enq 入队操作，入队操作相当于原子性的把节点插入队列中。</p>
<p>如果当前同步队列尾节点为null，说明当前线程是第一个加入同步队列进行等待的线程。</p>
<p><strong>在看第三条路线 acquireQueued</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1b967e531e07ba246285bcc5cf0db7c9.png" alt="img"></p>
<p>主要会有两个分支判断，首先会进行无限循环中，循环中每次都会判断给定当前节点的先驱节点，如果没有先驱节点会直接抛出空指针异常，直到返回 true。</p>
<p>然后判断给定节点的先驱节点是不是头节点，并且当前节点能否获取独占式锁，如果是头节点并且成功获取独占锁后，队列头指针用指向当前节点，然后释放前驱节点。如果没有获取到独占锁，就会进入 <code>shouldParkAfterFailedAcquire</code> 和 <code>parkAndCheckInterrupt</code> 方法中，我们贴出这两个方法的源码</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9d48e24ab82805f7ae1174d10b398dc7.png" alt="img"></p>
<p><code>shouldParkAfterFailedAcquire</code> 方法主要逻辑是使用<code>compareAndSetWaitStatus(pred, ws, Node.SIGNAL)</code>使用CAS将节点状态由 INITIAL 设置成 SIGNAL，表示当前线程阻塞。当 compareAndSetWaitStatus 设置失败则说明 shouldParkAfterFailedAcquire 方法返回 false，然后会在 acquireQueued 方法中死循环中会继续重试，直至compareAndSetWaitStatus 设置节点状态位为 SIGNAL 时 shouldParkAfterFailedAcquire 返回 true 时才会执行方法 parkAndCheckInterrupt 方法。（这块在后面研究 AQS 会细讲）</p>
<p><code>parkAndCheckInterrupt</code> 该方法的关键是会调用 LookSupport.park 方法（关于LookSupport会在以后的文章进行讨论），该方法是用来阻塞当前线程。</p>
<p>所以 acquireQueued 主要做了两件事情：如果当前节点的前驱节点是头节点，并且能够获取独占锁，那么当前线程能够获得锁该方法执行结束退出</p>
<p>如果获取锁失败的话，先将节点状态设置成 SIGNAL，然后调用 <code>LookSupport.park</code> 方法使得当前线程阻塞。</p>
<p>如果 <code>!tryAcquire</code> 和 <code>acquireQueued</code> 都为 true 的话，则打断当前线程。</p>
<p>那么它们的主要流程如下（注：只是加锁流程，并不是 lock 所有流程）</p>
<p><img src="https://img-blog.csdnimg.cn/20210411152305164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="非公平锁的加锁（lock）流程详解"><a href="#非公平锁的加锁（lock）流程详解" class="headerlink" title="非公平锁的加锁（lock）流程详解"></a>非公平锁的加锁（lock）流程详解</h3><p>非公平锁的加锁步骤和公平锁的步骤只有两处不同，一处是非公平锁在加锁前会直接使用 CAS 操作设置同步状态，如果设置成功，就会把当前线程设置为偏向锁的线程；一处是 CAS 操作失败执行 <code>tryAcquire</code> 方法，读取线程同步状态，如果未加锁会使用 CAS 再次进行加锁，不会等待 <code>hasQueuedPredecessors</code> 方法的执行，达到只要线程释放锁就会加锁的目的。下面通过源码和流程图来详细理解</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/94f03269a093d2f750711ad6870843e3.png" alt="img"></p>
<p>这是非公平锁和公平锁不同的两处地方，下面是非公平锁的加锁流程图</p>
<p><img src="https://img-blog.csdnimg.cn/20210411152332290.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="lockInterruptibly-以可中断的方式获取锁"><a href="#lockInterruptibly-以可中断的方式获取锁" class="headerlink" title="lockInterruptibly 以可中断的方式获取锁"></a>lockInterruptibly 以可中断的方式获取锁</h3><p>以下是 JavaDoc 官方解释：</p>
<p>lockInterruptibly 的中文意思为如果没有被打断，则获取锁。如果没有其他线程持有该锁，则获取该锁并立即返回，将锁保持计数设置为1。如果当前线程已经持有锁，那么此方法会立刻返回并且持有锁的数量会 + 1。如果锁是由另一个线程持有的，则出于线程调度目的，当前线程将被禁用，并处于休眠状态，直到发生以下两种情况之一</p>
<ul>
<li>锁被当前线程持有</li>
<li>一些其他线程打断了当前线程</li>
</ul>
<p>如果当前线程获取了锁，则锁保持计数将设置为1。</p>
<p>如果当前线程发生了如下情况：</p>
<ul>
<li>在进入此方法时设置了其中断状态</li>
<li>当获取锁的时候发生了中断（Thread.interrupt）</li>
</ul>
<p>那么当前线程就会抛出<code>InterruptedException</code> 并且当前线程的中断状态会清除。</p>
<p><strong>下面看一下它的源码是怎么写的</strong><br><img src="https://img-blog.csdnimg.cn/20210411152518440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>首先会调用 <code>acquireInterruptibly</code> 这个方法，判断当前线程是否被中断，如果中断抛出异常，没有中断则判断<code>公平锁/非公平锁</code> 是否已经获取锁，如果没有获取锁（tryAcquire 返回 false）则调用 <code>doAcquireInterruptibly</code> 方法，这个方法和 acquireQueued 方法没什么区别，就是线程在等待状态的过程中，如果线程被中断，线程会抛出异常。</p>
<p>下面是它的流程图<br><img src="https://img-blog.csdnimg.cn/20210411152757856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="tryLock-尝试加锁"><a href="#tryLock-尝试加锁" class="headerlink" title="tryLock 尝试加锁"></a>tryLock 尝试加锁</h3><p>仅仅当其他线程没有获取这把锁的时候获取这把锁，tryLock 的源代码和非公平锁的加锁流程基本一致，它的源代码如下<br><img src="https://img-blog.csdnimg.cn/20210411152834600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>tryLock 超时获取锁</p>
<p><code>ReentrantLock</code>除了能以中断的方式去获取锁，还可以以超时等待的方式去获取锁，所谓超时等待就是线程如果在超时时间内没有获取到锁，那么就会返回<code>false</code>，而不是一直死循环获取。可以使用 tryLock 和 tryLock(timeout, unit)) 结合起来实现公平锁，像这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (lock.tryLock() || lock.tryLock(timeout, unit)) &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>如果超过了指定时间，则返回值为 false。如果时间小于或者等于零，则该方法根本不会等待。</p>
<p>它的源码如下</p>
<p><img src="https://img-blog.csdnimg.cn/20210411152857258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>首先需要了解一下 <code>TimeUnit</code> 工具类，TimeUnit 表示给定粒度单位的持续时间，并且提供了一些用于时分秒跨单位转换的方法，通过使用这些方法进行定时和延迟操作。</p>
<p><code>toNanos</code> 用于把 long 型表示的时间转换成为纳秒，然后判断线程是否被打断，如果没有打断，则以<code>公平锁/非公平锁</code> 的方式获取锁，如果能够获取返回true，获取失败则调用<code>doAcquireNanos</code>方法使用超时等待的方式获取锁。在超时等待获取锁的过程中，如果等待时间大于应等待时间，或者应等待时间设置不合理的话，返回 false。</p>
<p><img src="https://img-blog.csdnimg.cn/2021041115292296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>这里面以超时的方式获取锁也可以画一张流程图如下</p>
<p><img src="https://img-blog.csdnimg.cn/2021041115294225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="unlock-解锁流程"><a href="#unlock-解锁流程" class="headerlink" title="unlock 解锁流程"></a>unlock 解锁流程</h3><p><code>unlock</code> 和 <code>lock</code> 是一对情侣，它们分不开彼此，在调用 lock 后必须通过 unlock 进行解锁。如果当前线程持有锁，在调用 unlock 后，count 计数将减少。如果保持计数为0就会进行解锁。如果当前线程没有持有锁，在调用 unlock 会抛出 <code>IllegalMonitorStateException</code> 异常。下面是它的源码</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b328b41d5fd146139a0e5c3698588e6d.png" alt="img"></p>
<p>在有了上面阅读源码的经历后，相信你会很快明白这段代码的意思，锁的释放不会区分公平锁还是非公平锁，主要的判断逻辑就是 <code>tryRelease</code> 方法，<code>getState</code> 方法会取得同步锁的重入次数，如果是获取了偏向锁，那么可能会多次获取，state 的值会大于 1，这时候 c 的值 &gt; 0 ，返回 false，解锁失败。如果 state &#x3D; 1，那么 c &#x3D; 0，再判断当前线程是否是独占锁的线程，释放独占锁，返回 true，当 head 指向的头结点不为 null，并且该节点的状态值不为0的话才会执行 unparkSuccessor 方法，再进行锁的获取。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/baa75efc307bfb4d37e60e53195d4636.png" alt="img"></p>
<h2 id="ReentrantLock-其他方法"><a href="#ReentrantLock-其他方法" class="headerlink" title="ReentrantLock 其他方法"></a>ReentrantLock 其他方法</h2><h3 id="isHeldByCurrentThread-amp-getHoldCount"><a href="#isHeldByCurrentThread-amp-getHoldCount" class="headerlink" title="isHeldByCurrentThread &amp; getHoldCount"></a>isHeldByCurrentThread &amp; getHoldCount</h3><p>在多线程同时访问时，ReentrantLock 由<code>最后一次</code>成功锁定的线程拥有，当这把锁没有被其他线程拥有时，线程调用 <code>lock()</code> 方法会立刻返回并成功获取锁。如果当前线程已经拥有锁，这个方法会立刻返回。可以通过 <code>isHeldByCurrentThread</code> 和 <code>getHoldCount</code> 来进行检查。</p>
<p>首先来看 isHeldByCurrentThread 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHeldByCurrentThread</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据方法名可以略知一二，<code>是否被当前线程持有</code>，它用来询问锁是否被其他线程拥有，这个方法和 <code>Thread.holdsLock(Object)</code> 方法内置的监视器锁相同，而 Thread.holdsLock(Object) 是 <code>Thread</code> 类的静态方法，是一个 <code>native</code> 类，它表示的意思是如果当前线程在某个对象上持有 monitor lock(监视器锁) 就会返回 true。这个类没有实际作用，仅仅用来测试和调试所用。例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> lock.isHeldByCurrentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法也可以确保重入锁能够表现出<code>不可重入</code>的行为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> !lock.isHeldByCurrentThread();</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行业务代码</span></span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前线程持有锁则 lock.isHeldByCurrentThread() 返回 true，否则返回 false。</p>
<p>我们在了解它的用法后，看一下它内部是怎样实现的，它内部只是调用了一下  sync.isHeldExclusively()，<code>sync</code> 是 ReentrantLock 的一个<code>静态内部类</code>，基于 AQS 实现，而 AQS 它是一种抽象队列同步器，是许多并发实现类的基础，例如 <strong>ReentrantLock&#x2F;Semaphore&#x2F;CountDownLatch</strong>。sync.isHeldExclusively() 方法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法会在拥有锁之前先去读一下状态，如果当前线程是锁的拥有者，则不需要检查。</p>
<p><code>getHoldCount()</code>方法和<code>isHeldByCurrentThread</code> 都是用来检查线程是否持有锁的方法，不同之处在于 getHoldCount() 用来查询当前线程持有锁的数量，对于每个未通过解锁操作匹配的锁定操作，线程都会保持锁定状态，这个方法也通常用于调试和测试，例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> lock.getHoldCount() == <span class="number">0</span>;</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行业务代码</span></span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法会返回当前线程持有锁的次数，如果当前线程没有持有锁，则返回0。</p>
<h3 id="newCondition-创建-ConditionObject-对象"><a href="#newCondition-创建-ConditionObject-对象" class="headerlink" title="newCondition 创建 ConditionObject 对象"></a>newCondition 创建 ConditionObject 对象</h3><p>ReentrantLock 可以通过 <code>newCondition</code> 方法创建 ConditionObject 对象，而 ConditionObject 实现了 <code>Condition</code> 接口，关于 Condition 的用法我们后面再讲。</p>
<h3 id="isLocked-判断是否锁定"><a href="#isLocked-判断是否锁定" class="headerlink" title="isLocked 判断是否锁定"></a>isLocked 判断是否锁定</h3><p>查询是否有任意线程已经获取锁，这个方法用来监视系统状态，而不是用来同步控制，很简单，直接判断 <code>state</code> 是否等于0。</p>
<h3 id="isFair-判断是否是公平锁的实例"><a href="#isFair-判断是否是公平锁的实例" class="headerlink" title="isFair 判断是否是公平锁的实例"></a>isFair 判断是否是公平锁的实例</h3><p>这个方法也比较简单，直接使用 <code>instanceof</code> 判断是不是 <code>FairSync</code> 内部类的实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isFair</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> sync <span class="keyword">instanceof</span> FairSync;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getOwner-判断锁拥有者"><a href="#getOwner-判断锁拥有者" class="headerlink" title="getOwner 判断锁拥有者"></a>getOwner 判断锁拥有者</h3><p>判断同步状态是否为0，如果是0，则没有线程拥有锁，如果不是0，直接返回获取锁的线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Thread <span class="title function_">getOwner</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getState() == <span class="number">0</span> ? <span class="literal">null</span> : getExclusiveOwnerThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="hasQueuedThreads-是否有等待线程"><a href="#hasQueuedThreads-是否有等待线程" class="headerlink" title="hasQueuedThreads 是否有等待线程"></a>hasQueuedThreads 是否有等待线程</h3><p>判断是否有线程正在等待获取锁，如果头节点与尾节点不相等，说明有等待获取锁的线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedThreads</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> head != tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="isQueued-判断线程是否排队"><a href="#isQueued-判断线程是否排队" class="headerlink" title="isQueued 判断线程是否排队"></a>isQueued 判断线程是否排队</h3><p>判断给定的线程是否正在排队，如果正在排队，返回 true。这个方法会遍历队列，如果找到匹配的线程，返回true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isQueued</span><span class="params">(Thread thread)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (thread == <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> tail; p != <span class="literal">null</span>; p = p.prev)</span><br><span class="line">    <span class="keyword">if</span> (p.thread == thread)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getQueueLength-获取队列长度"><a href="#getQueueLength-获取队列长度" class="headerlink" title="getQueueLength 获取队列长度"></a>getQueueLength 获取队列长度</h3><p>此方法会返回一个队列长度的估计值，该值只是一个估计值，因为在此方法遍历内部数据结构时，线程数可能会动态变化。 此方法设计用于监视系统状态，而不用于同步控制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getQueueLength</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> tail; p != <span class="literal">null</span>; p = p.prev) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p.thread != <span class="literal">null</span>)</span><br><span class="line">      ++n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getQueuedThreads-获取排队线程"><a href="#getQueuedThreads-获取排队线程" class="headerlink" title="getQueuedThreads 获取排队线程"></a>getQueuedThreads 获取排队线程</h3><p>返回一个包含可能正在等待获取此锁的线程的集合。 因为实际的线程集在构造此结果时可能会动态更改，所以返回的集合只是一个大概的列表集合。 返回的集合的元素没有特定的顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Collection&lt;Thread&gt; <span class="title function_">getQueuedThreads</span><span class="params">()</span> &#123;</span><br><span class="line">  ArrayList&lt;Thread&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Thread&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> tail; p != <span class="literal">null</span>; p = p.prev) &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> p.thread;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">null</span>)</span><br><span class="line">      list.add(t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="回答上面那个问题"><a href="#回答上面那个问题" class="headerlink" title="回答上面那个问题"></a>回答上面那个问题</h2><p>那么你看完源码分析后，你能总结出 <code>synchronized</code> 和 <code>lock</code> 锁的实现 <code>ReentrantLock</code> 有什么异同吗？</p>
<p>Synchronzied 和 Lock 的主要区别如下：</p>
<ul>
<li><p><strong>存在层面</strong>：Syncronized 是Java 中的一个关键字，存在于 JVM 层面，Lock 是 Java 中的一个接口</p>
</li>
<li><p><strong>锁的释放条件</strong>：1. 获取锁的线程执行完同步代码后，自动释放；2. 线程发生异常时，JVM会让线程释放锁；Lock 必须在 finally 关键字中释放锁，不然容易造成线程死锁</p>
</li>
<li><p><strong>锁的获取</strong>: 在 Syncronized 中，假设线程 A 获得锁，B 线程等待。如果 A 发生阻塞，那么 B 会一直等待。在 Lock 中，会分情况而定，Lock 中有尝试获取锁的方法，如果尝试获取到锁，则不用一直等待</p>
</li>
<li><p><strong>锁的状态</strong>：Synchronized 无法判断锁的状态，Lock 则可以判断</p>
</li>
<li><p><strong>锁的类型</strong>：Synchronized 是可重入，不可中断，非公平锁；Lock 锁则是 可重入，可判断，可公平锁</p>
</li>
<li><p><strong>锁的性能</strong>：Synchronized 适用于少量同步的情况下，性能开销比较大。Lock 锁适用于大量同步阶段：</p>
<p>Lock 锁可以提高多个线程进行读的效率(使用 readWriteLock)</p>
</li>
<li><p>在竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态；</p>
</li>
<li><p>ReetrantLock 提供了多样化的同步，比如有时间限制的同步，可以被Interrupt的同步（synchronized的同步是不能Interrupt的）等</p>
</li>
<li><p><strong>Synchronized和实现Lock接口的都是悲观锁</strong></p>
</li>
</ul>
<h3 id="还有什么要说的吗"><a href="#还有什么要说的吗" class="headerlink" title="还有什么要说的吗"></a>还有什么要说的吗</h3><p>面试官可能还会问你 ReentrantLock 的加锁流程是怎样的，其实如果你能把源码给他讲出来的话，一定是高分。如果你记不住源码流程的话可以记住下面这个<strong>简化版的加锁流程</strong></p>
<ul>
<li><p>如果 lock 加锁设置成功，设置当前线程为独占锁的线程；</p>
</li>
<li><p>如果 lock 加锁设置失败，还会再尝试获取一次锁数量，</p>
<p>如果锁数量为0，再基于 CAS 尝试将 state（锁数量）从0设置为1一次，如果设置成功，设置当前线程为独占锁的线程；</p>
<p>如果锁数量不为0或者上边的尝试又失败了，查看当前线程是不是已经是独占锁的线程了，如果是，则将当前的锁数量+1；如果不是，则将该线程封装在一个Node内，并加入到等待队列中去。等待被其前一个线程节点唤醒。</p>
</li>
</ul>
<h1 id="3、创建线程的方式"><a href="#3、创建线程的方式" class="headerlink" title="3、创建线程的方式"></a>3、创建线程的方式</h1><h3 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1.继承Thread类"></a>1.继承Thread类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadDemo1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;通过extendsThread来创建线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadDemo1</span> <span class="variable">threadDemo1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadDemo1</span>();</span><br><span class="line">        threadDemo1.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-实现Runnable接口创建线程"><a href="#2-实现Runnable接口创建线程" class="headerlink" title="2.实现Runnable接口创建线程"></a>2.实现Runnable接口创建线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实现Runnable接口创建线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-通过实现Callable接口创建线程"><a href="#3-通过实现Callable接口创建线程" class="headerlink" title="3.通过实现Callable接口创建线程"></a>3.通过实现Callable接口创建线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过实现Callable接口创建线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread02</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">MyThread02</span> <span class="variable">myThread02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread02</span>();</span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(myThread02);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">        System.out.println(o);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="4-通过创建线程池的方法创建线程"><a href="#4-通过创建线程池的方法创建线程" class="headerlink" title="4.通过创建线程池的方法创建线程"></a>4.通过创建线程池的方法创建线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过创建线程池的方法创建线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor=(ThreadPoolExecutor)service;</span><br><span class="line">        threadPoolExecutor.execute(<span class="keyword">new</span> <span class="title class_">NumberThread</span>());</span><br><span class="line"><span class="comment">//       service.execute(new NumberThread());</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="4、线程间通信"><a href="#4、线程间通信" class="headerlink" title="4、线程间通信"></a>4、线程间通信</h1><h3 id="1运用notify和wait实现线程的通信"><a href="#1运用notify和wait实现线程的通信" class="headerlink" title="1运用notify和wait实现线程的通信"></a>1运用notify和wait实现线程的通信</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShareData</span><span class="comment">//资源类</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//初始值为零的一个变量</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span><br><span class="line">  &#123;</span><br><span class="line">     <span class="comment">//判断</span></span><br><span class="line">     <span class="keyword">while</span>(number!=<span class="number">0</span>) &#123;</span><br><span class="line">       <span class="built_in">this</span>.wait();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//干活</span></span><br><span class="line">     ++number;</span><br><span class="line">     System.out.println(Thread.currentThread().getName()+<span class="string">&quot; \t &quot;</span>+number);</span><br><span class="line">     <span class="comment">//通知</span></span><br><span class="line">     <span class="built_in">this</span>.notifyAll();;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span><br><span class="line">  &#123;</span><br><span class="line">     <span class="comment">//判断</span></span><br><span class="line">     <span class="keyword">while</span>(number!=<span class="number">1</span>) &#123;</span><br><span class="line">       <span class="built_in">this</span>.wait();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//干活</span></span><br><span class="line">     --number;</span><br><span class="line">     System.out.println(Thread.currentThread().getName()+<span class="string">&quot; \t &quot;</span>+number);</span><br><span class="line">     <span class="comment">//通知</span></span><br><span class="line">     <span class="built_in">this</span>.notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> *现在两个线程，</span></span><br><span class="line"><span class="comment"> * 可以操作初始值为零的一个变量，</span></span><br><span class="line"><span class="comment"> * 实现一个线程对该变量加1，一个线程对该变量减1，</span></span><br><span class="line"><span class="comment"> * 交替，来10轮。 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xialei</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * 笔记：Java里面如何进行工程级别的多线程编写</span></span><br><span class="line"><span class="comment"> * 1 多线程变成模板（套路）-----上</span></span><br><span class="line"><span class="comment"> *     1.1  线程    操作    资源类  </span></span><br><span class="line"><span class="comment"> *     1.2  高内聚  低耦合</span></span><br><span class="line"><span class="comment"> * 2 多线程变成模板（套路）-----下</span></span><br><span class="line"><span class="comment"> *     2.1  判断</span></span><br><span class="line"><span class="comment"> *     2.2  干活</span></span><br><span class="line"><span class="comment"> *     2.3  通知</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotifyWaitDemo</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">  &#123;</span><br><span class="line">     <span class="type">ShareData</span> <span class="variable">sd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShareData</span>();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            sd.increment();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            sd.decrement();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            sd.increment();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            sd.decrement();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">     </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="https://img-blog.csdnimg.cn/20210411153106416.png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="2Condition实现"><a href="#2Condition实现" class="headerlink" title="2Condition实现"></a>2Condition实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShareData</span><span class="comment">//资源类</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//初始值为零的一个变量</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span>  <span class="operator">=</span> lock.newCondition(); </span><br><span class="line">   </span><br><span class="line">  <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span><br><span class="line">  &#123;</span><br><span class="line">     </span><br><span class="line">      lock.lock();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//判断</span></span><br><span class="line">          <span class="keyword">while</span>(number!=<span class="number">0</span>) &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//干活</span></span><br><span class="line">          ++number;</span><br><span class="line">          System.out.println(Thread.currentThread().getName()+<span class="string">&quot; \t &quot;</span>+number);</span><br><span class="line">          <span class="comment">//通知</span></span><br><span class="line">          condition.signalAll();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span><br><span class="line">  &#123;</span><br><span class="line">      </span><br><span class="line">      lock.lock();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//判断</span></span><br><span class="line">          <span class="keyword">while</span>(number!=<span class="number">1</span>) &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//干活</span></span><br><span class="line">          --number;</span><br><span class="line">          System.out.println(Thread.currentThread().getName()+<span class="string">&quot; \t &quot;</span>+number);</span><br><span class="line">          <span class="comment">//通知</span></span><br><span class="line">          condition.signalAll();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotifyWaitDemo</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">  &#123;</span><br><span class="line">     <span class="type">ShareData</span> <span class="variable">sd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShareData</span>();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            sd.increment();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            sd.decrement();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            sd.increment();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            sd.decrement();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">     </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<h1 id="5、线程间定制化调用通信"><a href="#5、线程间定制化调用通信" class="headerlink" title="5、线程间定制化调用通信"></a>5、线程间定制化调用通信</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> JUCProject.Condition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * 多线程之间按顺序调用，实现A-&gt;B-&gt;C</span></span><br><span class="line"><span class="comment"> * 三个线程启动，要求如下：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * AA打印5次，BB打印10次，CC打印15次</span></span><br><span class="line"><span class="comment"> * 接着</span></span><br><span class="line"><span class="comment"> * AA打印5次，BB打印10次，CC打印15次</span></span><br><span class="line"><span class="comment"> * ......来10轮</span></span><br><span class="line"><span class="comment"> *1 多线程变成模板（套路）-----上</span></span><br><span class="line"><span class="comment"> *     1.1  线程    操作    资源类</span></span><br><span class="line"><span class="comment"> *     1.2  高内聚  低耦合</span></span><br><span class="line"><span class="comment"> * 2 多线程变成模板（套路）-----下</span></span><br><span class="line"><span class="comment"> *     2.1  判断</span></span><br><span class="line"><span class="comment"> *     2.2  干活</span></span><br><span class="line"><span class="comment"> *     2.3  通知</span></span><br><span class="line"><span class="comment">3 防止虚假唤醒用while</span></span><br><span class="line"><span class="comment">4.注意标志位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShareResource</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> Condition condition1=lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition2=lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition3=lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print5</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">1</span>)&#123;</span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&#x27;\t&#x27;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">            number=<span class="number">2</span>;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print10</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">2</span>)&#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&#x27;\t&#x27;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">            number=<span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print15</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">3</span>)&#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;=<span class="number">15</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&#x27;\t&#x27;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">            number=<span class="number">1</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadOrderAccess</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ShareResource</span> <span class="variable">shareResource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShareResource</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                shareResource.print5();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                shareResource.print10();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                shareResource.print15();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="6、NotSafeDemo"><a href="#6、NotSafeDemo" class="headerlink" title="6、NotSafeDemo"></a>6、NotSafeDemo</h1><h3 id="1证明集合不安全"><a href="#1证明集合不安全" class="headerlink" title="1证明集合不安全"></a>1证明集合不安全</h3><p>java.util.ConcurrentModificationException</p>
<p>ArrayList在迭代的时候如果同时对其进行修改就会抛出java.util.ConcurrentModificationException异常<br>并发修改异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">30</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">8</span>));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">看ArrayList的源码</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">没有<span class="keyword">synchronized</span>线程不安全</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2解决方案"><a href="#2解决方案" class="headerlink" title="2解决方案"></a>2解决方案</h3><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">看Vector的源码</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">有<span class="keyword">synchronized</span>线程安全</span><br></pre></td></tr></table></figure>



<h4 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br></pre></td></tr></table></figure>


<p>Collections提供了方法synchronizedList保证list是同步线程安全的</p>
<p>那HashMap，HashSet是线程安全的吗？也不是<br>所以有同样的线程安全方法</p>
<p><img src="https://img-blog.csdnimg.cn/20210411153120467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">   <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">   lock.lock();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       Object[] elements = getArray();</span><br><span class="line">       <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">       Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">       newElements[len] = e;</span><br><span class="line">       setArray(newElements);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">CopyOnWrite容器即写时复制的容器。往一个容器添加元素的时候，不直接往当前容器Object[]添加，</span><br><span class="line">而是先将当前容器Object[]进行Copy，复制出一个新的容器Object[] newElements，然后向新的容器Object[] newElements里添加元素。</span><br><span class="line">添加元素后，再将原容器的引用指向新的容器setArray(newElements)。</span><br><span class="line">这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。</span><br><span class="line">所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</span><br></pre></td></tr></table></figure>

<h1 id="7、多线程锁"><a href="#7、多线程锁" class="headerlink" title="7、多线程锁"></a>7、多线程锁</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* * 1 标准访问，先打印邮件还是短信</span></span><br><span class="line"><span class="comment">2 停4秒在邮件方法内，先打印邮件还是短信</span></span><br><span class="line"><span class="comment">3 普通的hello方法，是先打邮件还是hello</span></span><br><span class="line"><span class="comment">4 现在有两部手机，先打印邮件还是短信</span></span><br><span class="line"><span class="comment">5 两个静态同步方法，1部手机，先打印邮件还是短信</span></span><br><span class="line"><span class="comment">6 两个静态同步方法，2部手机，先打印邮件还是短信</span></span><br><span class="line"><span class="comment">7 1个静态同步方法，1个普通同步方法，1部手机，先打印邮件还是hello</span></span><br><span class="line"><span class="comment">8 1个静态同步方法，1个普通同步方法，2部手机，先打印邮件还是hello</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        1、邮件</span></span><br><span class="line"><span class="comment">        2、邮件</span></span><br><span class="line"><span class="comment">        3、Hello</span></span><br><span class="line"><span class="comment">        4、短信</span></span><br><span class="line"><span class="comment">        5、邮件</span></span><br><span class="line"><span class="comment">        6、邮件</span></span><br><span class="line"><span class="comment">        7、hello</span></span><br><span class="line"><span class="comment">        8、hello</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>   <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="comment">//发邮件</span></span><br><span class="line">       TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="comment">//发短信</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----------sendSMS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    phone01.sendEmail();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                phone02.hello();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="8锁分析"><a href="#8锁分析" class="headerlink" title="8锁分析"></a>8锁分析</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A 一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，</span><br><span class="line">其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized方法</span><br><span class="line">锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法</span><br><span class="line"></span><br><span class="line">加个普通方法后发现和同步锁无关</span><br><span class="line">换成两个对象后，不是同一把锁了，情况立刻变化。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">synchronized实现同步的基础：Java中的每一个对象都可以作为锁。</span><br><span class="line">具体表现为以下3种形式。</span><br><span class="line">对于普通同步方法，锁是当前实例对象。</span><br><span class="line">对于静态同步方法，锁是当前类的Class对象。</span><br><span class="line">对于同步方法块，锁是Synchonized括号里配置的对象</span><br><span class="line"></span><br><span class="line">当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</span><br><span class="line"></span><br><span class="line">也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，</span><br><span class="line">可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，</span><br><span class="line">所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。</span><br><span class="line"></span><br><span class="line">所有的静态同步方法用的也是同一把锁——类对象本身，</span><br><span class="line">这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。</span><br><span class="line">但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，</span><br><span class="line">而不管是同一个实例对象的静态同步方法之间，</span><br><span class="line">还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！</span><br></pre></td></tr></table></figure>

<h1 id="8、ReentrantReadWriteLock读写锁"><a href="#8、ReentrantReadWriteLock读写锁" class="headerlink" title="8、ReentrantReadWriteLock读写锁"></a>8、ReentrantReadWriteLock读写锁</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        rwLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 正在写&quot;</span> + key);</span><br><span class="line">            <span class="comment">//暂停一会儿线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 写完了&quot;</span> + key);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        rwLock.readLock().lock();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 正在读&quot;</span> + key);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            result = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 读完了&quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyCache</span> <span class="variable">myCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCache</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                myCache.put(num + <span class="string">&quot;&quot;</span>, num + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                myCache.get(num + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="9、BlockingQueueDemo阻塞队列"><a href="#9、BlockingQueueDemo阻塞队列" class="headerlink" title="9、BlockingQueueDemo阻塞队列"></a>9、BlockingQueueDemo阻塞队列</h1><h3 id="种类分析"><a href="#种类分析" class="headerlink" title="种类分析"></a>种类分析</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayBlockingQueue：由数组结构组成的有界阻塞队列。</span><br><span class="line"></span><br><span class="line">LinkedBlockingQueue：由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列。</span><br><span class="line"></span><br><span class="line">PriorityBlockingQueue：支持优先级排序的无界阻塞队列。</span><br><span class="line"></span><br><span class="line">DelayQueue：使用优先级队列实现的延迟无界阻塞队列。</span><br><span class="line"></span><br><span class="line">SynchronousQueue：不存储元素的阻塞队列，也即单个元素的队列。</span><br><span class="line"></span><br><span class="line">LinkedTransferQueue：由链表组成的无界阻塞队列。</span><br><span class="line"></span><br><span class="line">LinkedBlockingDeque：由链表组成的双向阻塞队列。</span><br></pre></td></tr></table></figure>



<h3 id="BlockingQueue核心方法"><a href="#BlockingQueue核心方法" class="headerlink" title="BlockingQueue核心方法"></a>BlockingQueue核心方法</h3><p><img src="https://img-blog.csdnimg.cn/20210411153139907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210411153139984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用reentrantLock实现</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> Condition condition=lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">product</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">0</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+number);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">1</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+number);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product_Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.product();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.consumer();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.product();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.consumer();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用blockingQueue实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductConsumerTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;String&gt; blockingQueue=<span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;String&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Product</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            blockingQueue.put(<span class="string">&quot;product..&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;produce..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Consumer</span><span class="params">()</span>&#123;</span><br><span class="line">        String product=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             product = blockingQueue.take();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ProductConsumerTest</span> <span class="variable">productConsumerTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProductConsumerTest</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                productConsumerTest.Product();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                productConsumerTest.Consumer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                productConsumerTest.Product();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="10、ThreadPool线程池"><a href="#10、ThreadPool线程池" class="headerlink" title="10、ThreadPool线程池"></a>10、ThreadPool线程池</h1><h3 id="1为什么用线程池"><a href="#1为什么用线程池" class="headerlink" title="1为什么用线程池"></a>1为什么用线程池</h3><p>线程池的优势：<br>线程池做的工作只要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。</p>
<p>它的主要特点为：线程复用;控制最大并发数;管理线程。</p>
<p>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的销耗。<br>第二：提高响应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行。<br>第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>
<h3 id="2程池如何使用"><a href="#2程池如何使用" class="headerlink" title="2程池如何使用"></a>2程池如何使用</h3><h4 id="架构说明"><a href="#架构说明" class="headerlink" title="架构说明"></a>架构说明</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java中的线程池是通过Executor框架实现的，该框架中用到了Executor，Executors，ExecutorService，ThreadPoolExecutor这几个类</span><br></pre></td></tr></table></figure>

<img src="/2022/10/24/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/Users/lileitang/Desktop/Java/Java并发编程/JUC/12.png" alt="1584760706315" style="zoom: 80%;">

<h4 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Executors.newFixedThreadPool(<span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>执行长期任务性能好，创建一个线程池，一池有N个固定的线程，有固定线程数的线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的是LinkedBlockingQueue</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Executors.newSingleThreadExecutor()</span><br></pre></td></tr></table></figure>

<p>一个任务一个任务的执行，一池一线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">newSingleThreadExecutor 创建的线程池corePoolSize和maximumPoolSize值都是<span class="number">1</span>，它使用的是LinkedBlockingQueue</span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Executors.newCachedThreadPool()</span><br></pre></td></tr></table></figure>

<p>执行很多短期异步任务，线程池根据需要创建新线程，但在先前构建的线程可用时将重用它们。可扩容，遇强则强</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line">newCachedThreadPool创建的线程池将corePoolSize设置为<span class="number">0</span>，将maximumPoolSize设置为Integer.MAX_VALUE，它使用的是SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过<span class="number">60</span>秒，就销毁线程。</span><br></pre></td></tr></table></figure>



<h3 id="3线程池几个重要参数"><a href="#3线程池几个重要参数" class="headerlink" title="3线程池几个重要参数"></a>3线程池几个重要参数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、corePoolSize：线程池中的常驻核心线程数</span><br><span class="line">2、maximumPoolSize：线程池中能够容纳同时执行的最大线程数，此值必须大于等于1</span><br><span class="line">3、keepAliveTime：多余的空闲线程的存活时间，当前池中线程数量超过corePoolSize时，当空闲时间达到	keepAliveTime时，多余线程会被销毁直到只剩下corePoolSize个线程为止</span><br><span class="line">4、unit：keepAliveTime的单位 </span><br><span class="line">5、workQueue：任务队列，被提交但尚未被执行的任务</span><br><span class="line">6、threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程，一般默认的即可</span><br><span class="line">7、handler：拒绝策略，表示当队列满了，并且工作线程大于等于线程池的最大线程数（maximumPoolSize）时如何来拒绝请求执行的runnable的策略</span><br></pre></td></tr></table></figure>



<h3 id="4线程池底层工作原理"><a href="#4线程池底层工作原理" class="headerlink" title="4线程池底层工作原理"></a>4线程池底层工作原理</h3><p><img src="https://img-blog.csdnimg.cn/2021041115321658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411153216108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、在创建了线程池后，开始等待请求。</span><br><span class="line">2、当调用execute()方法添加一个请求任务时，线程池会做出如下判断：</span><br><span class="line">  2.1如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务；</span><br><span class="line">  2.2如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列；</span><br><span class="line">  2.3如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</span><br><span class="line">  2.4如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。</span><br><span class="line">3、当一个线程完成任务时，它会从队列中取下一个任务来执行。</span><br><span class="line">4、当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：</span><br><span class="line">    如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。</span><br><span class="line">    所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小。</span><br></pre></td></tr></table></figure>



<h3 id="5线程池的拒绝策略"><a href="#5线程池的拒绝策略" class="headerlink" title="5线程池的拒绝策略"></a>5线程池的拒绝策略</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">等待队列已经排满了，再也塞不下新任务了，同时，线程池中的max线程也达到了，无法继续为新任务服务。</span><br><span class="line"></span><br><span class="line">这个是时候我们就需要拒绝策略机制合理的处理这个问题。</span><br></pre></td></tr></table></figure>

<h4 id="JDK内置的拒绝策略"><a href="#JDK内置的拒绝策略" class="headerlink" title="JDK内置的拒绝策略"></a>JDK内置的拒绝策略</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AbortPolicy(默认)：直接抛出RejectedExecutionException异常阻止系统正常运行</span><br><span class="line">CallerRunsPolicy：“调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。</span><br><span class="line">DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加人队列中尝试再次提交当前任务。</span><br><span class="line">DiscardPolicy：该策略默默地丢弃无法处理的任务，不予任何处理也不抛出异常。如果允许任务丢失，这是最好的一种策略。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上内置拒绝策略均实现了RejectedExecutionHandle接口</p>
<h3 id="6自定义线程池"><a href="#6自定义线程池" class="headerlink" title="6自定义线程池"></a>6自定义线程池</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadPoolDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());<span class="comment">//</span></span><br><span class="line"><span class="comment">//        ExecutorService threadPool= Executors.newFixedThreadPool(5);//一池5个处理线程</span></span><br><span class="line"><span class="comment">//        ExecutorService threadPool = Executors.newSingleThreadExecutor();//一池1个线程</span></span><br><span class="line"><span class="comment">//       ExecutorService threadPool = Executors.newCachedThreadPool();//一池n个线程</span></span><br><span class="line">        ExecutorService threadPool= <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>,<span class="number">7</span>,<span class="number">2</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">3</span>),Executors.defaultThreadFactory(), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardOldestPolicy()</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟有10 个顾客来银行办理业务，目前池子里有五个工作人员提供服务</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">200</span>; i++) &#123;</span><br><span class="line">                threadPool.execute(()-&gt;&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 办理业务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="11、Java8之流式计算"><a href="#11、Java8之流式计算" class="headerlink" title="11、Java8之流式计算"></a>11、Java8之流式计算</h1><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><h4 id="java内置核心四大函数式接口"><a href="#java内置核心四大函数式接口" class="headerlink" title="java内置核心四大函数式接口"></a>java内置核心四大函数式接口</h4><p><img src="https://img-blog.csdnimg.cn/20210411153238445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//R apply(T t);函数型接口，一个参数，一个返回值</span></span><br><span class="line">Function&lt;String,Integer&gt; function = t -&gt;&#123;<span class="keyword">return</span> t.length();&#125;;</span><br><span class="line">System.out.println(function.apply(<span class="string">&quot;abcd&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//boolean test(T t);断定型接口，一个参数，返回boolean</span></span><br><span class="line">Predicate&lt;String&gt; predicate = t-&gt;&#123;<span class="keyword">return</span> t.startsWith(<span class="string">&quot;a&quot;</span>);&#125;;</span><br><span class="line">System.out.println(predicate.test(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// void accept(T t);消费型接口，一个参数，没有返回值</span></span><br><span class="line">Consumer&lt;String&gt; consumer = t-&gt;&#123;</span><br><span class="line">    System.out.println(t);</span><br><span class="line">&#125;;</span><br><span class="line">consumer.accept(<span class="string">&quot;javaXXXX&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//T get(); 供给型接口，无参数，有返回值</span></span><br><span class="line">Supplier&lt;String&gt; supplier =()-&gt;&#123;<span class="keyword">return</span> UUID.randomUUID().toString();&#125;;</span><br><span class="line">System.out.println(supplier.get());</span><br></pre></td></tr></table></figure>



<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stream 自己不会存储元素</span><br><span class="line"></span><br><span class="line">Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</span><br><span class="line"></span><br><span class="line">Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</span><br></pre></td></tr></table></figure>



<h3 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建一个Stream：一个数据源（数组、集合）</span><br><span class="line"></span><br><span class="line">中间操作：一个中间操作，处理数据源数据</span><br><span class="line"></span><br><span class="line">终止操作：一个终止操作，执行中间操作链，产生结果</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String  userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>     age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-02-26 22:24</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 题目：请按照给出数据，找出同时满足</span></span><br><span class="line"><span class="comment"> *      偶数ID且年龄大于24且用户名转为大写且用户名字母倒排序</span></span><br><span class="line"><span class="comment"> *      最后只输出一个用户名字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">11</span>,<span class="string">&quot;a&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">12</span>,<span class="string">&quot;b&quot;</span>,<span class="number">24</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">u3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">13</span>,<span class="string">&quot;c&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">u4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">14</span>,<span class="string">&quot;d&quot;</span>,<span class="number">28</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">u5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">16</span>,<span class="string">&quot;e&quot;</span>,<span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; list = Arrays.asList(u1,u2,u3,u4,u5);</span><br><span class="line"></span><br><span class="line">        list.stream().filter(p -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> p.getId() % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">        &#125;).filter(p -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> p.getAge() &gt; <span class="number">24</span>;</span><br><span class="line">        &#125;).map(f -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> f.getUserName().toUpperCase();</span><br><span class="line">        &#125;).sorted((o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">        &#125;).limit(<span class="number">1</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//    R apply(T t);</span></span><br><span class="line">        Function&lt;String,Integer&gt; function = t -&gt; &#123;<span class="keyword">return</span> t.length();&#125;;</span><br><span class="line">        System.out.println(function.apply(<span class="string">&quot;abc&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// boolean test(T t);</span></span><br><span class="line">        Predicate&lt;String&gt; predicate = t -&gt; &#123;<span class="keyword">return</span> t.startsWith(<span class="string">&quot;a&quot;</span>);&#125;;</span><br><span class="line">        System.out.println(predicate.test(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//void accept(T t);</span></span><br><span class="line">        Consumer&lt;String&gt; consumer = t -&gt; &#123;System.out.println(t);&#125;;</span><br><span class="line">        consumer.accept(<span class="string">&quot;java1018&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//    T get();</span></span><br><span class="line">        Supplier&lt;String&gt; supplier =  () -&gt; &#123;<span class="keyword">return</span> UUID.randomUUID().toString();&#125;;</span><br><span class="line">        System.out.println(supplier.get());;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="12、分支合并框架"><a href="#12、分支合并框架" class="headerlink" title="12、分支合并框架"></a>12、分支合并框架</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Fork：把一个复杂任务进行分拆，大事化小<br>Join：把分拆任务的结果进行合并<br><img src="https://img-blog.csdnimg.cn/20210411153253495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210411153253637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">ADJUST_VALUE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> begin;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> end;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.begin = begin;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>((end - begin)&lt;=ADJUST_VALUE)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>begin;i &lt;= end;i++)&#123;</span><br><span class="line">                result = result + i;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (begin + end)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">MyTask</span> <span class="variable">task01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(begin,middle);</span><br><span class="line">            <span class="type">MyTask</span> <span class="variable">task02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(middle+<span class="number">1</span>,end);</span><br><span class="line">            task01.fork();</span><br><span class="line">            task02.fork();</span><br><span class="line">            result =  task01.join() + task02.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分支合并例子</span></span><br><span class="line"><span class="comment"> * ForkJoinPool</span></span><br><span class="line"><span class="comment"> * ForkJoinTask</span></span><br><span class="line"><span class="comment"> * RecursiveTask</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">MyTask</span> <span class="variable">myTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        ForkJoinTask&lt;Integer&gt; forkJoinTask = forkJoinPool.submit(myTask);</span><br><span class="line"></span><br><span class="line">        System.out.println(forkJoinTask.get());</span><br><span class="line"></span><br><span class="line">        forkJoinPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="13、异步回调"><a href="#13、异步回调" class="headerlink" title="13、异步回调"></a>13、异步回调</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;没有返回,update mysql ok&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        completableFuture.get();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integerCompletableFuture</span> <span class="operator">=</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;有返回,insert mysql ok&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">        &#125;).whenComplete((t,u)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;****t:&quot;</span>+t);</span><br><span class="line">            System.out.println(<span class="string">&quot;****u:&quot;</span>+u);</span><br><span class="line">        &#125;).exceptionally(f-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;****exception:&quot;</span>+f.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">44444</span>;</span><br><span class="line">        &#125;).get();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="14、谈谈你对volatile的理解"><a href="#14、谈谈你对volatile的理解" class="headerlink" title="14、谈谈你对volatile的理解"></a>14、谈谈你对volatile的理解</h1><h3 id="1-volatile是Java虚拟机提供的轻量级的同步机制"><a href="#1-volatile是Java虚拟机提供的轻量级的同步机制" class="headerlink" title="1.volatile是Java虚拟机提供的轻量级的同步机制"></a>1.volatile是Java虚拟机提供的轻量级的同步机制</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.1保证可见性</span><br><span class="line">1.2不保证原子性</span><br><span class="line">1.3禁止指令重排</span><br></pre></td></tr></table></figure>

<h3 id="2-JMM你谈谈"><a href="#2-JMM你谈谈" class="headerlink" title="2.JMM你谈谈"></a>2.JMM你谈谈</h3><p>JMM(Java内存模型Java Memory Model,简称JMM)本身是一种抽象的概念 并不真实存在,它描述的是一组规则或规范通过规范定制了程序中各个变量(包括实例字段,静态字段和构成数组对象的元素)的访问方式.<br>JMM关于同步规定:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.线程解锁前,必须把共享变量的值刷新回主内存</span><br><span class="line">2.线程加锁前,必须读取主内存的最新值到自己的工作内存</span><br><span class="line">3.加锁解锁是同一把锁</span><br></pre></td></tr></table></figure>

<p>由于JVM运行程序的实体是线程,而每个线程创建时JVM都会为其创建一个工作内存(有些地方成为栈空间),工作内存是每个线程的私有数据区域,而Java内存模型中规定所有变量都存储在主内存,主内存是共享内存区域,所有线程都可访问,但线程对变量的操作(读取赋值等)必须在工作内存中进行,首先要将变量从主内存拷贝到自己的工作空间,然后对变量进行操作,操作完成再将变量写回主内存,不能直接操作主内存中的变量,各个线程中的工作内存储存着主内存中的变量副本拷贝,因此不同的线程无法访问对方的工作内存,此案成间的通讯(传值) 必须通过主内存来完成,其简要访问过程如下图:</p>
<p><img src="https://img-blog.csdnimg.cn/20210411153317652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="2-1可见性"><a href="#2-1可见性" class="headerlink" title="2.1可见性"></a>2.1可见性</h4><p>通过前面对JMM的介绍,我们知道各个线程对主内存中共享变量的操作都是各个线程各自拷贝到自己的工作内存操作后再写回主内存中的.这就可能存在一个线程AAA修改了共享变量X的值还未写回主内存中时 ,另外一个线程BBB又对内存中的一个共享变量X进行操作,但此时A线程工作内存中的共享比那里X对线程B来说并不不可见.这种工作内存与主内存同步延迟现象就造成了可见性问题.</p>
<h4 id="2-2原子性"><a href="#2-2原子性" class="headerlink" title="2.2原子性"></a>2.2原子性</h4><p>number++在多线程下是非线程安全的,如何不加synchronized解决?</p>
<p><img src="https://img-blog.csdnimg.cn/20210411153333433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="2-3VolatileDemo代码演示可见性-原子性代码"><a href="#2-3VolatileDemo代码演示可见性-原子性代码" class="headerlink" title="2.3VolatileDemo代码演示可见性+原子性代码"></a>2.3VolatileDemo代码演示可见性+原子性代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span> &#123;</span><br><span class="line"><span class="comment">//    int num = 0;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addToSixty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num = <span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">addSelf</span><span class="params">()</span>&#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">atomicAddSelf</span><span class="params">()</span>&#123;</span><br><span class="line">        atomicInteger.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1验证volatile的可见性</span></span><br><span class="line"><span class="comment"> *  1.1 如果int num = 0，number变量没有添加volatile关键字修饰</span></span><br><span class="line"><span class="comment"> * 1.2 添加了volatile，可以解决可见性</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2.验证volatile不保证原子性</span></span><br><span class="line"><span class="comment"> *  2.1 原子性指的是什么</span></span><br><span class="line"><span class="comment"> *      不可分割、完整性，即某个线程正在做某个具体业务时，中间不可以被加塞或者被分割，需要整体完整，要么同时成功，要么同时失败</span></span><br><span class="line"><span class="comment"> *  2.2 如何解决原子性</span></span><br><span class="line"><span class="comment"> *      2.2.1 方法加synchronized</span></span><br><span class="line"><span class="comment"> *      2.2.2 Atomic</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        visibilityByVolatile();//验证volatile的可见性</span></span><br><span class="line">        atomicByVolatile();<span class="comment">//验证volatile不保证原子性</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * volatile可以保证可见性，及时通知其他线程，主物理内存的值已经被修改</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">visibilityByVolatile</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MyData</span> <span class="variable">myData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyData</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t come in&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//线程暂停3s</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                myData.addToSixty();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t update value:&quot;</span> + myData.num);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line">        <span class="comment">//第二个线程是main线程</span></span><br><span class="line">        <span class="keyword">while</span> (myData.num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果myData的num一直为零，main线程一直在这里循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t mission is over, num value is &quot;</span> + myData.num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * volatile不保证原子性</span></span><br><span class="line"><span class="comment">     * 以及使用Atomic保证原子性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">atomicByVolatile</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MyData</span> <span class="variable">myData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyData</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">1000</span>; j++)&#123;</span><br><span class="line">                    myData.addSelf();</span><br><span class="line">                  myData.atomicAddSelf();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">&quot;Thread &quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等待上面的线程都计算完成后，再用main线程取得最终结果值</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t finally num value is &quot;</span>+myData.num);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t finally atomicnum value is &quot;</span>+myData.atomicInteger);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-4有序性"><a href="#2-4有序性" class="headerlink" title="2.4有序性"></a>2.4有序性</h4><p>计算机在执行程序时,为了提高性能,编译器和处理器常常会做指令重排,一把分为以下3中</p>
<p><img src="https://img-blog.csdnimg.cn/20210411153347906.png#pic_center" alt="在这里插入图片描述"></p>
<p>单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致.<br>处理器在进行重新排序是必须要考虑指令之间的数据依赖性</p>
<p>多线程环境中线程交替执行,由于编译器优化重排的存在,两个线程使用的变量能否保持一致性是无法确定的,结果无法预测<br><img src="https://img-blog.csdnimg.cn/20210411153401999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411153402272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="3-你在哪些地方用到过volatile"><a href="#3-你在哪些地方用到过volatile" class="headerlink" title="3.你在哪些地方用到过volatile?"></a>3.你在哪些地方用到过volatile?</h3><h4 id="3-1-单例模式DCL代码"><a href="#3-1-单例模式DCL代码" class="headerlink" title="3.1 单例模式DCL代码"></a>3.1 单例模式DCL代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonDemo instance=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonDemo</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双重检测机制</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonDemo.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">                    instance=<span class="keyword">new</span> <span class="title class_">SingletonDemo</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">                SingletonDemo.getInstance();</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-2代理模式volatile分析"><a href="#3-2代理模式volatile分析" class="headerlink" title="3.2代理模式volatile分析"></a>3.2代理模式volatile分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DCL(双端检锁) 机制不一定线程安全,原因是有指令重排的存在,加入<span class="keyword">volatile</span>可以禁止指令重排</span><br><span class="line">  原因在于某一个线程在执行到第一次检测,读取到的instance不为<span class="literal">null</span>时,instance的引用对象可能没有完成初始化.</span><br><span class="line">instance=<span class="keyword">new</span> <span class="title class_">SingletonDem</span>(); 可以分为以下步骤(伪代码)</span><br><span class="line"> </span><br><span class="line">memory=allocate();<span class="comment">//1.分配对象内存空间</span></span><br><span class="line">instance(memory);<span class="comment">//2.初始化对象</span></span><br><span class="line">instance=memory;<span class="comment">//3.设置instance的指向刚分配的内存地址,此时instance!=null </span></span><br><span class="line"> </span><br><span class="line">步骤<span class="number">2</span>和步骤<span class="number">3</span>不存在数据依赖关系.而且无论重排前还是重排后程序执行的结果在单线程中并没有改变,因此这种重排优化是允许的.</span><br><span class="line">memory=allocate();<span class="comment">//1.分配对象内存空间</span></span><br><span class="line">instance=memory;<span class="comment">//3.设置instance的指向刚分配的内存地址,此时instance!=null 但对象还没有初始化完.</span></span><br><span class="line">instance(memory);<span class="comment">//2.初始化对象</span></span><br><span class="line">但是指令重排只会保证串行语义的执行一致性(单线程) 并不会关心多线程间的语义一致性</span><br><span class="line">所以当一条线程访问instance不为<span class="literal">null</span>时,由于instance实例未必完成初始化,也就造成了线程安全问题.</span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<h1 id="15、CAS你知道吗"><a href="#15、CAS你知道吗" class="headerlink" title="15、CAS你知道吗"></a>15、CAS你知道吗</h1><h3 id="1-比较并交换"><a href="#1-比较并交换" class="headerlink" title="1.比较并交换"></a>1.比较并交换</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> veliger@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-12 9:57</span></span><br><span class="line"><span class="comment"> * 1.什么是CAS ? ===&gt; compareAndSet</span></span><br><span class="line"><span class="comment"> *  比较并交换</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CASDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">5</span>);</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">2019</span>)+<span class="string">&quot;\t current&quot;</span>+atomicInteger.get());</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">2014</span>)+<span class="string">&quot;\t current&quot;</span>+atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-CAS底层原理-如果知道-谈谈你对UnSafe的理解"><a href="#2-CAS底层原理-如果知道-谈谈你对UnSafe的理解" class="headerlink" title="2.CAS底层原理?如果知道,谈谈你对UnSafe的理解"></a>2.CAS底层原理?如果知道,谈谈你对UnSafe的理解</h3><h4 id="atomicInteger-getAndIncrement"><a href="#atomicInteger-getAndIncrement" class="headerlink" title="atomicInteger.getAndIncrement();"></a>atomicInteger.getAndIncrement();</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">atomicInteger.getAndIncrement()方法的源代码:</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">印出来一个问题:UnSafe类是什么?</span><br></pre></td></tr></table></figure>



<h4 id="UnSafe"><a href="#UnSafe" class="headerlink" title="UnSafe"></a>UnSafe</h4><p><img src="https://img-blog.csdnimg.cn/20210411153424753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>1.UnSafe<br> 是CAS的核心类 由于Java 方法无法直接访问底层 ,需要通过本地(native)方法来访问,UnSafe相当于一个后面,基于该类可以直接操作特额定的内存数据.UnSafe类在于sun.misc包中,其内部方法操作可以向C的指针一样直接操作内存,因为Java中CAS操作的助兴依赖于UNSafe类的方法.<br>注意UnSafe类中所有的方法都是native修饰的,也就是说UnSafe类中的方法都是直接调用操作底层资源执行响应的任务<br> 2.变量ValueOffset,便是该变量在内存中的偏移地址,因为UnSafe就是根据内存偏移地址获取数据的</p>
<p><img src="https://img-blog.csdnimg.cn/20210411153436704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p> 3.变量value和volatile修饰,保证了多线程之间的可见性.</p>
<h4 id="CAS是什么"><a href="#CAS是什么" class="headerlink" title="CAS是什么"></a>CAS是什么</h4><p>CAS的全称为Compare-And-Swap ,它是一条CPU并发原语.<br>它的功能是判断内存某个位置的值是否为预期值,如果是则更新为新的值,这个过程是原子的.</p>
<p>CAS并发原语提现在Java语言中就是sun.miscUnSaffe类中的各个方法.调用UnSafe类中的CAS方法,JVM会帮我实现CAS汇编指令.这是一种完全依赖于硬件 功能,通过它实现了原子操作,再次强调,由于CAS是一种系统原语,原语属于操作系统用于范畴,是由若干条指令组成,用于完成某个功能的一个过程,并且原语的执行必须是连续的,在执行过程中不允许中断,也即是说CAS是一条原子指令,不会造成所谓的数据不一致的问题.</p>
<p><img src="https://img-blog.csdnimg.cn/20210411153507266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210411153507305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210411153507296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="unSafe-getAndIncrement"><a href="#unSafe-getAndIncrement" class="headerlink" title="unSafe.getAndIncrement"></a>unSafe.getAndIncrement</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var1 AtomicInteger对象本身.</span><br><span class="line">var2 该对象值的引用地址</span><br><span class="line">var4 需要变动的数值</span><br><span class="line">var5 是用过var1 var2找出内存中绅士的值</span><br><span class="line">用该对象当前的值与var5比较</span><br><span class="line">如果相同,更新var5的值并且返回true</span><br><span class="line">如果不同,继续取值然后比较,直到更新完成</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210411153534544.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  假设线程A和线程B两个线程同时执行getAndAddInt操作(分别在不同的CPU上):</span><br><span class="line"></span><br><span class="line">1.AtomicInteger里面的value原始值为3,即主内存中AtomicInteger的value为3,根据JMM模型,线程A和线程B各自持有一份值为3的value的副本分别到各自的工作内存.</span><br><span class="line"></span><br><span class="line">2.线程A通过getIntVolatile(var1,var2) 拿到value值3,这是线程A被挂起.</span><br><span class="line"></span><br><span class="line">3.线程B也通过getIntVolatile(var1,var2) 拿到value值3,此时刚好线程B没有被挂起并执行compareAndSwapInt方法比较内存中的值也是3 成功修改内存的值为4 线程B打完收工 一切OK.</span><br><span class="line"></span><br><span class="line"> 4.这是线程A恢复,执行compareAndSwapInt方法比较,发现自己手里的数值和内存中的数字4不一致,说明该值已经被其他线程抢先一步修改了,那A线程修改失败,只能重新来一遍了.</span><br><span class="line"></span><br><span class="line"> 5.线程A重新获取value值,因为变量value是volatile修饰,所以其他线程对他的修改,线程A总是能够看到,线程A继续执行compareAndSwapInt方法进行比较替换,直到成功.</span><br></pre></td></tr></table></figure>



<h5 id="底层汇编"><a href="#底层汇编" class="headerlink" title="底层汇编"></a>底层汇编</h5><p><img src="https://img-blog.csdnimg.cn/20210411153546489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="简单版小总结"><a href="#简单版小总结" class="headerlink" title="简单版小总结"></a>简单版小总结</h5><p><img src="https://img-blog.csdnimg.cn/20210411153600476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="3-CAS缺点"><a href="#3-CAS缺点" class="headerlink" title="3.CAS缺点"></a>3.CAS缺点</h3><h5 id="循环时间长开销很大"><a href="#循环时间长开销很大" class="headerlink" title="循环时间长开销很大"></a>循环时间长开销很大</h5><p><img src="https://img-blog.csdnimg.cn/20210411153615898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="只能保证一个共享变量的原子性"><a href="#只能保证一个共享变量的原子性" class="headerlink" title="只能保证一个共享变量的原子性"></a>只能保证一个共享变量的原子性</h5><p><img src="https://img-blog.csdnimg.cn/20210411153627352.png#pic_center" alt="在这里插入图片描述"></p>
<h5 id="引出来ABA问题"><a href="#引出来ABA问题" class="headerlink" title="引出来ABA问题???"></a>引出来ABA问题???</h5><p>往下看。。。。。。。。</p>
<h1 id="16、原子类AtomicInteger的ABA问题谈谈-原子更新引用知道吗"><a href="#16、原子类AtomicInteger的ABA问题谈谈-原子更新引用知道吗" class="headerlink" title="16、原子类AtomicInteger的ABA问题谈谈?原子更新引用知道吗"></a>16、原子类AtomicInteger的ABA问题谈谈?原子更新引用知道吗</h1><h3 id="ABA问题的产生"><a href="#ABA问题的产生" class="headerlink" title="ABA问题的产生"></a>ABA问题的产生</h3><p><img src="https://img-blog.csdnimg.cn/20210411153644240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> veliger@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-12 21:23</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Getter</span><span class="meta">@Setter</span><span class="meta">@AllArgsConstructor</span><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicReferenceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">zs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zs&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">ls</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;ls&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        AtomicReference&lt;User&gt; userAtomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">        userAtomicReference.set(zs);</span><br><span class="line">        System.out.println(userAtomicReference.compareAndSet(zs, ls)+<span class="string">&quot;\t&quot;</span>+userAtomicReference.get().toString());</span><br><span class="line">        System.out.println(userAtomicReference.compareAndSet(zs, ls)+<span class="string">&quot;\t&quot;</span>+userAtomicReference.get().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="时间戳原子引用"><a href="#时间戳原子引用" class="headerlink" title="时间戳原子引用"></a>时间戳原子引用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: ABA问题的解决</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> veliger@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-12 21:30</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ABADemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference=<span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; stampedReference=<span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===以下是ABA问题的产生===&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">100</span>,<span class="number">101</span>);</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">101</span>,<span class="number">100</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//先暂停1秒 保证完成ABA</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            System.out.println(atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>)+<span class="string">&quot;\t&quot;</span>+atomicReference.get());</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">2</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;===以下是ABA问题的解决===&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 第1次版本号&quot;</span>+stamp+<span class="string">&quot;\t值是&quot;</span>+stampedReference.getReference());</span><br><span class="line">            <span class="comment">//暂停1秒钟t3线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">            stampedReference.compareAndSet(<span class="number">100</span>,<span class="number">101</span>,stampedReference.getStamp(),stampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 第2次版本号&quot;</span>+stampedReference.getStamp()+<span class="string">&quot;\t值是&quot;</span>+stampedReference.getReference());</span><br><span class="line">            stampedReference.compareAndSet(<span class="number">101</span>,<span class="number">100</span>,stampedReference.getStamp(),stampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 第3次版本号&quot;</span>+stampedReference.getStamp()+<span class="string">&quot;\t值是&quot;</span>+stampedReference.getReference());</span><br><span class="line">        &#125;,<span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 第1次版本号&quot;</span>+stamp+<span class="string">&quot;\t值是&quot;</span>+stampedReference.getReference());</span><br><span class="line">            <span class="comment">//保证线程3完成1次ABA</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> stampedReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 修改成功否&quot;</span>+result+<span class="string">&quot;\t最新版本号&quot;</span>+stampedReference.getStamp());</span><br><span class="line">            System.out.println(<span class="string">&quot;最新的值\t&quot;</span>+stampedReference.getReference());</span><br><span class="line">        &#125;,<span class="string">&quot;t4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="17、公平锁-x2F-非公平锁-x2F-可重入锁-x2F-递归锁-x2F-自旋锁谈谈你的理解-请手写一个自旋锁"><a href="#17、公平锁-x2F-非公平锁-x2F-可重入锁-x2F-递归锁-x2F-自旋锁谈谈你的理解-请手写一个自旋锁" class="headerlink" title="17、公平锁&#x2F;非公平锁&#x2F;可重入锁&#x2F;递归锁&#x2F;自旋锁谈谈你的理解?请手写一个自旋锁"></a>17、公平锁&#x2F;非公平锁&#x2F;可重入锁&#x2F;递归锁&#x2F;自旋锁谈谈你的理解?请手写一个自旋锁</h1><h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><h5 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">公平锁</span><br><span class="line">    是指多个线程按照申请锁的顺序来获取锁类似排队打饭 先来后到</span><br><span class="line">非公平锁</span><br><span class="line">    是指在多线程获取锁的顺序并不是按照申请锁的顺序,有可能后申请的线程比先申请的线程优先获取到锁,在高并发的情况下,有可能造成优先级反转或者饥饿现象</span><br></pre></td></tr></table></figure>

<h5 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h5><p>公平锁&#x2F;非公平锁<br>  并发包ReentrantLock的创建可以指定构造函数的boolean类型来得到公平锁或者非公平锁 默认是非公平锁</p>
<p><img src="https://img-blog.csdnimg.cn/20210411153659409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="可重入锁-又名递归锁"><a href="#可重入锁-又名递归锁" class="headerlink" title="可重入锁(又名递归锁)"></a>可重入锁(又名递归锁)</h3><p><img src="https://img-blog.csdnimg.cn/20210411153711810.png#pic_center" alt="在这里插入图片描述"></p>
<h5 id="ReentrantLock-x2F-synchronized就是一个典型的可重入锁"><a href="#ReentrantLock-x2F-synchronized就是一个典型的可重入锁" class="headerlink" title="ReentrantLock&#x2F;synchronized就是一个典型的可重入锁"></a>ReentrantLock&#x2F;synchronized就是一个典型的可重入锁</h5><p>可重入锁最大的作用就是避免死锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSms</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\tsendSms&quot;</span>);</span><br><span class="line">        sendEmail();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\tsendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *  可重入锁(也叫做递归锁)</span></span><br><span class="line"><span class="comment"> *  指的是同一先生外层函数获得锁后,内层敌对函数任然能获取该锁的代码</span></span><br><span class="line"><span class="comment"> *  在同一线程外外层方法获取锁的时候,在进入内层方法会自动获取锁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  也就是说,线程可以进入任何一个它已经标记的锁所同步的代码块</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> veliger@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-12 23:36</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReenterLockDemo</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * t1 sendSms</span></span><br><span class="line"><span class="comment">     * t1 sendEmail</span></span><br><span class="line"><span class="comment">     * t2 sendSms</span></span><br><span class="line"><span class="comment">     * t2 sendEmail</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendSms();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendSms();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="自旋锁-1"><a href="#自旋锁-1" class="headerlink" title="自旋锁"></a>自旋锁</h3><p><img src="https://img-blog.csdnimg.cn/20210411153725494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> JUC.CAS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 题目：</span></span><br><span class="line"><span class="comment">*   实现一个自旋锁</span></span><br><span class="line"><span class="comment">*   自旋锁的好处：循环比较直到成功为止，没有类似wait的阻塞</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   通过CAS操作完成自旋锁，A线程先进来调用mylock方法自己持有锁5秒，B随后进来发现当前</span></span><br><span class="line"><span class="comment">*   有线程持有锁，不是null,所有只能通过自旋等待，所以只能通过自旋等待，直到A释放锁后B随后抢到</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原子引用线程</span></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference=<span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myLock</span><span class="params">()</span>&#123;</span><br><span class="line">        Thread thread=Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t come in&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="literal">null</span>,thread))&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myUnlock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        atomicReference.compareAndSet(thread,<span class="literal">null</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t invoked myUnLock()&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">SpinLockDemo</span> <span class="variable">spinLockDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpinLockDemo</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            spinLockDemo.myLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            spinLockDemo.myUnlock();</span><br><span class="line">        &#125;,<span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            spinLockDemo.myLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            spinLockDemo.myUnlock();</span><br><span class="line">        &#125;,<span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="独占锁-写-x2F-共享锁-读-x2F-互斥锁"><a href="#独占锁-写-x2F-共享锁-读-x2F-互斥锁" class="headerlink" title="独占锁(写)&#x2F;共享锁(读)&#x2F;互斥锁"></a>独占锁(写)&#x2F;共享锁(读)&#x2F;互斥锁</h3><p><img src="https://img-blog.csdnimg.cn/20210411153739624.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCaChe</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保证可见性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">reentrantReadWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        reentrantReadWriteLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t正在写入&quot;</span> + key);</span><br><span class="line">            <span class="comment">//模拟网络延时</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t正在完成&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            reentrantReadWriteLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        reentrantReadWriteLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t正在读取&quot;</span>);</span><br><span class="line">            <span class="comment">//模拟网络延时</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t正在完成&quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            reentrantReadWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearCaChe</span><span class="params">()</span> &#123;</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * 多个线程同时操作 一个资源类没有任何问题 所以为了满足并发量</span></span><br><span class="line"><span class="comment"> * 读取共享资源应该可以同时进行</span></span><br><span class="line"><span class="comment"> * 但是</span></span><br><span class="line"><span class="comment"> * 如果有一个线程想去写共享资源来  就不应该有其他线程可以对资源进行读或写</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 小总结:</span></span><br><span class="line"><span class="comment"> * 读 读能共存</span></span><br><span class="line"><span class="comment"> * 读 写不能共存</span></span><br><span class="line"><span class="comment"> * 写 写不能共存</span></span><br><span class="line"><span class="comment"> * 写操作 原子+独占 整个过程必须是一个完成的统一整体 中间不允许被分割 被打断</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> veliger@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-13 0:45</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyCaChe</span> <span class="variable">myCaChe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCaChe</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                myCaChe.put(temp + <span class="string">&quot;&quot;</span>, temp);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                myCaChe.get(finalI + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="18、JUC强大的辅助类讲解"><a href="#18、JUC强大的辅助类讲解" class="headerlink" title="18、JUC强大的辅助类讲解"></a>18、JUC强大的辅助类讲解</h1><h3 id="CountDownLatch减少计数"><a href="#CountDownLatch减少计数" class="headerlink" title="CountDownLatch减少计数"></a>CountDownLatch减少计数</h3><ul>
<li>CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。</li>
<li>其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)，</li>
<li>当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> *  *让一些线程阻塞直到另一些线程完成一系列操作后才被唤醒。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。</span></span><br><span class="line"><span class="comment"> * 其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)，</span></span><br><span class="line"><span class="comment"> * 当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 解释：6个同学陆续离开教室后值班同学才可以关门。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * main主线程必须要等前面6个线程完成全部工作后，自己才能开干 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line">   &#123;</span><br><span class="line">         <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">6</span>);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">6</span>; i++) <span class="comment">//6个上自习的同学，各自离开教室的时间不一致</span></span><br><span class="line">       &#123;</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">              System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 号同学离开教室&quot;</span>);</span><br><span class="line">              countDownLatch.countDown();</span><br><span class="line">          &#125;, String.valueOf(i)).start();</span><br><span class="line">       &#125;</span><br><span class="line">       countDownLatch.await();</span><br><span class="line">       System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t****** 班长关门走人，main线程是班长&quot;</span>);</span><br><span class="line">          </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="CyclicBarrier循环栅栏"><a href="#CyclicBarrier循环栅栏" class="headerlink" title="CyclicBarrier循环栅栏"></a>CyclicBarrier循环栅栏</h3><ul>
<li>CyclicBarrier的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。线程进入屏障通过CyclicBarrier的await()方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CyclicBarrier</span></span><br><span class="line"><span class="comment"> * 的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，</span></span><br><span class="line"><span class="comment"> * 让一组线程到达一个屏障（也可以叫同步点）时被阻塞，</span></span><br><span class="line"><span class="comment"> * 直到最后一个线程到达屏障时，屏障才会开门，所有</span></span><br><span class="line"><span class="comment"> * 被屏障拦截的线程才会继续干活。</span></span><br><span class="line"><span class="comment"> * 线程进入屏障通过CyclicBarrier的await()方法。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 集齐7颗龙珠就可以召唤神龙</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUMBER</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">  &#123;</span><br><span class="line">     <span class="comment">//CyclicBarrier(int parties, Runnable barrierAction) </span></span><br><span class="line">     </span><br><span class="line">     <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(NUMBER, ()-&gt;&#123;System.out.println(<span class="string">&quot;*****集齐7颗龙珠就可以召唤神龙&quot;</span>);&#125;) ;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 星龙珠被收集 &quot;</span>);</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">       </span><br><span class="line">       &#125;, String.valueOf(i)).start();</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Semaphore信号量"><a href="#Semaphore信号量" class="headerlink" title="Semaphore信号量"></a>Semaphore信号量</h3><p> 在信号量上我们定义两种操作：</p>
<ul>
<li>acquire（获取） 当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），要么一直等下去，直到有线程释放信号量，或超时。</li>
<li>release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。</li>
<li>信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO(这里用一句话描述这个类的作用)  </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 在信号量上我们定义两种操作：</span></span><br><span class="line"><span class="comment"> * acquire（获取） 当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），</span></span><br><span class="line"><span class="comment"> *             要么一直等下去，直到有线程释放信号量，或超时。</span></span><br><span class="line"><span class="comment"> * release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">  &#123;</span><br><span class="line">     <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);<span class="comment">//模拟3个停车位</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">6</span>; i++) <span class="comment">//模拟6部汽车</span></span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> </span><br><span class="line">          &#123;</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 抢到了车位&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">5</span>));</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t------- 离开&quot;</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;, String.valueOf(i)).start();</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="19、死锁编码及定位分析"><a href="#19、死锁编码及定位分析" class="headerlink" title="19、死锁编码及定位分析"></a>19、死锁编码及定位分析</h1><p><img src="https://img-blog.csdnimg.cn/2021041115375350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//产生死锁代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HoldThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lockA;</span><br><span class="line">    <span class="keyword">private</span> String lockB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HoldThread</span><span class="params">(String lockA, String lockB)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lockA = lockA;</span><br><span class="line">        <span class="built_in">this</span>.lockB = lockB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 自己持有锁&quot;</span> + lockA + <span class="string">&quot;尝试获得&quot;</span> + lockB);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 自己持有锁&quot;</span> + lockB + <span class="string">&quot;尝试获得&quot;</span> + lockA);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * 死锁是指两个或者以上的进程在执行过程中,</span></span><br><span class="line"><span class="comment"> * 因争夺资源而造成的一种相互等待的现象,</span></span><br><span class="line"><span class="comment"> * 若无外力干涉那他们都将无法推进下去</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> veliger@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-14 0:05</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="string">&quot;lockA&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="string">&quot;lockB&quot;</span>;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">HoldThread</span>(lockA, lockB), <span class="string">&quot;threadAAA&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">HoldThread</span>(lockB, lockA), <span class="string">&quot;threadBBB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><h5 id="jps命令定位进程编号"><a href="#jps命令定位进程编号" class="headerlink" title="jps命令定位进程编号"></a>jps命令定位进程编号</h5><p><img src="https://img-blog.csdnimg.cn/20210411153807155.png#pic_center" alt="在这里插入图片描述"></p>
<h5 id="jstack找到死锁查看"><a href="#jstack找到死锁查看" class="headerlink" title="jstack找到死锁查看"></a>jstack找到死锁查看</h5><p><img src="https://img-blog.csdnimg.cn/20210411153820912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h1 id="20、同步器-AQS"><a href="#20、同步器-AQS" class="headerlink" title="20、同步器 AQS"></a>20、同步器 AQS</h1><p>AQS 的全称为：AbstractQueuedSynchronizer，这个类在 java.util.concurrent.locks 包下面。AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如：我们提到的 ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。</p>
<h3 id="AQS-的原理是什么？"><a href="#AQS-的原理是什么？" class="headerlink" title="AQS 的原理是什么？"></a>AQS 的原理是什么？</h3><p>AQS 核心思想是：如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<p><img src="https://img-blog.csdnimg.cn/20210411153833574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLH队列：</span><br><span class="line"></span><br><span class="line">CLH(Craig, Landin, and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210411153847220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>AQS的主要思想就是维护一个单一的状态信息state，通过getState()，setState()，compareAndSetState()方法来修改其值。对于AQS来说，线程同步的关键就是对状态值state进行操作，根据操作state的方式，又分为独占锁和共享锁；在独占方式下的获取和释放资源的方法为：acquire()和release()，在共享方式下的获取和释放资源的方法为：acquireShared()和releaseShared()。</p>
<p>使用独占方式获取的资源是与具体线程绑定的，就是如果一个线程获取了资源，就会标记是这个线程获取到了，其他线程再尝试操作state时会发现当前资源不是自己持有的，就会在获取失败后阻塞，然后该线程会被包装为一个Node节点，加入到AQS阻塞队列当中，直到持有state的线程释放资源，该线程会被唤醒继续争取资源。比如独占锁ReentrantLock的实现，当一个线程获取了ReentrantLock后，在AQS内部会使用CAS操作把state状态值从0改为1，然后设置当前锁的持有者为当前线程，当该线程再次获取锁的时候发现它就是锁的持有者，则会把状态值从1改为2，也就是设置了重入次数为2，当另一个线程获取锁时发现自己并不是锁的持有者就会被放入AQS阻塞队列后挂起。</p>
<p>谈到并发，我们不得不说<code>AQS(AbstractQueuedSynchronizer)</code>，所谓的<code>AQS</code>即是抽象的队列式的同步器，内部定义了很多锁相关的方法，我们熟知的<code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code>、<code>CountDownLatch</code>、<code>Semaphore</code>等都是基于<code>AQS</code>来实现的。</p>
<p>我们先看下<code>AQS</code>相关的<code>UML</code>图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411153913582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210411154013902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="1AQS实现原理"><a href="#1AQS实现原理" class="headerlink" title="1AQS实现原理"></a>1AQS实现原理</h3><p><code>AQS</code>中 维护了一个<code>volatile int state</code>（代表共享资源）和一个<code>FIFO</code>线程等待队列（多线程争用资源被阻塞时会进入此队列）。</p>
<p>这里<code>volatile</code>能够保证多线程下的可见性，当<code>state=1</code>则代表当前对象锁已经被占有，其他线程来加锁时则会失败，加锁失败的线程会被放入一个<code>FIFO</code>的等待队列中，比列会被<code>UNSAFE.park()</code>操作挂起，等待其他获取锁的线程释放锁才能够被唤醒。</p>
<p>另外<code>state</code>的操作都是通过<code>CAS</code>来保证其并发修改的安全性。</p>
<p>具体原理我们可以用一张图来简单概括：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411154121167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><code>AQS</code> 中提供了很多关于锁的实现方法，</p>
<ul>
<li>getState()：获取锁的标志state值</li>
<li>setState()：设置锁的标志state值</li>
<li>tryAcquire(int)：独占方式获取锁。尝试获取资源，成功则返回true，失败则返回false。</li>
<li>tryRelease(int)：独占方式释放锁。尝试释放资源，成功则返回true，失败则返回false。</li>
</ul>
<p>这里还有一些方法并没有列出来，接下来我们以<code>ReentrantLock</code>作为突破点通过源码和画图的形式一步步了解<code>AQS</code>内部实现原理。</p>
<h3 id="2目录结构"><a href="#2目录结构" class="headerlink" title="2目录结构"></a>2目录结构</h3><p>文章准备模拟多线程竞争锁、释放锁的场景来进行分析<code>AQS</code>源码：</p>
<p><strong>三个线程(线程一、线程二、线程三)同时来加锁&#x2F;释放锁</strong></p>
<p><strong>目录如下：</strong></p>
<ul>
<li><strong>线程一</strong>加锁成功时<code>AQS</code>内部实现</li>
<li><strong>线程二&#x2F;三</strong>加锁失败时<code>AQS</code>中等待队列的数据模型</li>
<li><strong>线程一</strong>释放锁及<strong>线程二</strong>获取锁实现原理</li>
<li>通过线程场景来讲解<strong>公平锁</strong>具体实现原理</li>
<li>通过线程场景来讲解Condition中a<code>wait()</code>和<code>signal()</code>实现原理</li>
</ul>
<p>这里会通过画图来分析每个线程加锁、释放锁后<code>AQS</code>内部的数据结构和实现原理</p>
<h3 id="3-场景分析"><a href="#3-场景分析" class="headerlink" title="3 场景分析"></a>3 场景分析</h3><h4 id="线程一加锁成功"><a href="#线程一加锁成功" class="headerlink" title="线程一加锁成功"></a>线程一加锁成功</h4><p>如果同时有<strong>三个线程</strong>并发抢占锁，此时<strong>线程一</strong>抢占锁成功，<strong>线程二</strong>和<strong>线程三</strong>抢占锁失败，具体执行流程如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411154205505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>此时<code>AQS</code>内部数据为：</p>
<p><img src="https://img-blog.csdnimg.cn/2021041115421770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>线程二</strong>、<strong>线程三</strong>加锁失败：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411154230114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>有图可以看出，等待队列中的节点<code>Node</code>是一个双向链表，这里<code>SIGNAL</code>是<code>Node</code>中<code>waitStatus</code>属性，<code>Node</code>中还有一个<code>nextWaiter</code>属性，这个并未在图中画出来，这个到后面<code>Condition</code>会具体讲解的。</p>
<p>具体看下抢占锁代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.concurrent.locks.ReentrantLock .NonfairSync:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用的<strong>ReentrantLock非公平锁</strong>，线程进来直接利用<code>CAS</code>尝试抢占锁，如果抢占成功<code>state</code>值回被改为1，且设置对象独占锁线程为当前线程。如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setExclusiveOwnerThread</span><span class="params">(Thread thread)</span> &#123;</span><br><span class="line">    exclusiveOwnerThread = thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程二抢占锁失败"><a href="#线程二抢占锁失败" class="headerlink" title="线程二抢占锁失败"></a>线程二抢占锁失败</h4><p>我们按照真实场景来分析，<strong>线程一</strong>抢占锁成功后，<code>state</code>变为1，<strong>线程二</strong>通过<code>CAS</code>修改<code>state</code>变量必然会失败。此时<code>AQS</code>中<code>FIFO</code>(First In First Out 先进先出)队列中数据如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411154245489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>我们将<strong>线程二</strong>执行的逻辑一步步拆解来看：</p>
<p><code>java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看看<code>tryAcquire()</code>的具体实现：<code>java.util.concurrent.locks.ReentrantLock .nonfairTryAcquire()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>nonfairTryAcquire()</code>方法中首先会获取<code>state</code>的值，如果不为0则说明当前对象的锁已经被其他线程所占有，接着判断占有锁的线程是否为当前线程，如果是则累加<code>state</code>值，这就是可重入锁的具体实现，累加<code>state</code>值，释放锁的时候也要依次递减<code>state</code>值。</p>
<p>如果<code>state</code>为0，则执行<code>CAS</code>操作，尝试更新<code>state</code>值为1，如果更新成功则代表当前线程加锁成功。</p>
<p>以<strong>线程二</strong>为例，因为<strong>线程一</strong>已经将<code>state</code>修改为1，所以<strong>线程二</strong>通过<code>CAS</code>修改<code>state</code>的值不会成功。加锁失败。</p>
<p><strong>线程二</strong>执行<code>tryAcquire()</code>后会返回false，接着执行<code>addWaiter(Node.EXCLUSIVE)</code>逻辑，将自己加入到一个<code>FIFO</code>等待队列中，代码实现如下：</p>
<p><code>java.util.concurrent.locks.AbstractQueuedSynchronizer.addWaiter()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;    </span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码首先会创建一个和当前线程绑定的<code>Node</code>节点，<code>Node</code>为双向链表。此时等待队列中的<code>tail</code>指针为空，直接调用<code>enq(node)</code>方法将当前线程加入等待队列尾部：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一遍循环时<code>tail</code>指针为空，进入if逻辑，使用<code>CAS</code>操作设置<code>head</code>指针，将<code>head</code>指向一个新创建的<code>Node</code>节点。此时<code>AQS</code>中数据：<br><img src="https://img-blog.csdnimg.cn/20210411154257128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>执行完成之后，<code>head</code>、<code>tail</code>、<code>t</code>都指向第一个<code>Node</code>元素。</p>
<p>接着执行第二遍循环，进入<code>else</code>逻辑，此时已经有了<code>head</code>节点，这里要操作的就是将<strong>线程二</strong>对应的<code>Node</code>节点挂到<code>head</code>节点后面。此时队列中就有了两个<code>Node</code>节点：</p>
<p><img src="https://img-blog.csdnimg.cn/2021041115435024.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><code>addWaiter()</code>方法执行完后，会返回当前线程创建的节点信息。继续往后执行<code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code>逻辑，此时传入的参数为<strong>线程二</strong>对应的<code>Node</code>节点信息：</p>
<p><code>java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndChecknIterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>acquireQueued()</code>这个方法会先判断当前传入的<code>Node</code>对应的前置节点是否为<code>head</code>，如果是则尝试加锁。加锁成功过则将当前节点设置为<code>head</code>节点，然后空置之前的<code>head</code>节点，方便后续被垃圾回收掉。</p>
<p>如果加锁失败或者<code>Node</code>的前置节点不是<code>head</code>节点，就会通过<code>shouldParkAfterFailedAcquire</code>方法 将<code>head</code>节点的<code>waitStatus</code>变为了<code>SIGNAL=-1</code>，最后执行<code>parkAndChecknIterrupt</code>方法，调用<code>LockSupport.park()</code>挂起当前线程。</p>
<p>此时<code>AQS</code>中的数据如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411154403597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>此时<strong>线程二</strong>就静静的待在<code>AQS</code>的等待队列里面了，等着其他线程释放锁来唤醒它。</p>
<h4 id="线程三抢占锁失败"><a href="#线程三抢占锁失败" class="headerlink" title="线程三抢占锁失败"></a>线程三抢占锁失败</h4><p>看完了<strong>线程二</strong>抢占锁失败的分析，那么再来分析<strong>线程三</strong>抢占锁失败就很简单了，先看看<code>addWaiter(Node mode)</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时等待队列的<code>tail</code>节点指向<strong>线程二</strong>，进入<code>if</code>逻辑后，通过<code>CAS</code>指令将<code>tail</code>节点重新指向<strong>线程三</strong>。接着<strong>线程三</strong>调用<code>enq()</code>方法执行入队操作，和上面<strong>线程二</strong>执行方式是一致的，入队后会修改<strong>线程二</strong>对应的<code>Node</code>中的<code>waitStatus=SIGNAL</code>。最后<strong>线程三</strong>也会被挂起。此时等待队列的数据如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411154439195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="线程一释放锁"><a href="#线程一释放锁" class="headerlink" title="线程一释放锁"></a>线程一释放锁</h4><p>现在来分析下释放锁的过程，首先是<strong>线程一</strong>释放锁，释放锁后会唤醒<code>head</code>节点的后置节点，也就是我们现在的<strong>线程二</strong>，具体操作流程如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411154452872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>执行完后等待队列数据如下：</p>
<p><img src="https://img-blog.csdnimg.cn/202104111545354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>此时<strong>线程二</strong>已经被唤醒，继续尝试获取锁，如果获取锁失败，则会继续被挂起。如果获取锁成功，则<code>AQS</code>中数据如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411154547763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>接着还是一步步拆解来看，先看看<strong>线程一</strong>释放锁的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.concurrent.locks.AbstractQueuedSynchronizer.release()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先会执行<code>tryRelease()</code>方法，这个方法具体实现在<code>ReentrantLock</code>中，如果<code>tryRelease</code>执行成功，则继续判断<code>head</code>节点的<code>waitStatus</code>是否为0，前面我们已经看到过，<code>head</code>的<code>waitStatue</code>为<code>SIGNAL(-1)</code>，这里就会执行<code>unparkSuccessor()</code>方法来唤醒<code>head</code>的后置节点，也就是我们上面图中<strong>线程二</strong>对应的<code>Node</code>节点。</p>
<p>此时看<code>ReentrantLock.tryRelease()</code>中的具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行完<code>ReentrantLock.tryRelease()</code>后，<code>state</code>被设置成0，Lock对象的独占锁被设置为null。此时看下<code>AQS</code>中的数据：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411154602113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>接着执行<code>java.util.concurrent.locks.AbstractQueuedSynchronizer.unparkSuccessor()</code>方法，唤醒<code>head</code>的后置节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要是将<code>head</code>节点的<code>waitStatus</code>设置为0，然后解除<code>head</code>节点<code>next</code>的指向，使<code>head</code>节点空置，等待着被垃圾回收。</p>
<p>此时重新将<code>head</code>指针指向<strong>线程二</strong>对应的<code>Node</code>节点，且使用<code>LockSupport.unpark</code>方法来唤醒<strong>线程二</strong>。</p>
<p>被唤醒的<strong>线程二</strong>会接着尝试获取锁，用<code>CAS</code>指令修改<code>state</code>数据。执行完成后可以查看<code>AQS</code>中数据：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a761b57430a731f5e7fb7ddb187efd68.png" alt="img"></p>
<p>此时<strong>线程二</strong>被唤醒，<strong>线程二</strong>接着之前被<code>park</code>的地方继续执行，继续执行<code>acquireQueued()</code>方法。</p>
<h4 id="线程二唤醒继续加锁"><a href="#线程二唤醒继续加锁" class="headerlink" title="线程二唤醒继续加锁"></a>线程二唤醒继续加锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时<strong>线程二</strong>被唤醒，继续执行<code>for</code>循环，判断<strong>线程二</strong>的前置节点是否为<code>head</code>，如果是则继续使用<code>tryAcquire()</code>方法来尝试获取锁，其实就是使用<code>CAS</code>操作来修改<code>state</code>值，如果修改成功则代表获取锁成功。接着将<strong>线程二</strong>设置为<code>head</code>节点，然后空置之前的<code>head</code>节点数据，被空置的节点数据等着被<strong>垃圾回收</strong>。</p>
<p>此时线程三获取锁成功，<code>AQS</code>中队列数据如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411154613612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>等待队列中的数据都等待着被垃圾回收。</p>
<h4 id="线程二释放锁-x2F-线程三加锁"><a href="#线程二释放锁-x2F-线程三加锁" class="headerlink" title="线程二释放锁&#x2F;线程三加锁"></a>线程二释放锁&#x2F;线程三加锁</h4><p>当<strong>线程二</strong>释放锁时，会唤醒被挂起的<strong>线程三</strong>，流程和上面大致相同，被唤醒的<strong>线程三</strong>会再次尝试加锁，具体代码可以参考上面内容。具体流程图如下：<br><img src="https://img-blog.csdnimg.cn/20210411154625793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>此时<code>AQS</code>中队列数据如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411154636178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="4公平锁实现原理"><a href="#4公平锁实现原理" class="headerlink" title="4公平锁实现原理"></a>4公平锁实现原理</h3><p>上面所有的加锁场景都是基于<strong>非公平锁</strong>来实现的，<strong>非公平锁</strong>是<code>ReentrantLock</code>的默认实现，那我们接着来看一下<strong>公平锁</strong>的实现原理，这里先用一张图来解释<strong>公平锁</strong>和<strong>非公平锁</strong>的区别：</p>
<p><strong>非公平锁</strong>执行流程：</p>
<p><img src="https://img-blog.csdnimg.cn/2021041115471937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>这里我们还是用之前的线程模型来举例子，当<strong>线程二</strong>释放锁的时候，唤醒被挂起的<strong>线程三</strong>，<strong>线程三</strong>执行<code>tryAcquire()</code>方法使用<code>CAS</code>操作来尝试修改<code>state</code>值，如果此时又来了一个<strong>线程四</strong>也来执行加锁操作，同样会执行<code>tryAcquire()</code>方法。</p>
<p>这种情况就会出现竞争，<strong>线程四</strong>如果获取锁成功，<strong>线程三</strong>仍然需要待在等待队列中被挂起。这就是所谓的<strong>非公平锁</strong>，<strong>线程三</strong>辛辛苦苦排队等到自己获取锁，却眼巴巴的看到<strong>线程四</strong>插队获取到了锁。</p>
<p><strong>公平锁</strong>执行流程：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411154730865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>公平锁在加锁的时候，会先判断<code>AQS</code>等待队列中是存在节点，如果存在节点则会直接入队等待，具体代码如下.</p>
<p>公平锁在获取锁是也是首先会执行<code>acquire()</code>方法，只不过公平锁单独实现了<code>tryAcquire()</code>方法：</p>
<p><code>#java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会执行<code>ReentrantLock</code>中公平锁的<code>tryAcquire()</code>方法</p>
<p><code>#java.util.concurrent.locks.ReentrantLock.FairSync.tryAcquire()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会先判断<code>state</code>值，如果不为0且获取锁的线程不是当前线程，直接返回false代表获取锁失败，被加入等待队列。如果是当前线程则可重入获取锁。</p>
<p>如果<code>state=0</code>则代表此时没有线程持有锁，执行<code>hasQueuedPredecessors()</code>判断<code>AQS</code>等待队列中是否有元素存在，如果存在其他等待线程，那么自己也会加入到等待队列尾部，做到真正的先来后到，有序加锁。具体代码如下：</p>
<p><code>#java.util.concurrent.locks.AbstractQueuedSynchronizer.hasQueuedPredecessors()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedPredecessors</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="literal">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码很有意思，返回<code>false</code>代表队列中没有节点或者仅有一个节点是当前线程创建的节点。返回<code>true</code>则代表队列中存在等待节点，当前线程需要入队等待。<br><img src="https://img-blog.csdnimg.cn/20210411154805834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>先判断<code>head</code>是否等于<code>tail</code>，如果队列中只有一个<code>Node</code>节点，那么<code>head</code>会等于<code>tail</code>，接着判断<code>head</code>的后置节点，这里肯定会是<code>null</code>，如果此<code>Node</code>节点对应的线程和当前的线程是同一个线程，那么则会返回<code>false</code>，代表没有等待节点或者等待节点就是当前线程创建的<code>Node</code>节点。此时当前线程会尝试获取锁。</p>
<p>如果<code>head</code>和<code>tail</code>不相等，说明队列中有等待线程创建的节点，此时直接返回<code>true</code>，如果只有一个节点，而此节点的线程和当前线程不一致，也会返回<code>true</code></p>
<p><strong>非公平锁</strong>和<strong>公平锁</strong>的区别：<strong>非公平锁</strong>性能高于<strong>公平锁</strong>性能。<strong>非公平锁</strong>可以减少<code>CPU</code>唤醒线程的开销，整体的吞吐效率会高点，<code>CPU</code>也不必取唤醒所有线程，会减少唤起线程的数量</p>
<p><strong>非公平锁</strong>性能虽然优于<strong>公平锁</strong>，但是会存在导致<strong>线程饥饿</strong>的情况。在最坏的情况下，可能存在某个线程<strong>一直获取不到锁</strong>。不过相比性能而言，饥饿问题可以暂时忽略，这可能就是<code>ReentrantLock</code>默认创建非公平锁的原因之一了。</p>
<h3 id="5Condition实现原理"><a href="#5Condition实现原理" class="headerlink" title="5Condition实现原理"></a>5Condition实现原理</h3><p>**Condition 简介</p>
<p>**</p>
<p>上面已经介绍了<code>AQS</code>所提供的核心功能，当然它还有很多其他的特性，这里我们来继续说下<code>Condition</code>这个组件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Condition`是在`java 1.5`中才出现的，它用来替代传统的`Object`的`wait()`、`notify()`实现线程间的协作，相比使用`Object`的`wait()`、`notify()`，使用`Condition`中的`await()`、`signal()`这种方式实现线程间协作更加安全和高效。因此通常来说比较推荐使用`Condition</span><br></pre></td></tr></table></figure>

<p>其中<code>AbstractQueueSynchronizer</code>中实现了<code>Condition</code>中的方法，主要对外提供<code>awaite(Object.wait())</code>和<code>signal(Object.notify())</code>调用。</p>
<h4 id="Condition-Demo示例"><a href="#Condition-Demo示例" class="headerlink" title="Condition Demo示例"></a>Condition Demo示例</h4><p>使用示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ReentrantLock 实现源码学习</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 一枝花算不算浪漫</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/28 7:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程一加锁成功&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程一执行await被挂起&quot;</span>);</span><br><span class="line">                condition.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程一被唤醒成功&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程一释放锁成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程二加锁成功&quot;</span>);</span><br><span class="line">                condition.signal();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程二唤醒线程一&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程二释放锁成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果如下图：<br><img src="https://img-blog.csdnimg.cn/20210411154841170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>这里<strong>线程一</strong>先获取锁，然后使用<code>await()</code>方法挂起当前线程并<strong>释放锁</strong>，<strong>线程二</strong>获取锁后使用<code>signal</code>唤醒<strong>线程一</strong>。</p>
<h4 id="Condition实现原理图解"><a href="#Condition实现原理图解" class="headerlink" title="Condition实现原理图解"></a>Condition实现原理图解</h4><p>我们还是用上面的<code>demo</code>作为实例，执行的流程如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411154852823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>线程一</strong>执行<code>await()</code>方法：</p>
<p>先看下具体的代码实现，<code>#java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject.await()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>await()</code>方法中首先调用<code>addConditionWaiter()</code>将当前线程加入到<code>Condition</code>队列中。</p>
<p>执行完后我们可以看下<code>Condition</code>队列中的数据：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411154935348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>具体实现代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addConditionWaiter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> lastWaiter;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会用当前线程创建一个<code>Node</code>节点，<code>waitStatus</code>为<code>CONDITION</code>。接着会释放该节点的锁，调用之前解析过的<code>release()</code>方法，释放锁后此时会唤醒被挂起的<strong>线程二</strong>，<strong>线程二</strong>会继续尝试获取锁。</p>
<p>接着调用<code>isOnSyncQueue()</code>方法判断当前节点是否为<code>Condition</code>队列中的头部节点，如果是则调用<code>LockSupport.park(this)</code>挂起<code>Condition</code>中当前线程。此时<strong>线程一</strong>被挂起，<strong>线程二</strong>获取锁成功。</p>
<p>具体流程如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411155011715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>线程二</strong>执行<code>signal()</code>方法：</p>
<p>首先我们考虑下<strong>线程二</strong>已经获取到锁，此时<code>AQS</code>等待队列中已经没有了数据。</p>
<p>接着就来看看<strong>线程二</strong>唤醒<strong>线程一</strong>的具体执行流程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先判断当前线程是否为获取锁的线程，如果不是则直接抛出异常。接着调用<code>doSignal()</code>方法来唤醒线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>)</span><br><span class="line">            lastWaiter = <span class="literal">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> node&#x27;s predecessor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里先从<code>transferForSignal()</code>方法来看，通过上面的分析我们知道<code>Condition</code>队列中只有线程一创建的一个<code>Node</code>节点，且<code>waitStatue</code>为<code>CONDITION</code>，先通过<code>CAS</code>修改当前节点<code>waitStatus</code>为0，然后执行<code>enq()</code>方法将当前线程加入到等待队列中，并返回当前线程的前置节点。</p>
<p>加入等待队列的代码在上面也已经分析过，此时等待队列中数据如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411155024455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>接着开始通过<code>CAS</code>修改当前节点的前置节点<code>waitStatus</code>为<code>SIGNAL</code>，并且唤醒当前线程。此时<code>AQS</code>中等待队列数据为：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411155036381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>线程一</strong>被唤醒后，继续执行<code>await()</code>方法中的 while 循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为此时线程一的<code>waitStatus</code>已经被修改为0，所以执行<code>isOnSyncQueue()</code>方法会返回<code>false</code>。跳出<code>while</code>循环。</p>
<p>接着执行<code>acquireQueued()</code>方法，这里之前也有讲过，尝试重新获取锁，如果获取锁失败继续会被挂起。直到另外线程释放锁才被唤醒。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时<strong>线程一</strong>的流程都已经分析完了，等<strong>线程二</strong>释放锁后，<strong>线程一</strong>会继续重试获取锁，流程到此终结。</p>
<h4 id="Condition总结"><a href="#Condition总结" class="headerlink" title="Condition总结"></a>Condition总结</h4><p>我们总结下 Condition 和 wait&#x2F;notify 的比较：</p>
<ul>
<li>Condition 可以精准的对多个不同条件进行控制，wait&#x2F;notify 只能和 synchronized 关键字一起使用，并且只能唤醒一个或者全部的等待队列；</li>
<li>Condition 需要使用 Lock 进行控制，使用的时候要注意 lock() 后及时的 unlock()，Condition 有类似于 await 的机制，因此不会产生加锁方式而产生的死锁出现，同时底层实现的是 park&#x2F;unpark 的机制，因此也不会产生先唤醒再挂起的死锁，一句话就是不会产生死锁，但是 wait&#x2F;notify 会产生先唤醒再挂起的死锁。</li>
</ul>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h3><p><strong>这里用了一步一图的方式结合三个线程依次加锁&#x2F;释放锁来展示了</strong><code>ReentrantLock</code><strong>的实现方式和实现原理，而</strong><code>ReentrantLock</code><strong>底层就是基于</strong><code>AQS</code><strong>实现的，所以我们也对</strong><code>AQS</code>**有了深刻的理解。</p>
<p>**</p>
<p>另外还介绍了<strong>公平锁</strong>与<strong>非公平锁</strong>的实现原理，<code>Condition</code>的实现原理，基本上都是使用<strong>源码+绘图</strong>的讲解方式，尽量让大家更容易去理解。</p>
<h1 id="21、谈谈对-ThreadLocal-的理解？"><a href="#21、谈谈对-ThreadLocal-的理解？" class="headerlink" title="21、谈谈对 ThreadLocal 的理解？"></a>21、谈谈对 ThreadLocal 的理解？</h1><p>为共享变量在每个线程中创建一个副本，每个线程可以访问自己内部的副本变量</p>
<p>内部源码：</p>
<p>里面会维护一个ThreadLocalMap对象，在ThreadLocalMap中有Entry对象,其中key指的是当前ThreadLocal实例，value指的是ThreadLocal对应的值，其中Entry继承WeakReference，将ThreadLocal对象变成弱引用对象，这样做的好处是在线程销毁的时候，对应的实体就会被回收，不会存在内存泄漏，因为弱引用对象在垃圾回收机制一运行就会被销毁。</p>
<p><img src="https://img-blog.csdnimg.cn/20210411155056982.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.get() 方法是用来获取 ThreadLocal 在当前线程中保存的变量副本；</span><br><span class="line"></span><br><span class="line">2.set() 用来设置当前线程中变量的副本；</span><br><span class="line"></span><br><span class="line">3.remove() 用来移除当前线程中变量的副本；</span><br><span class="line"></span><br><span class="line">4.initialValue() 是一个 protected 方法，一般是用来在使用时进行重写的，如果在没有 set 的时候就调用 get，会调用 initialValue 方法初始化内容。</span><br></pre></td></tr></table></figure>

<p>其中key和ThreadLocal是弱引用关系，当gc执行时就会被回收，但是value和ThreadLocal是强引用的关系，不会被回收，因此就会出现key为null，value有值的情况，会导致内存泄露，所以需要remove来移除当前线程中变量的副本来避免内存泄露的问题。</p>
<p><a href="https://www.bilibili.com/read/cv9258735">https://www.bilibili.com/read/cv9258735</a></p>
<h3 id="在哪些场景下会使用到-ThreadLocal？"><a href="#在哪些场景下会使用到-ThreadLocal？" class="headerlink" title="在哪些场景下会使用到 ThreadLocal？"></a>在哪些场景下会使用到 ThreadLocal？</h3><p>获取数据库连接，这是我们刚开始学习jdbc的用法，简单使用是没有问题的。但还是有两个问题无法解决：</p>
<p>高并发的情况下，可能多个线程同时获取到数据库连接，就会产生并发的问题。我们想到可以使用同步锁来处理，保证只有一个线程获取到数据库连接，但这样毫无疑问效率非常低。</p>
<p>如果有多条sql需要执行，需要用同一个connection对象。那就需要在多个方法中传递这个connection对象，方法传递会有点麻烦。<br>那么有没有更好的方法呢，就是本文讲到的ThreadLocal了。我们稍微修改一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectionManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span><span class="string">&quot;***&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Connection&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Connection&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">openConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connect</span> <span class="operator">=</span> threadLocal.get();</span><br><span class="line">        <span class="keyword">if</span>(connect == <span class="literal">null</span>)&#123;</span><br><span class="line">            connect = DriverManager.getConnection(url);</span><br><span class="line">            threadLocal.set(connect);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connect;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用了ThreadLocal后，由于线程访问的都是自己的Connection对象，所以就不存在高并发的问题。同时还解决了事务的问题，同一个事务里，Connection对象不需要传来传去，直接用ThreadLocal获取就可以了。<br>所以我们总结一下ThreadLocal的两点好处：</p>
<p>1.每个线程有自己的ThreadLocalMap对象，线程各自访问各自的，提供了保存对象到线程的方法。</p>
<p>2.减少了线程间传递参数的麻烦。</p>
<p>基于这样两点好处，我们在获取数据库连接，获取session，获取token信息等场景下使用ThreadLocal会很方便。</p>
]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>Java并发编程</tag>
        <tag>线程池</tag>
        <tag>线程进程</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis源码分析-内置数据源</title>
    <url>/2022/10/25/MyBatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E6%BA%90/</url>
    <content><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>本篇文章将向大家介绍 MyBatis 内置数据源的实现逻辑。搞懂这些数据源的实现，可使大家对数据源有更深入的认识。同时在配置这些数据源时，也会更清楚每种属性的意义和用途。因此，如果大家想知其然，也知其所以然。那么接下来就让我们一起去探索 MyBatis 内置数据源的源码吧。</p>
<p>MyBatis 支持三种数据源配置，分别为 UNPOOLED、POOLED 和 JNDI。并提供了两种数据源实现，分别是 UnpooledDataSource 和 PooledDataSource。在三种数据源配置中，UNPOOLED 和 POOLED 是我们最常用的两种配置。至于 JNDI，MyBatis 提供这种数据源的目的是为了让其能够运行在 EJB 或应用服务器等容器中，这一点官方文档中有所说明。由于 JNDI 数据源在日常开发中使用甚少，因此，本篇文章不打算分析 JNDI 数据源相关实现。大家若有兴趣，可自行分析。接下来，本文将重点分析 UNPOOLED 和 POOLED 两种数据源。其他的就不多说了，进入正题吧。</p>
<h2 id="2-内置数据源初始化过程"><a href="#2-内置数据源初始化过程" class="headerlink" title="2.内置数据源初始化过程"></a>2.内置数据源初始化过程</h2><p>在详细分析 UnpooledDataSource 和 PooledDataSource 两种数据源实现之前，我们先来了解一下数据源的配置与初始化过程。现在看数据源是如何配置的，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dataSource type=&quot;UNPOOLED|POOLED&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql...&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt;</span><br><span class="line">&lt;/dataSource&gt;</span><br></pre></td></tr></table></figure>

<p>数据源的配置是内嵌在 <environment> 节点中的，MyBatis 在解析 <environment> 节点时，会一并解析数据源的配置。MyBatis 会根据具体的配置信息，为不同的数据源创建相应工厂类，通过工厂类即可创建数据源实例。关于数据源配置的解析以及数据源工厂类的创建过程，我在 <a href="http://www.coolblog.xyz/2018/07/20/MyBatis-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/">MyBatis 配置文件解析过程</a>一文中分析过，这里就不赘述了。下面我们来看一下数据源工厂类的实现逻辑。</environment></environment></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UnpooledDataSourceFactory implements DataSourceFactory &#123;</span><br><span class="line">    </span><br><span class="line">    private static final String DRIVER_PROPERTY_PREFIX = &quot;driver.&quot;;</span><br><span class="line">    private static final int DRIVER_PROPERTY_PREFIX_LENGTH = DRIVER_PROPERTY_PREFIX.length();</span><br><span class="line"></span><br><span class="line">    protected DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    public UnpooledDataSourceFactory() &#123;</span><br><span class="line">        // 创建 UnpooledDataSource 对象</span><br><span class="line">        this.dataSource = new UnpooledDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setProperties(Properties properties) &#123;</span><br><span class="line">        Properties driverProperties = new Properties();</span><br><span class="line">        // 为 dataSource 创建元信息对象</span><br><span class="line">        MetaObject metaDataSource = SystemMetaObject.forObject(dataSource);</span><br><span class="line">        // 遍历 properties 键列表，properties 由配置文件解析器传入</span><br><span class="line">        for (Object key : properties.keySet()) &#123;</span><br><span class="line">            String propertyName = (String) key;</span><br><span class="line">            // 检测 propertyName 是否以 &quot;driver.&quot; 开头</span><br><span class="line">            if (propertyName.startsWith(DRIVER_PROPERTY_PREFIX)) &#123;</span><br><span class="line">                String value = properties.getProperty(propertyName);</span><br><span class="line">                // 存储配置信息到 driverProperties 中</span><br><span class="line">                driverProperties.setProperty(propertyName.substring(DRIVER_PROPERTY_PREFIX_LENGTH), value);</span><br><span class="line">            &#125; else if (metaDataSource.hasSetter(propertyName)) &#123;</span><br><span class="line">                String value = (String) properties.get(propertyName);</span><br><span class="line">                // 按需转换 value 类型</span><br><span class="line">                Object convertedValue = convertValue(metaDataSource, propertyName, value);</span><br><span class="line">                // 设置转换后的值到 UnpooledDataSourceFactory 指定属性中</span><br><span class="line">                metaDataSource.setValue(propertyName, convertedValue);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new DataSourceException(&quot;Unknown DataSource property: &quot; + propertyName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (driverProperties.size() &gt; 0) &#123;</span><br><span class="line">            // 设置 driverProperties 到 UnpooledDataSourceFactory 的 driverProperties 属性中</span><br><span class="line">            metaDataSource.setValue(&quot;driverProperties&quot;, driverProperties);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private Object convertValue(MetaObject metaDataSource, String propertyName, String value) &#123;</span><br><span class="line">        Object convertedValue = value;</span><br><span class="line">        // 获取属性对应的 setter 方法的参数类型</span><br><span class="line">        Class&lt;?&gt; targetType = metaDataSource.getSetterType(propertyName);</span><br><span class="line">        // 按照 setter 方法的参数类型进行类型转换</span><br><span class="line">        if (targetType == Integer.class || targetType == int.class) &#123;</span><br><span class="line">            convertedValue = Integer.valueOf(value);</span><br><span class="line">        &#125; else if (targetType == Long.class || targetType == long.class) &#123;</span><br><span class="line">            convertedValue = Long.valueOf(value);</span><br><span class="line">        &#125; else if (targetType == Boolean.class || targetType == boolean.class) &#123;</span><br><span class="line">            convertedValue = Boolean.valueOf(value);</span><br><span class="line">        &#125;</span><br><span class="line">        return convertedValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public DataSource getDataSource() &#123;</span><br><span class="line">        return dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是 UnpooledDataSourceFactory 的源码分析，除了 setProperties 方法稍复杂一点，其他的都比较简单，就不多说了。下面看看 PooledDataSourceFactory 的源码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PooledDataSourceFactory extends UnpooledDataSourceFactory &#123;</span><br><span class="line"></span><br><span class="line">    public PooledDataSourceFactory() &#123;</span><br><span class="line">        // 创建 PooledDataSource</span><br><span class="line">        this.dataSource = new PooledDataSource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是 PooledDataSource 类的所有源码，PooledDataSourceFactory 继承自 UnpooledDataSourceFactory，复用了父类的逻辑，因此它的实现很简单。</p>
<p>关于两种数据源的创建过程就先分析到这，接下来，我们去探究一下两种数据源是怎样实现的。</p>
<h2 id="3-UnpooledDataSource"><a href="#3-UnpooledDataSource" class="headerlink" title="3.UnpooledDataSource"></a>3.UnpooledDataSource</h2><p>UnpooledDataSource，从名称上即可知道，该种数据源不具有池化特性。该种数据源每次会返回一个新的数据库连接，而非复用旧的连接。由于 UnpooledDataSource 无需提供连接池功能，因此它的实现非常简单。核心的方法有三个，分别如下：</p>
<ol>
<li>initializeDriver - 初始化数据库驱动</li>
<li>doGetConnection - 获取数据连接</li>
<li>configureConnection - 配置数据库连接</li>
</ol>
<p>下面我将按照顺序分节对相关方法进行分析，由于 configureConnection 方法比较简单，因此我把它和 doGetConnection 放在一节中进行分析。下面先来分析 initializeDriver 方法。</p>
<h3 id="3-1-初始化数据库驱动"><a href="#3-1-初始化数据库驱动" class="headerlink" title="3.1 初始化数据库驱动"></a>3.1 初始化数据库驱动</h3><p>回顾我们一开始学习使用 JDBC 访问数据库时的情景，在执行 SQL 之前，通常都是先获取数据库连接。一般步骤都是加载数据库驱动，然后通过 DriverManager 获取数据库连接。UnpooledDataSource 也是使用 JDBC 访问数据库的，因此它获取数据库连接的过程也大致如此，只不过会稍有不同。下面我们一起来看一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- UnpooledDataSource</span><br><span class="line">private synchronized void initializeDriver() throws SQLException &#123;</span><br><span class="line">    // 检测缓存中是否包含了与 driver 对应的驱动实例</span><br><span class="line">    if (!registeredDrivers.containsKey(driver)) &#123;</span><br><span class="line">        Class&lt;?&gt; driverType;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 加载驱动类型</span><br><span class="line">            if (driverClassLoader != null) &#123;</span><br><span class="line">                // 使用 driverClassLoader 加载驱动</span><br><span class="line">                driverType = Class.forName(driver, true, driverClassLoader);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 通过其他 ClassLoader 加载驱动</span><br><span class="line">                driverType = Resources.classForName(driver);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 通过反射创建驱动实例</span><br><span class="line">            Driver driverInstance = (Driver) driverType.newInstance();</span><br><span class="line">            /*</span><br><span class="line">             * 注册驱动，注意这里是将 Driver 代理类 DriverProxy 对象注册到 DriverManager 中的，</span><br><span class="line">             * 而非 Driver 对象本身。DriverProxy 中并没什么特别的逻辑，就不分析。</span><br><span class="line">             */</span><br><span class="line">            DriverManager.registerDriver(new DriverProxy(driverInstance));</span><br><span class="line">            // 缓存驱动类名和实例</span><br><span class="line">            registeredDrivers.put(driver, driverInstance);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new SQLException(&quot;Error setting driver on UnpooledDataSource. Cause: &quot; + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，initializeDriver 方法主要包含三步操作，分别如下：</p>
<ol>
<li>加载驱动</li>
<li>通过反射创建驱动实例</li>
<li>注册驱动实例</li>
</ol>
<p>这三步都是都是常规操作，比较容易理解。上面代码中出现了缓存相关的逻辑，这个是用于避免重复注册驱动。因为 initializeDriver 放阿飞并不是在 UnpooledDataSource 初始化时被调用的，而是在获取数据库连接时被调用的。因此这里需要做个检测，避免每次获取数据库连接时都重新注册驱动。这个是一个比较小的点，大家看代码时注意一下即可。下面看一下获取数据库连接的逻辑。</p>
<h3 id="3-2-获取数据库连接"><a href="#3-2-获取数据库连接" class="headerlink" title="3.2 获取数据库连接"></a>3.2 获取数据库连接</h3><p>在使用 JDBC 时，我们都是通过 DriverManager 的接口方法获取数据库连接。本节所要分析的源码也不例外，一起看一下吧。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- UnpooledDataSource</span><br><span class="line">public Connection getConnection() throws SQLException &#123;</span><br><span class="line">	return doGetConnection(username, password);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">private Connection doGetConnection(String username, String password) throws SQLException &#123;</span><br><span class="line">    Properties props = new Properties();</span><br><span class="line">    if (driverProperties != null) &#123;</span><br><span class="line">        props.putAll(driverProperties);</span><br><span class="line">    &#125;</span><br><span class="line">    if (username != null) &#123;</span><br><span class="line">        // 存储 user 配置</span><br><span class="line">        props.setProperty(&quot;user&quot;, username);</span><br><span class="line">    &#125;</span><br><span class="line">    if (password != null) &#123;</span><br><span class="line">        // 存储 password 配置</span><br><span class="line">        props.setProperty(&quot;password&quot;, password);</span><br><span class="line">    &#125;</span><br><span class="line">    // 调用重载方法</span><br><span class="line">    return doGetConnection(props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Connection doGetConnection(Properties properties) throws SQLException &#123;</span><br><span class="line">    // 初始化驱动</span><br><span class="line">    initializeDriver();</span><br><span class="line">    // 获取连接</span><br><span class="line">    Connection connection = DriverManager.getConnection(url, properties);</span><br><span class="line">    // 配置连接，包括自动提交以及事务等级</span><br><span class="line">    configureConnection(connection);</span><br><span class="line">    return connection;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void configureConnection(Connection conn) throws SQLException &#123;</span><br><span class="line">    if (autoCommit != null &amp;&amp; autoCommit != conn.getAutoCommit()) &#123;</span><br><span class="line">        // 设置自动提交</span><br><span class="line">        conn.setAutoCommit(autoCommit);</span><br><span class="line">    &#125;</span><br><span class="line">    if (defaultTransactionIsolationLevel != null) &#123;</span><br><span class="line">        // 设置事务隔离级别</span><br><span class="line">        conn.setTransactionIsolation(defaultTransactionIsolationLevel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，上面方法将一些配置信息放入到 Properties 对象中，然后将数据库连接和 Properties 对象传给 DriverManager 的 getConnection 方法即可获取到数据库连接。</p>
<p>好了，关于 UnpooledDataSource 就先说到这。下面分析一下 PooledDataSource，它的实现要复杂一些。</p>
<h2 id="4-PooledDataSource"><a href="#4-PooledDataSource" class="headerlink" title="4.PooledDataSource"></a>4.PooledDataSource</h2><p>PooledDataSource 内部实现了连接池功能，用于复用数据库连接。因此，从效率上来说，PooledDataSource 要高于 UnpooledDataSource。PooledDataSource 需要借助一些辅助类帮助它完成连接池的功能，所以接下来，我们先来认识一下相关的辅助类。</p>
<h3 id="4-1-辅助类介绍"><a href="#4-1-辅助类介绍" class="headerlink" title="4.1 辅助类介绍"></a>4.1 辅助类介绍</h3><p>PooledDataSource 需要借助两个辅助类帮其完成功能，这两个辅助类分别是 PoolState 和 PooledConnection。PoolState 用于记录连接池运行时的状态，比如连接获取次数，无效连接数量等。同时 PoolState 内部定义了两个 PooledConnection 集合，用于存储空闲连接和活跃连接。PooledConnection 内部定义了一个 Connection 类型的变量，用于指向真实的数据库连接。以及一个 Connection 的代理类，用于对部分方法调用进行拦截。至于为什么要拦截，随后将进行分析。除此之外，PooledConnection 内部也定义了一些字段，用于记录数据库连接的一些运行时状态。接下来，我们来看一下 PooledConnection 的定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class PooledConnection implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    private static final String CLOSE = &quot;close&quot;;</span><br><span class="line">    private static final Class&lt;?&gt;[] IFACES = new Class&lt;?&gt;[]&#123;Connection.class&#125;;</span><br><span class="line"></span><br><span class="line">    private final int hashCode;</span><br><span class="line">    private final PooledDataSource dataSource;</span><br><span class="line">    // 真实的数据库连接</span><br><span class="line">    private final Connection realConnection;</span><br><span class="line">    // 数据库连接代理</span><br><span class="line">    private final Connection proxyConnection;</span><br><span class="line">    </span><br><span class="line">    // 从连接池中取出连接时的时间戳</span><br><span class="line">    private long checkoutTimestamp;</span><br><span class="line">    // 数据库连接创建时间</span><br><span class="line">    private long createdTimestamp;</span><br><span class="line">    // 数据库连接最后使用时间</span><br><span class="line">    private long lastUsedTimestamp;</span><br><span class="line">    // connectionTypeCode = (url + username + password).hashCode()</span><br><span class="line">    private int connectionTypeCode;</span><br><span class="line">    // 表示连接是否有效</span><br><span class="line">    private boolean valid;</span><br><span class="line"></span><br><span class="line">    public PooledConnection(Connection connection, PooledDataSource dataSource) &#123;</span><br><span class="line">        this.hashCode = connection.hashCode();</span><br><span class="line">        this.realConnection = connection;</span><br><span class="line">        this.dataSource = dataSource;</span><br><span class="line">        this.createdTimestamp = System.currentTimeMillis();</span><br><span class="line">        this.lastUsedTimestamp = System.currentTimeMillis();</span><br><span class="line">        this.valid = true;</span><br><span class="line">        // 创建 Connection 的代理类对象</span><br><span class="line">        this.proxyConnection = (Connection) Proxy.newProxyInstance(Connection.class.getClassLoader(), IFACES, this);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    // 省略部分代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面再来看看 PoolState 的定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PoolState &#123;</span><br><span class="line"></span><br><span class="line">    protected PooledDataSource dataSource;</span><br><span class="line"></span><br><span class="line">    // 空闲连接列表</span><br><span class="line">    protected final List&lt;PooledConnection&gt; idleConnections = new ArrayList&lt;PooledConnection&gt;();</span><br><span class="line">    // 活跃连接列表</span><br><span class="line">    protected final List&lt;PooledConnection&gt; activeConnections = new ArrayList&lt;PooledConnection&gt;();</span><br><span class="line">    // 从连接池中获取连接的次数</span><br><span class="line">    protected long requestCount = 0;</span><br><span class="line">    // 请求连接总耗时（单位：毫秒）</span><br><span class="line">    protected long accumulatedRequestTime = 0;</span><br><span class="line">    // 连接执行时间总耗时</span><br><span class="line">    protected long accumulatedCheckoutTime = 0;</span><br><span class="line">    // 执行时间超时的连接数</span><br><span class="line">    protected long claimedOverdueConnectionCount = 0;</span><br><span class="line">    // 超时时间累加值</span><br><span class="line">    protected long accumulatedCheckoutTimeOfOverdueConnections = 0;</span><br><span class="line">    // 等待时间累加值</span><br><span class="line">    protected long accumulatedWaitTime = 0;</span><br><span class="line">    // 等待次数</span><br><span class="line">    protected long hadToWaitCount = 0;</span><br><span class="line">    // 无效连接数</span><br><span class="line">    protected long badConnectionCount = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面对 PooledConnection 和 PoolState 的定义进行了一些注释，这两个类中有很多字段用来记录运行时状态。但在这些字段并非核心，因此大家知道每个字段的用途就行了。关于这两个辅助类的介绍就先到这</p>
<h3 id="4-2-获取连接"><a href="#4-2-获取连接" class="headerlink" title="4.2 获取连接"></a>4.2 获取连接</h3><p>前面已经说过，PooledDataSource 会将用过的连接进行回收，以便可以复用连接。因此从 PooledDataSource 获取连接时，如果空闲链接列表里有连接时，可直接取用。那如果没有空闲连接怎么办呢？此时有两种解决办法，要么创建新连接，要么等待其他连接完成任务。具体怎么做，需视情况而定。下面我们深入到源码中一探究竟。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Connection getConnection() throws SQLException &#123;</span><br><span class="line">    // 返回 Connection 的代理对象</span><br><span class="line">    return popConnection(dataSource.getUsername(), dataSource.getPassword()).getProxyConnection();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private PooledConnection popConnection(String username, String password) throws SQLException &#123;</span><br><span class="line">    boolean countedWait = false;</span><br><span class="line">    PooledConnection conn = null;</span><br><span class="line">    long t = System.currentTimeMillis();</span><br><span class="line">    int localBadConnectionCount = 0;</span><br><span class="line"></span><br><span class="line">    while (conn == null) &#123;</span><br><span class="line">        synchronized (state) &#123;</span><br><span class="line">            // 检测空闲连接集合（idleConnections）是否为空</span><br><span class="line">            if (!state.idleConnections.isEmpty()) &#123;</span><br><span class="line">                // idleConnections 不为空，表示有空闲连接可以使用</span><br><span class="line">                conn = state.idleConnections.remove(0);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                /*</span><br><span class="line">                 * 暂无空闲连接可用，但如果活跃连接数还未超出限制</span><br><span class="line">                 *（poolMaximumActiveConnections），则可创建新的连接</span><br><span class="line">                 */</span><br><span class="line">                if (state.activeConnections.size() &lt; poolMaximumActiveConnections) &#123;</span><br><span class="line">                    // 创建新连接</span><br><span class="line">                    conn = new PooledConnection(dataSource.getConnection(), this);</span><br><span class="line">                    </span><br><span class="line">                &#125; else &#123;    // 连接池已满，不能创建新连接</span><br><span class="line">                    // 取出运行时间最长的连接</span><br><span class="line">                    PooledConnection oldestActiveConnection = state.activeConnections.get(0);</span><br><span class="line">                    // 获取运行时长</span><br><span class="line">                    long longestCheckoutTime = oldestActiveConnection.getCheckoutTime();</span><br><span class="line">                    // 检测运行时长是否超出限制，即超时</span><br><span class="line">                    if (longestCheckoutTime &gt; poolMaximumCheckoutTime) &#123;</span><br><span class="line">                        // 累加超时相关的统计字段</span><br><span class="line">                        state.claimedOverdueConnectionCount++;</span><br><span class="line">                        state.accumulatedCheckoutTimeOfOverdueConnections += longestCheckoutTime;</span><br><span class="line">                        state.accumulatedCheckoutTime += longestCheckoutTime;</span><br><span class="line"></span><br><span class="line">                        // 从活跃连接集合中移除超时连接</span><br><span class="line">                        state.activeConnections.remove(oldestActiveConnection);</span><br><span class="line">                        // 若连接未设置自动提交，此处进行回滚操作</span><br><span class="line">                        if (!oldestActiveConnection.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">                            try &#123;</span><br><span class="line">                                oldestActiveConnection.getRealConnection().rollback();</span><br><span class="line">                            &#125; catch (SQLException e) &#123;...&#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        /*</span><br><span class="line">                         * 创建一个新的 PooledConnection，注意，</span><br><span class="line">                         * 此处复用 oldestActiveConnection 的 realConnection 变量</span><br><span class="line">                         */</span><br><span class="line">                        conn = new PooledConnection(oldestActiveConnection.getRealConnection(), this);</span><br><span class="line">                        /*</span><br><span class="line">                         * 复用 oldestActiveConnection 的一些信息，注意 PooledConnection 中的 </span><br><span class="line">                         * createdTimestamp 用于记录 Connection 的创建时间，而非 PooledConnection </span><br><span class="line">                         * 的创建时间。所以这里要复用原连接的时间信息。</span><br><span class="line">                         */</span><br><span class="line">                        conn.setCreatedTimestamp(oldestActiveConnection.getCreatedTimestamp());</span><br><span class="line">                        conn.setLastUsedTimestamp(oldestActiveConnection.getLastUsedTimestamp());</span><br><span class="line"></span><br><span class="line">                        // 设置连接为无效状态</span><br><span class="line">                        oldestActiveConnection.invalidate();</span><br><span class="line">                        </span><br><span class="line">                    &#125; else &#123;    // 运行时间最长的连接并未超时</span><br><span class="line">                        try &#123;</span><br><span class="line">                            if (!countedWait) &#123;</span><br><span class="line">                                state.hadToWaitCount++;</span><br><span class="line">                                countedWait = true;</span><br><span class="line">                            &#125;</span><br><span class="line">                            long wt = System.currentTimeMillis();</span><br><span class="line">                            // 当前线程进入等待状态</span><br><span class="line">                            state.wait(poolTimeToWait);</span><br><span class="line">                            state.accumulatedWaitTime += System.currentTimeMillis() - wt;</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (conn != null) &#123;</span><br><span class="line">                /*</span><br><span class="line">                 * 检测连接是否有效，isValid 方法除了会检测 valid 是否为 true，</span><br><span class="line">                 * 还会通过 PooledConnection 的 pingConnection 方法执行 SQL 语句，</span><br><span class="line">                 * 检测连接是否可用。pingConnection 方法的逻辑不复杂，大家可以自行分析。</span><br><span class="line">                 * 另外，官方文档在介绍 POOLED 类型数据源时，也介绍了连接有效性检测方面的</span><br><span class="line">                 * 属性，有三个：poolPingQuery，poolPingEnabled 和 </span><br><span class="line">                 * poolPingConnectionsNotUsedFor。关于这三个属性，大家可以查阅官方文档</span><br><span class="line">                 */</span><br><span class="line">                if (conn.isValid()) &#123;</span><br><span class="line">                    if (!conn.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">                        // 进行回滚操作</span><br><span class="line">                        conn.getRealConnection().rollback();</span><br><span class="line">                    &#125;</span><br><span class="line">                    conn.setConnectionTypeCode(assembleConnectionTypeCode(dataSource.getUrl(), username, password));</span><br><span class="line">                    // 设置统计字段</span><br><span class="line">                    conn.setCheckoutTimestamp(System.currentTimeMillis());</span><br><span class="line">                    conn.setLastUsedTimestamp(System.currentTimeMillis());</span><br><span class="line">                    state.activeConnections.add(conn);</span><br><span class="line">                    state.requestCount++;</span><br><span class="line">                    state.accumulatedRequestTime += System.currentTimeMillis() - t;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 连接无效，此时累加无效连接相关的统计字段</span><br><span class="line">                    state.badConnectionCount++;</span><br><span class="line">                    localBadConnectionCount++;</span><br><span class="line">                    conn = null;</span><br><span class="line">                    if (localBadConnectionCount &gt; (poolMaximumIdleConnections</span><br><span class="line">                        + poolMaximumLocalBadConnectionTolerance)) &#123;</span><br><span class="line">                        throw new SQLException(...);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (conn == null) &#123;</span><br><span class="line">        throw new SQLException(...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码冗长，过程比较复杂，下面把代码逻辑梳理一下。从连接池中获取连接首先会遇到两种情况：</p>
<ol>
<li>连接池中有空闲连接</li>
<li>连接池中无空闲连接</li>
</ol>
<p>对于第一种情况，处理措施就很简单了，把连接取出返回即可。对于第二种情况，则要进行细分，会有如下的情况。</p>
<ol>
<li>活跃连接数没有超出最大活跃连接数</li>
<li>活跃连接数超出最大活跃连接数</li>
</ol>
<p>对于上面两种情况，第一种情况比较好处理，直接创建新的连接即可。至于第二种情况，需要再次进行细分。</p>
<ol>
<li>活跃连接的运行时间超出限制，即超时了</li>
<li>活跃连接未超时</li>
</ol>
<p>对于第一种情况，我们直接将超时连接强行中断，并进行回滚，然后复用部分字段重新创建 PooledConnection 即可。对于第二种情况，目前没有更好的处理方式了，只能等待了。下面用一段伪代码演示各种情况及相应的处理措施，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (连接池中有空闲连接) &#123;</span><br><span class="line">    1. 将连接从空闲连接集合中移除</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    if (活跃连接数未超出限制) &#123;</span><br><span class="line">        1. 创建新连接</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        1. 从活跃连接集合中取出第一个元素</span><br><span class="line">        2. 获取连接运行时长</span><br><span class="line">        </span><br><span class="line">        if (连接超时) &#123;</span><br><span class="line">            1. 将连接从活跃集合中移除</span><br><span class="line">            2. 复用原连接的成员变量，并创建新的 PooledConnection 对象</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            1. 线程进入等待状态</span><br><span class="line">            2. 线程被唤醒后，重新执行以上逻辑</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">1. 将连接添加到活跃连接集合中</span><br><span class="line">2. 返回连接</span><br></pre></td></tr></table></figure>

<p>最后用一个流程图大致描绘 popConnection 的逻辑，如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15346642047612.jpg" alt="img"></p>
<h3 id="4-3-回收连接"><a href="#4-3-回收连接" class="headerlink" title="4.3 回收连接"></a>4.3 回收连接</h3><p>相比于获取连接，回收连接的逻辑要简单的多。回收连接成功与否只取决于空闲连接集合的状态，所需处理情况很少，因此比较简单。下面看一下相关的逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void pushConnection(PooledConnection conn) throws SQLException &#123;</span><br><span class="line">    synchronized (state) &#123;</span><br><span class="line">        // 从活跃连接池中移除连接</span><br><span class="line">        state.activeConnections.remove(conn);</span><br><span class="line">        if (conn.isValid()) &#123;</span><br><span class="line">            // 空闲连接集合未满</span><br><span class="line">            if (state.idleConnections.size() &lt; poolMaximumIdleConnections</span><br><span class="line">                &amp;&amp; conn.getConnectionTypeCode() == expectedConnectionTypeCode) &#123;</span><br><span class="line">                state.accumulatedCheckoutTime += conn.getCheckoutTime();</span><br><span class="line"></span><br><span class="line">                // 回滚未提交的事务</span><br><span class="line">                if (!conn.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">                    conn.getRealConnection().rollback();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 创建新的 PooledConnection</span><br><span class="line">                PooledConnection newConn = new PooledConnection(conn.getRealConnection(), this);</span><br><span class="line">                state.idleConnections.add(newConn);</span><br><span class="line">                // 复用时间信息</span><br><span class="line">                newConn.setCreatedTimestamp(conn.getCreatedTimestamp());</span><br><span class="line">                newConn.setLastUsedTimestamp(conn.getLastUsedTimestamp());</span><br><span class="line"></span><br><span class="line">                // 将原连接置为无效状态</span><br><span class="line">                conn.invalidate();</span><br><span class="line"></span><br><span class="line">                // 通知等待的线程</span><br><span class="line">                state.notifyAll();</span><br><span class="line">                </span><br><span class="line">            &#125; else &#123;    // 空闲连接集合已满</span><br><span class="line">                state.accumulatedCheckoutTime += conn.getCheckoutTime();</span><br><span class="line">                // 回滚未提交的事务</span><br><span class="line">                if (!conn.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">                    conn.getRealConnection().rollback();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 关闭数据库连接</span><br><span class="line">                conn.getRealConnection().close();</span><br><span class="line">                conn.invalidate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            state.badConnectionCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码首先将连接从活跃连接集合中移除，然后再根据空闲集合是否有空闲空间进行后续处理。如果空闲集合未满，此时复用原连接的字段信息创建新的连接，并将其放入空闲集合中即可。若空闲集合已满，此时无需回收连接，直接关闭即可。pushConnection 方法的逻辑并不复杂，就不多说了。</p>
<p>我们知道获取连接的方法 popConnection 是由 getConnection 方法调用的，那回收连接的方法 pushConnection 是由谁调用的呢？答案是 PooledConnection 中的代理逻辑。相关代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- PooledConnection</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">    String methodName = method.getName();</span><br><span class="line">    // 检测 close 方法是否被调用，若被调用则拦截之</span><br><span class="line">    if (CLOSE.hashCode() == methodName.hashCode() &amp;&amp; CLOSE.equals(methodName)) &#123;</span><br><span class="line">        // 将回收连接中，而不是直接将连接关闭</span><br><span class="line">        dataSource.pushConnection(this);</span><br><span class="line">        return null;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (!Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">                checkConnection();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 调用真实连接的目标方法</span><br><span class="line">            return method.invoke(realConnection, args);</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            throw ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上一节中，getConnection 方法返回的是 Connection 代理对象，不知道大家有没有注意到。代理对象中的方法被调用时，会被上面的代理逻辑所拦截。如果代理对象的 close 方法被调用，MyBatis 并不会直接调用真实连接的 close 方法关闭连接，而是调用 pushConnection 方法回收连接。同时会唤醒处于睡眠中的线程，使其恢复运行。整个过程并不复杂，就不多说了。</p>
<h3 id="4-4-小节"><a href="#4-4-小节" class="headerlink" title="4.4 小节"></a>4.4 小节</h3><p>本章分析了 PooledDataSource 的部分源码及一些辅助类的源码，除此之外，PooledDataSource 中还有部分源码没有分析，大家若有兴趣，可自行分析。好了，关于 PooledDataSource 的分析就先到这。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>本篇文章对 MyBatis 两种内置数据源进行了较为详细的分析，总的来说，这两种数据源的源码都不是很难理解。大家在阅读源码的过程中，首先应搞懂源码的主要逻辑，然后再去分析一些边边角角的逻辑。不要一开始就陷入各种细节中，容易迷失方向。</p>
<p>好了，到此本文就结束了。若文章有错误不妥之处，希望大家指明。最后，感谢大家阅读我的文章。</p>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis源码分析-缓存原理</title>
    <url>/2022/10/25/MyBatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>在 Web 应用中，缓存是必不可少的组件。通常我们都会用 Redis 或 memcached 等缓存中间件，拦截大量奔向数据库的请求，减轻数据库压力。作为一个重要的组件，MyBatis 自然也在内部提供了相应的支持。通过在框架层面增加缓存功能，可减轻数据库的压力，同时又可以提升查询速度，可谓一举两得。MyBatis 缓存结构由一级缓存和二级缓存构成，这两级缓存均是使用 Cache 接口的实现类。因此，在接下里的章节中，我将首先会向大家介绍 Cache 几种实现类的源码，然后再分析一级和二级缓存的实现。下面先来分析 Cache 及其实现类。</p>
<h2 id="2-缓存类介绍"><a href="#2-缓存类介绍" class="headerlink" title="2.缓存类介绍"></a>2.缓存类介绍</h2><p>在 MyBatis 中，Cache 是缓存接口，定义了一些基本的缓存操作，所有缓存类都应该实现该接口。MyBatis 内部提供了丰富的缓存实现类，比如具有基本缓存功能的 PerpetualCache，具有 LRU 策略的缓存 LruCache，以及可保证线程安全的缓存 SynchronizedCache 和具备阻塞功能的缓存 BlockingCache 等。除此之外，还有很多缓存实现类，这里就不一一列举了。需要特别说明的是，MyBatis 在实现缓存模块的过程中，使用了装饰模式。在以上几种缓存实现类中，PerpetualCache 相当于装饰模式中的 ConcreteComponent。LruCache、SynchronizedCache 和 BlockingCache 等相当于装饰模式中的 ConcreteDecorator。它们的关系如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15348250188091.jpg" alt="img"></p>
<p>以上对 Cache 接口的实现类进行了简单的介绍，接下来，我们一起深入到源码中，看看这些缓存类的实现。</p>
<h3 id="2-1-PerpetualCache"><a href="#2-1-PerpetualCache" class="headerlink" title="2.1 PerpetualCache"></a>2.1 PerpetualCache</h3><p>PerpetualCache 是一个具有基本功能的缓存类，内部使用了 HashMap 实现缓存功能。它的源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PerpetualCache implements Cache &#123;</span><br><span class="line"></span><br><span class="line">    private final String id;</span><br><span class="line"></span><br><span class="line">    private Map&lt;Object, Object&gt; cache = new HashMap&lt;Object, Object&gt;();</span><br><span class="line"></span><br><span class="line">    public PerpetualCache(String id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getSize() &#123;</span><br><span class="line">        return cache.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void putObject(Object key, Object value) &#123;</span><br><span class="line">        // 存储键值对到 HashMap</span><br><span class="line">        cache.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object getObject(Object key) &#123;</span><br><span class="line">        // 查找缓存项</span><br><span class="line">        return cache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object removeObject(Object key) &#123;</span><br><span class="line">        // 移除缓存项</span><br><span class="line">        return cache.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        cache.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 省略部分代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是 PerpetualCache 的全部代码，很简单。接下来，我们通过装饰类对该类进行装饰，使其功能变的丰富起来。</p>
<h3 id="2-2-LruCache"><a href="#2-2-LruCache" class="headerlink" title="2.2 LruCache"></a>2.2 LruCache</h3><p>LruCache，顾名思义，是一种具有 LRU 策略的缓存实现类。除此之外，MyBatis 还提供了具有 FIFO 策略的缓存 FifoCache。不过并未提供 LFU 缓存，如果大家有兴趣，可以自行拓展。接下来，我们来看一下 LruCache 的实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class LruCache implements Cache &#123;</span><br><span class="line"></span><br><span class="line">    private final Cache delegate;</span><br><span class="line">    private Map&lt;Object, Object&gt; keyMap;</span><br><span class="line">    private Object eldestKey;</span><br><span class="line"></span><br><span class="line">    public LruCache(Cache delegate) &#123;</span><br><span class="line">        this.delegate = delegate;</span><br><span class="line">        setSize(1024);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int getSize() &#123;</span><br><span class="line">        return delegate.getSize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSize(final int size) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * 初始化 keyMap，注意，keyMap 的类型继承自 LinkedHashMap，</span><br><span class="line">         * 并覆盖了 removeEldestEntry 方法</span><br><span class="line">         */</span><br><span class="line">        keyMap = new LinkedHashMap&lt;Object, Object&gt;(size, .75F, true) &#123;</span><br><span class="line">            private static final long serialVersionUID = 4267176411845948333L;</span><br><span class="line"></span><br><span class="line">            // 覆盖 LinkedHashMap 的 removeEldestEntry 方法</span><br><span class="line">            @Override</span><br><span class="line">            protected boolean removeEldestEntry(Map.Entry&lt;Object, Object&gt; eldest) &#123;</span><br><span class="line">                boolean tooBig = size() &gt; size;</span><br><span class="line">                if (tooBig) &#123;</span><br><span class="line">                    // 获取将要被移除缓存项的键值</span><br><span class="line">                    eldestKey = eldest.getKey();</span><br><span class="line">                &#125;</span><br><span class="line">                return tooBig;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void putObject(Object key, Object value) &#123;</span><br><span class="line">        // 存储缓存项</span><br><span class="line">        delegate.putObject(key, value);</span><br><span class="line">        cycleKeyList(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object getObject(Object key) &#123;</span><br><span class="line">        // 刷新 key 在 keyMap 中的位置</span><br><span class="line">        keyMap.get(key);</span><br><span class="line">        // 从被装饰类中获取相应缓存项</span><br><span class="line">        return delegate.getObject(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object removeObject(Object key) &#123;</span><br><span class="line">        // 从被装饰类中移除相应的缓存项</span><br><span class="line">        return delegate.removeObject(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        delegate.clear();</span><br><span class="line">        keyMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void cycleKeyList(Object key) &#123;</span><br><span class="line">        // 存储 key 到 keyMap 中</span><br><span class="line">        keyMap.put(key, key);</span><br><span class="line">        if (eldestKey != null) &#123;</span><br><span class="line">            // 从被装饰类中移除相应的缓存项</span><br><span class="line">            delegate.removeObject(eldestKey);</span><br><span class="line">            eldestKey = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 省略部分代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，LruCache 的 keyMap 属性是实现 LRU 策略的关键，该属性类型继承自 LinkedHashMap，并覆盖了 removeEldestEntry 方法。LinkedHashMap 可保持键值对的插入顺序，当插入一个新的键值对时，LinkedHashMap 内部的 tail 节点会指向最新插入的节点。head 节点则指向第一个被插入的键值对，也就是最久未被访问的那个键值对。默认情况下，LinkedHashMap 仅维护键值对的插入顺序。若要基于 LinkedHashMap 实现 LRU 缓存，还需通过构造方法将 LinkedHashMap 的 accessOrder 属性设为 true，此时 LinkedHashMap 会维护键值对的访问顺序。比如，上面代码中 getObject 方法中执行了这样一句代码 keyMap.get(key)，目的是刷新 key 对应的键值对在 LinkedHashMap 的位置。LinkedHashMap 会将 key 对应的键值对移动到链表的尾部，尾部节点表示最久刚被访问过或者插入的节点。除了需将 accessOrder 设为 true，还需覆盖 removeEldestEntry 方法。LinkedHashMap 在插入新的键值对时会调用该方法，以决定是否在插入新的键值对后，移除老的键值对。在上面的代码中，当被装饰类的容量超出了 keyMap 的所规定的容量（由构造方法传入）后，keyMap 会移除最长时间未被访问的键，并保存到 eldestKey 中，然后由 cycleKeyList 方法将 eldestKey 传给被装饰类的 removeObject 方法，移除相应的缓存项目。</p>
<p>上面讲了 LinkedHashMap 是如何实现 LRU 特性的，这个是理解 LruCache 的源码的关键所在，所以大家务必搞懂。如果大家想深入了解 LinkedHashMap 的源码，也可参考我之前写的文章 <a href="https://www.tianxiaobo.com/2018/01/24/LinkedHashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90%EF%BC%88JDK1-8%EF%BC%89/">LinkedHashMap 源码详细分析</a>。好了，关于 LruCache 就先分析这么多了。</p>
<h3 id="2-3-BlockingCache"><a href="#2-3-BlockingCache" class="headerlink" title="2.3 BlockingCache"></a>2.3 BlockingCache</h3><p>BlockingCache 实现了阻塞特性，该特性是基于 Java 重入锁实现的。同一时刻下，BlockingCache 仅允许一个线程访问指定 key 的缓存项，其他线程将会被阻塞住。下面我们来看一下 BlockingCache 的源码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class BlockingCache implements Cache &#123;</span><br><span class="line"></span><br><span class="line">    private long timeout;</span><br><span class="line">    private final Cache delegate;</span><br><span class="line">    private final ConcurrentHashMap&lt;Object, ReentrantLock&gt; locks;</span><br><span class="line"></span><br><span class="line">    public BlockingCache(Cache delegate) &#123;</span><br><span class="line">        this.delegate = delegate;</span><br><span class="line">        this.locks = new ConcurrentHashMap&lt;Object, ReentrantLock&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void putObject(Object key, Object value) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 存储缓存项</span><br><span class="line">            delegate.putObject(key, value);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 释放锁</span><br><span class="line">            releaseLock(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object getObject(Object key) &#123;</span><br><span class="line">        // 请        // 请求锁</span><br><span class="line">        acquireLock(key);</span><br><span class="line">        Object value = delegate.getObject(key);</span><br><span class="line">        // 若缓存命中，则释放锁。需要注意的是，未命中则不释放锁</span><br><span class="line">        if (value != null) &#123;</span><br><span class="line">            // 释放锁</span><br><span class="line">            releaseLock(key);</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object removeObject(Object key) &#123;</span><br><span class="line">        // 释放锁</span><br><span class="line">        releaseLock(key);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ReentrantLock getLockForKey(Object key) &#123;</span><br><span class="line">        ReentrantLock lock = new ReentrantLock();</span><br><span class="line">        // 存储 &lt;key, Lock&gt; 键值对到 locks 中</span><br><span class="line">        ReentrantLock previous = locks.putIfAbsent(key, lock);</span><br><span class="line">        return previous == null ? lock : previous;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void acquireLock(Object key) &#123;</span><br><span class="line">        Lock lock = getLockForKey(key);</span><br><span class="line">        if (timeout &gt; 0) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 尝试加锁</span><br><span class="line">                boolean acquired = lock.tryLock(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">                if (!acquired) &#123;</span><br><span class="line">                    throw new CacheException(&quot;...&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                throw new CacheException(&quot;...&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 加锁</span><br><span class="line">            lock.lock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void releaseLock(Object key) &#123;</span><br><span class="line">        // 获取与当前 key 对应的锁</span><br><span class="line">        ReentrantLock lock = locks.get(key);</span><br><span class="line">        if (lock.isHeldByCurrentThread()) &#123;</span><br><span class="line">            // 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 省略部分代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，查询缓存时，getObject 方法会先获取与 key 对应的锁，并加锁。若缓存命中，getObject 方法会释放锁，否则将一直锁定。getObject 方法若返回 null，表示缓存未命中。此时 MyBatis 会进行数据库查询，并调用 putObject 方法存储查询结果。同时，putObject 方法会将指定 key 对应的锁进行解锁，这样被阻塞的线程即可恢复运行。</p>
<p>上面的描述有点啰嗦，倒是 BlockingCache 类的注释说到比较简单明了。这里引用一下：</p>
<blockquote>
<p>It sets a lock over a cache key when the element is not found in cache.<br>This way, other threads will wait until this element is filled instead of hitting the database.</p>
</blockquote>
<p>这段话的意思是，当指定 key 对应元素不存在于缓存中时，BlockingCache 会根据 lock 进行加锁。此时，其他线程将会进入等待状态，直到与 key 对应的元素被填充到缓存中。而不是让所有线程都去访问数据库。</p>
<p>在上面代码中，removeObject 方法的逻辑很奇怪，仅调用了 releaseLock 方法释放锁，却没有调用被装饰类的 removeObject 方法移除指定缓存项。这样做是为什么呢？大家可以先思考，答案将在分析二级缓存的相关逻辑时分析。</p>
<h2 id="3-CacheKey"><a href="#3-CacheKey" class="headerlink" title="3. CacheKey"></a>3. CacheKey</h2><p>在 MyBatis 中，引入缓存的目的是为提高查询效率，降低数据库压力。既然 MyBatis 引入了缓存，那么大家思考过缓存中的 key 和 value 的值分别是什么吗？大家可能很容易能回答出 value 的内容，不就是 SQL 的查询结果吗。那 key 是什么呢？是字符串，还是其他什么对象？如果是字符串的话，那么大家首先能想到的是用 SQL 语句作为 key。但这是不对的，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM author where id &gt; ?</span><br></pre></td></tr></table></figure>

<p>id &gt; 1 和 id &gt; 10 查出来的结果可能是不同的，所以我们不能简单的使用 SQL 语句作为 key。从这里可以看出来，运行时参数将会影响查询结果，因此我们的 key 应该涵盖运行时参数。除此之外呢，如果进行分页查询也会导致查询结果不同，因此 key 也应该涵盖分页参数。综上，我们不能使用简单的 SQL 语句作为 key。应该考虑使用一种复合对象，能涵盖可影响查询结果的因子。在 MyBatis 中，这种复合对象就是 CacheKey。下面来看一下它的定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class CacheKey implements Cloneable, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final int DEFAULT_MULTIPLYER = 37;</span><br><span class="line">    private static final int DEFAULT_HASHCODE = 17;</span><br><span class="line"></span><br><span class="line">    // 乘子，默认为37</span><br><span class="line">    private final int multiplier;</span><br><span class="line">    // CacheKey 的 hashCode，综合了各种影响因子</span><br><span class="line">    private int hashcode;</span><br><span class="line">    // 校验和</span><br><span class="line">    private long checksum;</span><br><span class="line">    // 影响因子个数</span><br><span class="line">    private int count;</span><br><span class="line">    // 影响因子集合</span><br><span class="line">    private List&lt;Object&gt; updateList;</span><br><span class="line">    </span><br><span class="line">    public CacheKey() &#123;</span><br><span class="line">        this.hashcode = DEFAULT_HASHCODE;</span><br><span class="line">        this.multiplier = DEFAULT_MULTIPLYER;</span><br><span class="line">        this.count = 0;</span><br><span class="line">        this.updateList = new ArrayList&lt;Object&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 省略其他方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，除了 multiplier 是恒定不变的 ，其他变量将在更新操作中被修改。下面看一下更新操作的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** 每当执行更新操作时，表示有新的影响因子参与计算 */</span><br><span class="line">public void update(Object object) &#123;</span><br><span class="line">        int baseHashCode = object == null ? 1 : ArrayUtil.hashCode(object);</span><br><span class="line">    // 自增 count</span><br><span class="line">    count++;</span><br><span class="line">    // 计算校验和</span><br><span class="line">    checksum += baseHashCode;</span><br><span class="line">    // 更新 baseHashCode</span><br><span class="line">    baseHashCode *= count;</span><br><span class="line"></span><br><span class="line">    // 计算 hashCode</span><br><span class="line">    hashcode = multiplier * hashcode + baseHashCode;</span><br><span class="line"></span><br><span class="line">    // 保存影响因子</span><br><span class="line">    updateList.add(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当不断有新的影响因子参与计算时，hashcode 和 checksum 将会变得愈发复杂和随机。这样可降低冲突率，使 CacheKey 可在缓存中更均匀的分布。CacheKey 最终要作为键存入 HashMap，因此它需要覆盖 equals 和 hashCode 方法。下面我们来看一下这两个方法的实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean equals(Object object) &#123;</span><br><span class="line">    // 检测是否为同一个对象</span><br><span class="line">    if (this == object) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 检测 object 是否为 CacheKey</span><br><span class="line">    if (!(object instanceof CacheKey)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    final CacheKey cacheKey = (CacheKey) object;</span><br><span class="line"></span><br><span class="line">    // 检测 hashCode 是否相等</span><br><span class="line">    if (hashcode != cacheKey.hashcode) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    // 检测校验和是否相同</span><br><span class="line">    if (checksum != cacheKey.checksum) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    // 检测 coutn 是否相同</span><br><span class="line">    if (count != cacheKey.count) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果上面的检测都通过了，下面分别对每个影响因子进行比较</span><br><span class="line">    for (int i = 0; i &lt; updateList.size(); i++) &#123;</span><br><span class="line">        Object thisObject = updateList.get(i);</span><br><span class="line">        Object thatObject = cacheKey.updateList.get(i);</span><br><span class="line">        if (!ArrayUtil.equals(thisObject, thatObject)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">    // 返回 hashcode 变量</span><br><span class="line">    return hashcode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>equals 方法的检测逻辑比较严格，对 CacheKey 中多个成员变量进行了检测，已保证两者相等。hashCode 方法比较简单，返回 hashcode 变量即可。</p>
<p>关于 CacheKey 就先分析到这，CacheKey 在一二级缓存中会被用到，接下来还会看到它的身影。</p>
<h2 id="4-一级缓存"><a href="#4-一级缓存" class="headerlink" title="4.一级缓存"></a>4.一级缓存</h2><p>在进行数据库查询之前，MyBatis 首先会检查以及缓存中是否有相应的记录，若有的话直接返回即可。一级缓存是数据库的最后一道防护，若一级缓存未命中，查询请求将落到数据库上。一级缓存是在 BaseExecutor 被初始化的，下面我们来看一下相关的初始化逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class BaseExecutor implements Executor &#123;</span><br><span class="line">	protected PerpetualCache localCache;</span><br><span class="line">    // 省略其他字段</span><br><span class="line">    </span><br><span class="line">    protected BaseExecutor(Configuration configuration, Transaction transaction) &#123;</span><br><span class="line">        this.localCache = new PerpetualCache(&quot;LocalCache&quot;);</span><br><span class="line">        // 省略其他字段初始化方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，一级缓存的类型为 PerpetualCache，没有被其他缓存类装饰过。一级缓存所存储从查询结果会在 MyBatis 执行更新操作（INSERT&#x2F;UPDATE&#x2F;DELETE），以及提交和回滚事务时被清空。下面我们来看一下查询一级缓存的逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException &#123;</span><br><span class="line">    BoundSql boundSql = ms.getBoundSql(parameter);</span><br><span class="line">    // 创建 CacheKey</span><br><span class="line">    CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">    return query(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">    // 省略部分代码</span><br><span class="line">    </span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    try &#123;</span><br><span class="line">        queryStack++;</span><br><span class="line">        // 查询一级缓存</span><br><span class="line">        list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null;</span><br><span class="line">        if (list != null) &#123;</span><br><span class="line">            // 存储过程相关逻辑，忽略</span><br><span class="line">            handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 缓存未命中，则从数据库中查询</span><br><span class="line">            list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        queryStack--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 省略部分代码</span><br><span class="line">    </span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，在访问一级缓存之前，MyBatis 首先会调用 createCacheKey 方法创建 CacheKey。下面我们来看一下 createCacheKey 方法的逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public CacheKey createCacheKey(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql) &#123;</span><br><span class="line">    if (closed) &#123;</span><br><span class="line">        throw new ExecutorException(&quot;Executor was closed.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 创建 CacheKey 对象</span><br><span class="line">    CacheKey cacheKey = new CacheKey();</span><br><span class="line">    // 将 MappedStatement 的 id 作为影响因子进行计算</span><br><span class="line">    cacheKey.update(ms.getId());</span><br><span class="line">	// RowBounds 用于分页查询，下面将它的两个字段作为影响因子进行计算</span><br><span class="line">    cacheKey.update(rowBounds.getOffset());</span><br><span class="line">    cacheKey.update(rowBounds.getLimit());</span><br><span class="line">    // 获取 sql 语句，并进行计算</span><br><span class="line">    cacheKey.update(boundSql.getSql());</span><br><span class="line">    List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">    TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry();</span><br><span class="line">    for (ParameterMapping parameterMapping : parameterMappings) &#123;</span><br><span class="line">        if (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">            Object value;    // 运行时参数</span><br><span class="line">            // 当前大段代码用于获取 SQL 中的占位符 #&#123;xxx&#125; 对应的运行时参数，</span><br><span class="line">            // 前文有类似分析，这里忽略了</span><br><span class="line">            String propertyName = parameterMapping.getProperty();</span><br><span class="line">            if (boundSql.hasAdditionalParameter(propertyName)) &#123;</span><br><span class="line">                value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">            &#125; else if (parameterObject == null) &#123;</span><br><span class="line">                value = null;</span><br><span class="line">            &#125; else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">                value = parameterObject;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">                value = metaObject.getValue(propertyName);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 让运行时参数参与计算</span><br><span class="line">            cacheKey.update(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (configuration.getEnvironment() != null) &#123;</span><br><span class="line">        // 获取 Environment id 遍历，并让其参与计算</span><br><span class="line">        cacheKey.update(configuration.getEnvironment().getId());</span><br><span class="line">    &#125;</span><br><span class="line">    return cacheKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，在计算 CacheKey 的过程中，有很多影响因子参与了计算。比如 MappedStatement 的 id 字段，SQL 语句，分页参数，运行时变量，Environment 的 id 字段等。通过让这些影响因子参与计算，可以很好的区分不同查询请求。所以，我们可以简单的把 CacheKey 看做是一个查询请求的 id。有了 CacheKey，我们就可以使用它读写缓存了。在上面代码中，若一级缓存为命中，BaseExecutor 会调用 queryFromDatabase 查询数据库，并将查询结果写入缓存中。下面看一下 queryFromDatabase 的逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds,ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    // 向缓存中存储一个占位符</span><br><span class="line">    localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">    try &#123;</span><br><span class="line">        // 查询数据库</span><br><span class="line">        list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 移除占位符</span><br><span class="line">        localCache.removeObject(key);</span><br><span class="line">    &#125;</span><br><span class="line">    // 存储查询结果</span><br><span class="line">    localCache.putObject(key, list);</span><br><span class="line">    </span><br><span class="line">    // 存储过程相关逻辑，忽略</span><br><span class="line">    if (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">        localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此，关于一级缓存相关的逻辑就差不多分析完了。一级缓存的逻辑比较简单，大家可以简单过一遍。接下来分析二级缓存。</p>
<h2 id="5-二级缓存"><a href="#5-二级缓存" class="headerlink" title="5.二级缓存"></a>5.二级缓存</h2><p>二级缓存构建在一级缓存之上，在收到查询请求时，MyBatis 首先会查询二级缓存。若二级缓存未命中，再去查询一级缓存。与一级缓存不同，二级缓存和具体的命名空间绑定，一级缓存则是和 SqlSession 绑定。在按照 MyBatis 规范使用 SqlSession 的情况下，一级缓存不存在并发问题。二级缓存则不然，二级缓存可在多个命名空间间共享。这种情况下，会存在并发问题，因此需要针对性去处理。除了并发问题，二级缓存还存在事务问题，相关问题将在接下来进行分析。下面首先来看一下访问二级缓存的逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- CachingExecutor</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException &#123;</span><br><span class="line">    BoundSql boundSql = ms.getBoundSql(parameterObject);</span><br><span class="line">    // 创建 CacheKey</span><br><span class="line">    CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">    return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span><br><span class="line">    throws SQLException &#123;</span><br><span class="line">    // 从 MappedStatement 中获取 Cache，注意这里的 Cache 并非是在 CachingExecutor 中创建的</span><br><span class="line">    Cache cache = ms.getCache();</span><br><span class="line">    // 如果配置文件中没有配置 &lt;cache&gt;，则 cache 为空</span><br><span class="line">    if (cache != null) &#123;</span><br><span class="line">        flushCacheIfRequired(ms);</span><br><span class="line">        if (ms.isUseCache() &amp;&amp; resultHandler == null) &#123;</span><br><span class="line">            ensureNoOutParams(ms, boundSql);</span><br><span class="line">            // 访问二级缓存</span><br><span class="line">            List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">            // 缓存未命中</span><br><span class="line">            if (list == null) &#123;</span><br><span class="line">                // 向一级缓存或者数据库进行查询</span><br><span class="line">                list = delegate.&lt;E&gt;query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">                // 缓存查询结果</span><br><span class="line">                tcm.putObject(cache, key, list);</span><br><span class="line">            &#125;</span><br><span class="line">            return list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return delegate.&lt;E&gt;query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，注意二级缓存是从 MappedStatement 中获取的，而非由 CachingExecutor 创建。由于 MappedStatement 存在于全局配置中，可以多个 CachingExecutor 获取到，这样就会出现线程安全问题。除此之外，若不加以控制，多个事务共用一个缓存实例，会导致脏读问题。线程安全问题可以通过 SynchronizedCache 装饰类解决，该装饰类会在 Cache 实例构造期间被添加上。相关过程可以参考我之前写的文章 <a href="https://www.tianxiaobo.com/2018/07/30/MyBatis-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/#211-%E8%A7%A3%E6%9E%90-cache-%E8%8A%82%E7%82%B9">MyBatis-源码分析-映射文件解析过程</a>，这里就不多说了。至于脏读问题，需要借助其他类来处理，也就是上面代码中 tcm 变量对应的类型。下面分析一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** 事务缓存管理器 */</span><br><span class="line">public class TransactionalCacheManager &#123;</span><br><span class="line"></span><br><span class="line">    // Cache 与 TransactionalCache 的映射关系表</span><br><span class="line">    private final Map&lt;Cache, TransactionalCache&gt; transactionalCaches = new HashMap&lt;Cache, TransactionalCache&gt;();</span><br><span class="line"></span><br><span class="line">    public void clear(Cache cache) &#123;</span><br><span class="line">        // 获取 TransactionalCache 对象，并调用该对象的 clear 方法，下同</span><br><span class="line">        getTransactionalCache(cache).clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getObject(Cache cache, CacheKey key) &#123;</span><br><span class="line">        return getTransactionalCache(cache).getObject(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void putObject(Cache cache, CacheKey key, Object value) &#123;</span><br><span class="line">        getTransactionalCache(cache).putObject(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void commit() &#123;</span><br><span class="line">        for (TransactionalCache txCache : transactionalCaches.values()) &#123;</span><br><span class="line">            txCache.commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void rollback() &#123;</span><br><span class="line">        for (TransactionalCache txCache : transactionalCaches.values()) &#123;</span><br><span class="line">            txCache.rollback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private TransactionalCache getTransactionalCache(Cache cache) &#123;</span><br><span class="line">        // 从映射表中获取 TransactionalCache</span><br><span class="line">        TransactionalCache txCache = transactionalCaches.get(cache);</span><br><span class="line">        if (txCache == null) &#123;</span><br><span class="line">            // TransactionalCache 也是一种装饰类，为 Cache 增加事务功能</span><br><span class="line">            txCache = new TransactionalCache(cache);</span><br><span class="line">            transactionalCaches.put(cache, txCache);</span><br><span class="line">        &#125;</span><br><span class="line">        return txCache;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TransactionalCacheManager 内部维护了 Cache 实例与 TransactionalCache 实例间的映射关系，该类也仅负责维护两者的映射关系，真正做事的还是 TransactionalCache。TransactionalCache 是一种缓存装饰器，可以为 Cache 实例增加事务功能。我在之前提到的脏读问题正是由该类进行处理的。下面分析一下该类的逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TransactionalCache implements Cache &#123;</span><br><span class="line"></span><br><span class="line">    private final Cache delegate;</span><br><span class="line">    private boolean clearOnCommit;</span><br><span class="line">    // 在事务被提交前，所有从数据库中查询的结果将缓存在此集合中</span><br><span class="line">    private final Map&lt;Object, Object&gt; entriesToAddOnCommit;</span><br><span class="line">    // 在事务被提交前，当缓存未命中时，CacheKey 将会被存储在此集合中</span><br><span class="line">    private final Set&lt;Object&gt; entriesMissedInCache;</span><br><span class="line"></span><br><span class="line">    // 省略部分代码</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object getObject(Object key) &#123;</span><br><span class="line">        // 查询 delegate 所代表的缓存</span><br><span class="line">        Object object = delegate.getObject(key);</span><br><span class="line">        if (object == null) &#123;</span><br><span class="line">            // 缓存未命中，则将 key 存入到 entriesMissedInCache 中</span><br><span class="line">            entriesMissedInCache.add(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (clearOnCommit) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return object;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void putObject(Object key, Object object) &#123;</span><br><span class="line">        // 将键值对存入到 entriesToAddOnCommit 中，而非 delegate 缓存中</span><br><span class="line">        entriesToAddOnCommit.put(key, object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object removeObject(Object key) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        clearOnCommit = true;</span><br><span class="line">        // 清空 entriesToAddOnCommit，但不清空 delegate 缓存</span><br><span class="line">        entriesToAddOnCommit.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void commit() &#123;</span><br><span class="line">        // 根据 clearOnCommit 的值决定是否清空 delegate</span><br><span class="line">        if (clearOnCommit) &#123;</span><br><span class="line">            delegate.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 刷新未缓存的结果到 delegate 缓存中</span><br><span class="line">        flushPendingEntries();</span><br><span class="line">        // 重置 entriesToAddOnCommit 和 entriesMissedInCache</span><br><span class="line">        reset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void rollback() &#123;</span><br><span class="line">        unlockMissedEntries();</span><br><span class="line">        reset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void reset() &#123;</span><br><span class="line">        clearOnCommit = false;</span><br><span class="line">        // 清空集合</span><br><span class="line">        entriesToAddOnCommit.clear();</span><br><span class="line">        entriesMissedInCache.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void flushPendingEntries() &#123;</span><br><span class="line">        for (Map.Entry&lt;Object, Object&gt; entry : entriesToAddOnCommit.entrySet()) &#123;</span><br><span class="line">            // 将 entriesToAddOnCommit 中的内容转存到 delegate 中</span><br><span class="line">            delegate.putObject(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        for (Object entry : entriesMissedInCache) &#123;</span><br><span class="line">            if (!entriesToAddOnCommit.containsKey(entry)) &#123;</span><br><span class="line">                // 存入空值</span><br><span class="line">                delegate.putObject(entry, null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void unlockMissedEntries() &#123;</span><br><span class="line">        for (Object entry : entriesMissedInCache) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">				// 调用 removeObject 进行解锁</span><br><span class="line">                delegate.removeObject(entry);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                log.warn(&quot;...&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 TransactionalCache 的代码中，我们要重点关注 entriesToAddOnCommit 集合，TransactionalCache 中的很多方法都会与这个集合打交道。该集合用于存储从查询的结果，那为什么要将结果保存在该集合中，而非 delegate 所表示的缓存中呢？主要是因为直接存到 delegate 会导致脏数据问题。下面通过一张图演示一下脏数据问题发生的过程，假设两个线程开启两个不同的事务，它们的执行过程如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15350410327117.jpg" alt="img"></p>
<p>如上图，时刻2，事务 A 对记录 A 进行了更新。时刻3，事务 A 从数据库查询记录 A，并将记录 A 写入缓存中。时刻4，事务 B 查询记录 A，由于缓存中存在记录 A，事务 B 直接从缓存中取数据。这个时候，脏数据问题就发生了。事务 B 在事务 A 未提交情况下，读取到了事务 A 所修改的记录。为了解决这个问题，我们可以为每个事务引入一个独立的缓存。查询数据时，仍从 delegate 缓存（以下统称为共享缓存）中查询。若缓存未命中，则查询数据库。存储查询结果时，并不直接存储查询结果到共享缓存中，而是先存储到事务缓存中，也就是 entriesToAddOnCommit 集合。当事务提交时，再将事务缓存中的缓存项转存到共享缓存中。这样，事务 B 只能在事务 A 提交后，才能读取到事务 A 所做的修改，解决了脏读问题。整个过程大致如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15351741016583.jpg" alt="img"></p>
<p>如上，时刻2，事务 A 和 B 同时查询记录 A。此时共享缓存中还没没有数据，所以两个事务均会向数据库发起查询请求，并将查询结果存储到各自的事务缓存中。时刻3，事务 A 更新记录 A，这里把更新后的记录 A 记为 A′。时刻4，两个事务再次进行查询。此时，事务 A 读取到的记录为修改后的值，而事务 B 读取到的记录仍为原值。时刻5，事务 A 被提交，并将事务缓存 A 中的内容转存到共享缓存中。时刻6，事务 B 再次查询记录 A，由于共享缓存中有相应的数据，所以直接取缓存数据即可。因此得到记录 A′，而非记录 A。但由于事务 A 已经提交，所以事务 B 读取到的记录 A′ 并非是脏数据。MyBatis 引入事务缓存解决了脏读问题，事务间只能读取到其他事务提交后的内容，这相当于事务隔离级别中的“读已提交（Read Committed）”。但需要注意的时，MyBatis 缓存事务机制只能解决脏读问题，并不能解决“不可重复读”问题。再回到上图，事务 B 在被提交前进行了三次查询。前两次查询得到的结果为记录 A，最后一次查询得到的结果为 A′。最有一次的查询结果与前两次不同，这就会导致“不可重复读”的问题。MyBatis 的缓存事务机制最高只支持“读已提交”，并不能解决“不可重复读”问题。即使数据库使用了更高的隔离级别解决了这个问题，但因 MyBatis 缓存事务机制级别较低。此时仍然会导致“不可重复读”问题的发生，这个在日常开发中需要注意一下。</p>
<p>下面写点测试代码验证 MyBatis 所导致的“不可重复读”问题，首先看一下实体类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    </span><br><span class="line">    // 省略 getter/setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的数据表如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       student</span><br><span class="line">+----+----------+------+</span><br><span class="line">| id | name     | age  |</span><br><span class="line">+----+----------+------+</span><br><span class="line">|  1 | coolblog |   20 |</span><br><span class="line">+----+----------+------+</span><br></pre></td></tr></table></figure>

<p>Dao 接口与映射文件定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface StudentDao &#123;</span><br><span class="line">    Student findOne(@Param(&quot;id&quot;) Integer id);</span><br><span class="line">    int update(@Param(&quot;id&quot;) Integer id, @Param(&quot;name&quot;) String name);</span><br><span class="line">&#125;</span><br><span class="line">&lt;mapper namespace=&quot;xyz.coolblog.dao.StudentDao&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 注意要在映射文件中配置缓存 --&gt;</span><br><span class="line">    &lt;cache/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=&quot;findOne&quot; resultType=&quot;xyz.coolblog.model.Student&quot;&gt;</span><br><span class="line">        SELECT</span><br><span class="line">            `id`, `name`, `age`</span><br><span class="line">        FROM</span><br><span class="line">            student</span><br><span class="line">        WHERE</span><br><span class="line">            id = #&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;update id=&quot;update&quot;&gt;</span><br><span class="line">        UPDATE</span><br><span class="line">            student</span><br><span class="line">        SET</span><br><span class="line">            `name` = #&#123;name&#125;</span><br><span class="line">        WHERE</span><br><span class="line">            id = #&#123;id&#125;</span><br><span class="line">    &lt;/update&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>测试代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TransactionalCacheTest &#123;</span><br><span class="line"></span><br><span class="line">    private SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    private CountDownLatch countDownLatch = new CountDownLatch(1);</span><br><span class="line">    </span><br><span class="line">    @Before</span><br><span class="line">    public void prepare() throws IOException &#123;</span><br><span class="line">        String resource = &quot;mybatis-transactional-cache-config.xml&quot;;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testTransactional() throws IOException, InterruptedException, ExecutionException &#123;</span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(2);</span><br><span class="line">        // 开启两个线程</span><br><span class="line">        Future&lt;String&gt; fa = es.submit(this::transactionalA);</span><br><span class="line">        Future&lt;String&gt; fb = es.submit(this::transactionalB);</span><br><span class="line"></span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">        es.awaitTermination(6, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        System.out.println(fa.get());</span><br><span class="line">        System.out.println(&quot;\n -------- 分割线 ------- \n&quot;);</span><br><span class="line">        System.out.println(fb.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String transactionalA() throws Exception &#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        StudentDao studentDao = sqlSession.getMapper(StudentDao.class);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        sb.append(&quot;时刻1：开启事务 A\n&quot;);</span><br><span class="line">        sb.append(&quot;时刻2：查询记录 A\n&quot;);</span><br><span class="line"></span><br><span class="line">        Student s1 = studentDao.findOne(1);</span><br><span class="line">        sb.append(s1).append(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">        sb.append(&quot;时刻3：更新记录 A\n&quot;);</span><br><span class="line">        studentDao.update(1, &quot;tianxiaobo&quot;);</span><br><span class="line">        sb.append(&quot;时刻4：查询记录 A&#x27;\n&quot;);</span><br><span class="line">        Student s2 = studentDao.findOne(1);</span><br><span class="line">        sb.append(s2).append(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">        // 此处睡眠1秒，让事务 B 在事务 A 提交前，完成时刻4的查询请求</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">        sb.append(&quot;时刻5：提交事务 A&quot;);</span><br><span class="line">        sqlSession.commit();</span><br><span class="line"></span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String transactionalB() throws Exception &#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        StudentDao studentDao = sqlSession.getMapper(StudentDao.class);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        sb.append(&quot;时刻1：开启事务 B\n&quot;);</span><br><span class="line">        sb.append(&quot;时刻2：查询数据 A\n&quot;);</span><br><span class="line">        Student s1 = studentDao.findOne(1);</span><br><span class="line">        sb.append(s1).append(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">        sb.append(&quot;时刻3：---------\n&quot;);</span><br><span class="line">        sb.append(&quot;时刻4：查询数据 A\n&quot;);</span><br><span class="line">        Student s2 = studentDao.findOne(1);</span><br><span class="line">        sb.append(s2).append(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">        // 此处睡眠3秒，等待事务 A 提交</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line"></span><br><span class="line">        sb.append(&quot;时刻5：---------\n&quot;);</span><br><span class="line">        sb.append(&quot;时刻6：查询数据 A&#x27;\n&quot;);</span><br><span class="line">        Student s3 = studentDao.findOne(1);</span><br><span class="line">        sb.append(s3).append(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">        sb.append(&quot;时刻7：提交事务 B&quot;);</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后对输出结果进行简单的美化，如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15351259392691.jpg" alt="img"></p>
<p>如上，事务 B 在时刻2和时刻4读取到的记录与数据库中的记录一致，表示可重复读。但当事务 A 提交后，事务 B 在时刻6读取到的数据则是事务 A 修改的内容，这个时候就出现了“不可重复读”问题。以上测试是基于 MySql 数据可读，MySQL 默认事务级别为“可重复读”。</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15351270530717.jpg" alt="img"></p>
<p>下面在本地开启两个 MySQL 客户端，模拟上面的执行流程。最终结果如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15351281217963.jpg" alt="img"></p>
<p>从测试结果可以看出，不可重复读问题并未发生，事务 B 三次查询结果均相同。好了，到此关于 MyBatis 二级缓存所引发的问题就分析完了。</p>
<p>接下来，我们再来看一下 entriesMissedInCache 集合，这个集合是用于存储未命中缓存的查询请求对应的 CacheKey。单独分析与 entriesMissedInCache 相关的逻辑没什么意义，要搞清 entriesMissedInCache 的实际用途，需要把它和 BlockingCache 的逻辑结合起来进行分析。在 BlockingCache，同一时刻仅允许一个线程通过 getObject 方法查询指定 key 对应的缓存项。如果缓存未命中，getObject 方法不会释放锁，导致其他线程被阻塞住。其他线程要想恢复运行，必须进行解锁，解锁逻辑由 BlockingCache 的 putObject 和 removeObject 方法执行。其中 putObject 会在 TransactionalCache 的 flushPendingEntries 方法中被调用，removeObject 方法则由 TransactionalCache 的 unlockMissedEntries 方法调用。flushPendingEntries 和 unlockMissedEntries 最终都会遍历 entriesMissedInCache 集合，并将集合元素传给 BlockingCache 的相关方法。这样可以解开指定 key 对应的锁，让阻塞线程恢复运行。</p>
<p>最后特别说明一下，本节的内容参考了<a href="https://www.amazon.cn/dp/B073LWG7F7/ref=sr_1_1?ie=UTF8&qid=1535112987&sr=8-1&keywords=mybatis%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95">《MyBatis技术内幕》</a> 一书中关于缓存的一些分析，这里向这本书的作者表示感谢。如果大家不是很能看懂上面的内容，也可参考这本书的部分章节。</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h2><p>本篇文章简单介绍了一些缓存类的实现，并对一二级缓存进行了深入分析。本文仅分析了缓存的使用过程，并未对缓存的初始化，以及 CachingExecutor 和 SimpleExecutor（继承自 BaseExecutor）创建过程进行分析。相关内容已在本系列之前的文章中已分析过，再次分析有点赘述。对于本文忽略掉的部分，希望大家可以自行探索，或者阅读我之前写的文章。</p>
<p>好了，到此本篇文章就结束了。谢谢大家的阅读。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://book.douban.com/subject/27087564/">《MyBatis 技术内幕》- 徐郡明</a></li>
<li><a href="http://www.mybatis.org/mybatis-3/zh/index.html">MyBatis 官方文档</a></li>
</ul>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis源码分析-SQL的执行过程</title>
    <url>/2022/10/25/MyBatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-SQL%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="1-本文速览"><a href="#1-本文速览" class="headerlink" title="1.本文速览"></a>1.本文速览</h2><p>本篇文章较为详细的介绍了 MyBatis 执行 SQL 的过程。该过程本身比较复杂，牵涉到的技术点比较多。包括但不限于 Mapper 接口代理类的生成、接口方法的解析、SQL 语句的解析、运行时参数的绑定、查询结果自动映射、延迟加载等。本文对所列举的技术点，以及部分未列举的技术点都做了较为详细的分析。全文篇幅很大，需要大家耐心阅读。下面来看一下本文的目录：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15344933870130.jpg" alt="img"></p>
<p>源码分析类文章通常比较枯燥。因此，我在分析源码的过程中写了一些示例，同时也绘制了一些图片。希望通过这些示例和图片，帮助大家理解 MyBatis 的源码。</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15344935868615.jpg" alt="img"></p>
<p>本篇文章篇幅很大，全文字数约 26000 字，阅读时间预计超过 100 分钟。通读本文可能会比较累，大家可以分次阅读。好了，本文的速览就先到这，下面进入正文。</p>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>在前面的文章中，我分析了配置文件和映射文件的解析过程。经过前面复杂的解析过程后，现在，MyBatis 已经进入了就绪状态，等待使用者发号施令。本篇文章我将分析MyBatis 执行 SQL 的过程，该过程比较复杂，涉及的技术点很多。包括但不限于以下技术点：</p>
<ol>
<li>为 mapper 接口生成实现类</li>
<li>根据配置信息生成 SQL，并将运行时参数设置到 SQL 中</li>
<li>一二级缓存的实现</li>
<li>插件机制</li>
<li>数据库连接的获取与管理</li>
<li>查询结果的处理，以及延迟加载等</li>
</ol>
<p>如果大家能掌握上面的技术点，那么对 MyBatis 的原理将会有很深入的理解。若将以上技术点一一展开分析，会导致文章篇幅很大，因此我打算将以上知识点分成数篇文章进行分析。本篇文章将分析以上列表中的第1个、第2个以及第6个技术点，其他技术点将会在随后的文章中进行分析。好了，其他的就不多说了，下面开始我们的源码分析之旅。</p>
<h2 id="2-SQL-执行过程分析"><a href="#2-SQL-执行过程分析" class="headerlink" title="2.SQL 执行过程分析"></a>2.SQL 执行过程分析</h2><h3 id="2-1-SQL-执行入口分析"><a href="#2-1-SQL-执行入口分析" class="headerlink" title="2.1 SQL 执行入口分析"></a>2.1 SQL 执行入口分析</h3><p>在单独使用 MyBatis 进行数据库操作时，我们通常都会先调用 SqlSession 接口的 getMapper 方法为我们的 Mapper 接口生成实现类。然后就可以通过 Mapper 进行数据库操作。比如像下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArticleMapper articleMapper = session.getMapper(ArticleMapper.class);</span><br><span class="line">Article article = articleMapper.findOne(1);</span><br></pre></td></tr></table></figure>

<p>如果大家对 MyBatis 较为理解，会知道 SqlSession 是通过 JDK 动态代理的方式为接口生成代理对象的。在调用接口方法时，方法调用会被代理逻辑拦截。在代理逻辑中可根据方法名及方法归属接口获取到当前方法对应的 SQL 以及其他一些信息，拿到这些信息即可进行数据库操作。</p>
<p>上面是一个简版的 SQL 执行过程，省略了很多细节。下面我们先按照这个简版的流程进行分析，首先我们来看一下 Mapper 接口的代理对象创建过程。</p>
<h4 id="2-1-1-为-Mapper-接口创建代理对象"><a href="#2-1-1-为-Mapper-接口创建代理对象" class="headerlink" title="2.1.1 为 Mapper 接口创建代理对象"></a>2.1.1 为 Mapper 接口创建代理对象</h4><p>本节，我们从 DefaultSqlSession 的 getMapper 方法开始看起，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- DefaultSqlSession</span><br><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type) &#123;</span><br><span class="line">    return configuration.&lt;T&gt;getMapper(type, this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// -☆- Configuration</span><br><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123;</span><br><span class="line">    return mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// -☆- MapperRegistry</span><br><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123;</span><br><span class="line">    // 从 knownMappers 中获取与 type 对应的 MapperProxyFactory</span><br><span class="line">    final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    if (mapperProxyFactory == null) &#123;</span><br><span class="line">        throw new BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 创建代理对象</span><br><span class="line">        return mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new BindingException(&quot;Error getting mapper instance. Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，经过连续的调用，Mapper 接口代理对象的创建逻辑初现端倪。如果没看过我前面的分析文章，大家可能不知道 knownMappers 集合中的元素是何时存入的。这里再说一遍吧，MyBatis 在解析配置文件的 <mappers> 节点的过程中，会调用 MapperRegistry 的 addMapper 方法将 Class 到 MapperProxyFactory 对象的映射关系存入到 knownMappers。具体的代码就不分析了，大家可以阅读我之前写的文章，或者自行分析相关的代码。</mappers></p>
<p>在获取到 MapperProxyFactory 对象后，即可调用工厂方法为 Mapper 接口生成代理对象了。相关逻辑如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- MapperProxyFactory</span><br><span class="line">public T newInstance(SqlSession sqlSession) &#123;</span><br><span class="line">    /*</span><br><span class="line">     * 创建 MapperProxy 对象，MapperProxy 实现了 </span><br><span class="line">     * InvocationHandler 接口，代理逻辑封装在此类中</span><br><span class="line">     */</span><br><span class="line">    final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    return newInstance(mapperProxy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123;</span><br><span class="line">    // 通过 JDK 动态代理创建代理对象</span><br><span class="line">    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[]&#123;mapperInterface&#125;, mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码首先创建了一个 MapperProxy 对象，该对象实现了 InvocationHandler 接口。然后将对象作为参数传给重载方法，并在重载方法中调用 JDK 动态代理接口为 Mapper 生成代理对象。</p>
<p>到此，关于 Mapper 接口代理对象的创建过程就分析完了。现在我们的 ArticleMapper 接口指向的代理对象已经创建完毕，下面就可以调用接口方法进行数据库操作了。由于接口方法会被代理逻辑拦截，所以下面我们把目光聚焦在代理逻辑上面，看看代理逻辑会做哪些事情。</p>
<h4 id="2-1-2-执行代理逻辑"><a href="#2-1-2-执行代理逻辑" class="headerlink" title="2.1.2 执行代理逻辑"></a>2.1.2 执行代理逻辑</h4><p>在 MyBatis 中，Mapper 接口方法的代理逻辑实现的比较简单。该逻辑首先会对拦截的方法进行一些检测，以决定是否执行后续的数据库操作。对应的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 如果方法是定义在 Object 类中的，则直接调用</span><br><span class="line">        if (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">            return method.invoke(this, args);</span><br><span class="line">            </span><br><span class="line">        /*</span><br><span class="line">         * 下面的代码最早出现在 mybatis-3.4.2 版本中，用于支持 JDK 1.8 中的</span><br><span class="line">         * 新特性 - 默认方法。这段代码的逻辑就不分析了，有兴趣的同学可以</span><br><span class="line">         * 去 Github 上看一下相关的相关的讨论（issue #709），链接如下：</span><br><span class="line">         * </span><br><span class="line">         *   https://github.com/mybatis/mybatis-3/issues/709</span><br><span class="line">         */  </span><br><span class="line">        &#125; else if (isDefaultMethod(method)) &#123;</span><br><span class="line">            return invokeDefaultMethod(proxy, method, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        throw ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 从缓存中获取 MapperMethod 对象，若缓存未命中，则创建 MapperMethod 对象</span><br><span class="line">    final MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">    </span><br><span class="line">    // 调用 execute 方法执行 SQL</span><br><span class="line">    return mapperMethod.execute(sqlSession, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，代理逻辑会首先检测被拦截的方法是不是定义在 Object 中的，比如 equals、hashCode 方法等。对于这类方法，直接执行即可。除此之外，MyBatis 从 3.4.2 版本开始，对 JDK 1.8 接口的默认方法提供了支持，具体就不分析了。完成相关检测后，紧接着从缓存中获取或者创建 MapperMethod 对象，然后通过该对象中的 execute 方法执行 SQL。在分析 execute 方法之前，我们先来看一下 MapperMethod 对象的创建过程。MapperMethod 的创建过程看似普通，但却包含了一些重要的逻辑，所以不能忽视。</p>
<h5 id="2-1-2-1-创建-MapperMethod-对象"><a href="#2-1-2-1-创建-MapperMethod-对象" class="headerlink" title="2.1.2.1 创建 MapperMethod 对象"></a>2.1.2.1 创建 MapperMethod 对象</h5><p>本节来分析一下 MapperMethod 的构造方法，看看它的构造方法中都包含了哪些逻辑。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MapperMethod &#123;</span><br><span class="line"></span><br><span class="line">    private final SqlCommand command;</span><br><span class="line">    private final MethodSignature method;</span><br><span class="line"></span><br><span class="line">    public MapperMethod(Class&lt;?&gt; mapperInterface, Method method, Configuration config) &#123;</span><br><span class="line">        // 创建 SqlCommand 对象，该对象包含一些和 SQL 相关的信息</span><br><span class="line">        this.command = new SqlCommand(config, mapperInterface, method);</span><br><span class="line">        // 创建 MethodSignature 对象，从类名中可知，该对象包含了被拦截方法的一些信息</span><br><span class="line">        this.method = new MethodSignature(config, mapperInterface, method);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，MapperMethod 构造方法的逻辑很简单，主要是创建 SqlCommand 和 MethodSignature 对象。这两个对象分别记录了不同的信息，这些信息在后续的方法调用中都会被用到。下面我们深入到这两个类的构造方法中，探索它们的初始化逻辑。</p>
<h6 id="①-创建-SqlCommand-对象"><a href="#①-创建-SqlCommand-对象" class="headerlink" title="① 创建 SqlCommand 对象"></a>① 创建 SqlCommand 对象</h6><p>前面说了 SqlCommand 中保存了一些和 SQL 相关的信息，那具体有哪些信息呢？答案在下面的代码中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static class SqlCommand &#123;</span><br><span class="line"></span><br><span class="line">    private final String name;</span><br><span class="line">    private final SqlCommandType type;</span><br><span class="line"></span><br><span class="line">    public SqlCommand(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method) &#123;</span><br><span class="line">        final String methodName = method.getName();</span><br><span class="line">        final Class&lt;?&gt; declaringClass = method.getDeclaringClass();</span><br><span class="line">        // 解析 MappedStatement</span><br><span class="line">        MappedStatement ms = resolveMappedStatement(mapperInterface, methodName, declaringClass, configuration);</span><br><span class="line">        </span><br><span class="line">        // 检测当前方法是否有对应的 MappedStatement</span><br><span class="line">        if (ms == null) &#123;</span><br><span class="line">            // 检测当前方法是否有 @Flush 注解</span><br><span class="line">            if (method.getAnnotation(Flush.class) != null) &#123;</span><br><span class="line">                // 设置 name 和 type 遍历</span><br><span class="line">                name = null;</span><br><span class="line">                type = SqlCommandType.FLUSH;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                /*</span><br><span class="line">                 * 若 ms == null 且方法无 @Flush 注解，此时抛出异常。</span><br><span class="line">                 * 这个异常比较常见，大家应该眼熟吧</span><br><span class="line">                 */ </span><br><span class="line">                throw new BindingException(&quot;Invalid bound statement (not found): &quot;</span><br><span class="line">                    + mapperInterface.getName() + &quot;.&quot; + methodName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 设置 name 和 type 变量</span><br><span class="line">            name = ms.getId();</span><br><span class="line">            type = ms.getSqlCommandType();</span><br><span class="line">            if (type == SqlCommandType.UNKNOWN) &#123;</span><br><span class="line">                throw new BindingException(&quot;Unknown execution method for: &quot; + name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，SqlCommand 的构造方法主要用于初始化它的两个成员变量。代码不是很长，逻辑也不难理解，就不多说了。继续往下看。</p>
<h6 id="②-创建-MethodSignature-对象"><a href="#②-创建-MethodSignature-对象" class="headerlink" title="② 创建 MethodSignature 对象"></a>② 创建 MethodSignature 对象</h6><p>MethodSignature 即方法签名，顾名思义，该类保存了一些和目标方法相关的信息。比如目标方法的返回类型，目标方法的参数列表信息等。下面，我们来分析一下 MethodSignature 的构造方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static class MethodSignature &#123;</span><br><span class="line"></span><br><span class="line">    private final boolean returnsMany;</span><br><span class="line">    private final boolean returnsMap;</span><br><span class="line">    private final boolean returnsVoid;</span><br><span class="line">    private final boolean returnsCursor;</span><br><span class="line">    private final Class&lt;?&gt; returnType;</span><br><span class="line">    private final String mapKey;</span><br><span class="line">    private final Integer resultHandlerIndex;</span><br><span class="line">    private final Integer rowBoundsIndex;</span><br><span class="line">    private final ParamNameResolver paramNameResolver;</span><br><span class="line"></span><br><span class="line">    public MethodSignature(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method) &#123;</span><br><span class="line"></span><br><span class="line">        // 通过反射解析方法返回类型</span><br><span class="line">        Type resolvedReturnType = TypeParameterResolver.resolveReturnType(method, mapperInterface);</span><br><span class="line">        if (resolvedReturnType instanceof Class&lt;?&gt;) &#123;</span><br><span class="line">            this.returnType = (Class&lt;?&gt;) resolvedReturnType;</span><br><span class="line">        &#125; else if (resolvedReturnType instanceof ParameterizedType) &#123;</span><br><span class="line">            this.returnType = (Class&lt;?&gt;) ((ParameterizedType) resolvedReturnType).getRawType();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.returnType = method.getReturnType();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 检测返回值类型是否是 void、集合或数组、Cursor、Map 等</span><br><span class="line">        this.returnsVoid = void.class.equals(this.returnType);</span><br><span class="line">        this.returnsMany = configuration.getObjectFactory().isCollection(this.returnType) || this.returnType.isArray();</span><br><span class="line">        this.returnsCursor = Cursor.class.equals(this.returnType);</span><br><span class="line">        // 解析 @MapKey 注解，获取注解内容</span><br><span class="line">        this.mapKey = getMapKey(method);</span><br><span class="line">        this.returnsMap = this.mapKey != null;</span><br><span class="line">        /*</span><br><span class="line">         * 获取 RowBounds 参数在参数列表中的位置，如果参数列表中</span><br><span class="line">         * 包含多个 RowBounds 参数，此方法会抛出异常</span><br><span class="line">         */ </span><br><span class="line">        this.rowBoundsIndex = getUniqueParamIndex(method, RowBounds.class);</span><br><span class="line">        // 获取 ResultHandler 参数在参数列表中的位置</span><br><span class="line">        this.resultHandlerIndex = getUniqueParamIndex(method, ResultHandler.class);</span><br><span class="line">        // 解析参数列表</span><br><span class="line">        this.paramNameResolver = new ParamNameResolver(configuration, method);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码用于检测目标方法的返回类型，以及解析目标方法参数列表。其中，检测返回类型的目的是为避免查询方法返回错误的类型。比如我们要求接口方法返回一个对象，结果却返回了对象集合，这会导致类型转换错误。关于返回值类型的解析过程先说到这，下面分析参数列表的解析过程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ParamNameResolver &#123;</span><br><span class="line"></span><br><span class="line">    private static final String GENERIC_NAME_PREFIX = &quot;param&quot;;</span><br><span class="line">    private final SortedMap&lt;Integer, String&gt; names;</span><br><span class="line"></span><br><span class="line">    public ParamNameResolver(Configuration config, Method method) &#123;</span><br><span class="line">        // 获取参数类型列表</span><br><span class="line">        final Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span><br><span class="line">        // 获取参数注解</span><br><span class="line">        final Annotation[][] paramAnnotations = method.getParameterAnnotations();</span><br><span class="line">        final SortedMap&lt;Integer, String&gt; map = new TreeMap&lt;Integer, String&gt;();</span><br><span class="line">        int paramCount = paramAnnotations.length;</span><br><span class="line"></span><br><span class="line">        for (int paramIndex = 0; paramIndex &lt; paramCount; paramIndex++) &#123;</span><br><span class="line">            // 检测当前的参数类型是否为 RowBounds 或 ResultHandler</span><br><span class="line">            if (isSpecialParameter(paramTypes[paramIndex])) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            String name = null;</span><br><span class="line">            for (Annotation annotation : paramAnnotations[paramIndex]) &#123;</span><br><span class="line">                if (annotation instanceof Param) &#123;</span><br><span class="line">                    hasParamAnnotation = true;</span><br><span class="line">                    // 获取 @Param 注解内容</span><br><span class="line">                    name = ((Param) annotation).value();</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // name 为空，表明未给参数配置 @Param 注解</span><br><span class="line">            if (name == null) &#123;</span><br><span class="line">                // 检测是否设置了 useActualParamName 全局配置</span><br><span class="line">                if (config.isUseActualParamName()) &#123;</span><br><span class="line">                    /*</span><br><span class="line">                     * 通过反射获取参数名称。此种方式要求 JDK 版本为 1.8+，</span><br><span class="line">                     * 且要求编译时加入 -parameters 参数，否则获取到的参数名</span><br><span class="line">                     * 仍然是 arg1, arg2, ..., argN</span><br><span class="line">                     */</span><br><span class="line">                    name = getActualParamName(method, paramIndex);</span><br><span class="line">                &#125;</span><br><span class="line">                if (name == null) &#123;</span><br><span class="line">                    /*</span><br><span class="line">                     * 使用 map.size() 返回值作为名称，思考一下为什么不这样写：</span><br><span class="line">                     *   name = String.valueOf(paramIndex);</span><br><span class="line">                     * 因为如果参数列表中包含 RowBounds 或 ResultHandler，这两个参数</span><br><span class="line">                     * 会被忽略掉，这样将导致名称不连续。</span><br><span class="line">                     *</span><br><span class="line">                     * 比如参数列表 (int p1, int p2, RowBounds rb, int p3)</span><br><span class="line">                     *  - 期望得到名称列表为 [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]</span><br><span class="line">                     *  - 实际得到名称列表为 [&quot;0&quot;, &quot;1&quot;, &quot;3&quot;]</span><br><span class="line">                     */</span><br><span class="line">                    name = String.valueOf(map.size());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 存储 paramIndex 到 name 的映射</span><br><span class="line">            map.put(paramIndex, name);</span><br><span class="line">        &#125;</span><br><span class="line">        names = Collections.unmodifiableSortedMap(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是方法参数列表的解析过程，解析完毕后，可得到参数下标到参数名的映射关系，这些映射关系最终存储在 ParamNameResolver 的 names 成员变量中。这些映射关系将会在后面的代码中被用到，大家留意一下。</p>
<p>下面写点代码测试一下 ParamNameResolver 的解析逻辑。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ParamNameResolverTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test() throws NoSuchMethodException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        Configuration config = new Configuration();</span><br><span class="line">        config.setUseActualParamName(false);</span><br><span class="line">        Method method = ArticleMapper.class.getMethod(&quot;select&quot;, Integer.class, String.class, RowBounds.class, Article.class);</span><br><span class="line"></span><br><span class="line">        ParamNameResolver resolver = new ParamNameResolver(config, method);</span><br><span class="line">        Field field = resolver.getClass().getDeclaredField(&quot;names&quot;);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        // 通过反射获取 ParamNameResolver 私有成员变量 names</span><br><span class="line">        Object names = field.get(resolver);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;names: &quot; + names);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class ArticleMapper &#123;</span><br><span class="line">        public void select(@Param(&quot;id&quot;) Integer id, @Param(&quot;author&quot;) String author, RowBounds rb, Article article) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15332278473776.jpg" alt="img"></p>
<p>参数索引与名称映射图如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15332286696017.jpg" alt="img"></p>
<p>到此，关于 MapperMethod 的初始化逻辑就分析完了，继续往下分析。</p>
<h5 id="2-1-2-2-执行-execute-方法"><a href="#2-1-2-2-执行-execute-方法" class="headerlink" title="2.1.2.2 执行 execute 方法"></a>2.1.2.2 执行 execute 方法</h5><p>前面已经分析了 MapperMethod 的初始化过程，现在 MapperMethod 创建好了。那么，接下来要做的事情是调用 MapperMethod 的 execute 方法，执行 SQL。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- MapperMethod</span><br><span class="line">public Object execute(SqlSession sqlSession, Object[] args) &#123;</span><br><span class="line">    Object result;</span><br><span class="line">    </span><br><span class="line">    // 根据 SQL 类型执行相应的数据库操作</span><br><span class="line">    switch (command.getType()) &#123;</span><br><span class="line">        case INSERT: &#123;</span><br><span class="line">            // 对用户传入的参数进行转换，下同</span><br><span class="line">            Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">            // 执行插入操作，rowCountResult 方法用于处理返回值</span><br><span class="line">            result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case UPDATE: &#123;</span><br><span class="line">            Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">            // 执行更新操作</span><br><span class="line">            result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case DELETE: &#123;</span><br><span class="line">            Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">            // 执行删除操作</span><br><span class="line">            result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case SELECT:</span><br><span class="line">            // 根据目标方法的返回类型进行相应的查询操作</span><br><span class="line">            if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">                /*</span><br><span class="line">                 * 如果方法返回值为 void，但参数列表中包含 ResultHandler，表明使用者</span><br><span class="line">                 * 想通过 ResultHandler 的方式获取查询结果，而非通过返回值获取结果</span><br><span class="line">                 */</span><br><span class="line">                executeWithResultHandler(sqlSession, args);</span><br><span class="line">                result = null;</span><br><span class="line">            &#125; else if (method.returnsMany()) &#123;</span><br><span class="line">                // 执行查询操作，并返回多个结果 </span><br><span class="line">                result = executeForMany(sqlSession, args);</span><br><span class="line">            &#125; else if (method.returnsMap()) &#123;</span><br><span class="line">                // 执行查询操作，并将结果封装在 Map 中返回</span><br><span class="line">                result = executeForMap(sqlSession, args);</span><br><span class="line">            &#125; else if (method.returnsCursor()) &#123;</span><br><span class="line">                // 执行查询操作，并返回一个 Cursor 对象</span><br><span class="line">                result = executeForCursor(sqlSession, args);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">                // 执行查询操作，并返回一个结果</span><br><span class="line">                result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case FLUSH:</span><br><span class="line">            // 执行刷新操作</span><br><span class="line">            result = sqlSession.flushStatements();</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            throw new BindingException(&quot;Unknown execution method for: &quot; + command.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 如果方法的返回值为基本类型，而返回值却为 null，此种情况下应抛出异常</span><br><span class="line">    if (result == null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">        throw new BindingException(&quot;Mapper method &#x27;&quot; + command.getName()</span><br><span class="line">            + &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType()</span><br><span class="line">            + &quot;).&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，execute 方法主要由一个 switch 语句组成，用于根据 SQL 类型执行相应的数据库操作。该方法的逻辑清晰，不需要太多的分析。不过在上面的方法中 convertArgsToSqlCommandParam 方法出现次数比较频繁，这里分析一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- MapperMethod</span><br><span class="line">public Object convertArgsToSqlCommandParam(Object[] args) &#123;</span><br><span class="line">    return paramNameResolver.getNamedParams(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Object getNamedParams(Object[] args) &#123;</span><br><span class="line">    final int paramCount = names.size();</span><br><span class="line">    if (args == null || paramCount == 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125; else if (!hasParamAnnotation &amp;&amp; paramCount == 1) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * 如果方法参数列表无 @Param 注解，且仅有一个非特别参数，则返回该参数的值。</span><br><span class="line">         * 比如如下方法：</span><br><span class="line">         *     List findList(RowBounds rb, String name)</span><br><span class="line">         * names 如下：</span><br><span class="line">         *     names = &#123;1 : &quot;0&quot;&#125;</span><br><span class="line">         * 此种情况下，返回 args[names.firstKey()]，即 args[1] -&gt; name</span><br><span class="line">         */</span><br><span class="line">        return args[names.firstKey()];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        final Map&lt;String, Object&gt; param = new ParamMap&lt;Object&gt;();</span><br><span class="line">        int i = 0;</span><br><span class="line">        for (Map.Entry&lt;Integer, String&gt; entry : names.entrySet()) &#123;</span><br><span class="line">            // 添加 &lt;参数名, 参数值&gt; 键值对到 param 中</span><br><span class="line">            param.put(entry.getValue(), args[entry.getKey()]);</span><br><span class="line">            // genericParamName = param + index。比如 param1, param2, ... paramN</span><br><span class="line">            final String genericParamName = GENERIC_NAME_PREFIX + String.valueOf(i + 1);</span><br><span class="line">            /*</span><br><span class="line">             * 检测 names 中是否包含 genericParamName，什么情况下会包含？答案如下：</span><br><span class="line">             *</span><br><span class="line">             *   使用者显式将参数名称配置为 param1，即 @Param(&quot;param1&quot;)</span><br><span class="line">             */</span><br><span class="line">            if (!names.containsValue(genericParamName)) &#123;</span><br><span class="line">                // 添加 &lt;param*, value&gt; 到 param 中</span><br><span class="line">                param.put(genericParamName, args[entry.getKey()]);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return param;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，convertArgsToSqlCommandParam 是一个空壳方法，该方法最终调用了 ParamNameResolver 的 getNamedParams 方法。getNamedParams 方法的主要逻辑是根据条件返回不同的结果，该方法的代码不是很难理解，我也进行了比较详细的注释，就不多说了。</p>
<p>分析完 convertArgsToSqlCommandParam 的逻辑，接下来说说 MyBatis 对哪些 SQL 指令提供了支持，如下：</p>
<ul>
<li>查询语句：SELECT</li>
<li>更新语句：INSERT&#x2F;UPDATE&#x2F;DELETE</li>
<li>存储过程：CALL</li>
</ul>
<p>在上面的列表中，我刻意对 SELECT&#x2F;INSERT&#x2F;UPDATE&#x2F;DELETE 等指令进行了分类，分类依据指令的功能以及 MyBatis 执行这些指令的过程。这里把 SELECT 称为查询语句，INSERT&#x2F;UPDATE&#x2F;DELETE 等称为更新语句。接下来，先来分析查询语句的执行过程。</p>
<h3 id="2-2-查询语句的执行过程分析"><a href="#2-2-查询语句的执行过程分析" class="headerlink" title="2.2 查询语句的执行过程分析"></a>2.2 查询语句的执行过程分析</h3><p>查询语句对应的方法比较多，有如下几种：</p>
<ul>
<li>executeWithResultHandler</li>
<li>executeForMany</li>
<li>executeForMap</li>
<li>executeForCursor</li>
</ul>
<p>这些方法在内部调用了 SqlSession 中的一些 select* 方法，比如 selectList、selectMap、selectCursor 等。这些方法的返回值类型是不同的，因此对于每种返回类型，需要有专门的处理方法。以 selectList 方法为例，该方法的返回值类型为 List。但如果我们的 Mapper 或 Dao 的接口方法返回值类型为数组，或者 Set，直接将 List 类型的结果返回给 Mapper&#x2F;Dao 就不合适了。execute* 等方法只是对 select* 等方法做了一层简单的封装，因此接下来我们应该把目光放在这些 select* 方法上。下面我们来分析一下 selectOne 方法的源码，如下：</p>
<h4 id="2-2-1-selectOne-方法分析"><a href="#2-2-1-selectOne-方法分析" class="headerlink" title="2.2.1 selectOne 方法分析"></a>2.2.1 selectOne 方法分析</h4><p>本节选择分析 selectOne 方法，而不是其他的方法，大家或许会觉得奇怪。前面提及了 selectList、selectMap、selectCursor 等方法，这里却分析一个未提及的方法。这样做并没什么特别之处，主要原因是 selectOne 在内部会调用 selectList 方法。这里分析 selectOne 方法是为了告知大家，selectOne 和 selectList 方法是有联系的，同时分析 selectOne 方法等同于分析 selectList 方法。如果你不信的话，那我们看源码吧，源码面前了无秘密。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- DefaultSqlSession</span><br><span class="line">public &lt;T&gt; T selectOne(String statement, Object parameter) &#123;</span><br><span class="line">    // 调用 selectList 获取结果</span><br><span class="line">    List&lt;T&gt; list = this.&lt;T&gt;selectList(statement, parameter);</span><br><span class="line">    if (list.size() == 1) &#123;</span><br><span class="line">        // 返回结果</span><br><span class="line">        return list.get(0);</span><br><span class="line">    &#125; else if (list.size() &gt; 1) &#123;</span><br><span class="line">        // 如果查询结果大于1则抛出异常，这个异常也是很常见的</span><br><span class="line">        throw new TooManyResultsException(</span><br><span class="line">            &quot;Expected one result (or null) to be returned by selectOne(), but found: &quot; + list.size());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，selectOne 方法在内部调用 selectList 了方法，并取 selectList 返回值的第1个元素作为自己的返回值。如果 selectList 返回的列表元素大于1，则抛出异常。上面代码比较易懂，就不多说了。下面我们来看看 selectList 方法的实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- DefaultSqlSession</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) &#123;</span><br><span class="line">    // 调用重载方法</span><br><span class="line">    return this.selectList(statement, parameter, RowBounds.DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private final Executor executor;</span><br><span class="line"></span><br><span class="line">public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 获取 MappedStatement</span><br><span class="line">        MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">        // 调用 Executor 实现类中的 query 方法</span><br><span class="line">        return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw ExceptionFactory.wrapException(&quot;Error querying database.  Cause: &quot; + e, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，这里要来说说 executor 变量，该变量类型为 Executor。Executor 是一个接口，它的实现类如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15336511991684.jpg" alt="img"></p>
<p>如上，Executor 有这么多的实现类，大家猜一下 executor 变量对应哪个实现类。要弄清楚这个问题，需要大家到源头去查证。这里提示一下，大家可以跟踪一下 DefaultSqlSessionFactory 的 openSession 方法，很快就能发现executor 变量创建的踪迹。限于篇幅原因，本文就不分析 openSession 方法的源码了。好了，下面我来直接告诉大家 executor 变量对应哪个实现类吧。默认情况下，executor 的类型为 CachingExecutor，该类是一个装饰器类，用于给目标 Executor 增加二级缓存功能。那目标 Executor 是谁呢？默认情况下是 SimpleExecutor。</p>
<p>现在大家搞清楚 executor 变量的身份了，接下来继续分析 selectOne 方法的调用栈。先来看看 CachingExecutor 的 query 方法是怎样实现的。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- CachingExecutor</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException &#123;</span><br><span class="line">    // 获取 BoundSql</span><br><span class="line">    BoundSql boundSql = ms.getBoundSql(parameterObject);</span><br><span class="line">    // 创建 CacheKey</span><br><span class="line">    CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">    // 调用重载方法</span><br><span class="line">    return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码用于获取 BoundSql 对象，创建 CacheKey 对象，然后再将这两个对象传给重载方法。关于 BoundSql 的获取过程较为复杂，我将在下一节进行分析。CacheKey 以及接下来即将出现的一二级缓存将会独立成文进行分析。</p>
<p>上面的方法和 SimpleExecutor 父类 BaseExecutor 中的实现没什么区别，有区别的地方在于这个方法所调用的重载方法。我们继续往下看。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- CachingExecutor</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">    // 从 MappedStatement 中获取缓存</span><br><span class="line">    Cache cache = ms.getCache();</span><br><span class="line">    // 若映射文件中未配置缓存或参照缓存，此时 cache = null</span><br><span class="line">    if (cache != null) &#123;</span><br><span class="line">        flushCacheIfRequired(ms);</span><br><span class="line">        if (ms.isUseCache() &amp;&amp; resultHandler == null) &#123;</span><br><span class="line">            ensureNoOutParams(ms, boundSql);</span><br><span class="line">            List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">            if (list == null) &#123;</span><br><span class="line">                // 若缓存未命中，则调用被装饰类的 query 方法</span><br><span class="line">                list = delegate.&lt;E&gt;query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">                tcm.putObject(cache, key, list); // issue #578 and #116</span><br><span class="line">            &#125;</span><br><span class="line">            return list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 调用被装饰类的 query 方法</span><br><span class="line">    return delegate.&lt;E&gt;query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码涉及到了二级缓存，若二级缓存为空，或未命中，则调用被装饰类的 query 方法。下面来看一下 BaseExecutor 的中签名相同的 query 方法是如何实现的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- BaseExecutor</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">    if (closed) &#123;</span><br><span class="line">        throw new ExecutorException(&quot;Executor was closed.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (queryStack == 0 &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">        clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    try &#123;</span><br><span class="line">        queryStack++;</span><br><span class="line">        // 从一级缓存中获取缓存项</span><br><span class="line">        list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null;</span><br><span class="line">        if (list != null) &#123;</span><br><span class="line">            // 存储过程相关处理逻辑，本文不分析存储过程，故该方法不分析了</span><br><span class="line">            handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 一级缓存未命中，则从数据库中查询</span><br><span class="line">            list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        queryStack--;</span><br><span class="line">    &#125;</span><br><span class="line">    if (queryStack == 0) &#123;</span><br><span class="line">        // 从一级缓存中延迟加载嵌套查询结果</span><br><span class="line">        for (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">            deferredLoad.load();</span><br><span class="line">        &#125;</span><br><span class="line">        deferredLoads.clear();</span><br><span class="line">        if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">            clearLocalCache();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，上面的方法主要用于从一级缓存中查找查询结果。若缓存未命中，再向数据库进行查询。在上面的代码中，出现了一个新的类 DeferredLoad，这个类用于延迟加载。该类的实现并不复杂，但是具体用途让我有点疑惑。这个我目前也未完全搞清楚，就不强行分析了。接下来，我们来看一下 queryFromDatabase 方法的实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- BaseExecutor</span><br><span class="line">private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds,</span><br><span class="line">    ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    // 向缓存中存储一个占位符</span><br><span class="line">    localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">    try &#123;</span><br><span class="line">        // 调用 doQuery 进行查询</span><br><span class="line">        list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 移除占位符</span><br><span class="line">        localCache.removeObject(key);</span><br><span class="line">    &#125;</span><br><span class="line">    // 缓存查询结果</span><br><span class="line">    localCache.putObject(key, list);</span><br><span class="line">    if (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">        localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码仍然不是 selectOne 方法调用栈的终点，抛开缓存操作，queryFromDatabase 最终还会调用 doQuery 进行查询。下面我们继续进行跟踪。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- SimpleExecutor</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">    Statement stmt = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        Configuration configuration = ms.getConfiguration();</span><br><span class="line">        // 创建 StatementHandler</span><br><span class="line">        StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        // 创建 Statement</span><br><span class="line">        stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">        // 执行查询操作</span><br><span class="line">        return handler.&lt;E&gt;query(stmt, resultHandler);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 关闭 Statement</span><br><span class="line">        closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法中仍然有不少的逻辑，完全看不到即将要到达终点的趋势，不过这离终点又近了一步。接下来，我们先跳过 StatementHandler 和 Statement 创建过程，这两个对象的创建过程会在后面进行说明。这里，我们以 PreparedStatementHandler 为例，看看它的 query 方法是怎样实现的。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- PreparedStatementHandler</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException &#123;</span><br><span class="line">    PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">    // 执行 SQL</span><br><span class="line">    ps.execute();</span><br><span class="line">    // 处理执行结果</span><br><span class="line">    return resultSetHandler.&lt;E&gt;handleResultSets(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里似乎看到了希望，整个调用过程总算要结束了。不过先别高兴的太早，SQL 执行结果的处理过程也很复杂，稍后将会专门拿出一节内容进行分析。</p>
<p>以上就是 selectOne 方法的执行过程，尽管我已经简化了代码分析，但是整个过程看起来还是很复杂的。查询过程涉及到了很多方法调用，不把这些调用方法搞清楚，很难对 MyBatis 的查询过程有深入的理解。所以在接下来的章节中，我将会对一些重要的调用进行分析。如果大家不满足于泛泛而谈，那么接下来咱们一起进行更为深入的探索吧。</p>
<h4 id="2-2-2-获取-BoundSql"><a href="#2-2-2-获取-BoundSql" class="headerlink" title="2.2.2 获取 BoundSql"></a>2.2.2 获取 BoundSql</h4><p>我们在执行 SQL 时，一个重要的任务是将 SQL 语句解析出来。我们都知道 SQL 是配置在映射文件中的，但由于映射文件中的 SQL 可能会包含占位符 #{}，以及动态 SQL 标签，比如 <if>、<where> 等。因此，我们并不能直接使用映射文件中配置的 SQL。MyBatis 会将映射文件中的 SQL 解析成一组 SQL 片段。如果某个片段中也包含动态 SQL 相关的标签，那么，MyBatis 会对该片段再次进行分片。最终，一个 SQL 配置将会被解析成一个 SQL 片段树。形如下面的图片：</where></if></p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15328318597125.jpg" alt="img"></p>
<p>我们需要对片段树进行解析，以便从每个片段对象中获取相应的内容。然后将这些内容组合起来即可得到一个完成的 SQL 语句，这个完整的 SQL 以及其他的一些信息最终会存储在 BoundSql 对象中。下面我们来看一下 BoundSql 类的成员变量信息，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private final String sql;</span><br><span class="line">private final List&lt;ParameterMapping&gt; parameterMappings;</span><br><span class="line">private final Object parameterObject;</span><br><span class="line">private final Map&lt;String, Object&gt; additionalParameters;</span><br><span class="line">private final MetaObject metaParameters;</span><br></pre></td></tr></table></figure>

<p>下面用一个表格列举各个成员变量的含义。</p>
<table>
<thead>
<tr>
<th align="left">变量名</th>
<th align="left">类型</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">sql</td>
<td align="left">String</td>
<td align="left">一个完整的 SQL 语句，可能会包含问号 ? 占位符</td>
</tr>
<tr>
<td align="left">parameterMappings</td>
<td align="left">List</td>
<td align="left">参数映射列表，SQL 中的每个 #{xxx} 占位符都会被解析成相应的 ParameterMapping 对象</td>
</tr>
<tr>
<td align="left">parameterObject</td>
<td align="left">Object</td>
<td align="left">运行时参数，即用户传入的参数，比如 Article 对象，或是其他的参数</td>
</tr>
<tr>
<td align="left">additionalParameters</td>
<td align="left">Map</td>
<td align="left">附加参数集合，用于存储一些额外的信息，比如 datebaseId 等</td>
</tr>
<tr>
<td align="left">metaParameters</td>
<td align="left">MetaObject</td>
<td align="left">additionalParameters 的元信息对象</td>
</tr>
</tbody></table>
<p>以上对 BoundSql 的成员变量做了简要的说明，部分参数的用途大家现在可能不是很明白。不过不用着急，这些变量在接下来的源码分析过程中会陆续的出现。到时候对着源码多思考，或是写点测试代码调试一下，即可弄懂。</p>
<p>好了，现在准备工作已经做好。接下来，开始分析 BoundSql 的构建过程。我们源码之旅的第一站是 MappedStatement 的 getBoundSql 方法，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- MappedStatement</span><br><span class="line">public BoundSql getBoundSql(Object parameterObject) &#123;</span><br><span class="line"></span><br><span class="line">    // 调用 sqlSource 的 getBoundSql 获取 BoundSql</span><br><span class="line">    BoundSql boundSql = sqlSource.getBoundSql(parameterObject);</span><br><span class="line">    List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">    if (parameterMappings == null || parameterMappings.isEmpty()) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * 创建新的 BoundSql，这里的 parameterMap 是 ParameterMap 类型。</span><br><span class="line">         * 由&lt;ParameterMap&gt; 节点进行配置，该节点已经废弃，不推荐使用。默认情况下，</span><br><span class="line">         * parameterMap.getParameterMappings() 返回空集合</span><br><span class="line">         */ </span><br><span class="line">        boundSql = new BoundSql(configuration, boundSql.getSql(), parameterMap.getParameterMappings(), parameterObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 省略不重要的逻辑</span><br><span class="line"></span><br><span class="line">    return boundSql;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，MappedStatement 的 getBoundSql 在内部调用了 SqlSource 实现类的 getBoundSql 方法。处理此处的调用，余下的逻辑都不是重要逻辑，就不啰嗦了。接下来，我们把目光转移到 SqlSource 实现类的 getBoundSql 方法上。SqlSource 是一个接口，它有如下几个实现类：</p>
<ul>
<li>DynamicSqlSource</li>
<li>RawSqlSource</li>
<li>StaticSqlSource</li>
<li>ProviderSqlSource</li>
<li>VelocitySqlSource</li>
</ul>
<p>在如上几个实现类中，我们应该选择分析哪个实现类的逻辑呢？如果大家分析过 MyBatis 映射文件的解析过程，或者阅读过我上一篇的关于<a href="http://www.coolblog.xyz/2018/07/30/MyBatis-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/">MyBatis 映射文件分析</a>的文章，那么这个问题不难回答。好了，不卖关子了，我来回答一下这个问题吧。首先我们把最后两个排除掉，不常用。剩下的三个实现类中，仅前两个实现类会在映射文件解析的过程中被使用。当 SQL 配置中包含 <code>$&#123;&#125;</code>（不是 #{}）占位符，或者包含 <if>、<where> 等标签时，会被认为是动态 SQL，此时使用 DynamicSqlSource 存储 SQL 片段。否则，使用 RawSqlSource 存储 SQL 配置信息。相比之下 DynamicSqlSource 存储的 SQL 片段类型较多，解析起来也更为复杂一些。因此下面我将分析 DynamicSqlSource 的 getBoundSql 方法。弄懂这个，RawSqlSource 也不在话下。好了，下面开始分析。</where></if></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- DynamicSqlSource</span><br><span class="line">public BoundSql getBoundSql(Object parameterObject) &#123;</span><br><span class="line">    // 创建 DynamicContext</span><br><span class="line">    DynamicContext context = new DynamicContext(configuration, parameterObject);</span><br><span class="line"></span><br><span class="line">    // 解析 SQL 片段，并将解析结果存储到 DynamicContext 中</span><br><span class="line">    rootSqlNode.apply(context);</span><br><span class="line">    </span><br><span class="line">    SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration);</span><br><span class="line">    Class&lt;?&gt; parameterType = parameterObject == null ? Object.class : parameterObject.getClass();</span><br><span class="line">    /*</span><br><span class="line">     * 构建 StaticSqlSource，在此过程中将 sql 语句中的占位符 #&#123;&#125; 替换为问号 ?，</span><br><span class="line">     * 并为每个占位符构建相应的 ParameterMapping</span><br><span class="line">     */</span><br><span class="line">    SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings());</span><br><span class="line">    </span><br><span class="line">    // 调用 StaticSqlSource 的 getBoundSql 获取 BoundSql</span><br><span class="line">    BoundSql boundSql = sqlSource.getBoundSql(parameterObject);</span><br><span class="line"></span><br><span class="line">    // 将 DynamicContext 的 ContextMap 中的内容拷贝到 BoundSql 中</span><br><span class="line">    for (Map.Entry&lt;String, Object&gt; entry : context.getBindings().entrySet()) &#123;</span><br><span class="line">        boundSql.setAdditionalParameter(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    return boundSql;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，DynamicSqlSource 的 getBoundSql 方法的代码看起来不多，但是逻辑却并不简单。该方法由数个步骤组成，这里总结一下：</p>
<ol>
<li>创建 DynamicContext</li>
<li>解析 SQL 片段，并将解析结果存储到 DynamicContext 中</li>
<li>解析 SQL 语句，并构建 StaticSqlSource</li>
<li>调用 StaticSqlSource 的 getBoundSql 获取 BoundSql</li>
<li>将 DynamicContext 的 ContextMap 中的内容拷贝到 BoundSql 中</li>
</ol>
<p>如上5个步骤中，第5步为常规操作，就不多说了，其他步骤将会在接下来章节中一一进行分析。按照顺序，我们先来分析 DynamicContext 的实现。</p>
<h5 id="2-2-2-1-DynamicContext"><a href="#2-2-2-1-DynamicContext" class="headerlink" title="2.2.2.1 DynamicContext"></a>2.2.2.1 DynamicContext</h5><p>DynamicContext 是 SQL 语句构建的上下文，每个 SQL 片段解析完成后，都会将解析结果存入 DynamicContext 中。待所有的 SQL 片段解析完毕后，一条完整的 SQL 语句就会出现在 DynamicContext 对象中。下面我们来看一下 DynamicContext 类的定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DynamicContext &#123;</span><br><span class="line"></span><br><span class="line">    public static final String PARAMETER_OBJECT_KEY = &quot;_parameter&quot;;</span><br><span class="line">    public static final String DATABASE_ID_KEY = &quot;_databaseId&quot;;</span><br><span class="line"></span><br><span class="line">    private final ContextMap bindings;</span><br><span class="line">    private final StringBuilder sqlBuilder = new StringBuilder();</span><br><span class="line"></span><br><span class="line">    public DynamicContext(Configuration configuration, Object parameterObject) &#123;</span><br><span class="line">        // 创建 ContextMap</span><br><span class="line">        if (parameterObject != null &amp;&amp; !(parameterObject instanceof Map)) &#123;</span><br><span class="line">            MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">            bindings = new ContextMap(metaObject);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            bindings = new ContextMap(null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 存放运行时参数 parameterObject 以及 databaseId</span><br><span class="line">        bindings.put(PARAMETER_OBJECT_KEY, parameterObject);</span><br><span class="line">        bindings.put(DATABASE_ID_KEY, configuration.getDatabaseId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 省略部分代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，上面只贴了 DynamicContext 类的部分代码。其中 sqlBuilder 变量用于存放 SQL 片段的解析结果，bindings 则用于存储一些额外的信息，比如运行时参数 和 databaseId 等。bindings 类型为 ContextMap，ContextMap 定义在 DynamicContext 中，是一个静态内部类。该类继承自 HashMap，并覆写了 get 方法。它的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static class ContextMap extends HashMap&lt;String, Object&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private MetaObject parameterMetaObject;</span><br><span class="line"></span><br><span class="line">    public ContextMap(MetaObject parameterMetaObject) &#123;</span><br><span class="line">        this.parameterMetaObject = parameterMetaObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object get(Object key) &#123;</span><br><span class="line">        String strKey = (String) key;</span><br><span class="line">        // 检查是否包含 strKey，若包含则直接返回</span><br><span class="line">        if (super.containsKey(strKey)) &#123;</span><br><span class="line">            return super.get(strKey);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (parameterMetaObject != null) &#123;</span><br><span class="line">            // 从运行时参数中查找结果</span><br><span class="line">            return parameterMetaObject.getValue(strKey);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DynamicContext 对外提供了两个接口，用于操作 sqlBuilder。分别如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void appendSql(String sql) &#123;</span><br><span class="line">    sqlBuilder.append(sql);</span><br><span class="line">    sqlBuilder.append(&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getSql() &#123;</span><br><span class="line">    return sqlBuilder.toString().trim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是对 DynamicContext 的简单介绍，DynamicContext 的源码不难理解，这里就不多说了。继续往下分析。</p>
<h5 id="2-2-2-2-解析-SQL-片段"><a href="#2-2-2-2-解析-SQL-片段" class="headerlink" title="2.2.2.2 解析 SQL 片段"></a>2.2.2.2 解析 SQL 片段</h5><p>对于一个包含了 ${} 占位符，或 <if>、<where> 等标签的 SQL，在解析的过程中，会被分解成多个片段。每个片段都有对应的类型，每种类型的片段都有不同的解析逻辑。在源码中，片段这个概念等价于 sql 节点，即 SqlNode。SqlNode 是一个接口，它有众多的实现类。其继承体系如下：</where></if></p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15337454686583.jpg" alt="img"></p>
<p>上图只画出了部分的实现类，还有一小部分没画出来，不过这并不影响接下来的分析。在众多实现类中，StaticTextSqlNode 用于存储静态文本，TextSqlNode 用于存储带有 ${} 占位符的文本，IfSqlNode 则用于存储 <if> 节点的内容。MixedSqlNode 内部维护了一个 SqlNode 集合，用于存储各种各样的 SqlNode。接下来，我将会对 MixedSqlNode 、StaticTextSqlNode、TextSqlNode、IfSqlNode、WhereSqlNode 以及 TrimSqlNode 等进行分析，其他的实现类请大家自行分析。Talk is cheap，show you the code.</if></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MixedSqlNode implements SqlNode &#123;</span><br><span class="line">    private final List&lt;SqlNode&gt; contents;</span><br><span class="line"></span><br><span class="line">    public MixedSqlNode(List&lt;SqlNode&gt; contents) &#123;</span><br><span class="line">        this.contents = contents;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean apply(DynamicContext context) &#123;</span><br><span class="line">        // 遍历 SqlNode 集合</span><br><span class="line">        for (SqlNode sqlNode : contents) &#123;</span><br><span class="line">            // 调用 salNode 对象本身的 apply 方法解析 sql</span><br><span class="line">            sqlNode.apply(context);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MixedSqlNode 可以看做是 SqlNode 实现类对象的容器，凡是实现了 SqlNode 接口的类都可以存储到 MixedSqlNode 中，包括它自己。MixedSqlNode 解析方法 apply 逻辑比较简单，即遍历 SqlNode 集合，并调用其他 SalNode 实现类对象的 apply 方法解析 sql。那下面我们来看看其他 SalNode 实现类的 apply 方法是怎样实现的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class StaticTextSqlNode implements SqlNode &#123;</span><br><span class="line"></span><br><span class="line">    private final String text;</span><br><span class="line"></span><br><span class="line">    public StaticTextSqlNode(String text) &#123;</span><br><span class="line">        this.text = text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean apply(DynamicContext context) &#123;</span><br><span class="line">        context.appendSql(text);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StaticTextSqlNode 用于存储静态文本，所以它不需要什么解析逻辑，直接将其存储的 SQL 片段添加到 DynamicContext 中即可。StaticTextSqlNode 的实现比较简单，看起来很轻松。下面分析一下 TextSqlNode。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TextSqlNode implements SqlNode &#123;</span><br><span class="line"></span><br><span class="line">    private final String text;</span><br><span class="line">    private final Pattern injectionFilter;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean apply(DynamicContext context) &#123;</span><br><span class="line">        // 创建 $&#123;&#125; 占位符解析器</span><br><span class="line">        GenericTokenParser parser = createParser(new BindingTokenParser(context, injectionFilter));</span><br><span class="line">        // 解析 $&#123;&#125; 占位符，并将解析结果添加到 DynamicContext 中</span><br><span class="line">        context.appendSql(parser.parse(text));</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private GenericTokenParser createParser(TokenHandler handler) &#123;</span><br><span class="line">        // 创建占位符解析器，GenericTokenParser 是一个通用解析器，并非只能解析 $&#123;&#125;</span><br><span class="line">        return new GenericTokenParser(&quot;$&#123;&quot;, &quot;&#125;&quot;, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class BindingTokenParser implements TokenHandler &#123;</span><br><span class="line"></span><br><span class="line">        private DynamicContext context;</span><br><span class="line">        private Pattern injectionFilter;</span><br><span class="line"></span><br><span class="line">        public BindingTokenParser(DynamicContext context, Pattern injectionFilter) &#123;</span><br><span class="line">            this.context = context;</span><br><span class="line">            this.injectionFilter = injectionFilter;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String handleToken(String content) &#123;</span><br><span class="line">            Object parameter = context.getBindings().get(&quot;_parameter&quot;);</span><br><span class="line">            if (parameter == null) &#123;</span><br><span class="line">                context.getBindings().put(&quot;value&quot;, null);</span><br><span class="line">            &#125; else if (SimpleTypeRegistry.isSimpleType(parameter.getClass())) &#123;</span><br><span class="line">                context.getBindings().put(&quot;value&quot;, parameter);</span><br><span class="line">            &#125;</span><br><span class="line">            // 通过 ONGL 从用户传入的参数中获取结果</span><br><span class="line">            Object value = OgnlCache.getValue(content, context.getBindings());</span><br><span class="line">            String srtValue = (value == null ? &quot;&quot; : String.valueOf(value));</span><br><span class="line">            // 通过正则表达式检测 srtValue 有效性</span><br><span class="line">            checkInjection(srtValue);</span><br><span class="line">            return srtValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，GenericTokenParser 是一个通用的标记解析器，用于解析形如 ${xxx}，#{xxx} 等标记。GenericTokenParser 负责将标记中的内容抽取出来，并将标记内容交给相应的 TokenHandler 去处理。BindingTokenParser 负责解析标记内容，并将解析结果返回给 GenericTokenParser，用于替换 ${xxx} 标记。举个例子说明一下吧，如下。</p>
<p>我们有这样一个 SQL 语句，用于从 article 表中查询某个作者所写的文章。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM article WHERE author = &#x27;$&#123;author&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>假设我们我们传入的 author 值为 tianxiaobo，那么该 SQL 最终会被解析成如下的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM article WHERE author = &#x27;tianxiaobo&#x27;</span><br></pre></td></tr></table></figure>

<p>一般情况下，使用 ${author} 接受参数都没什么问题。但是怕就怕在有人不怀好意，构建了一些恶意的参数。当用这些恶意的参数替换 ${author} 时就会出现灾难性问题 – SQL 注入。比如我们构建这样一个参数 <code>author = tianxiaobo&#39;; DELETE FROM article;#</code>，然后我们把这个参数传给 TextSqlNode 进行解析。得到的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM article WHERE author = &#x27;tianxiaobo&#x27;; DELETE FROM article;#&#x27;</span><br></pre></td></tr></table></figure>

<p>看到没，由于传入的参数没有经过转义，最终导致了一条 SQL 被恶意参数拼接成了两条 SQL。更要命的是，第二天 SQL 会把 article 表的数据清空，这个后果就很严重了（从删库到跑路）。这就是为什么我们不应该在 SQL 语句中是用 ${} 占位符，风险太大。</p>
<p>分析完 TextSqlNode 的逻辑，接下来，分析 IfSqlNode 的实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class IfSqlNode implements SqlNode &#123;</span><br><span class="line"></span><br><span class="line">    private final ExpressionEvaluator evaluator;</span><br><span class="line">    private final String test;</span><br><span class="line">    private final SqlNode contents;</span><br><span class="line"></span><br><span class="line">    public IfSqlNode(SqlNode contents, String test) &#123;</span><br><span class="line">        this.test = test;</span><br><span class="line">        this.contents = contents;</span><br><span class="line">        this.evaluator = new ExpressionEvaluator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean apply(DynamicContext context) &#123;</span><br><span class="line">        // 通过 ONGL 评估 test 表达式的结果</span><br><span class="line">        if (evaluator.evaluateBoolean(test, context.getBindings())) &#123;</span><br><span class="line">            // 若 test 表达式中的条件成立，则调用其他节点的 apply 方法进行解析</span><br><span class="line">            contents.apply(context);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IfSqlNode 对应的是 <if test="xxx"> 节点，<if> 节点是日常开发中使用频次比较高的一个节点。它的具体用法我想大家都很熟悉了，这里就不多啰嗦。IfSqlNode 的 apply 方法逻辑并不复杂，首先是通过 ONGL 检测 test 表达式是否为 true，如果为 true，则调用其他节点的 apply 方法继续进行解析。需要注意的是 <if> 节点中也可嵌套其他的动态节点，并非只有纯文本。因此 contents 变量遍历指向的是 MixedSqlNode，而非 StaticTextSqlNode。</if></if></if></p>
<p>关于 IfSqlNode 就说到这，接下来分析 WhereSqlNode 的实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class WhereSqlNode extends TrimSqlNode &#123;</span><br><span class="line"></span><br><span class="line">    /** 前缀列表 */</span><br><span class="line">    private static List&lt;String&gt; prefixList = Arrays.asList(&quot;AND &quot;, &quot;OR &quot;, &quot;AND\n&quot;, &quot;OR\n&quot;, &quot;AND\r&quot;, &quot;OR\r&quot;, &quot;AND\t&quot;, &quot;OR\t&quot;);</span><br><span class="line"></span><br><span class="line">    public WhereSqlNode(Configuration configuration, SqlNode contents) &#123;</span><br><span class="line">        // 调用父类的构造方法</span><br><span class="line">        super(configuration, contents, &quot;WHERE&quot;, prefixList, null, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 MyBatis 中，WhereSqlNode 和 SetSqlNode 都是基于 TrimSqlNode 实现的，所以上面的代码看起来很简单。WhereSqlNode 对应于 <where> 节点，关于该节点的用法以及它的应用场景，大家请自行查阅资料。我在分析源码的过程中，默认大家已经知道了该节点的用途和应用场景。</where></p>
<p>接下来，我们把目光聚焦在 TrimSqlNode 的实现上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TrimSqlNode implements SqlNode &#123;</span><br><span class="line"></span><br><span class="line">    private final SqlNode contents;</span><br><span class="line">    private final String prefix;</span><br><span class="line">    private final String suffix;</span><br><span class="line">    private final List&lt;String&gt; prefixesToOverride;</span><br><span class="line">    private final List&lt;String&gt; suffixesToOverride;</span><br><span class="line">    private final Configuration configuration;</span><br><span class="line"></span><br><span class="line">   // 省略构造方法</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean apply(DynamicContext context) &#123;</span><br><span class="line">        // 创建具有过滤功能的 DynamicContext</span><br><span class="line">        FilteredDynamicContext filteredDynamicContext = new FilteredDynamicContext(context);</span><br><span class="line">        // 解析节点内容</span><br><span class="line">        boolean result = contents.apply(filteredDynamicContext);</span><br><span class="line">        // 过滤掉前缀和后缀</span><br><span class="line">        filteredDynamicContext.applyAll();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，apply 方法首选调用了其他 SqlNode 的 apply 方法解析节点内容，这步操作完成后，FilteredDynamicContext 中会得到一条 SQL 片段字符串。接下里需要做的事情是过滤字符串前缀后和后缀，并添加相应的前缀和后缀。这个事情由 FilteredDynamicContext 负责，FilteredDynamicContext 是 TrimSqlNode 的私有内部类。我们去看一下它的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private class FilteredDynamicContext extends DynamicContext &#123;</span><br><span class="line"></span><br><span class="line">    private DynamicContext delegate;</span><br><span class="line">    /** 构造方法会将下面两个布尔值置为 false */</span><br><span class="line">    private boolean prefixApplied;</span><br><span class="line">    private boolean suffixApplied;</span><br><span class="line">    private StringBuilder sqlBuffer;</span><br><span class="line">    </span><br><span class="line">    // 省略构造方法</span><br><span class="line"></span><br><span class="line">    public void applyAll() &#123;</span><br><span class="line">        sqlBuffer = new StringBuilder(sqlBuffer.toString().trim());</span><br><span class="line">        String trimmedUppercaseSql = sqlBuffer.toString().toUpperCase(Locale.ENGLISH);</span><br><span class="line">        if (trimmedUppercaseSql.length() &gt; 0) &#123;</span><br><span class="line">            // 引用前缀和后缀，也就是对 sql 进行过滤操作，移除掉前缀或后缀</span><br><span class="line">            applyPrefix(sqlBuffer, trimmedUppercaseSql);</span><br><span class="line">            applySuffix(sqlBuffer, trimmedUppercaseSql);</span><br><span class="line">        &#125;</span><br><span class="line">        // 将当前对象的 sqlBuffer 内容添加到代理类中</span><br><span class="line">        delegate.appendSql(sqlBuffer.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 省略部分方法</span><br><span class="line"></span><br><span class="line">    private void applyPrefix(StringBuilder sql, String trimmedUppercaseSql) &#123;</span><br><span class="line">        if (!prefixApplied) &#123;</span><br><span class="line">            // 设置 prefixApplied 为 true，以下逻辑仅会被执行一次</span><br><span class="line">            prefixApplied = true;</span><br><span class="line">            if (prefixesToOverride != null) &#123;</span><br><span class="line">                for (String toRemove : prefixesToOverride) &#123;</span><br><span class="line">                    // 检测当前 sql 字符串是否包含 toRemove 前缀，比如 &#x27;AND &#x27;, &#x27;AND\t&#x27;</span><br><span class="line">                    if (trimmedUppercaseSql.startsWith(toRemove)) &#123;</span><br><span class="line">                        // 移除前缀</span><br><span class="line">                        sql.delete(0, toRemove.trim().length());</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 插入前缀，比如 WHERE</span><br><span class="line">            if (prefix != null) &#123;</span><br><span class="line">                sql.insert(0, &quot; &quot;);</span><br><span class="line">                sql.insert(0, prefix);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 该方法逻辑与 applyPrefix 大同小异，大家自行分析</span><br><span class="line">    private void applySuffix(StringBuilder sql, String trimmedUppercaseSql) &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们重点关注 applyAll 和 applyPrefix 方法，其他的方法大家自行分析。applyAll 方法的逻辑比较简单，首先从 sqlBuffer 中获取 SQL 字符串。然后调用 applyPrefix 和 applySuffix 进行过滤操作。最后将过滤后的 SQL 字符串添加到被装饰的类中。applyPrefix 方法会首先检测 SQL 字符串是不是以 “AND “，”OR “，或 “AND\n”， “OR\n” 等前缀开头，若是则将前缀从 sqlBuffer 中移除。然后将前缀插入到 sqlBuffer 的首部，整个逻辑就结束了。下面写点代码简单验证一下，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SqlNodeTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testWhereSqlNode() throws IOException &#123;</span><br><span class="line">        String sqlFragment = &quot;AND id = #&#123;id&#125;&quot;;</span><br><span class="line">        MixedSqlNode msn = new MixedSqlNode(Arrays.asList(new StaticTextSqlNode(sqlFragment)));</span><br><span class="line">        WhereSqlNode wsn = new WhereSqlNode(new Configuration(), msn);</span><br><span class="line">        DynamicContext dc = new DynamicContext(new Configuration(), new ParamMap&lt;&gt;());</span><br><span class="line">        wsn.apply(dc);</span><br><span class="line">        System.out.println(&quot;解析前：&quot; + sqlFragment);</span><br><span class="line">        System.out.println(&quot;解析后：&quot; + dc.getSql());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15337932275070.jpg" alt="img"></p>
<h5 id="2-2-2-3-解析-占位符"><a href="#2-2-2-3-解析-占位符" class="headerlink" title="2.2.2.3 解析 #{} 占位符"></a>2.2.2.3 解析 #{} 占位符</h5><p>经过前面的解析，我们已经能从 DynamicContext 获取到完整的 SQL 语句了。但这并不意味着解析过程就结束了，因为当前的 SQL 语句中还有一种占位符没有处理，即 #{}。与 ${} 占位符的处理方式不同，MyBatis 并不会直接将 #{} 占位符替换为相应的参数值。#{} 占位符的解析逻辑这里先不多说，等相应的源码分析完了，答案就明了了。</p>
<p>#{} 占位符的解析逻辑是包含在 SqlSourceBuilder 的 parse 方法中，该方法最终会将解析后的 SQL 以及其他的一些数据封装到 StaticSqlSource 中。下面，一起来看一下 SqlSourceBuilder 的 parse 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- SqlSourceBuilder</span><br><span class="line">public SqlSource parse(String originalSql, Class&lt;?&gt; parameterType, Map&lt;String, Object&gt; additionalParameters) &#123;</span><br><span class="line">    // 创建 #&#123;&#125; 占位符处理器</span><br><span class="line">    ParameterMappingTokenHandler handler = new ParameterMappingTokenHandler(configuration, parameterType, additionalParameters);</span><br><span class="line">    // 创建 #&#123;&#125; 占位符解析器</span><br><span class="line">    GenericTokenParser parser = new GenericTokenParser(&quot;#&#123;&quot;, &quot;&#125;&quot;, handler);</span><br><span class="line">    // 解析 #&#123;&#125; 占位符，并返回解析结果</span><br><span class="line">    String sql = parser.parse(originalSql);</span><br><span class="line">    // 封装解析结果到 StaticSqlSource 中，并返回</span><br><span class="line">    return new StaticSqlSource(configuration, sql, handler.getParameterMappings());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，GenericTokenParser 的用途上一节已经介绍过了，就不多说了。接下来，我们重点关注 #{} 占位符处理器 ParameterMappingTokenHandler 的逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String handleToken(String content) &#123;</span><br><span class="line">    // 获取 content 的对应的 ParameterMapping</span><br><span class="line">    parameterMappings.add(buildParameterMapping(content));</span><br><span class="line">    // 返回 ?</span><br><span class="line">    return &quot;?&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ParameterMappingTokenHandler 的 handleToken 方法看起来比较简单，但实际上并非如此。GenericTokenParser 负责将 #{} 占位符中的内容抽取出来，并将抽取出的内容传给 handleToken 方法。handleToken 放阿飞负责将传入的参数解析成对应的 ParameterMapping 对象，这步操作由 buildParameterMapping 方法完成。下面我们看一下 buildParameterMapping 的源码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private ParameterMapping buildParameterMapping(String content) &#123;</span><br><span class="line">    /*</span><br><span class="line">     * 将 #&#123;xxx&#125; 占位符中的内容解析成 Map。大家可能很好奇一个普通的字符串是怎么解析成 Map 的，</span><br><span class="line">     * 举例说明一下。如下：</span><br><span class="line">     * </span><br><span class="line">     *    #&#123;age,javaType=int,jdbcType=NUMERIC,typeHandler=MyTypeHandler&#125;</span><br><span class="line">     *    </span><br><span class="line">     * 上面占位符中的内容最终会被解析成如下的结果：</span><br><span class="line">     * </span><br><span class="line">     *  &#123;</span><br><span class="line">     *      &quot;property&quot;: &quot;age&quot;,</span><br><span class="line">     *      &quot;typeHandler&quot;: &quot;MyTypeHandler&quot;, </span><br><span class="line">     *      &quot;jdbcType&quot;: &quot;NUMERIC&quot;, </span><br><span class="line">     *      &quot;javaType&quot;: &quot;int&quot;</span><br><span class="line">     *  &#125;</span><br><span class="line">     * </span><br><span class="line">     * parseParameterMapping 内部依赖 ParameterExpression 对字符串进行解析，ParameterExpression 的</span><br><span class="line">     * 逻辑不是很复杂，这里就不分析了。大家若有兴趣，可自行分析</span><br><span class="line">     */</span><br><span class="line">    Map&lt;String, String&gt; propertiesMap = parseParameterMapping(content);</span><br><span class="line">    String property = propertiesMap.get(&quot;property&quot;);</span><br><span class="line">    Class&lt;?&gt; propertyType;</span><br><span class="line">    // metaParameters 为 DynamicContext 成员变量 bindings 的元信息对象</span><br><span class="line">    if (metaParameters.hasGetter(property)) &#123;</span><br><span class="line">        propertyType = metaParameters.getGetterType(property);</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     * parameterType 是运行时参数的类型。如果用户传入的是单个参数，比如 Article 对象，此时 </span><br><span class="line">     * parameterType 为 Article.class。如果用户传入的多个参数，比如 [id = 1, author = &quot;coolblog&quot;]，</span><br><span class="line">     * MyBatis 会使用 ParamMap 封装这些参数，此时 parameterType 为 ParamMap.class。如果 </span><br><span class="line">     * parameterType 有相应的 TypeHandler，这里则把 parameterType 设为 propertyType</span><br><span class="line">     */</span><br><span class="line">    &#125; else if (typeHandlerRegistry.hasTypeHandler(parameterType)) &#123;</span><br><span class="line">        propertyType = parameterType;</span><br><span class="line">    &#125; else if (JdbcType.CURSOR.name().equals(propertiesMap.get(&quot;jdbcType&quot;))) &#123;</span><br><span class="line">        propertyType = java.sql.ResultSet.class;</span><br><span class="line">    &#125; else if (property == null || Map.class.isAssignableFrom(parameterType)) &#123;</span><br><span class="line">        // 如果 property 为空，或 parameterType 是 Map 类型，则将 propertyType 设为 Object.class</span><br><span class="line">        propertyType = Object.class;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /*</span><br><span class="line">         * 代码逻辑走到此分支中，表明 parameterType 是一个自定义的类，</span><br><span class="line">         * 比如 Article，此时为该类创建一个元信息对象</span><br><span class="line">         */</span><br><span class="line">        MetaClass metaClass = MetaClass.forClass(parameterType, configuration.getReflectorFactory());</span><br><span class="line">        // 检测参数对象有没有与 property 想对应的 getter 方法</span><br><span class="line">        if (metaClass.hasGetter(property)) &#123;</span><br><span class="line">            // 获取成员变量的类型</span><br><span class="line">            propertyType = metaClass.getGetterType(property);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            propertyType = Object.class;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // -------------------------- 分割线 ---------------------------</span><br><span class="line">    </span><br><span class="line">    ParameterMapping.Builder builder = new ParameterMapping.Builder(configuration, property, propertyType);</span><br><span class="line">    </span><br><span class="line">    // 将 propertyType 赋值给 javaType</span><br><span class="line">    Class&lt;?&gt; javaType = propertyType;</span><br><span class="line">    String typeHandlerAlias = null;</span><br><span class="line">    </span><br><span class="line">    // 遍历 propertiesMap</span><br><span class="line">    for (Map.Entry&lt;String, String&gt; entry : propertiesMap.entrySet()) &#123;</span><br><span class="line">        String name = entry.getKey();</span><br><span class="line">        String value = entry.getValue();</span><br><span class="line">        if (&quot;javaType&quot;.equals(name)) &#123;</span><br><span class="line">            // 如果用户明确配置了 javaType，则以用户的配置为准</span><br><span class="line">            javaType = resolveClass(value);</span><br><span class="line">            builder.javaType(javaType);</span><br><span class="line">        &#125; else if (&quot;jdbcType&quot;.equals(name)) &#123;</span><br><span class="line">            // 解析 jdbcType</span><br><span class="line">            builder.jdbcType(resolveJdbcType(value));</span><br><span class="line">        &#125; else if (&quot;mode&quot;.equals(name)) &#123;...&#125; </span><br><span class="line">        else if (&quot;numericScale&quot;.equals(name)) &#123;...&#125; </span><br><span class="line">        else if (&quot;resultMap&quot;.equals(name)) &#123;...&#125; </span><br><span class="line">        else if (&quot;typeHandler&quot;.equals(name)) &#123;</span><br><span class="line">        	typeHandlerAlias = value;    </span><br><span class="line">        &#125; </span><br><span class="line">        else if (&quot;jdbcTypeName&quot;.equals(name)) &#123;...&#125; </span><br><span class="line">        else if (&quot;property&quot;.equals(name)) &#123;...&#125; </span><br><span class="line">        else if (&quot;expression&quot;.equals(name)) &#123;</span><br><span class="line">            throw new BuilderException(&quot;Expression based parameters are not supported yet&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new BuilderException(&quot;An invalid property &#x27;&quot; + name + &quot;&#x27; was found in mapping #&#123;&quot; + content</span><br><span class="line">                + &quot;&#125;.  Valid properties are &quot; + parameterProperties);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeHandlerAlias != null) &#123;</span><br><span class="line">        // 解析 TypeHandler</span><br><span class="line">        builder.typeHandler(resolveTypeHandler(javaType, typeHandlerAlias));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 构建 ParameterMapping 对象</span><br><span class="line">    return builder.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，buildParameterMapping 代码很多，逻辑看起来很复杂。但是它做的事情却不是很多，只有3件事情。如下：</p>
<ol>
<li>解析 content</li>
<li>解析 propertyType，对应分割线之上的代码</li>
<li>构建 ParameterMapping 对象，对应分割线之下的代码</li>
</ol>
<p>buildParameterMapping 代码比较多，不太好理解，下面写个示例演示一下。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SqlSourceBuilderTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        // 带有复杂 #&#123;&#125; 占位符的参数，接下里会解析这个占位符</span><br><span class="line">        String sql = &quot;SELECT * FROM Author WHERE age = #&#123;age,javaType=int,jdbcType=NUMERIC&#125;&quot;;</span><br><span class="line">        SqlSourceBuilder sqlSourceBuilder = new SqlSourceBuilder(new Configuration());</span><br><span class="line">        SqlSource sqlSource = sqlSourceBuilder.parse(sql, Author.class, new HashMap&lt;&gt;());</span><br><span class="line">        BoundSql boundSql = sqlSource.getBoundSql(new Author());</span><br><span class="line">        </span><br><span class="line">        System.out.println(String.format(&quot;SQL: %s\n&quot;, boundSql.getSql()));</span><br><span class="line">        System.out.println(String.format(&quot;ParameterMappings: %s&quot;, boundSql.getParameterMappings()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Author &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    </span><br><span class="line">    // 省略 getter/setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下：<br><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15338192358463.jpg" alt="img"></p>
<p>正如测试结果所示，SQL 中的 #{age, …} 占位符被替换成了问号 ?。#{age, …} 也被解析成了一个 ParameterMapping 对象。</p>
<p>本节的最后，我们再来看一下 StaticSqlSource 的创建过程。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class StaticSqlSource implements SqlSource &#123;</span><br><span class="line"></span><br><span class="line">    private final String sql;</span><br><span class="line">    private final List&lt;ParameterMapping&gt; parameterMappings;</span><br><span class="line">    private final Configuration configuration;</span><br><span class="line"></span><br><span class="line">    public StaticSqlSource(Configuration configuration, String sql) &#123;</span><br><span class="line">        this(configuration, sql, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public StaticSqlSource(Configuration configuration, String sql, List&lt;ParameterMapping&gt; parameterMappings) &#123;</span><br><span class="line">        this.sql = sql;</span><br><span class="line">        this.parameterMappings = parameterMappings;</span><br><span class="line">        this.configuration = configuration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public BoundSql getBoundSql(Object parameterObject) &#123;</span><br><span class="line">        // 创建 BoundSql 对象</span><br><span class="line">        return new BoundSql(configuration, sql, parameterMappings, parameterObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码没有什么太复杂的地方，从上面代码中可以看出 BoundSql 的创建过程也很简单。正因为前面经历了这么复杂的解析逻辑，BoundSql 的创建过程才会如此简单。到此，关于 BoundSql 构建的过程就分析完了，稍作休息，我们进行后面的分析。</p>
<h4 id="2-2-3-创建-StatementHandler"><a href="#2-2-3-创建-StatementHandler" class="headerlink" title="2.2.3 创建 StatementHandler"></a>2.2.3 创建 StatementHandler</h4><p>在 MyBatis 的源码中，StatementHandler 是一个非常核心接口。之所以说它核心，是因为从代码分层的角度来说，StatementHandler 是 MyBatis 源码的边界，再往下层就是 JDBC 层面的接口了。StatementHandler 需要和 JDBC 层面的接口打交道，它要做的事情有很多。在执行 SQL 之前，StatementHandler 需要创建合适的 Statement 对象，然后填充参数值到 Statement 对象中，最后通过 Statement 对象执行 SQL。这还不算完，待 SQL 执行完毕，还要去处理查询结果等。这些过程看似简单，但实现起来却很复杂。好在，这些过程对应的逻辑并不需要我们亲自实现，只需要耐心看一下，难度降低了不少。好了，其他的就不多说了。下面我们来看一下 StatementHandler 的继承体系。</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15344759978280.jpg" alt="img"></p>
<p>上图中，最下层的三种 StatementHandler 实现类与三种不同的 Statement 进行交互，这个不难看出来。但 RoutingStatementHandler 则是一个奇怪的存在，因为 JDBC 中并不存在 RoutingStatement。那它有什么用呢？接下来，我们到代码中寻找答案。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- Configuration</span><br><span class="line">public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement,</span><br><span class="line">    Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line">    // 创建具有路由功能的 StatementHandler</span><br><span class="line">    StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">    // 应用插件到 StatementHandler 上</span><br><span class="line">    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">    return statementHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，newStatementHandler 方法在创建 StatementHandler 之后，还会应用插件到 StatementHandler 上。关于 MyBatis 的插件机制，后面独立成文进行讲解，这里就不分析了。下面分析一下 RoutingStatementHandler。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class RoutingStatementHandler implements StatementHandler &#123;</span><br><span class="line"></span><br><span class="line">    private final StatementHandler delegate;</span><br><span class="line"></span><br><span class="line">    public RoutingStatementHandler(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds,</span><br><span class="line">        ResultHandler resultHandler, BoundSql boundSql) &#123;</span><br><span class="line"></span><br><span class="line">        // 根据 StatementType 创建不同的 StatementHandler </span><br><span class="line">        switch (ms.getStatementType()) &#123;</span><br><span class="line">            case STATEMENT:</span><br><span class="line">                delegate = new SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">                break;</span><br><span class="line">            case PREPARED:</span><br><span class="line">                delegate = new PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">                break;</span><br><span class="line">            case CALLABLE:</span><br><span class="line">                delegate = new CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                throw new ExecutorException(&quot;Unknown statement type: &quot; + ms.getStatementType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 其他方法逻辑均由别的 StatementHandler 代理完成，就不贴代码了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，RoutingStatementHandler 的构造方法会根据 MappedStatement 中的 statementType 变量创建不同的 StatementHandler 实现类。默认情况下，statementType 值为 PREPARED。关于 StatementHandler 创建的过程就先分析到这，StatementHandler 创建完成了，后续要做到事情是创建 Statement，以及将运行时参数和 Statement 进行绑定。接下里，就来分析这一块的逻辑。</p>
<h4 id="2-2-4-设置运行时参数到-SQL-中"><a href="#2-2-4-设置运行时参数到-SQL-中" class="headerlink" title="2.2.4 设置运行时参数到 SQL 中"></a>2.2.4 设置运行时参数到 SQL 中</h4><p>JDBC 提供了三种 Statement 接口，分别是 Statement、PreparedStatement 和 CallableStatement。他们的关系如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15344760633457.jpg" alt="img"></p>
<p>上面三个接口的层级分明，其中 Statement 接口提供了执行 SQL，获取执行结果等基本功能。PreparedStatement 在此基础上，对 IN 类型的参数提供了支持。使得我们可以使用运行时参数替换 SQL 中的问号 ? 占位符，而不用手动拼接 SQL。CallableStatement 则是 在 PreparedStatement 基础上，对 OUT 类型的参数提供了支持，该种类型的参数用于保存存储过程输出的结果。</p>
<p>本节，我将分析 PreparedStatement 的创建，以及设置运行时参数到 SQL 中的过程。其他两种 Statement 的处理过程，大家请自行分析。Statement 的创建入口是在 SimpleExecutor 的 prepareStatement 方法中，下面从这个方法开始进行分析。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- SimpleExecutor</span><br><span class="line">private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException &#123;</span><br><span class="line">    Statement stmt;</span><br><span class="line">    // 获取数据库连接</span><br><span class="line">    Connection connection = getConnection(statementLog);</span><br><span class="line">    // 创建 Statement，</span><br><span class="line">    stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">    // 为 Statement 设置 IN 参数</span><br><span class="line">    handler.parameterize(stmt);</span><br><span class="line">    return stmt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，上面代码的逻辑不复杂，总共包含三个步骤。如下：</p>
<ol>
<li>获取数据库连接</li>
<li>创建 Statement</li>
<li>为 Statement 设置 IN 参数</li>
</ol>
<p>上面三个步骤看起来并不难实现，实际上如果大家愿意写，也能写出来。不过 MyBatis 对着三个步骤进行拓展，实现上也相对复杂一下。以获取数据库连接为例，MyBatis 并未没有在 getConnection 方法中直接调用 JDBC DriverManager 的 getConnection 方法获取获取连接，而是通过数据源获取获取连接。MyBatis 提供了两种基于 JDBC 接口的数据源，分别为 PooledDataSource 和 UnpooledDataSource。创建或获取数据库连接的操作最终是由这两个数据源执行。限于篇幅问题，本节不打算分析以上两种数据源的源码，相关分析会在下一篇文章中展开。</p>
<p>接下来，我将分析 PreparedStatement 的创建，以及 IN 参数设置的过程。按照顺序，先来分析 PreparedStatement 的创建过程。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- PreparedStatementHandler</span><br><span class="line">public Statement prepare(Connection connection, Integer transactionTimeout) throws SQLException &#123;</span><br><span class="line">    Statement statement = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 创建 Statement</span><br><span class="line">        statement = instantiateStatement(connection);</span><br><span class="line">        // 设置超时和 FetchSize</span><br><span class="line">        setStatementTimeout(statement, transactionTimeout);</span><br><span class="line">        setFetchSize(statement);</span><br><span class="line">        return statement;</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">        closeStatement(statement);</span><br><span class="line">        throw e;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        closeStatement(statement);</span><br><span class="line">        throw new ExecutorException(&quot;Error preparing statement.  Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected Statement instantiateStatement(Connection connection) throws SQLException &#123;</span><br><span class="line">    String sql = boundSql.getSql();</span><br><span class="line">    // 根据条件调用不同的 prepareStatement 方法创建 PreparedStatement</span><br><span class="line">    if (mappedStatement.getKeyGenerator() instanceof Jdbc3KeyGenerator) &#123;</span><br><span class="line">        String[] keyColumnNames = mappedStatement.getKeyColumns();</span><br><span class="line">        if (keyColumnNames == null) &#123;</span><br><span class="line">            return connection.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return connection.prepareStatement(sql, keyColumnNames);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (mappedStatement.getResultSetType() != null) &#123;</span><br><span class="line">        return connection.prepareStatement(sql, mappedStatement.getResultSetType().getValue(), ResultSet.CONCUR_READ_ONLY);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return connection.prepareStatement(sql);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，PreparedStatement 的创建过程没什么复杂的地方，就不多说了。下面分析运行时参数是如何被设置到 SQL 中的过程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- PreparedStatementHandler</span><br><span class="line">public void parameterize(Statement statement) throws SQLException &#123;</span><br><span class="line">    // 通过参数处理器 ParameterHandler 设置运行时参数到 PreparedStatement 中</span><br><span class="line">    parameterHandler.setParameters((PreparedStatement) statement);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DefaultParameterHandler implements ParameterHandler &#123;</span><br><span class="line">    private final TypeHandlerRegistry typeHandlerRegistry;</span><br><span class="line">    private final MappedStatement mappedStatement;</span><br><span class="line">    private final Object parameterObject;</span><br><span class="line">    private final BoundSql boundSql;</span><br><span class="line">    private final Configuration configuration;</span><br><span class="line"></span><br><span class="line">    public void setParameters(PreparedStatement ps) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * 从 BoundSql 中获取 ParameterMapping 列表，每个 ParameterMapping </span><br><span class="line">         * 与原始 SQL 中的 #&#123;xxx&#125; 占位符一一对应</span><br><span class="line">         */</span><br><span class="line">        List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">        if (parameterMappings != null) &#123;</span><br><span class="line">            for (int i = 0; i &lt; parameterMappings.size(); i++) &#123;</span><br><span class="line">                ParameterMapping parameterMapping = parameterMappings.get(i);</span><br><span class="line">                // 检测参数类型，排除掉 mode 为 OUT 类型的 parameterMapping</span><br><span class="line">                if (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">                    Object value;</span><br><span class="line">                    // 获取属性名</span><br><span class="line">                    String propertyName = parameterMapping.getProperty();</span><br><span class="line">                    // 检测 BoundSql 的 additionalParameters 是否包含 propertyName</span><br><span class="line">                    if (boundSql.hasAdditionalParameter(propertyName)) &#123;</span><br><span class="line">                        value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">                    &#125; else if (parameterObject == null) &#123;</span><br><span class="line">                        value = null;</span><br><span class="line"></span><br><span class="line">                    // 检测运行时参数是否有相应的类型解析器</span><br><span class="line">                    &#125; else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">                        /*</span><br><span class="line">                         * 若运行时参数的类型有相应的类型处理器 TypeHandler，则将 </span><br><span class="line">                         * parameterObject 设为当前属性的值。</span><br><span class="line">                         */</span><br><span class="line">                        value = parameterObject;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // 为用户传入的参数 parameterObject 创建元信息对象</span><br><span class="line">                        MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">                        // 从用户传入的参数中获取 propertyName 对应的值</span><br><span class="line">                        value = metaObject.getValue(propertyName);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    // ---------------------分割线---------------------</span><br><span class="line"></span><br><span class="line">                    TypeHandler typeHandler = parameterMapping.getTypeHandler();</span><br><span class="line">                    JdbcType jdbcType = parameterMapping.getJdbcType();</span><br><span class="line">                    if (value == null &amp;&amp; jdbcType == null) &#123;</span><br><span class="line">                        // 此处 jdbcType = JdbcType.OTHER</span><br><span class="line">                        jdbcType = configuration.getJdbcTypeForNull();</span><br><span class="line">                    &#125;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        // 由类型处理器 typeHandler 向 ParameterHandler 设置参数</span><br><span class="line">                        typeHandler.setParameter(ps, i + 1, value, jdbcType);</span><br><span class="line">                    &#125; catch (TypeException e) &#123;</span><br><span class="line">                        throw new TypeException(...);</span><br><span class="line">                    &#125; catch (SQLException e) &#123;</span><br><span class="line">                        throw new TypeException(...);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码，分割线以上的大段代码用于获取 #{xxx} 占位符属性所对应的运行时参数。分割线以下的代码则是获取 #{xxx} 占位符属性对应的 TypeHandler，并在最后通过 TypeHandler 将运行时参数值设置到 PreparedStatement 中。关于 TypeHandler 的用途，我在本系列文章的<a href="http://www.coolblog.xyz/2018/07/16/MyBatis-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E5%AF%BC%E8%AF%BB/">导读</a>一文介绍过，这里就不赘述了。大家若不熟悉，可以去看看。</p>
<h4 id="2-2-5-占位符的解析与参数的设置过程梳理"><a href="#2-2-5-占位符的解析与参数的设置过程梳理" class="headerlink" title="2.2.5 #{} 占位符的解析与参数的设置过程梳理"></a>2.2.5 #{} 占位符的解析与参数的设置过程梳理</h4><p>前面两节的内容比较多，本节我将对前两节的部分内容进行梳理，以便大家能够更好理解这两节内容之间的联系。假设我们有这样一条 SQL 语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM author WHERE name = #&#123;name&#125; AND age = #&#123;age&#125;</span><br></pre></td></tr></table></figure>

<p>这个 SQL 语句中包含两个 #{} 占位符，在运行时这两个占位符会被解析成两个 ParameterMapping 对象。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ParameterMapping&#123;property=&#x27;name&#x27;, mode=IN, javaType=class java.lang.String, jdbcType=null, ...&#125;</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ParameterMapping&#123;property=&#x27;age&#x27;, mode=IN, javaType=class java.lang.Integer, jdbcType=null, ...&#125;</span><br></pre></td></tr></table></figure>

<p>#{} 占位符解析完毕后，得到的 SQL 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM Author WHERE name = ? AND age = ?</span><br></pre></td></tr></table></figure>

<p>这里假设下面这个方法与上面的 SQL 对应：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Author findByNameAndAge(@Param(&quot;name&quot;) String name, @Param(&quot;age&quot;) Integer age)</span><br></pre></td></tr></table></figure>

<p>该方法的参数列表会被 ParamNameResolver 解析成一个 map，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    0: &quot;name&quot;,</span><br><span class="line">    1: &quot;age&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设该方法在运行时有如下的调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">findByNameAndAge(&quot;tianxiaobo&quot;, 20)    // 20岁，好年轻啊，但是回不去了呀 😁</span><br></pre></td></tr></table></figure>

<p>此时，需要再次借助 ParamNameResolver 力量。这次我们将参数名和运行时的参数值绑定起来，得到如下的映射关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;tianxiaobo&quot;,</span><br><span class="line">    &quot;age&quot;: 20,</span><br><span class="line">    &quot;param1&quot;: &quot;tianxiaobo&quot;,</span><br><span class="line">    &quot;param2&quot;: 20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下一步，我们要将运行时参数设置到 SQL 中。由于原 SQL 经过解析后，占位符信息已经被擦除掉了，我们无法直接将运行时参数 SQL 中。不过好在，这些占位符信息被记录在了 ParameterMapping 中了，MyBatis 会将 ParameterMapping 会按照 #{} 的解析顺序存入到 List 中。这样我们通过 ParameterMapping 在列表中的位置确定它与 SQL 中的哪个 <code>?</code> 占位符相关联。同时通过 ParameterMapping 中的 property 字段，我们到“参数名与参数值”映射表中查找具体的参数值。这样，我们就可以将参数值准确的设置到 SQL 中了，此时 SQL 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM Author WHERE name = &quot;tianxiaobo&quot; AND age = 20</span><br></pre></td></tr></table></figure>

<p>整个流程如下图所示。</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15339208668346.jpg" alt="img"></p>
<p>当运行时参数被设置到 SQL 中 后，下一步要做的事情是执行 SQL，然后处理 SQL 执行结果。对于更新操作，数据库一般返回一个 int 行数值，表示受影响行数，这个处理起来比较简单。但对于查询操作，返回的结果类型多变，处理方式也很复杂。接下来，我们就来看看 MyBatis 是如何处理查询结果的。</p>
<h4 id="2-2-6-处理查询结果"><a href="#2-2-6-处理查询结果" class="headerlink" title="2.2.6 处理查询结果"></a>2.2.6 处理查询结果</h4><p>MyBatis 可以将查询结果，即结果集 ResultSet 自动映射成实体类对象。这样使用者就无需再手动操作结果集，并将数据填充到实体类对象中。这可大大降低开发的工作量，提高工作效率。在 MyBatis 中，结果集的处理工作由结果集处理器 ResultSetHandler 执行。ResultSetHandler 是一个接口，它只有一个实现类 DefaultResultSetHandler。结果集的处理入口方法是 handleResultSets，下面来看一下该方法的实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public List&lt;Object&gt; handleResultSets(Statement stmt) throws SQLException &#123;</span><br><span class="line">    </span><br><span class="line">    final List&lt;Object&gt; multipleResults = new ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    int resultSetCount = 0;</span><br><span class="line">    // 获取第一个结果集</span><br><span class="line">    ResultSetWrapper rsw = getFirstResultSet(stmt);</span><br><span class="line"></span><br><span class="line">    List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();</span><br><span class="line">    int resultMapCount = resultMaps.size();</span><br><span class="line">    validateResultMapsCount(rsw, resultMapCount);</span><br><span class="line"></span><br><span class="line">    while (rsw != null &amp;&amp; resultMapCount &gt; resultSetCount) &#123;</span><br><span class="line">        ResultMap resultMap = resultMaps.get(resultSetCount);</span><br><span class="line">        // 处理结果集</span><br><span class="line">        handleResultSet(rsw, resultMap, multipleResults, null);</span><br><span class="line">        // 获取下一个结果集</span><br><span class="line">        rsw = getNextResultSet(stmt);</span><br><span class="line">        cleanUpAfterHandlingResultSet();</span><br><span class="line">        resultSetCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 以下逻辑均与多结果集有关，就不分析了，代码省略</span><br><span class="line">    String[] resultSets = mappedStatement.getResultSets();</span><br><span class="line">    if (resultSets != null) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    return collapseSingleResultList(multipleResults);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private ResultSetWrapper getFirstResultSet(Statement stmt) throws SQLException &#123;</span><br><span class="line">    // 获取结果集</span><br><span class="line">    ResultSet rs = stmt.getResultSet();</span><br><span class="line">    while (rs == null) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * 移动 ResultSet 指针到下一个上，有些数据库驱动可能需要使用者</span><br><span class="line">         * 先调用 getMoreResults 方法，然后才能调用 getResultSet 方法</span><br><span class="line">         * 获取到第一个 ResultSet</span><br><span class="line">         */</span><br><span class="line">        if (stmt.getMoreResults()) &#123;</span><br><span class="line">            rs = stmt.getResultSet();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (stmt.getUpdateCount() == -1) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">     * 这里并不直接返回 ResultSet，而是将其封装到 ResultSetWrapper 中。</span><br><span class="line">     * ResultSetWrapper 中包含了 ResultSet 一些元信息，比如列名称、每列对应的 JdbcType、</span><br><span class="line">     * 以及每列对应的 Java 类名（class name，譬如 java.lang.String）等。</span><br><span class="line">     */</span><br><span class="line">    return rs != null ? new ResultSetWrapper(rs, configuration) : null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，该方法首先从 Statement 中获取第一个结果集，然后调用 handleResultSet 方法对该结果集进行处理。一般情况下，如果我们不调用存储过程，不会涉及到多结果集的问题。由于存储过程并不是很常用，所以关于多结果集的处理逻辑我就不分析了。下面，我们把目光聚焦在单结果集的处理逻辑上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void handleResultSet(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Object&gt; multipleResults, ResultMapping parentMapping) throws SQLException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (parentMapping != null) &#123;</span><br><span class="line">            // 多结果集相关逻辑，不分析了</span><br><span class="line">            handleRowValues(rsw, resultMap, null, RowBounds.DEFAULT, parentMapping);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /*</span><br><span class="line">             * 检测 resultHandler 是否为空。ResultHandler 是一个接口，使用者可实现该接口，</span><br><span class="line">             * 这样我们可以通过 ResultHandler 自定义接收查询结果的动作。比如我们可将结果存储到</span><br><span class="line">             * List、Map 亦或是 Set，甚至丢弃，这完全取决于大家的实现逻辑。</span><br><span class="line">             */ </span><br><span class="line">            if (resultHandler == null) &#123;</span><br><span class="line">                // 创建默认的结果处理器</span><br><span class="line">                DefaultResultHandler defaultResultHandler = new DefaultResultHandler(objectFactory);</span><br><span class="line">                // 处理结果集的行数据</span><br><span class="line">                handleRowValues(rsw, resultMap, defaultResultHandler, rowBounds, null);</span><br><span class="line">                multipleResults.add(defaultResultHandler.getResultList());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 处理结果集的行数据</span><br><span class="line">                handleRowValues(rsw, resultMap, resultHandler, rowBounds, null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        closeResultSet(rsw.getResultSet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面代码中，出镜率最高的 handleRowValues 方法，该方法用于处理结果集中的数据。下面来看一下这个方法的逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void handleRowValues(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler&lt;?&gt; resultHandler,</span><br><span class="line">        RowBounds rowBounds, ResultMapping parentMapping) throws SQLException &#123;</span><br><span class="line"></span><br><span class="line">    if (resultMap.hasNestedResultMaps()) &#123;</span><br><span class="line">        ensureNoRowBounds();</span><br><span class="line">        checkResultHandler();</span><br><span class="line">        // 处理嵌套映射，关于嵌套映射本文就不分析了</span><br><span class="line">        handleRowValuesForNestedResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 处理简单映射</span><br><span class="line">        handleRowValuesForSimpleResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，handleRowValues 方法中针对两种映射方式进行了处理。一种是嵌套映射，另一种是简单映射。本文所说的嵌套查询是指 <ResultMap> 中嵌套了一个 <ResultMap> ，关于此种映射的处理方式本文就不进行分析了。下面我将详细分析简单映射的处理逻辑，如下：</ResultMap></ResultMap></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void handleRowValuesForSimpleResultMap(ResultSetWrapper rsw, ResultMap resultMap,</span><br><span class="line">        ResultHandler&lt;?&gt; resultHandler, RowBounds rowBounds, ResultMapping parentMapping) throws SQLException &#123;</span><br><span class="line"></span><br><span class="line">    DefaultResultContext&lt;Object&gt; resultContext = new DefaultResultContext&lt;Object&gt;();</span><br><span class="line">    // 根据 RowBounds 定位到指定行记录</span><br><span class="line">    skipRows(rsw.getResultSet(), rowBounds);</span><br><span class="line">    // 检测是否还有更多行的数据需要处理</span><br><span class="line">    while (shouldProcessMoreRows(resultContext, rowBounds) &amp;&amp; rsw.getResultSet().next()) &#123;</span><br><span class="line">        // 获取经过鉴别器处理后的 ResultMap</span><br><span class="line">        ResultMap discriminatedResultMap = resolveDiscriminatedResultMap(rsw.getResultSet(), resultMap, null);</span><br><span class="line">        // 从 resultSet 中获取结果</span><br><span class="line">        Object rowValue = getRowValue(rsw, discriminatedResultMap);</span><br><span class="line">        // 存储结果</span><br><span class="line">        storeObject(resultHandler, resultContext, rowValue, parentMapping, rsw.getResultSet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面方法的逻辑较多，这里简单总结一下。如下：</p>
<ol>
<li>根据 RowBounds 定位到指定行记录</li>
<li>循环处理多行数据</li>
<li>使用鉴别器处理 ResultMap</li>
<li>映射 ResultSet，得到映射结果 rowValue</li>
<li>存储结果</li>
</ol>
<p>在如上几个步骤中，鉴别器相关的逻辑就不分析了，不是很常用。第2步的检测逻辑比较简单，就不分析了。下面分析第一个步骤对应的代码逻辑。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void skipRows(ResultSet rs, RowBounds rowBounds) throws SQLException &#123;</span><br><span class="line">    // 检测 rs 的类型，不同的类型行数据定位方式是不同的</span><br><span class="line">    if (rs.getType() != ResultSet.TYPE_FORWARD_ONLY) &#123;</span><br><span class="line">        if (rowBounds.getOffset() != RowBounds.NO_ROW_OFFSET) &#123;</span><br><span class="line">            // 直接定位到 rowBounds.getOffset() 位置处</span><br><span class="line">            rs.absolute(rowBounds.getOffset());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int i = 0; i &lt; rowBounds.getOffset(); i++) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * 通过多次调用 rs.next() 方法实现行数据定位。</span><br><span class="line">             * 当 Offset 数值很大时，这种效率很低下</span><br><span class="line">             */</span><br><span class="line">            rs.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyBatis 默认提供了 RowBounds 用于分页，从上面的代码中可以看出，这并非是一个高效的分页方式。除了使用 RowBounds，还可以使用一些第三方分页插件进行分页。关于第三方的分页插件，大家请自行查阅资料，这里就不展开说明了。下面分析一下 ResultSet 的映射过程，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Object getRowValue(ResultSetWrapper rsw, ResultMap resultMap) throws SQLException &#123;</span><br><span class="line">    final ResultLoaderMap lazyLoader = new ResultLoaderMap();</span><br><span class="line">    // 创建实体类对象，比如 Article 对象</span><br><span class="line">    Object rowValue = createResultObject(rsw, resultMap, lazyLoader, null);</span><br><span class="line">    if (rowValue != null &amp;&amp; !hasTypeHandlerForResultObject(rsw, resultMap.getType())) &#123;</span><br><span class="line">        final MetaObject metaObject = configuration.newMetaObject(rowValue);</span><br><span class="line">        boolean foundValues = this.useConstructorMappings;</span><br><span class="line">        </span><br><span class="line">        // 检测是否应该自动映射结果集</span><br><span class="line">        if (shouldApplyAutomaticMappings(resultMap, false)) &#123;</span><br><span class="line">            // 进行自动映射</span><br><span class="line">            foundValues = applyAutomaticMappings(rsw, resultMap, metaObject, null) || foundValues;</span><br><span class="line">        &#125;</span><br><span class="line">        // 根据 &lt;resultMap&gt; 节点中配置的映射关系进行映射</span><br><span class="line">        foundValues = applyPropertyMappings(rsw, resultMap, metaObject, lazyLoader, null) || foundValues;</span><br><span class="line">        foundValues = lazyLoader.size() &gt; 0 || foundValues;</span><br><span class="line">        rowValue = foundValues || configuration.isReturnInstanceForEmptyRow() ? rowValue : null;</span><br><span class="line">    &#125;</span><br><span class="line">    return rowValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的方法中，重要的逻辑已经注释出来了。分别如下：</p>
<ol>
<li>创建实体类对象</li>
<li>检测结果集是否需要自动映射，若需要则进行自动映射</li>
<li>按 <resultMap> 中配置的映射关系进行映射</resultMap></li>
</ol>
<p>这三处代码的逻辑比较复杂，接下来按顺序进行分节说明。首先分析实体类的创建过程。</p>
<h5 id="2-2-6-1-创建实体类对象"><a href="#2-2-6-1-创建实体类对象" class="headerlink" title="2.2.6.1 创建实体类对象"></a>2.2.6.1 创建实体类对象</h5><p>在我们的印象里，创建实体类对象是一个很简单的过程。直接通过 new 关键字，或通过反射即可完成任务。大家可能会想，把这么简单过程也拿出来说说，怕是有凑字数的嫌疑。实则不然，MyBatis 的维护者写了不少逻辑，以保证能成功创建实体类对象。如果实在无法创建，则抛出异常。下面我们来看一下 MyBatis 创建实体类对象的过程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- DefaultResultSetHandler</span><br><span class="line">private Object createResultObject(ResultSetWrapper rsw, ResultMap resultMap, ResultLoaderMap lazyLoader, String columnPrefix) throws SQLException &#123;</span><br><span class="line"></span><br><span class="line">    this.useConstructorMappings = false;</span><br><span class="line">    final List&lt;Class&lt;?&gt;&gt; constructorArgTypes = new ArrayList&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">    final List&lt;Object&gt; constructorArgs = new ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    // 调用重载方法创建实体类对象</span><br><span class="line">    Object resultObject = createResultObject(rsw, resultMap, constructorArgTypes, constructorArgs, columnPrefix);</span><br><span class="line">    // 检测实体类是否有相应的类型处理器</span><br><span class="line">    if (resultObject != null &amp;&amp; !hasTypeHandlerForResultObject(rsw, resultMap.getType())) &#123;</span><br><span class="line">        final List&lt;ResultMapping&gt; propertyMappings = resultMap.getPropertyResultMappings();</span><br><span class="line">        for (ResultMapping propertyMapping : propertyMappings) &#123;</span><br><span class="line">            // 如果开启了延迟加载，则为 resultObject 生成代理类</span><br><span class="line">            if (propertyMapping.getNestedQueryId() != null &amp;&amp; propertyMapping.isLazy()) &#123;</span><br><span class="line">                /*</span><br><span class="line">                 * 创建代理类，默认使用 Javassist 框架生成代理类。由于实体类通常不会实现接口，</span><br><span class="line">                 * 所以不能使用 JDK 动态代理 API 为实体类生成代理。</span><br><span class="line">                 */</span><br><span class="line">                resultObject = configuration.getProxyFactory()</span><br><span class="line">                    .createProxy(resultObject, lazyLoader, configuration, objectFactory, constructorArgTypes, constructorArgs);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this.useConstructorMappings =</span><br><span class="line">        resultObject != null &amp;&amp; !constructorArgTypes.isEmpty();</span><br><span class="line">    return resultObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，创建实体类对象的过程被封装在了 createResultObject 的重载方法中了，关于该方法，待会再分析。创建完实体类对后，还需要对 <resultMap> 中配置的映射信息进行检测。若发现有关联查询，且关联查询结果的加载方式为延迟加载，此时需为实体类生成代理类。举个例子说明一下，假设有如下两个实体类：</resultMap></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** 作者类 */</span><br><span class="line">public class Author &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private Integer sex;</span><br><span class="line">    </span><br><span class="line">    // 省略 getter/setter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 文章类 */</span><br><span class="line">public class Article &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String title;</span><br><span class="line">    // 一对一关系</span><br><span class="line">    private Author author;</span><br><span class="line">    private String content;</span><br><span class="line">    </span><br><span class="line">    // 省略 getter/setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，Article 对象中的数据由一条 SQL 从 article 表中查询。Article 类有一个 author 字段，该字段的数据由另一条 SQL 从 author 表中查出。我们在将 article 表的查询结果填充到 Article 类对象中时，并不希望 MyBaits 立即执行另一条 SQL 查询 author 字段对应的数据。而是期望在我们调用 article.getAuthor() 方法时，MyBaits 再执行另一条 SQL 从 author 表中查询出所需的数据。若如此，我们需要改造 getAuthor 方法，以保证调用该方法时可让 MyBaits 执行相关的 SQL。关于延迟加载后面将会进行详细的分析，这里先说这么多。下面分析 createResultObject 重载方法的逻辑，如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Object createResultObject(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs, String columnPrefix) throws SQLException &#123;</span><br><span class="line"></span><br><span class="line">    final Class&lt;?&gt; resultType = resultMap.getType();</span><br><span class="line">    final MetaClass metaType = MetaClass.forClass(resultType, reflectorFactory);</span><br><span class="line">    // 获取 &lt;constructor&gt; 节点对应的 ResultMapping</span><br><span class="line">    final List&lt;ResultMapping&gt; constructorMappings = resultMap.getConstructorResultMappings();</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 检测是否有与返回值类型相对应的 TypeHandler，若有则直接从</span><br><span class="line">     * 通过 TypeHandler 从结果集中提取数据，并生成返回值对象</span><br><span class="line">     */</span><br><span class="line">    if (hasTypeHandlerForResultObject(rsw, resultType)) &#123;</span><br><span class="line">        // 通过 TypeHandler 获取提取，并生成返回值对象</span><br><span class="line">        return createPrimitiveResultObject(rsw, resultMap, columnPrefix);</span><br><span class="line">    &#125; else if (!constructorMappings.isEmpty()) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * 通过 &lt;constructor&gt; 节点配置的映射信息从 ResultSet 中提取数据，</span><br><span class="line">         * 然后将这些数据传给指定构造方法，即可创建实体类对象</span><br><span class="line">         */</span><br><span class="line">        return createParameterizedResultObject(rsw, resultType, constructorMappings, constructorArgTypes, constructorArgs, columnPrefix);</span><br><span class="line">    &#125; else if (resultType.isInterface() || metaType.hasDefaultConstructor()) &#123;</span><br><span class="line">        // 通过 ObjectFactory 调用目标类的默认构造方法创建实例</span><br><span class="line">        return objectFactory.create(resultType);</span><br><span class="line">    &#125; else if (shouldApplyAutomaticMappings(resultMap, false)) &#123;</span><br><span class="line">        // 通过自动映射查找合适的构造方法创建实例</span><br><span class="line">        return createByConstructorSignature(rsw, resultType, constructorArgTypes, constructorArgs, columnPrefix);</span><br><span class="line">    &#125;</span><br><span class="line">    throw new ExecutorException(&quot;Do not know how to create an instance of &quot; + resultType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，createResultObject 方法中包含了4种创建实体类对象的方式。一般情况下，若无特殊要求，MyBatis 会通过 ObjectFactory 调用默认构造方法创建实体类对象。ObjectFactory 是一个接口，大家可以实现这个接口，以按照自己的逻辑控制对象的创建过程。到此，实体类对象已经创建好了，接下里要做的事情是将结果集中的数据映射到实体类对象中。</p>
<h5 id="2-2-6-2-结果集映射"><a href="#2-2-6-2-结果集映射" class="headerlink" title="2.2.6.2 结果集映射"></a>2.2.6.2 结果集映射</h5><p>在 MyBatis 中，结果集自动映射有三种等级。三种等级官方文档上有所说明，这里直接引用一下。如下：</p>
<ul>
<li><code>NONE</code> - 禁用自动映射。仅设置手动映射属性</li>
<li><code>PARTIAL</code> - 将自动映射结果除了那些有内部定义内嵌结果映射的(joins)</li>
<li><code>FULL</code> - 自动映射所有</li>
</ul>
<p>除了以上三种等级，我们还可以显示配置 <resultMap> 节点的 autoMapping 属性，以启用或者禁用指定 ResultMap 的自定映射设定。下面，来看一下自动映射相关的逻辑。</resultMap></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private boolean shouldApplyAutomaticMappings(ResultMap resultMap, boolean isNested) &#123;</span><br><span class="line">    // 检测 &lt;resultMap&gt; 是否配置了 autoMapping 属性</span><br><span class="line">    if (resultMap.getAutoMapping() != null) &#123;</span><br><span class="line">        // 返回 autoMapping 属性</span><br><span class="line">        return resultMap.getAutoMapping();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (isNested) &#123;</span><br><span class="line">            // 对于嵌套 resultMap，仅当全局的映射行为为 FULL 时，才进行自动映射</span><br><span class="line">            return AutoMappingBehavior.FULL == configuration.getAutoMappingBehavior();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 对于普通的 resultMap，只要全局的映射行为不为 NONE，即可进行自动映射</span><br><span class="line">            return AutoMappingBehavior.NONE != configuration.getAutoMappingBehavior();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，shouldApplyAutomaticMappings 方法用于检测是否应为当前结果集应用自动映射。检测结果取决于 <resultMap> 节点的 autoMapping 属性，以及全局自动映射行为。上面代码的逻辑不难理解，就不多说了。接下来分析 MyBatis 如何进行自动映射。</resultMap></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private boolean applyAutomaticMappings(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, String columnPrefix) throws SQLException &#123;</span><br><span class="line"></span><br><span class="line">    // 获取 UnMappedColumnAutoMapping 列表</span><br><span class="line">    List&lt;UnMappedColumnAutoMapping&gt; autoMapping = createAutomaticMappings(rsw, resultMap, metaObject, columnPrefix);</span><br><span class="line">    boolean foundValues = false;</span><br><span class="line">    if (!autoMapping.isEmpty()) &#123;</span><br><span class="line">        for (UnMappedColumnAutoMapping mapping : autoMapping) &#123;</span><br><span class="line">            // 通过 TypeHandler 从结果集中获取指定列的数据</span><br><span class="line">            final Object value = mapping.typeHandler.getResult(rsw.getResultSet(), mapping.column);</span><br><span class="line">            if (value != null) &#123;</span><br><span class="line">                foundValues = true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (value != null || (configuration.isCallSettersOnNulls() &amp;&amp; !mapping.primitive)) &#123;</span><br><span class="line">                // 通过元信息对象设置 value 到实体类对象的指定字段上</span><br><span class="line">                metaObject.setValue(mapping.property, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return foundValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>applyAutomaticMappings 方法的代码不多，逻辑也不是很复杂。首先是获取 UnMappedColumnAutoMapping 集合，然后遍历该集合，并通过 TypeHandler 从结果集中获取数据，最后再将获取到的数据设置到实体类对象中。虽然逻辑上看起来没什么复杂的东西，但如果不清楚 UnMappedColumnAutoMapping 的用途，是无法理解上面代码的逻辑的。所以下面简单介绍一下 UnMappedColumnAutoMapping 的用途。</p>
<p>UnMappedColumnAutoMapping 用于记录未配置在 <resultMap> 节点中的映射关系。该类定义在 DefaultResultSetHandler 内部，它的代码如下：</resultMap></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static class UnMappedColumnAutoMapping &#123;</span><br><span class="line"></span><br><span class="line">    private final String column;</span><br><span class="line">    private final String property;</span><br><span class="line">    private final TypeHandler&lt;?&gt; typeHandler;</span><br><span class="line">    private final boolean primitive;</span><br><span class="line"></span><br><span class="line">    public UnMappedColumnAutoMapping(String column, String property, TypeHandler&lt;?&gt; typeHandler, boolean primitive) &#123;</span><br><span class="line">        this.column = column;</span><br><span class="line">        this.property = property;</span><br><span class="line">        this.typeHandler = typeHandler;</span><br><span class="line">        this.primitive = primitive;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，以上就是 UnMappedColumnAutoMapping 类的所有代码，没什么逻辑，仅用于记录映射关系。下面看一下获取 UnMappedColumnAutoMapping 集合的过程，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- DefaultResultSetHandler</span><br><span class="line">private List&lt;UnMappedColumnAutoMapping&gt; createAutomaticMappings(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, String columnPrefix) throws SQLException &#123;</span><br><span class="line"></span><br><span class="line">    final String mapKey = resultMap.getId() + &quot;:&quot; + columnPrefix;</span><br><span class="line">    // 从缓存中获取 UnMappedColumnAutoMapping 列表</span><br><span class="line">    List&lt;UnMappedColumnAutoMapping&gt; autoMapping = autoMappingsCache.get(mapKey);</span><br><span class="line">    // 缓存未命中</span><br><span class="line">    if (autoMapping == null) &#123;</span><br><span class="line">        autoMapping = new ArrayList&lt;UnMappedColumnAutoMapping&gt;();</span><br><span class="line">        // 从 ResultSetWrapper 中获取未配置在 &lt;resultMap&gt; 中的列名</span><br><span class="line">        final List&lt;String&gt; unmappedColumnNames = rsw.getUnmappedColumnNames(resultMap, columnPrefix);</span><br><span class="line">        for (String columnName : unmappedColumnNames) &#123;</span><br><span class="line">            String propertyName = columnName;</span><br><span class="line">            if (columnPrefix != null &amp;&amp; !columnPrefix.isEmpty()) &#123;</span><br><span class="line">                if (columnName.toUpperCase(Locale.ENGLISH).startsWith(columnPrefix)) &#123;</span><br><span class="line">                    // 获取不包含列名前缀的属性名</span><br><span class="line">                    propertyName = columnName.substring(columnPrefix.length());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 将下划线形式的列名转成驼峰式，比如 AUTHOR_NAME -&gt; authorName</span><br><span class="line">            final String property = metaObject.findProperty(propertyName, configuration.isMapUnderscoreToCamelCase());</span><br><span class="line">            if (property != null &amp;&amp; metaObject.hasSetter(property)) &#123;</span><br><span class="line">                // 检测当前属性是否存在于 resultMap 中</span><br><span class="line">                if (resultMap.getMappedProperties().contains(property)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                // 获取属性对于的类型</span><br><span class="line">                final Class&lt;?&gt; propertyType = metaObject.getSetterType(property);</span><br><span class="line">                if (typeHandlerRegistry.hasTypeHandler(propertyType, rsw.getJdbcType(columnName))) &#123;</span><br><span class="line">                    // 获取类型处理器</span><br><span class="line">                    final TypeHandler&lt;?&gt; typeHandler = rsw.getTypeHandler(propertyType, columnName);</span><br><span class="line">                    // 封装上面获取到的信息到 UnMappedColumnAutoMapping 对象中</span><br><span class="line">                    autoMapping.add(new UnMappedColumnAutoMapping(columnName, property, typeHandler, propertyType.isPrimitive()));</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    configuration.getAutoMappingUnknownColumnBehavior()</span><br><span class="line">                        .doAction(mappedStatement, columnName, property, propertyType);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                /*</span><br><span class="line">                 * 若 property 为空，或实体类中无 property 属性，此时无法完成</span><br><span class="line">                 * 列名与实体类属性建立映射关系。针对这种情况，有三种处理方式，</span><br><span class="line">                 *   1. 什么都不做</span><br><span class="line">                 *   2. 仅打印日志</span><br><span class="line">                 *   3. 抛出异常</span><br><span class="line">                 * 默认情况下，是什么都不做</span><br><span class="line">                 */</span><br><span class="line">                configuration.getAutoMappingUnknownColumnBehavior()</span><br><span class="line">                    .doAction(mappedStatement, columnName, (property != null) ? property : propertyName, null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 写入缓存</span><br><span class="line">        autoMappingsCache.put(mapKey, autoMapping);</span><br><span class="line">    &#125;</span><br><span class="line">    return autoMapping;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码有点多，不过不用太担心，耐心看一下，还是可以看懂的。下面我来总结一下这个方法的逻辑。</p>
<ol>
<li>从 ResultSetWrapper 中获取未配置在 <resultMap> 中的列名</resultMap></li>
<li>遍历上一步获取到的列名列表</li>
<li>若列名包含列名前缀，则移除列名前缀，得到属性名</li>
<li>将下划线形式的列名转成驼峰式</li>
<li>获取属性类型</li>
<li>获取类型处理器</li>
<li>创建 UnMappedColumnAutoMapping 实例</li>
</ol>
<p>以上步骤中，除了第一步，其他都是常规操作，无需过多说明。下面来分析第一个步骤的逻辑，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- ResultSetWrapper</span><br><span class="line">public List&lt;String&gt; getUnmappedColumnNames(ResultMap resultMap, String columnPrefix) throws SQLException &#123;</span><br><span class="line">    List&lt;String&gt; unMappedColumnNames = unMappedColumnNamesMap.get(getMapKey(resultMap, columnPrefix));</span><br><span class="line">    if (unMappedColumnNames == null) &#123;</span><br><span class="line">        // 加载已映射与未映射列名</span><br><span class="line">        loadMappedAndUnmappedColumnNames(resultMap, columnPrefix);</span><br><span class="line">        // 获取未映射列名</span><br><span class="line">        unMappedColumnNames = unMappedColumnNamesMap.get(getMapKey(resultMap, columnPrefix));</span><br><span class="line">    &#125;</span><br><span class="line">    return unMappedColumnNames;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void loadMappedAndUnmappedColumnNames(ResultMap resultMap, String columnPrefix) throws SQLException &#123;</span><br><span class="line">    List&lt;String&gt; mappedColumnNames = new ArrayList&lt;String&gt;();</span><br><span class="line">    List&lt;String&gt; unmappedColumnNames = new ArrayList&lt;String&gt;();</span><br><span class="line">    final String upperColumnPrefix = columnPrefix == null ? null : columnPrefix.toUpperCase(Locale.ENGLISH);</span><br><span class="line">    // 为 &lt;resultMap&gt; 中的列名拼接前缀</span><br><span class="line">    final Set&lt;String&gt; mappedColumns = prependPrefixes(resultMap.getMappedColumns(), upperColumnPrefix);</span><br><span class="line">    /*</span><br><span class="line">     * 遍历 columnNames，columnNames 是 ResultSetWrapper 的成员变量，</span><br><span class="line">     * 保存了当前结果集中的所有列名</span><br><span class="line">     */</span><br><span class="line">    for (String columnName : columnNames) &#123;</span><br><span class="line">        final String upperColumnName = columnName.toUpperCase(Locale.ENGLISH);</span><br><span class="line">        // 检测已映射列名集合中是否包含当前列名</span><br><span class="line">        if (mappedColumns.contains(upperColumnName)) &#123;</span><br><span class="line">            mappedColumnNames.add(upperColumnName);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 将列名存入 unmappedColumnNames 中</span><br><span class="line">            unmappedColumnNames.add(columnName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 缓存列名集合</span><br><span class="line">    mappedColumnNamesMap.put(getMapKey(resultMap, columnPrefix), mappedColumnNames);</span><br><span class="line">    unMappedColumnNamesMap.put(getMapKey(resultMap, columnPrefix), unmappedColumnNames);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，已映射列名与未映射列名的分拣逻辑并不复杂。我简述一下这个逻辑，首先是从当前数据集中获取列名集合，然后获取 <resultMap> 中配置的列名集合。之后遍历数据集中的列名集合，并判断列名是否被配置在了 <resultMap> 节点中。若配置了，则表明该列名已有映射关系，此时该列名存入 mappedColumnNames 中。若未配置，则表明列名未与实体类的某个字段形成映射关系，此时该列名存入 unmappedColumnNames 中。这样，列名的分拣工作就完成了。分拣过程示意图如下：</resultMap></resultMap></p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15340836193656.jpg" alt="img"></p>
<p>如上图所示，实体类 Author 的 id 和 name 字段与列名 id 和 name 被配置在了 <resultMap> 中，它们之间形成了映射关系。列名 age、sex 和 email 未配置在 <resultMap> 中，因此未与 Author 中的字段形成映射，所以他们最终都被放入了 unMappedColumnNames 集合中。弄懂了未映射列名获取的过程，自动映射的代码逻辑就不难懂了。好了，关于自动映射的分析就先到这，接下来分析一下 MyBatis 是如何将结果集中的数据填充到已映射的实体类字段中的。</resultMap></resultMap></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- DefaultResultSetHandler</span><br><span class="line">private boolean applyPropertyMappings(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject,ResultLoaderMap lazyLoader, String columnPrefix) throws SQLException &#123;</span><br><span class="line">    </span><br><span class="line">    // 获取已映射的列名</span><br><span class="line">    final List&lt;String&gt; mappedColumnNames = rsw.getMappedColumnNames(resultMap, columnPrefix);</span><br><span class="line">    boolean foundValues = false;</span><br><span class="line">    // 获取 ResultMapping</span><br><span class="line">    final List&lt;ResultMapping&gt; propertyMappings = resultMap.getPropertyResultMappings();</span><br><span class="line">    for (ResultMapping propertyMapping : propertyMappings) &#123;</span><br><span class="line">        // 拼接列名前缀，得到完整列名</span><br><span class="line">        String column = prependPrefix(propertyMapping.getColumn(), columnPrefix);</span><br><span class="line">        if (propertyMapping.getNestedResultMapId() != null) &#123;</span><br><span class="line">            column = null;</span><br><span class="line">        &#125;</span><br><span class="line">        /*</span><br><span class="line">         * 下面的 if 分支由三个或条件组合而成，三个条件的含义如下：</span><br><span class="line">         *   条件一：检测 column 是否为 &#123;prop1=col1, prop2=col2&#125; 形式，该</span><br><span class="line">         *          种形式的 column 一般用于关联查询</span><br><span class="line">         *   条件二：检测当前列名是否被包含在已映射的列名集合中，若包含则可进行数据集映射操作</span><br><span class="line">         *   条件三：多结果集相关，暂不分析</span><br><span class="line">         */</span><br><span class="line">        if (propertyMapping.isCompositeResult()</span><br><span class="line">            || (column != null &amp;&amp; mappedColumnNames.contains(column.toUpperCase(Locale.ENGLISH)))</span><br><span class="line">            || propertyMapping.getResultSet() != null) &#123;</span><br><span class="line">            </span><br><span class="line">            // 从结果集中获取指定列的数据</span><br><span class="line">            Object value = getPropertyMappingValue(rsw.getResultSet(), metaObject, propertyMapping, lazyLoader, columnPrefix);</span><br><span class="line">            </span><br><span class="line">            final String property = propertyMapping.getProperty();</span><br><span class="line">            if (property == null) &#123;</span><br><span class="line">                continue;</span><br><span class="line"></span><br><span class="line">            // 若获取到的值为 DEFERED，则延迟加载该值</span><br><span class="line">            &#125; else if (value == DEFERED) &#123;</span><br><span class="line">                foundValues = true;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (value != null) &#123;</span><br><span class="line">                foundValues = true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (value != null || (configuration.isCallSettersOnNulls() &amp;&amp; !metaObject.getSetterType(property)</span><br><span class="line">                                  .isPrimitive())) &#123;</span><br><span class="line"></span><br><span class="line">                // 将获取到的值设置到实体类对象中</span><br><span class="line">                metaObject.setValue(property, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return foundValues;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Object getPropertyMappingValue(ResultSet rs, MetaObject metaResultObject, ResultMapping propertyMapping,ResultLoaderMap lazyLoader, String columnPrefix) throws SQLException &#123;</span><br><span class="line"></span><br><span class="line">    if (propertyMapping.getNestedQueryId() != null) &#123;</span><br><span class="line">        // 获取关联查询结果，下一节分析</span><br><span class="line">        return getNestedQueryMappingValue(rs, metaResultObject, propertyMapping, lazyLoader, columnPrefix);</span><br><span class="line">    &#125; else if (propertyMapping.getResultSet() != null) &#123;</span><br><span class="line">        addPendingChildRelation(rs, metaResultObject, propertyMapping);</span><br><span class="line">        return DEFERED;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        final TypeHandler&lt;?&gt; typeHandler = propertyMapping.getTypeHandler();</span><br><span class="line">        // 拼接前缀</span><br><span class="line">        final String column = prependPrefix(propertyMapping.getColumn(), columnPrefix);</span><br><span class="line">        // 从 ResultSet 中获取指定列的值</span><br><span class="line">        return typeHandler.getResult(rs, column);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，applyPropertyMappings 方法首先从 ResultSetWrapper 中获取已映射列名集合 mappedColumnNames，从 ResultMap 获取映射对象 ResultMapping 集合。然后遍历 ResultMapping 集合，再此过程中调用 getPropertyMappingValue 获取指定指定列的数据，最后将获取到的数据设置到实体类对象中。到此，基本的结果集映射过程就分析完了。</p>
<p>结果集映射相关的代码比较多，结果集的映射过程比较复杂的，需要一定的耐心去阅读和理解代码。好了，稍作休息，稍后分析关联查询相关的逻辑。</p>
<h5 id="2-2-6-3-关联查询与延迟加载"><a href="#2-2-6-3-关联查询与延迟加载" class="headerlink" title="2.2.6.3 关联查询与延迟加载"></a>2.2.6.3 关联查询与延迟加载</h5><p>我们在学习 MyBatis 框架时，会经常碰到一对一，一对多的使用场景。对于这样的场景，通常我们可以用一条 SQL 进行多表查询完成任务。当然我们也可以使用关联查询，将一条 SQL 拆成两条去完成查询任务。MyBatis 提供了两个标签用于支持一对一和一对多的使用场景，分别是 <association> 和 <collection>。下面我来演示一下如何使用 <association> 完成一对一的关联查询。先来看看实体类的定义：</association></collection></association></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** 作者类 */</span><br><span class="line">public class Author &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private Integer sex;</span><br><span class="line">    private String email;</span><br><span class="line">    </span><br><span class="line">    // 省略 getter/setter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 文章类 */</span><br><span class="line">public class Article &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String title;</span><br><span class="line">    // 一对一关系</span><br><span class="line">    private Author author;</span><br><span class="line">    private String content;</span><br><span class="line">    private Date createTime;</span><br><span class="line">    </span><br><span class="line">    // 省略 getter/setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关表记录如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15341573511612.jpg" alt="img"></p>
<p>接下来看一下 Mapper 接口与映射文件的定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface ArticleDao &#123;</span><br><span class="line">    Article findOne(@Param(&quot;id&quot;) int id);</span><br><span class="line">    Author findAuthor(@Param(&quot;id&quot;) int authorId);</span><br><span class="line">&#125;</span><br><span class="line">&lt;mapper namespace=&quot;xyz.coolblog.dao.ArticleDao&quot;&gt;</span><br><span class="line">    &lt;resultMap id=&quot;articleResult&quot; type=&quot;Article&quot;&gt;</span><br><span class="line">        &lt;result property=&quot;createTime&quot; column=&quot;create_time&quot;/&gt;</span><br><span class="line">        &lt;association property=&quot;author&quot; column=&quot;author_id&quot; javaType=&quot;Author&quot; select=&quot;findAuthor&quot;/&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=&quot;findOne&quot; resultMap=&quot;articleResult&quot;&gt;</span><br><span class="line">        SELECT</span><br><span class="line">            id, author_id, title, content, create_time</span><br><span class="line">        FROM</span><br><span class="line">            article</span><br><span class="line">        WHERE</span><br><span class="line">            id = #&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=&quot;findAuthor&quot; resultType=&quot;Author&quot;&gt;</span><br><span class="line">        SELECT</span><br><span class="line">            id, name, age, sex, email</span><br><span class="line">        FROM</span><br><span class="line">            author</span><br><span class="line">        WHERE</span><br><span class="line">            id = #&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>好了，必要在的准备工作做完了，下面可以写测试代码了。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OneToOneTest &#123;</span><br><span class="line"></span><br><span class="line">    private SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    public void prepare() throws IOException &#123;</span><br><span class="line">        String resource = &quot;mybatis-one-to-one-config.xml&quot;;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Test</span><br><span class="line">    public void testOne2One() &#123;</span><br><span class="line">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">        try &#123;</span><br><span class="line">            ArticleDao articleDao = session.getMapper(ArticleDao.class);</span><br><span class="line">            Article article = articleDao.findOne(1);</span><br><span class="line"></span><br><span class="line">            Author author = article.getAuthor();</span><br><span class="line">            article.setAuthor(null);</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;\narticles info:&quot;);</span><br><span class="line">            System.out.println(article);</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;\nauthor info:&quot;);</span><br><span class="line">            System.out.println(author);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            session.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15341724299678.jpg" alt="img"></p>
<p>如上，从上面的输出结果中可以看出，我们在调用 ArticleDao 的 findOne 方法时，MyBatis 执行了两条 SQL，完成了一对一的查询需求。理解了上面的例子后，下面就可以深入到源码中，看看 MyBatis 是如何实现关联查询的。接下里从 getNestedQueryMappingValue 方法开始分析，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Object getNestedQueryMappingValue(ResultSet rs, MetaObject metaResultObject, ResultMapping propertyMapping, ResultLoaderMap lazyLoader, String columnPrefix) throws SQLException &#123;</span><br><span class="line"></span><br><span class="line">    // 获取关联查询 id，id = 命名空间 + &lt;association&gt; 的 select 属性值</span><br><span class="line">    final String nestedQueryId = propertyMapping.getNestedQueryId();</span><br><span class="line">    final String property = propertyMapping.getProperty();</span><br><span class="line">    // 根据 nestedQueryId 获取 MappedStatement</span><br><span class="line">    final MappedStatement nestedQuery = configuration.getMappedStatement(nestedQueryId);</span><br><span class="line">    final Class&lt;?&gt; nestedQueryParameterType = nestedQuery.getParameterMap().getType();</span><br><span class="line">    /*</span><br><span class="line">     * 生成关联查询语句参数对象，参数类型可能是一些包装类，Map 或是自定义的实体类，</span><br><span class="line">     * 具体类型取决于配置信息。以上面的例子为基础，下面分析不同配置对参数类型的影响：</span><br><span class="line">     *   1. &lt;association column=&quot;author_id&quot;&gt; </span><br><span class="line">     *      column 属性值仅包含列信息，参数类型为 author_id 列对应的类型，这里为 Integer</span><br><span class="line">     * </span><br><span class="line">     *   2. &lt;association column=&quot;&#123;id=author_id, name=title&#125;&quot;&gt; </span><br><span class="line">     *      column 属性值包含了属性名与列名的复合信息，MyBatis 会根据列名从 ResultSet 中</span><br><span class="line">     *      获取列数据，并将列数据设置到实体类对象的指定属性中，比如：</span><br><span class="line">     *          Author&#123;id=1, name=&quot;MyBatis 源码分析系列文章导读&quot;, age=null, ....&#125;</span><br><span class="line">     *      或是以键值对 &lt;属性, 列数据&gt; 的形式，将两者存入 Map 中。比如：</span><br><span class="line">     *          &#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;MyBatis 源码分析系列文章导读&quot;&#125;</span><br><span class="line">     *</span><br><span class="line">     *      至于参数类型到底为实体类还是 Map，取决于关联查询语句的配置信息。比如：</span><br><span class="line">     *          &lt;select id=&quot;findAuthor&quot;&gt;  -&gt;  参数类型为 Map</span><br><span class="line">     *          &lt;select id=&quot;findAuthor&quot; parameterType=&quot;Author&quot;&gt; -&gt; 参数类型为实体类</span><br><span class="line">     */</span><br><span class="line">    final Object nestedQueryParameterObject = prepareParameterForNestedQuery(rs, propertyMapping, nestedQueryParameterType, columnPrefix);</span><br><span class="line">    Object value = null;</span><br><span class="line">    if (nestedQueryParameterObject != null) &#123;</span><br><span class="line">        // 获取 BoundSql</span><br><span class="line">        final BoundSql nestedBoundSql = nestedQuery.getBoundSql(nestedQueryParameterObject);</span><br><span class="line">        final CacheKey key = executor.createCacheKey(nestedQuery, nestedQueryParameterObject, RowBounds.DEFAULT, nestedBoundSql);</span><br><span class="line">        final Class&lt;?&gt; targetType = propertyMapping.getJavaType();</span><br><span class="line"></span><br><span class="line">        // 检查一级缓存是否保存了关联查询结果</span><br><span class="line">        if (executor.isCached(nestedQuery, key)) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * 从一级缓存中获取关联查询的结果，并通过 metaResultObject </span><br><span class="line">             * 将结果设置到相应的实体类对象中</span><br><span class="line">             */</span><br><span class="line">            executor.deferLoad(nestedQuery, metaResultObject, property, key, targetType);</span><br><span class="line">            value = DEFERED;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 创建结果加载器</span><br><span class="line">            final ResultLoader resultLoader = new ResultLoader(configuration, executor, nestedQuery, nestedQueryParameterObject, targetType, key, nestedBoundSql);</span><br><span class="line">            // 检测当前属性是否需要延迟加载</span><br><span class="line">            if (propertyMapping.isLazy()) &#123;</span><br><span class="line">                // 添加延迟加载相关的对象到 loaderMap 集合中</span><br><span class="line">                lazyLoader.addLoader(property, metaResultObject, resultLoader);</span><br><span class="line">                value = DEFERED;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 直接执行关联查询</span><br><span class="line">                value = resultLoader.loadResult();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，上面对关联查询进行了比较多的注释，导致该方法看起来有点复杂。当然，真实的逻辑确实有点复杂，因为它还调用了其他的很多方法。下面先来总结一下该方法的逻辑：</p>
<ol>
<li>根据 nestedQueryId 获取 MappedStatement</li>
<li>生成参数对象</li>
<li>获取 BoundSql</li>
<li>检测一级缓存中是否有关联查询的结果，若有，则将结果设置到实体类对象中</li>
<li>若一级缓存未命中，则创建结果加载器 ResultLoader</li>
<li>检测当前属性是否需要进行延迟加载，若需要，则添加延迟加载相关的对象到 loaderMap 集合中</li>
<li>如不需要延迟加载，则直接通过结果加载器加载结果</li>
</ol>
<p>如上，getNestedQueryMappingValue 的中逻辑多是都是和延迟加载有关。除了延迟加载，以上流程中针对一级缓存的检查是十分有必要的，若缓存命中，可直接取用结果，无需再在执行关联查询 SQL。若缓存未命中，接下来就要按部就班执行延迟加载相关逻辑，接下来，分析一下 MyBatis 延迟加载是如何实现的。首先我们来看一下添加延迟加载相关对象到 loaderMap 集合中的逻辑，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- ResultLoaderMap</span><br><span class="line">public void addLoader(String property, MetaObject metaResultObject, ResultLoader resultLoader) &#123;</span><br><span class="line">    // 将属性名转为大写</span><br><span class="line">    String upperFirst = getUppercaseFirstProperty(property);</span><br><span class="line">    if (!upperFirst.equalsIgnoreCase(property) &amp;&amp; loaderMap.containsKey(upperFirst)) &#123;</span><br><span class="line">        throw new ExecutorException(&quot;Nested lazy loaded result property &#x27;&quot; + property +</span><br><span class="line">                                    &quot;&#x27; for query id &#x27;&quot; + resultLoader.mappedStatement.getId() +</span><br><span class="line">                                    &quot; already exists in the result map. The leftmost property of all lazy loaded properties must be unique within a result map.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 创建 LoadPair，并将 &lt;大写属性名，LoadPair对象&gt; 键值对添加到 loaderMap 中</span><br><span class="line">    loaderMap.put(upperFirst, new LoadPair(property, metaResultObject, resultLoader));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，addLoader 方法的参数最终都传给了 LoadPair，该类的 load 方法会在内部调用 ResultLoader 的 loadResult 方法进行关联查询，并通过 metaResultObject 将查询结果设置到实体类对象中。那 LoadPair 的 load 方法由谁调用呢？答案是实体类的代理对象。下面我们修改一下上面示例中的部分代码，演示一下延迟加载。首先，我们需要在 MyBatis 配置文件的 <settings> 节点中加入或覆盖如下配置：</settings></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 开启延迟加载 --&gt;</span><br><span class="line">&lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">&lt;!-- 关闭积极的加载策略 --&gt;</span><br><span class="line">&lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">&lt;!-- 延迟加载的触发方法 --&gt;</span><br><span class="line">&lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,hashCode&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>上面三个配置 MyBatis 官方文档中有较为详细的介绍，大家可以参考官方文档，我就不详细介绍了。下面修改一下测试类的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OneToOneTest &#123;</span><br><span class="line"></span><br><span class="line">    private SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    public void prepare() throws IOException &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    @Test</span><br><span class="line">    public void testOne2One() &#123;</span><br><span class="line">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">        try &#123;</span><br><span class="line">            ArticleDao articleDao = session.getMapper(ArticleDao.class);</span><br><span class="line">            Article article = articleDao.findOne(1);</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;\narticles info:&quot;);</span><br><span class="line">            System.out.println(article);</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;\n延迟加载 author 字段：&quot;);</span><br><span class="line">            // 通过 getter 方法触发延迟加载</span><br><span class="line">            Author author = article.getAuthor();</span><br><span class="line">            System.out.println(&quot;\narticles info:&quot;);</span><br><span class="line">            System.out.println(article);</span><br><span class="line">            System.out.println(&quot;\nauthor info:&quot;);</span><br><span class="line">            System.out.println(author);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            session.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15341727747023.jpg" alt="img"></p>
<p>从上面结果中可以看出，我们在未调用 getAuthor 方法时，Article 对象中的 author 字段为 null。调用该方法后，再次输出 Article 对象，发现其 author 字段有值了，表明 author 字段的延迟加载逻辑被触发了。既然调用 getAuthor 可以触发延迟加载，那么该方法一定被做过手脚了，不然该方法应该返回 null 才是。如果大家还记得 2.2.6.1 节中的内容，大概就知道是怎么回事了 - MyBatis 会为需要延迟加载的类生成代理类，代理逻辑会拦截实体类的方法调用。默认情况下，MyBatis 会使用 Javassist 为实体类生成代理，代理逻辑封装在 JavassistProxyFactory 类中，下面一起看一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- JavassistProxyFactory</span><br><span class="line">public Object invoke(Object enhanced, Method method, Method methodProxy, Object[] args) throws Throwable &#123;</span><br><span class="line">    final String methodName = method.getName();</span><br><span class="line">    try &#123;</span><br><span class="line">        synchronized (lazyLoader) &#123;</span><br><span class="line">            if (WRITE_REPLACE_METHOD.equals(methodName)) &#123;</span><br><span class="line">                // 针对 writeReplace 方法的处理逻辑，与延迟加载无关，不分析了</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (lazyLoader.size() &gt; 0 &amp;&amp; !FINALIZE_METHOD.equals(methodName)) &#123;</span><br><span class="line">                    /*</span><br><span class="line">                     * 如果 aggressive 为 true，或触发方法（比如 equals，hashCode 等）被调用，</span><br><span class="line">                     * 则加载所有的所有延迟加载的数据</span><br><span class="line">                     */</span><br><span class="line">                    if (aggressive || lazyLoadTriggerMethods.contains(methodName)) &#123;</span><br><span class="line">                        lazyLoader.loadAll();</span><br><span class="line">                    &#125; else if (PropertyNamer.isSetter(methodName)) &#123;</span><br><span class="line">                        final String property = PropertyNamer.methodToProperty(methodName);</span><br><span class="line">                        // 如果使用者显示调用了 setter 方法，则将相应的延迟加载类从 loaderMap 中移除</span><br><span class="line">                        lazyLoader.remove(property);</span><br><span class="line">                        </span><br><span class="line">                    // 检测使用者是否调用 getter 方法</span><br><span class="line">                    &#125; else if (PropertyNamer.isGetter(methodName)) &#123;</span><br><span class="line">                        final String property = PropertyNamer.methodToProperty(methodName);</span><br><span class="line">                        // 检测该属性是否有相应的 LoadPair 对象</span><br><span class="line">                        if (lazyLoader.hasLoader(property)) &#123;</span><br><span class="line">                            // 执行延迟加载逻辑</span><br><span class="line">                            lazyLoader.load(property);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 调用被代理类的方法</span><br><span class="line">        return methodProxy.invoke(enhanced, args);</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        throw ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，代理方法首先会检查 aggressive 是否为 true，如果不满足，再去检查 lazyLoadTriggerMethods 是否包含当前方法名。这里两个条件只要一个为 true，当前实体类中所有需要延迟加载。aggressive 和 lazyLoadTriggerMethods 两个变量的值取决于下面的配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">&lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,hashCode&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>现在大家知道上面两个配置是如何在代码中使用的了，比较简单，就不多说了。</p>
<p>回到上面的代码中，如果执行线程未进入第一个条件分支，那么紧接着，代理逻辑会检查使用者是不是调用了实体类的 setter 方法，如果调用了，就将该属性对应的 LoadPair 从 loaderMap 中移除。为什么要这么做呢？答案是：使用者既然手动调用 setter 方法，说明使用者想自定义某个属性的值。此时，延迟加载逻辑不应该再修改该属性的值，所以这里从 loaderMap 中移除属性对于的 LoadPair。</p>
<p>最后如果使用者调用的是某个属性的 getter 方法，且该属性配置了延迟加载，此时延迟加载逻辑就会被触发。那接下来，我们来看看延迟加载逻辑是怎样实现的的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- ResultLoaderMap</span><br><span class="line">public boolean load(String property) throws SQLException &#123;</span><br><span class="line">    // 从 loaderMap 中移除 property 所对应的 LoadPair</span><br><span class="line">    LoadPair pair = loaderMap.remove(property.toUpperCase(Locale.ENGLISH));</span><br><span class="line">    if (pair != null) &#123;</span><br><span class="line">        // 加载结果</span><br><span class="line">        pair.load();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// -☆- LoadPair</span><br><span class="line">public void load() throws SQLException &#123;</span><br><span class="line">    if (this.metaResultObject == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;metaResultObject is null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (this.resultLoader == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;resultLoader is null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 调用重载方法</span><br><span class="line">    this.load(null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void load(final Object userObject) throws SQLException &#123;</span><br><span class="line">    /*</span><br><span class="line">     * 若 metaResultObject 和 resultLoader 为 null，则创建相关对象。</span><br><span class="line">     * 在当前调用情况下，两者均不为 null，条件不成立。篇幅原因，下面代码不分析了</span><br><span class="line">     */</span><br><span class="line">    if (this.metaResultObject == null || this.resultLoader == null) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    // 线程安全检测</span><br><span class="line">    if (this.serializationCheck == null) &#123;</span><br><span class="line">        final ResultLoader old = this.resultLoader;</span><br><span class="line">        // 重新创建新的 ResultLoader 和 ClosedExecutor，ClosedExecutor 是非线程安全的</span><br><span class="line">        this.resultLoader = new ResultLoader(old.configuration, new ClosedExecutor(), old.mappedStatement, old.parameterObject, old.targetType, old.cacheKey, old.boundSql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 调用 ResultLoader 的 loadResult 方法加载结果，</span><br><span class="line">     * 并通过 metaResultObject 设置结果到实体类对象中</span><br><span class="line">     */</span><br><span class="line">    this.metaResultObject.setValue(property, this.resultLoader.loadResult());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码比较多，但是没什么特别的逻辑，我们重点关注最后一行有效代码就行了。下面看一下 ResultLoader 的 loadResult 方法逻辑是怎样的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object loadResult() throws SQLException &#123;</span><br><span class="line">    // 执行关联查询</span><br><span class="line">    List&lt;Object&gt; list = selectList();</span><br><span class="line">    // 抽取结果</span><br><span class="line">    resultObject = resultExtractor.extractObjectFromList(list, targetType);</span><br><span class="line">    return resultObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private &lt;E&gt; List&lt;E&gt; selectList() throws SQLException &#123;</span><br><span class="line">    Executor localExecutor = executor;</span><br><span class="line">    if (Thread.currentThread().getId() != this.creatorThreadId || localExecutor.isClosed()) &#123;</span><br><span class="line">        localExecutor = newExecutor();</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 通过 Executor 就行查询，这个之前已经分析过了</span><br><span class="line">        return localExecutor.&lt;E&gt;query(mappedStatement, parameterObject, RowBounds.DEFAULT,</span><br><span class="line">                                      Executor.NO_RESULT_HANDLER, cacheKey, boundSql);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (localExecutor != executor) &#123;</span><br><span class="line">            localExecutor.close(false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，我们在 ResultLoader 中终于看到了执行关联查询的代码，即 selectList 方法中的逻辑。该方法在内部通过 Executor 进行查询。至于查询结果的抽取过程，并不是本节所关心的点，因此大家自行分析吧。到此，关于关联查询与延迟加载就分析完了。最后我们来看一下映射结果的存储过程是怎样的。</p>
<h5 id="2-2-6-4-存储映射结果"><a href="#2-2-6-4-存储映射结果" class="headerlink" title="2.2.6.4 存储映射结果"></a>2.2.6.4 存储映射结果</h5><p>存储映射结果是“查询结果”处理流程中的最后一环，实际上也是查询语句执行过程的最后一环。本节内容分析完，整个查询过程就分析完了，那接下来让我们带着喜悦的心情来分析映射结果存储逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void storeObject(ResultHandler&lt;?&gt; resultHandler, DefaultResultContext&lt;Object&gt; resultContext,Object rowValue, ResultMapping parentMapping, ResultSet rs) throws SQLException &#123;</span><br><span class="line">    if (parentMapping != null) &#123;</span><br><span class="line">        // 多结果集相关，不分析了</span><br><span class="line">        linkToParents(rs, parentMapping, rowValue);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 存储结果</span><br><span class="line">        callResultHandler(resultHandler, resultContext, rowValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void callResultHandler(ResultHandler&lt;?&gt; resultHandler, DefaultResultContext&lt;Object&gt; resultContext, Object rowValue) &#123;</span><br><span class="line">    // 设置结果到 resultContext 中</span><br><span class="line">    resultContext.nextResultObject(rowValue);</span><br><span class="line">    // 从 resultContext 获取结果，并存储到 resultHandler 中</span><br><span class="line">    ((ResultHandler&lt;Object&gt;) resultHandler).handleResult(resultContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，上面方法显示将 rowValue 设置到 ResultContext 中，然后再将 ResultContext 对象作为参数传给 ResultHandler 的 handleResult 方法。下面我们分别看一下 ResultContext 和 ResultHandler 的实现类。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DefaultResultContext&lt;T&gt; implements ResultContext&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private T resultObject;</span><br><span class="line">    private int resultCount;</span><br><span class="line">    </span><br><span class="line">    /** 状态字段 */</span><br><span class="line">    private boolean stopped;</span><br><span class="line"></span><br><span class="line">    // 省略部分代码</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isStopped() &#123;</span><br><span class="line">        return stopped;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void nextResultObject(T resultObject) &#123;</span><br><span class="line">        resultCount++;</span><br><span class="line">        this.resultObject = resultObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        this.stopped = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，DefaultResultContext 中包含了一个状态字段，表明结果上下文的状态。在处理多行数据时，MyBatis 会检查该字段的值，已决定是否需要进行后续的处理。该类的逻辑比较简单，不多说了。下面再来看一下 DefaultResultHandler 的源码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DefaultResultHandler implements ResultHandler&lt;Object&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final List&lt;Object&gt; list;</span><br><span class="line"></span><br><span class="line">    public DefaultResultHandler() &#123;</span><br><span class="line">        list = new ArrayList&lt;Object&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 省略部分源码</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void handleResult(ResultContext&lt;? extends Object&gt; context) &#123;</span><br><span class="line">        // 添加结果到 list 中</span><br><span class="line">        list.add(context.getResultObject());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;Object&gt; getResultList() &#123;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，DefaultResultHandler 默认使用 List 存储结果。除此之外，如果 Mapper （或 Dao）接口方法返回值为 Map 类型，此时则需要另一种 ResultHandler 实现类处理结果，即 DefaultMapResultHandler。关于 DefaultMapResultHandler 的源码大家自行分析吧啊，本节就不展开了。</p>
<h3 id="2-3-更新语句的执行过程分析"><a href="#2-3-更新语句的执行过程分析" class="headerlink" title="2.3 更新语句的执行过程分析"></a>2.3 更新语句的执行过程分析</h3><p>在上一节中，我较为完整的分析了查询语句的执行过程。尽管有些地方一笔带过了，但多数细节都分析到了。如果大家搞懂了查询语句的执行过程，那么理解更新语句的执行过程也将不在话下。执行更新语句所需处理的情况较之查询语句要简单不少，两者最大的区别更新语句的执行结果类型单一，处理逻辑要简单不是。除此之外，两者在缓存的处理上也有比较大的区别。更新过程会立即刷新缓存，而查询过程则不会。至于其他的不同点，就不一一列举了。下面开始分析更新语句的执行过程。</p>
<h4 id="2-3-1-更新语句执行过程全貌"><a href="#2-3-1-更新语句执行过程全貌" class="headerlink" title="2.3.1 更新语句执行过程全貌"></a>2.3.1 更新语句执行过程全貌</h4><p>首先，我们还是从 MapperMethod 的 execute 方法开始看起。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆-  MapperMethod</span><br><span class="line">public Object execute(SqlSession sqlSession, Object[] args) &#123;</span><br><span class="line">    Object result;</span><br><span class="line">    switch (command.getType()) &#123;</span><br><span class="line">        case INSERT: &#123;    // 执行插入语句</span><br><span class="line">            Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">            result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case UPDATE: &#123;    // 执行更新语句</span><br><span class="line">            Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">            result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case DELETE: &#123;    // 执行删除语句</span><br><span class="line">            Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">            result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case SELECT:</span><br><span class="line">            // ...</span><br><span class="line">            break;</span><br><span class="line">        case FLUSH:</span><br><span class="line">            // ...</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            throw new BindingException(&quot;Unknown execution method for: &quot; + command.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    if (result == null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;...&#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，插入、更新以及删除操作最终都调用了 SqlSession 接口中的方法。这三个方法返回值均是受影响行数，是一个整型值。rowCountResult 方法负责处理这个整型值，该方法的逻辑暂时先不分析，放在最后分析。接下来，我们往下层走一步，进入 SqlSession 实现类 DefaultSqlSession 的代码中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- DefaultSqlSession</span><br><span class="line">public int insert(String statement, Object parameter) &#123;</span><br><span class="line">    return update(statement, parameter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int delete(String statement, Object parameter) &#123;</span><br><span class="line">    return update(statement, parameter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int update(String statement, Object parameter) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        dirty = true;</span><br><span class="line">        // 获取 MappedStatement</span><br><span class="line">        MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">        // 调用 Executor 的 update 方法</span><br><span class="line">        return executor.update(ms, wrapCollection(parameter));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw ExceptionFactory.wrapException(&quot;Error updating database.  Cause: &quot; + e, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，insert 和 delete 方法最终都调用了同一个 update 方法，这就是为什么我把他们归为一类的原因。既然它们最终调用的都是同一个方法，那么MyBatis 为什么还要在 SqlSession 中提供这么多方法呢，难道只提供 update 方法不行么？答案是：只提供一个 update 方法从实现上完全可行，但是从接口的语义化的角度来说，这样做并不好。一般情况下，使用者觉得 update 接口方法应该仅负责执行 UPDATE 语句，如果它还兼职执行其他的 SQL 语句，会让使用者产生疑惑。对于对外的接口，接口功能越单一，语义越清晰越好。在日常开发中，我们为客户端提供接口时，也应该这样做。比如我之前写过一个文章评论的开关接口，我写的接口如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Result openComment();</span><br><span class="line">Result closeComment();</span><br></pre></td></tr></table></figure>

<p>上面接口语义比较清晰，同时没有参数，后端不用校验参数，客户端同学也不用思考传什么值。如果我像下面这样定义接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Result updateCommentStatus(Integer status);    // 0 - 关闭，1 - 开启</span><br></pre></td></tr></table></figure>

<p>首先这个方法没有上面两个方法语义清晰，其次需要传入一个整型状态值，客户端需要注意传值，后端也要进行校验。好了，关于接口语义化就先说这么多。扯多了，回归正题，下面分析 Executor 的 update 方法。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- CachingExecutor</span><br><span class="line">public int update(MappedStatement ms, Object parameterObject) throws SQLException &#123;</span><br><span class="line">    // 刷新二级缓存</span><br><span class="line">    flushCacheIfRequired(ms);</span><br><span class="line">    return delegate.update(ms, parameterObject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// -☆- BaseExecutor</span><br><span class="line">public int update(MappedStatement ms, Object parameter) throws SQLException &#123;</span><br><span class="line">    if (closed) &#123;</span><br><span class="line">        throw new ExecutorException(&quot;Executor was closed.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 刷新一级缓存</span><br><span class="line">    clearLocalCache();</span><br><span class="line">    return doUpdate(ms, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，Executor 实现类中的方法在进行下一步操作之前，都会先刷新各自的缓存。默认情况下，insert、update 和 delete 操作都会清空一二级缓存。清空缓存的逻辑不复杂，大家自行分析。下面分析 doUpdate 方法，该方法是一个抽象方法，因此我们到 BaseExecutor 的子类 SimpleExecutor 中看看该方法是如何实现的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- SimpleExecutor</span><br><span class="line">public int doUpdate(MappedStatement ms, Object parameter) throws SQLException &#123;</span><br><span class="line">    Statement stmt = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        Configuration configuration = ms.getConfiguration();</span><br><span class="line">        // 创建 StatementHandler</span><br><span class="line">        StatementHandler handler = configuration.newStatementHandler(this, ms, parameter, RowBounds.DEFAULT, null, null);</span><br><span class="line">        // 创建 Statement</span><br><span class="line">        stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">        // 调用 StatementHandler 的 update 方法</span><br><span class="line">        return handler.update(stmt);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StatementHandler 和 Statement 的创建过程前面已经分析过，这里就不重复分析了。下面分析 PreparedStatementHandler 的 update 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- PreparedStatementHandler</span><br><span class="line">public int update(Statement statement) throws SQLException &#123;</span><br><span class="line">    PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">    // 执行 SQL</span><br><span class="line">    ps.execute();</span><br><span class="line">    // 返回受影响行数</span><br><span class="line">    int rows = ps.getUpdateCount();</span><br><span class="line">    // 获取用户传入的参数值，参数值类型可能是普通的实体类，也可能是 Map</span><br><span class="line">    Object parameterObject = boundSql.getParameterObject();</span><br><span class="line">    </span><br><span class="line">    KeyGenerator keyGenerator = mappedStatement.getKeyGenerator();</span><br><span class="line">    // 获取自增主键的值，并将值填入到参数对象中</span><br><span class="line">    keyGenerator.processAfter(executor, mappedStatement, ps, parameterObject);</span><br><span class="line">    return rows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PreparedStatementHandler 的 update 方法的逻辑比较清晰明了了，更新语句的 SQL 会在此方法中被执行。执行结果为受影响行数，对于 insert 语句，有时候我们还想获取自增主键的值，因此我们需要进行一些额外的操作。这些额外操作的逻辑封装在 KeyGenerator 的实现类中，下面我们一起看一下 KeyGenerator 的实现逻辑。</p>
<h4 id="2-3-2-KeyGenerator"><a href="#2-3-2-KeyGenerator" class="headerlink" title="2.3.2 KeyGenerator"></a>2.3.2 KeyGenerator</h4><p>KeyGenerator 是一个接口，目前它有三个实现类，分别如下：</p>
<ol>
<li>Jdbc3KeyGenerator</li>
<li>SelectKeyGenerator</li>
<li>NoKeyGenerator</li>
</ol>
<p>Jdbc3KeyGenerator 用于获取插入数据后的自增主键数值。某些数据库不支持自增主键，需要手动填写主键字段，此时需要借助 SelectKeyGenerator 获取主键值。至于 NoKeyGenerator，这是一个空实现，没什么可说的。下面，我将分析 Jdbc3KeyGenerator 的源码，至于 SelectKeyGenerator，大家请自行分析。下面看源码吧。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- Jdbc3KeyGenerator</span><br><span class="line">public void processBefore(Executor executor, MappedStatement ms, Statement stmt, Object parameter) &#123;</span><br><span class="line">    // 空方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void processAfter(Executor executor, MappedStatement ms, Statement stmt, Object parameter) &#123;</span><br><span class="line">    processBatch(ms, stmt, getParameters(parameter));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void processBatch(MappedStatement ms, Statement stmt, Collection&lt;Object&gt; parameters) &#123;</span><br><span class="line">    ResultSet rs = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        rs = stmt.getGeneratedKeys();</span><br><span class="line">        final Configuration configuration = ms.getConfiguration();</span><br><span class="line">        final TypeHandlerRegistry typeHandlerRegistry = configuration.getTypeHandlerRegistry();</span><br><span class="line">        // 获取主键字段</span><br><span class="line">        final String[] keyProperties = ms.getKeyProperties();</span><br><span class="line">        // 获取结果集 ResultSet 的元数据</span><br><span class="line">        final ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line">        TypeHandler&lt;?&gt;[] typeHandlers = null;</span><br><span class="line">        // ResultSet 中数据的列数要大于等于主键的数量</span><br><span class="line">        if (keyProperties != null &amp;&amp; rsmd.getColumnCount() &gt;= keyProperties.length) &#123;</span><br><span class="line">            // 遍历 parameters</span><br><span class="line">            for (Object parameter : parameters) &#123;</span><br><span class="line">                // 对于批量插入，ResultSet 会返回多行数据</span><br><span class="line">                if (!rs.next()) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                final MetaObject metaParam = configuration.newMetaObject(parameter);</span><br><span class="line">                if (typeHandlers == null) &#123;</span><br><span class="line">                    // 为每个主键属性获取 TypeHandler</span><br><span class="line">                    typeHandlers = getTypeHandlers(typeHandlerRegistry, metaParam, keyProperties, rsmd);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 填充结果到运行时参数中</span><br><span class="line">                populateKeys(rs, metaParam, keyProperties, typeHandlers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new ExecutorException(...);</span><br><span class="line">    &#125; finally &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Collection&lt;Object&gt; getParameters(Object parameter) &#123;</span><br><span class="line">    Collection&lt;Object&gt; parameters = null;</span><br><span class="line">    if (parameter instanceof Collection) &#123;</span><br><span class="line">        parameters = (Collection) parameter;</span><br><span class="line">    &#125; else if (parameter instanceof Map) &#123;</span><br><span class="line">        Map parameterMap = (Map) parameter;</span><br><span class="line">        /*</span><br><span class="line">         * 如果 parameter 是 Map 类型，则从其中提取指定 key 对应的值。</span><br><span class="line">         * 至于 Map 中为什么会出现 collection/list/array 等键。大家</span><br><span class="line">         * 可以参考 DefaultSqlSession 的 wrapCollection 方法</span><br><span class="line">         */</span><br><span class="line">        if (parameterMap.containsKey(&quot;collection&quot;)) &#123;</span><br><span class="line">            parameters = (Collection) parameterMap.get(&quot;collection&quot;);</span><br><span class="line">        &#125; else if (parameterMap.containsKey(&quot;list&quot;)) &#123;</span><br><span class="line">            parameters = (List) parameterMap.get(&quot;list&quot;);</span><br><span class="line">        &#125; else if (parameterMap.containsKey(&quot;array&quot;)) &#123;</span><br><span class="line">            parameters = Arrays.asList((Object[]) parameterMap.get(&quot;array&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (parameters == null) &#123;</span><br><span class="line">        parameters = new ArrayList&lt;Object&gt;();</span><br><span class="line">        // 将普通的对象添加到 parameters 中</span><br><span class="line">        parameters.add(parameter);</span><br><span class="line">    &#125;</span><br><span class="line">    return parameters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Jdbc3KeyGenerator 的 processBefore 方法是一个空方法，processAfter 则是一个空壳方法，只有一行代码。Jdbc3KeyGenerator 的重点在 processBatch 方法中，由于存在批量插入的情况，所以该方法的名字类包含 batch 单词，表示可处理批量插入的结果集。processBatch 方法的逻辑并不是很复杂，主要流程如下：</p>
<ol>
<li>获取主键数组(keyProperties)</li>
<li>获取 ResultSet 元数据</li>
<li>遍历参数列表，为每个主键属性获取 TypeHandler</li>
<li>从 ResultSet 中获取主键数据，并填充到参数中</li>
</ol>
<p>在上面流程中，第 1~3 步骤都是常规操作，第4个步骤需要分析一下。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void populateKeys(ResultSet rs, MetaObject metaParam, String[] keyProperties, TypeHandler&lt;?&gt;[] typeHandlers) throws SQLException &#123;</span><br><span class="line">    // 遍历 keyProperties</span><br><span class="line">    for (int i = 0; i &lt; keyProperties.length; i++) &#123;</span><br><span class="line">        // 获取主键属性</span><br><span class="line">        String property = keyProperties[i];</span><br><span class="line">        TypeHandler&lt;?&gt; th = typeHandlers[i];</span><br><span class="line">        if (th != null) &#123;</span><br><span class="line">            // 从 ResultSet 中获取某列的值</span><br><span class="line">            Object value = th.getResult(rs, i + 1);</span><br><span class="line">            // 设置结果值到运行时参数中</span><br><span class="line">            metaParam.setValue(property, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，populateKeys 方法首先是遍历主键数组，然后通过 TypeHandler 从 ResultSet 中获取自增主键的值，最后再通过元信息对象将自增主键的值设置到参数中。</p>
<p>以上就是 Jdbc3KeyGenerator 的原理分析，下面写个示例演示一下。</p>
<p>本次演示所用到的实体类如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Author &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private Integer sex;</span><br><span class="line">    private String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mapper 接口和映射文件内容如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface AuthorDao &#123;</span><br><span class="line">    int insertMany(List&lt;Author&gt; authors);</span><br><span class="line">&#125;</span><br><span class="line">&lt;insert id=&quot;insertMany&quot; keyProperty=&quot;id&quot; useGeneratedKeys=&quot;true&quot;&gt;</span><br><span class="line">    INSERT INTO</span><br><span class="line">    	author (`name`, `age`, `sex`, `email`)</span><br><span class="line">    VALUES</span><br><span class="line">    &lt;foreach item=&quot;author&quot; index=&quot;index&quot; collection=&quot;list&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">        (#&#123;author.name&#125;, #&#123;author.age&#125;, #&#123;author.sex&#125;, #&#123;author.email&#125;)</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<p>测试代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class InsertManyTest &#123;</span><br><span class="line"></span><br><span class="line">    private SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    public void prepare() throws IOException &#123;</span><br><span class="line">        String resource = &quot;mybatis-insert-many-config.xml&quot;;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testInsertMany() &#123;</span><br><span class="line">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">        try &#123;</span><br><span class="line">            List&lt;Author&gt; authors = new ArrayList&lt;&gt;();</span><br><span class="line">            // 添加多个 Author 对象到 authors 中</span><br><span class="line">            authors.add(new Author(&quot;tianxiaobo-1&quot;, 20, 0, &quot;coolblog.xyz@outlook.com&quot;));</span><br><span class="line">            authors.add(new Author(&quot;tianxiaobo-2&quot;, 18, 0, &quot;coolblog.xyz@outlook.com&quot;));</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;\nBefore Insert: &quot;);</span><br><span class="line">            authors.forEach(author -&gt; System.out.println(&quot;  &quot; + author));</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">            AuthorDao authorDao = session.getMapper(AuthorDao.class);</span><br><span class="line">            authorDao.insertMany(authors);</span><br><span class="line">            session.commit();</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;\nAfter Insert: &quot;);</span><br><span class="line">            authors.forEach(author -&gt; System.out.println(&quot;  &quot; + author));</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            session.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在测试代码中，我创建了一个 Author 集合，并向集合中插入了两个 Author 对象。然后将集合中的元素批量插入到 author 表中，得到如下结果：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15343307821193.jpg" alt="img"></p>
<p>如上图，执行插入语句前，列表中元素的 id 字段均为 null。插入数据后，列表元素中的 id 字段均被赋值了。好了，到此，关于 Jdbc3KeyGenerator 的原理与使用就分析完了。</p>
<h4 id="2-3-3-处理更新结果"><a href="#2-3-3-处理更新结果" class="headerlink" title="2.3.3 处理更新结果"></a>2.3.3 处理更新结果</h4><p>更新语句的执行结果是一个整型值，表示本次更新所影响的行数。由于返回值类型简单，因此处理逻辑也很简单。下面我们简单看一下，放松放松。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆-  MapperMethod</span><br><span class="line">private Object rowCountResult(int rowCount) &#123;</span><br><span class="line">    final Object result;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 这里的 method 类型为 MethodSignature，即方法签名，包含了某个方法较为详细的信息。</span><br><span class="line">     * 某个方法指的是 Mapper 或 Dao 接口中的方法，比如上一节示例 AuthorDao 中的</span><br><span class="line">     * insertMany 方法。</span><br><span class="line">     */</span><br><span class="line">    if (method.returnsVoid()) &#123;</span><br><span class="line">        // 方法返回类型为 void，则不用返回结果，这里将结果置空</span><br><span class="line">        result = null;</span><br><span class="line">    &#125; else if (Integer.class.equals(method.getReturnType()) || Integer.TYPE.equals(method.getReturnType())) &#123;</span><br><span class="line">        // 方法返回类型为 Integer 或 int，直接赋值返回即可</span><br><span class="line">        result = rowCount;</span><br><span class="line">    &#125; else if (Long.class.equals(method.getReturnType()) || Long.TYPE.equals(method.getReturnType())) &#123;</span><br><span class="line">        // 如果返回值类型为 Long 或者 long，这里强转一下即可</span><br><span class="line">        result = (long) rowCount;</span><br><span class="line">    &#125; else if (Boolean.class.equals(method.getReturnType()) || Boolean.TYPE.equals(method.getReturnType())) &#123;</span><br><span class="line">        // 方法返回类型为布尔类型，若 rowCount &gt; 0，则返回 ture，否则返回 false</span><br><span class="line">        result = rowCount &gt; 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new BindingException(...);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，MyBatis 对于更新语句的执行结果处理逻辑足够简单，很容易看懂，我就不多说了。</p>
<h3 id="2-4-小节"><a href="#2-4-小节" class="headerlink" title="2.4 小节"></a>2.4 小节</h3><p>经过前面前面的分析，相信大家对 MyBatis 执行 SQL 的过程都有比较深入的理解。本章的最后，用一张图 MyBatis 的执行过程进行一个总结。如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15343456438237.jpg" alt="img"></p>
<p>在 MyBatis 中，SQL 执行过程的实现代码是有层次的，每层都有相应的功能。比如，SqlSession 是对外接口的接口，因此它提供了各种语义清晰的方法，供使用者调用。Executor 层做的事情较多，比如一二级缓存功能就是嵌入在该层内的。StatementHandler 层主要是与 JDBC 层面的接口打交道。至于 ParameterHandler 和 ResultSetHandler，一个负责向 SQL 中设置运行时参数，另一个负责处理 SQL 执行结果，它们俩可以看做是 StatementHandler 辅助类。最后看一下右边横跨数层的类，Configuration 是一个全局配置类，很多地方都依赖它。MappedStatement 对应 SQL 配置，包含了 SQL 配置的相关信息。BoundSql 中包含了已完成解析的 SQL 语句，以及运行时参数等。</p>
<p>到此，关于 SQL 的执行过程就分析完了。内容比较多，希望大家耐心阅读。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>到这里，本文就接近尾声了。本篇文章从本月的1号开始写，一直到16号才写完初稿。内容之多，完全超出我事先的预计。尽管本文篇幅很大，但仍有部分逻辑和细节没有分析到，比如 SelectKeyGenerator。对于这些内容，如果大家能耐心看完本文，并且仔细分析了 MyBatis 执行 SQL 的相关源码，那么对 MyBatis 的原理会有很深的理解。深入理解 MyBatis，对日常工作也会产生积极的影响。比如我现在就以随心所欲的写 SQL 映射文件，把不合理的配置统统删掉。如果遇到 MyBatis 层面的异常，也不用担心无法解决了。好了，一不小心又扯多了。本篇文章篇幅比较大，这其中可能存在这一些错误不妥之处。如果大家发现了，望指明，这里先说声谢谢。</p>
<p>好了，本文到此就结束了。感谢大家的阅读。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://book.douban.com/subject/27087564/">《MyBatis 技术内幕》- 徐郡明</a></li>
<li><a href="http://www.mybatis.org/mybatis-3/zh/index.html">MyBatis 官方文档</a></li>
</ul>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis源码分析-映射文件解析过程</title>
    <url>/2022/10/25/MyBatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>在上一篇文章中，我详细分析了 MyBatis 配置文件的解析过程。由于上一篇文章的篇幅比较大，加之映射文件解析过程也比较复杂的原因。所以我将映射文件解析过程的分析内容从上一篇文章中抽取出来，独立成文，于是就有了本篇文章。在本篇文章中，我将分析映射文件中出现的一些及节点，比如 <cache>，<cache-ref>，<resultMap>, &lt;select | insert | update | delete&gt; 等。除了分析常规的 XML 解析过程外，我还会向大家介绍 Mapper 接口的绑定过程等。综上所述，本篇文章内容会比较丰富，如果大家对此感兴趣，不妨花点时间读一读，会有新的收获。当然，本篇文章通篇是关于源码分析的，所以阅读本文需要大家对 MyBatis 有一定的了解。如果大家对 MyBatis 还不是很了解，建议阅读一下 MyBatis 的<a href="http://www.mybatis.org/mybatis-3/zh/index.html">官方文档</a>。</resultMap></cache-ref></cache></p>
<p>其他的就不多说了，下面开始我们的 MyBatis 源码之旅。</p>
<h2 id="2-映射文件解析过程分析"><a href="#2-映射文件解析过程分析" class="headerlink" title="2.映射文件解析过程分析"></a>2.映射文件解析过程分析</h2><p>我在前面说过，映射文件的解析过程是 MyBatis 配置文件解析过程的一部分。MyBatis 的配置文件由 XMLConfigBuilder 的 parseConfiguration 进行解析，该方法依次解析了 <properties>、<settings>、<typeAliases> 等节点。至于 <mappers> 节点，parseConfiguration 则是在方法的结尾对其进行了解析。该部分的解析逻辑封装在 mapperElement 方法中，下面来看一下。</mappers></typeAliases></settings></properties></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- XMLConfigBuilder</span><br><span class="line">private void mapperElement(XNode parent) throws Exception &#123;</span><br><span class="line">    if (parent != null) &#123;</span><br><span class="line">        for (XNode child : parent.getChildren()) &#123;</span><br><span class="line">            if (&quot;package&quot;.equals(child.getName())) &#123;</span><br><span class="line">                // 获取 &lt;package&gt; 节点中的 name 属性</span><br><span class="line">                String mapperPackage = child.getStringAttribute(&quot;name&quot;);</span><br><span class="line">                // 从指定包中查找 mapper 接口，并根据 mapper 接口解析映射配置</span><br><span class="line">                configuration.addMappers(mapperPackage);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 获取 resource/url/class 等属性</span><br><span class="line">                String resource = child.getStringAttribute(&quot;resource&quot;);</span><br><span class="line">                String url = child.getStringAttribute(&quot;url&quot;);</span><br><span class="line">                String mapperClass = child.getStringAttribute(&quot;class&quot;);</span><br><span class="line"></span><br><span class="line">                // resource 不为空，且其他两者为空，则从指定路径中加载配置</span><br><span class="line">                if (resource != null &amp;&amp; url == null &amp;&amp; mapperClass == null) &#123;</span><br><span class="line">                    ErrorContext.instance().resource(resource);</span><br><span class="line">                    InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">                    XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">                    // 解析映射文件</span><br><span class="line">                    mapperParser.parse();</span><br><span class="line"></span><br><span class="line">                // url 不为空，且其他两者为空，则通过 url 加载配置</span><br><span class="line">                &#125; else if (resource == null &amp;&amp; url != null &amp;&amp; mapperClass == null) &#123;</span><br><span class="line">                    ErrorContext.instance().resource(url);</span><br><span class="line">                    InputStream inputStream = Resources.getUrlAsStream(url);</span><br><span class="line">                    XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">                    // 解析映射文件</span><br><span class="line">                    mapperParser.parse();</span><br><span class="line"></span><br><span class="line">                // mapperClass 不为空，且其他两者为空，则通过 mapperClass 解析映射配置</span><br><span class="line">                &#125; else if (resource == null &amp;&amp; url == null &amp;&amp; mapperClass != null) &#123;</span><br><span class="line">                    Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">                    configuration.addMapper(mapperInterface);</span><br><span class="line"></span><br><span class="line">                // 以上条件不满足，则抛出异常</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    throw new BuilderException(&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码比较简单，主要逻辑是遍历 mappers 的子节点，并根据节点属性值判断通过什么方式加载映射文件或映射信息。这里，我把配置在注解中的内容称为<code>映射信息</code>，以 XML 为载体的配置称为<code>映射文件</code>。在 MyBatis 中，共有四种加载映射文件或信息的方式。第一种是从文件系统中加载映射文件；第二种是通过 URL 的方式加载和解析映射文件；第三种是通过 mapper 接口加载映射信息，映射信息可以配置在注解中，也可以配置在映射文件中。最后一种是通过包扫描的方式获取到某个包下的所有类，并使用第三种方式为每个类解析映射信息。</p>
<p>以上简单介绍了 MyBatis 加载映射文件或信息的几种方式。需要注意的是，在 MyBatis 中，通过注解配置映射信息的方式是有一定局限性的，这一点 MyBatis 官方文档中描述的比较清楚。这里引用一下：</p>
<blockquote>
<p>因为最初设计时，MyBatis 是一个 XML 驱动的框架。配置信息是基于 XML 的，而且映射语句也是定义在 XML 中的。而到了 MyBatis 3，就有新选择了。MyBatis 3 构建在全面且强大的基于 Java 语言的配置 API 之上。这个配置 API 是基于 XML 的 MyBatis 配置的基础，也是新的基于注解配置的基础。注解提供了一种简单的方式来实现<strong>简单映射语句</strong>，而不会引入大量的开销。</p>
</blockquote>
<blockquote>
<p><strong>注意：</strong> 不幸的是，<strong>Java 注解的的表达力和灵活性十分有限</strong>。尽管很多时间都花在调查、设计和试验上，<strong>最强大的 MyBatis 映射并不能用注解来构建</strong>——并不是在开玩笑，的确是这样。</p>
</blockquote>
<p>如上所示，重点语句我用黑体标注了出来。限于 Java 注解的表达力和灵活性，通过注解的方式并不能完全发挥 MyBatis 的能力。所以，对于一些较为复杂的配置信息，我们还是应该通过 XML 的方式进行配置。正因此，在接下的章节中，我会重点分析基于 XML 的映射文件的解析过程。如果能弄懂此种配置方式的解析过程，那么基于注解的解析过程也不在话下。</p>
<p>下面开始分析映射文件的解析过程，在展开分析之前，先来看一下映射文件解析入口。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- XMLMapperBuilder</span><br><span class="line">public void parse() &#123;</span><br><span class="line">    // 检测映射文件是否已经被解析过</span><br><span class="line">    if (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">        // 解析 mapper 节点</span><br><span class="line">        configurationElement(parser.evalNode(&quot;/mapper&quot;));</span><br><span class="line">        // 添加资源路径到“已解析资源集合”中</span><br><span class="line">        configuration.addLoadedResource(resource);</span><br><span class="line">        // 通过命名空间绑定 Mapper 接口</span><br><span class="line">        bindMapperForNamespace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 处理未完成解析的节点</span><br><span class="line">    parsePendingResultMaps();</span><br><span class="line">    parsePendingCacheRefs();</span><br><span class="line">    parsePendingStatements();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，映射文件解析入口逻辑包含三个核心操作，分别如下：</p>
<ol>
<li>解析 mapper 节点</li>
<li>通过命名空间绑定 Mapper 接口</li>
<li>处理未完成解析的节点</li>
</ol>
<p>这三个操作对应的逻辑，我将会在随后的章节中依次进行分析。下面，先来分析第一个操作对应的逻辑。</p>
<h3 id="2-1-解析映射文件"><a href="#2-1-解析映射文件" class="headerlink" title="2.1 解析映射文件"></a>2.1 解析映射文件</h3><p>在 MyBatis 映射文件中，可以配置多种节点。比如 <cache>，<resultMap>，<sql> 以及 &lt;select | insert | update | delete&gt; 等。下面我们来看一个映射文件配置示例。</sql></resultMap></cache></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mapper namespace=&quot;xyz.coolblog.dao.AuthorDao&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;cache/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;resultMap id=&quot;authorResult&quot; type=&quot;Author&quot;&gt;</span><br><span class="line">        &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;</span><br><span class="line">        &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;</span><br><span class="line">        &lt;!-- ... --&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    &lt;sql id=&quot;table&quot;&gt;</span><br><span class="line">        author</span><br><span class="line">    &lt;/sql&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=&quot;findOne&quot; resultMap=&quot;authorResult&quot;&gt;</span><br><span class="line">        SELECT</span><br><span class="line">            id, name, age, sex, email</span><br><span class="line">        FROM</span><br><span class="line">            &lt;include refid=&quot;table&quot;/&gt;</span><br><span class="line">        WHERE</span><br><span class="line">            id = #&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- &lt;insert|update|delete/&gt; --&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>上面是一个比较简单的映射文件，还有一些的节点没有出现在上面。以上每种配置中的每种节点的解析逻辑都封装在了相应的方法中，这些方法由 XMLMapperBuilder 类的 configurationElement 方法统一调用。该方法的逻辑如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void configurationElement(XNode context) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 获取 mapper 命名空间</span><br><span class="line">        String namespace = context.getStringAttribute(&quot;namespace&quot;);</span><br><span class="line">        if (namespace == null || namespace.equals(&quot;&quot;)) &#123;</span><br><span class="line">            throw new BuilderException(&quot;Mapper&#x27;s namespace cannot be empty&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 设置命名空间到 builderAssistant 中</span><br><span class="line">        builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line"></span><br><span class="line">        // 解析 &lt;cache-ref&gt; 节点</span><br><span class="line">        cacheRefElement(context.evalNode(&quot;cache-ref&quot;));</span><br><span class="line"></span><br><span class="line">        // 解析 &lt;cache&gt; 节点</span><br><span class="line">        cacheElement(context.evalNode(&quot;cache&quot;));</span><br><span class="line"></span><br><span class="line">        // 已废弃配置，这里不做分析</span><br><span class="line">        parameterMapElement(context.evalNodes(&quot;/mapper/parameterMap&quot;));</span><br><span class="line"></span><br><span class="line">        // 解析 &lt;resultMap&gt; 节点</span><br><span class="line">        resultMapElements(context.evalNodes(&quot;/mapper/resultMap&quot;));</span><br><span class="line"></span><br><span class="line">        // 解析 &lt;sql&gt; 节点</span><br><span class="line">        sqlElement(context.evalNodes(&quot;/mapper/sql&quot;));</span><br><span class="line"></span><br><span class="line">        // 解析 &lt;select&gt;、...、&lt;delete&gt; 等节点</span><br><span class="line">        buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new BuilderException(&quot;Error parsing Mapper XML. The XML location is &#x27;&quot; + resource + &quot;&#x27;. Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码的执行流程清晰明了。在阅读源码时，我们可以按部就班的分析每个方法调用即可。不过在写文章进行叙述时，需要做一些调整。下面我将会先分析 <cache> 节点的解析过程，然后再分析 <cache-ref> 节点，之后会按照顺序分析其他节点的解析过程。接下来，我们来看看 <cache> 节点的解析过程。</cache></cache-ref></cache></p>
<h4 id="2-1-1-解析-节点"><a href="#2-1-1-解析-节点" class="headerlink" title="2.1.1 解析  节点"></a>2.1.1 解析 <cache> 节点</cache></h4><p>MyBatis 提供了一、二级缓存，其中一级缓存是 SqlSession 级别的，默认为开启状态。二级缓存配置在映射文件中，使用者需要显示配置才能开启。如果没有特殊要求，二级缓存的配置很容易。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;cache/&gt;</span><br></pre></td></tr></table></figure>

<p>如果我们想修改缓存的一些属性，可以像下面这样配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;cache</span><br><span class="line">  eviction=&quot;FIFO&quot;</span><br><span class="line">  flushInterval=&quot;60000&quot;</span><br><span class="line">  size=&quot;512&quot;</span><br><span class="line">  readOnly=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>根据上面的配置创建出的缓存有以下特点：</p>
<ol>
<li>按先进先出的策略淘汰缓存项</li>
<li>缓存的容量为 512 个对象引用</li>
<li>缓存每隔60秒刷新一次</li>
<li>缓存返回的对象是写安全的，即在外部修改对象不会影响到缓存内部存储对象</li>
</ol>
<p>除了上面两种配置方式，我们还可以给 MyBatis 配置第三方缓存或者自己实现的缓存等。比如，我们将 Ehcache 缓存整合到 MyBatis 中，可以这样配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;timeToIdleSeconds&quot; value=&quot;3600&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;timeToLiveSeconds&quot; value=&quot;3600&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;maxEntriesLocalHeap&quot; value=&quot;1000&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;maxEntriesLocalDisk&quot; value=&quot;10000000&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;memoryStoreEvictionPolicy&quot; value=&quot;LRU&quot;/&gt;</span><br><span class="line">&lt;/cache&gt;</span><br></pre></td></tr></table></figure>

<p>以上简单介绍了几种缓存配置方式，关于 MyBatis 缓存更多的知识，后面我会独立成文进行分析，这里就不深入说明了。下面我们来分析一下缓存配置的解析逻辑，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void cacheElement(XNode context) throws Exception &#123;</span><br><span class="line">    if (context != null) &#123;</span><br><span class="line">        // 获取各种属性</span><br><span class="line">        String type = context.getStringAttribute(&quot;type&quot;, &quot;PERPETUAL&quot;);</span><br><span class="line">        Class&lt;? extends Cache&gt; typeClass = typeAliasRegistry.resolveAlias(type);</span><br><span class="line">        String eviction = context.getStringAttribute(&quot;eviction&quot;, &quot;LRU&quot;);</span><br><span class="line">        Class&lt;? extends Cache&gt; evictionClass = typeAliasRegistry.resolveAlias(eviction);</span><br><span class="line">        Long flushInterval = context.getLongAttribute(&quot;flushInterval&quot;);</span><br><span class="line">        Integer size = context.getIntAttribute(&quot;size&quot;);</span><br><span class="line">        boolean readWrite = !context.getBooleanAttribute(&quot;readOnly&quot;, false);</span><br><span class="line">        boolean blocking = context.getBooleanAttribute(&quot;blocking&quot;, false);</span><br><span class="line"></span><br><span class="line">        // 获取子节点配置</span><br><span class="line">        Properties props = context.getChildrenAsProperties();</span><br><span class="line"></span><br><span class="line">        // 构建缓存对象</span><br><span class="line">        builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, blocking, props);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，大段代码用来解析 <cache> 节点的属性和子节点，这些代码没什么好说的。缓存的构建逻辑封装在 BuilderAssistant 类的 useNewCache 方法中，下面我们来看一下该方法的逻辑。</cache></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- MapperBuilderAssistant</span><br><span class="line">public Cache useNewCache(Class&lt;? extends Cache&gt; typeClass,</span><br><span class="line">    Class&lt;? extends Cache&gt; evictionClass,Long flushInterval,</span><br><span class="line">    Integer size,boolean readWrite,boolean blocking,Properties props) &#123;</span><br><span class="line"></span><br><span class="line">    // 使用建造模式构建缓存实例</span><br><span class="line">    Cache cache = new CacheBuilder(currentNamespace)</span><br><span class="line">        .implementation(valueOrDefault(typeClass, PerpetualCache.class))</span><br><span class="line">        .addDecorator(valueOrDefault(evictionClass, LruCache.class))</span><br><span class="line">        .clearInterval(flushInterval)</span><br><span class="line">        .size(size)</span><br><span class="line">        .readWrite(readWrite)</span><br><span class="line">        .blocking(blocking)</span><br><span class="line">        .properties(props)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    // 添加缓存到 Configuration 对象中</span><br><span class="line">    configuration.addCache(cache);</span><br><span class="line"></span><br><span class="line">    // 设置 currentCache 遍历，即当前使用的缓存</span><br><span class="line">    currentCache = cache;</span><br><span class="line">    return cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面使用了建造模式构建 Cache 实例，Cache 实例的构建过程略为复杂，我们跟下去看看。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- CacheBuilder</span><br><span class="line">public Cache build() &#123;</span><br><span class="line">    // 设置默认的缓存类型（PerpetualCache）和缓存装饰器（LruCache）</span><br><span class="line">    setDefaultImplementations();</span><br><span class="line"></span><br><span class="line">    // 通过反射创建缓存</span><br><span class="line">    Cache cache = newBaseCacheInstance(implementation, id);</span><br><span class="line">    setCacheProperties(cache);</span><br><span class="line">    // 仅对内置缓存 PerpetualCache 应用装饰器</span><br><span class="line">    if (PerpetualCache.class.equals(cache.getClass())) &#123;</span><br><span class="line">        // 遍历装饰器集合，应用装饰器</span><br><span class="line">        for (Class&lt;? extends Cache&gt; decorator : decorators) &#123;</span><br><span class="line">        	// 通过反射创建装饰器实例</span><br><span class="line">            cache = newCacheDecoratorInstance(decorator, cache);</span><br><span class="line">            // 设置属性值到缓存实例中</span><br><span class="line">            setCacheProperties(cache);</span><br><span class="line">        &#125;</span><br><span class="line">        // 应用标准的装饰器，比如 LoggingCache、SynchronizedCache</span><br><span class="line">        cache = setStandardDecorators(cache);</span><br><span class="line">    &#125; else if (!LoggingCache.class.isAssignableFrom(cache.getClass())) &#123;</span><br><span class="line">        // 应用具有日志功能的缓存装饰器</span><br><span class="line">        cache = new LoggingCache(cache);</span><br><span class="line">    &#125;</span><br><span class="line">    return cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的构建过程流程较为复杂，这里总结一下。如下：</p>
<ol>
<li>设置默认的缓存类型及装饰器</li>
<li>应用装饰器到 PerpetualCache 对象上<ul>
<li>遍历装饰器类型集合，并通过反射创建装饰器实例</li>
<li>将属性设置到实例中</li>
</ul>
</li>
<li>应用一些标准的装饰器</li>
<li>对非 LoggingCache 类型的缓存应用 LoggingCache 装饰器</li>
</ol>
<p>在以上4个步骤中，最后一步的逻辑很简单，无需多说。下面按顺序分析前3个步骤对应的逻辑，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void setDefaultImplementations() &#123;</span><br><span class="line">    if (implementation == null) &#123;</span><br><span class="line">        // 设置默认的缓存实现类</span><br><span class="line">        implementation = PerpetualCache.class;</span><br><span class="line">        if (decorators.isEmpty()) &#123;</span><br><span class="line">            // 添加 LruCache 装饰器</span><br><span class="line">            decorators.add(LruCache.class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上逻辑比较简单，主要做的事情是在 implementation 为空的情况下，为它设置一个默认值。如果大家仔细看前面的方法，会发现 MyBatis 做了不少判空的操作。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 判空操作1，若用户未设置 cache 节点的 type 和 eviction 属性，这里设置默认值 PERPETUAL</span><br><span class="line">String type = context.getStringAttribute(&quot;type&quot;, &quot;PERPETUAL&quot;);</span><br><span class="line">String eviction = context.getStringAttribute(&quot;eviction&quot;, &quot;LRU&quot;);</span><br><span class="line"></span><br><span class="line">// 判空操作2，若 typeClass 或 evictionClass 为空，valueOrDefault 方法会为它们设置默认值</span><br><span class="line">Cache cache = new CacheBuilder(currentNamespace)</span><br><span class="line">            .implementation(valueOrDefault(typeClass, PerpetualCache.class))</span><br><span class="line">            .addDecorator(valueOrDefault(evictionClass, LruCache.class))</span><br><span class="line">            // 省略部分代码</span><br><span class="line">            .build();</span><br></pre></td></tr></table></figure>

<p>既然前面已经做了两次判空操作，implementation 不可能为空，那么 setDefaultImplementations 方法似乎没有存在的必要了。其实不然，如果有人不按套路写代码。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cache cache = new CacheBuilder(currentNamespace)</span><br><span class="line">            // 忘记设置 implementation</span><br><span class="line">            .build();</span><br></pre></td></tr></table></figure>

<p>这里忘记设置 implementation，或人为的将 implementation 设为空。如果不对 implementation 进行判空，会导致 build 方法在构建实例时触发空指针异常，对于框架来说，出现空指针异常是很尴尬的，这是一个低级错误。这里以及之前做了这么多判空，就是为了避免出现空指针的情况，以提高框架的健壮性。好了，关于 setDefaultImplementations 方法的分析先到这，继续往下分析。</p>
<p>我们在使用 MyBatis 内置缓存时，一般不用为它们配置自定义属性。但使用第三方缓存时，则应按需进行配置。比如前面演示 MyBatis 整合 Ehcache 时，就为 Ehcache 配置了一些必要的属性。下面我们来看一下这部分配置是如何设置到缓存实例中的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void setCacheProperties(Cache cache) &#123;</span><br><span class="line">    if (properties != null) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * 为缓存实例生成一个“元信息”实例，forObject 方法调用层次比较深，但最终调用了 </span><br><span class="line">         * MetaClass 的 forClass 方法。关于 MetaClass 的源码，我在上一篇文章中已经</span><br><span class="line">         * 详细分析过了，这里不再赘述。</span><br><span class="line">         */</span><br><span class="line">        MetaObject metaCache = SystemMetaObject.forObject(cache);</span><br><span class="line">        for (Map.Entry&lt;Object, Object&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">            String name = (String) entry.getKey();</span><br><span class="line">            String value = (String) entry.getValue();</span><br><span class="line">            if (metaCache.hasSetter(name)) &#123;</span><br><span class="line">                // 获取 setter 方法的参数类型</span><br><span class="line">                Class&lt;?&gt; type = metaCache.getSetterType(name);</span><br><span class="line">                /*</span><br><span class="line">                 * 根据参数类型对属性值进行转换，并将转换后的值</span><br><span class="line">                 * 通过 setter 方法设置到 Cache 实例中</span><br><span class="line">                 */</span><br><span class="line">                if (String.class == type) &#123;</span><br><span class="line">                    metaCache.setValue(name, value);</span><br><span class="line">                &#125; else if (int.class == type || Integer.class == type) &#123;</span><br><span class="line">                	/*</span><br><span class="line">                	 * 此处及以下分支包含两个步骤：</span><br><span class="line">                	 *   1.类型转换 → Integer.valueOf(value)</span><br><span class="line">                	 *   2.将转换后的值设置到缓存实例中 → metaCache.setValue(name, value)</span><br><span class="line">                	 */ </span><br><span class="line">                    metaCache.setValue(name, Integer.valueOf(value));</span><br><span class="line">                &#125; else if (long.class == type || Long.class == type) &#123;</span><br><span class="line">                    metaCache.setValue(name, Long.valueOf(value));</span><br><span class="line">                &#125; </span><br><span class="line">                else if (short.class == type || Short.class == type) &#123;...&#125; </span><br><span class="line">                else if (byte.class == type || Byte.class == type) &#123;...&#125; </span><br><span class="line">                else if (float.class == type || Float.class == type) &#123;...&#125; </span><br><span class="line">                else if (boolean.class == type || Boolean.class == type) &#123;...&#125; </span><br><span class="line">                else if (double.class == type || Double.class == type) &#123;...&#125; </span><br><span class="line">                else &#123;</span><br><span class="line">                    throw new CacheException(&quot;Unsupported property type for cache: &#x27;&quot; + name + &quot;&#x27; of type &quot; + type);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果缓存类实现了 InitializingObject 接口，则调用 initialize 方法执行初始化逻辑</span><br><span class="line">    if (InitializingObject.class.isAssignableFrom(cache.getClass())) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ((InitializingObject) cache).initialize();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new CacheException(&quot;Failed cache initialization for &#x27;&quot; +</span><br><span class="line">                cache.getId() + &quot;&#x27; on &#x27;&quot; + cache.getClass().getName() + &quot;&#x27;&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的大段代码用于对属性值进行类型转换，和设置转换后的值到 Cache 实例中。关于上面代码中出现的 MetaObject，大家可以自己尝试分析一下。最后，我们来看一下设置标准装饰器的过程。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Cache setStandardDecorators(Cache cache) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 创建“元信息”对象</span><br><span class="line">        MetaObject metaCache = SystemMetaObject.forObject(cache);</span><br><span class="line">        if (size != null &amp;&amp; metaCache.hasSetter(&quot;size&quot;)) &#123;</span><br><span class="line">            // 设置 size 属性，</span><br><span class="line">            metaCache.setValue(&quot;size&quot;, size);</span><br><span class="line">        &#125;</span><br><span class="line">        if (clearInterval != null) &#123;</span><br><span class="line">            // clearInterval 不为空，应用 ScheduledCache 装饰器</span><br><span class="line">            cache = new ScheduledCache(cache);</span><br><span class="line">            ((ScheduledCache) cache).setClearInterval(clearInterval);</span><br><span class="line">        &#125;</span><br><span class="line">        if (readWrite) &#123;</span><br><span class="line">            // readWrite 为 true，应用 SerializedCache 装饰器</span><br><span class="line">            cache = new SerializedCache(cache);</span><br><span class="line">        &#125;</span><br><span class="line">        /*</span><br><span class="line">         * 应用 LoggingCache，SynchronizedCache 装饰器，</span><br><span class="line">         * 使原缓存具备打印日志和线程同步的能力</span><br><span class="line">         */</span><br><span class="line">        cache = new LoggingCache(cache);</span><br><span class="line">        cache = new SynchronizedCache(cache);</span><br><span class="line">        if (blocking) &#123;</span><br><span class="line">            // blocking 为 true，应用 BlockingCache 装饰器</span><br><span class="line">            cache = new BlockingCache(cache);</span><br><span class="line">        &#125;</span><br><span class="line">        return cache;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new CacheException(&quot;Error building standard cache decorators.  Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码用于为缓存应用一些基本的装饰器，除了 LoggingCache 和 SynchronizedCache 这两个是必要的装饰器，其他的装饰器应用与否，取决于用户的配置。</p>
<p>到此，关于缓存的解析过程就分析完了。这一块的内容比较多，不过好在代码逻辑不是很复杂，耐心看还是可以弄懂的。其他的就不多说了，进入下一节的分析。</p>
<h4 id="2-1-2-解析-节点"><a href="#2-1-2-解析-节点" class="headerlink" title="2.1.2 解析  节点"></a>2.1.2 解析 <cache-ref> 节点</cache-ref></h4><p>在 MyBatis 中，二级缓存是可以共用的。这需要使用 <cache-ref> 节点配置参照缓存，比如像下面这样。</cache-ref></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- Mapper1.xml --&gt;</span><br><span class="line">&lt;mapper namespace=&quot;xyz.coolblog.dao.Mapper1&quot;&gt;</span><br><span class="line">    &lt;!-- Mapper1 与 Mapper2 共用一个二级缓存 --&gt;</span><br><span class="line">    &lt;cache-ref namespace=&quot;xyz.coolblog.dao.Mapper2&quot;/&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Mapper2.xml --&gt;</span><br><span class="line">&lt;mapper namespace=&quot;xyz.coolblog.dao.Mapper2&quot;&gt;</span><br><span class="line">    &lt;cache/&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>接下来，我们对照上面的配置分析 cache-ref 的解析过程。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void cacheRefElement(XNode context) &#123;</span><br><span class="line">    if (context != null) &#123;</span><br><span class="line">        configuration.addCacheRef(builderAssistant.getCurrentNamespace(), context.getStringAttribute(&quot;namespace&quot;));</span><br><span class="line">        // 创建 CacheRefResolver 实例</span><br><span class="line">        CacheRefResolver cacheRefResolver = new CacheRefResolver(builderAssistant, context.getStringAttribute(&quot;namespace&quot;));</span><br><span class="line">        try &#123;</span><br><span class="line">            // 解析参照缓存</span><br><span class="line">            cacheRefResolver.resolveCacheRef();</span><br><span class="line">        &#125; catch (IncompleteElementException e) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * 这里对 IncompleteElementException 异常进行捕捉，并将 cacheRefResolver </span><br><span class="line">             * 存入到 Configuration 的 incompleteCacheRefs 集合中</span><br><span class="line">             */</span><br><span class="line">            configuration.addIncompleteCacheRef(cacheRefResolver);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，<cache-ref> 节点的解析逻辑封装在了 CacheRefResolver 的 resolveCacheRef 方法中。下面，我们一起看一下这个方法的逻辑。</cache-ref></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- CacheRefResolver</span><br><span class="line">public Cache resolveCacheRef() &#123;</span><br><span class="line">    // 调用 builderAssistant 的 useNewCache(namespace) 方法</span><br><span class="line">    return assistant.useCacheRef(cacheRefNamespace);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// -☆- MapperBuilderAssistant</span><br><span class="line">public Cache useCacheRef(String namespace) &#123;</span><br><span class="line">    if (namespace == null) &#123;</span><br><span class="line">        throw new BuilderException(&quot;cache-ref element requires a namespace attribute.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        unresolvedCacheRef = true;</span><br><span class="line">        // 根据命名空间从全局配置对象（Configuration）中查找相应的缓存实例</span><br><span class="line">        Cache cache = configuration.getCache(namespace);</span><br><span class="line">        </span><br><span class="line">        /*</span><br><span class="line">         * 若未查找到缓存实例，此处抛出异常。这里存在两种情况导致未查找到 cache 实例，</span><br><span class="line">         * 分别如下：</span><br><span class="line">         *     1.使用者在 &lt;cache-ref&gt; 中配置了一个不存在的命名空间，</span><br><span class="line">         *       导致无法找到 cache 实例</span><br><span class="line">         *     2.使用者所引用的缓存实例还未创建</span><br><span class="line">         */</span><br><span class="line">        if (cache == null) &#123;</span><br><span class="line">            throw new IncompleteElementException(&quot;No cache for namespace &#x27;&quot; + namespace + &quot;&#x27; could be found.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 设置 cache 为当前使用缓存</span><br><span class="line">        currentCache = cache;</span><br><span class="line">        unresolvedCacheRef = false;</span><br><span class="line">        return cache;</span><br><span class="line">    &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">        throw new IncompleteElementException(&quot;No cache for namespace &#x27;&quot; + namespace + &quot;&#x27; could be found.&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是 cache-ref 的解析过程，逻辑并不复杂。不过这里要注意 cache 为空的情况，我在代码中已经注释了可能导致 cache 为空的两种情况。第一种情况比较好理解，第二种情况稍微复杂点，但是也不难理解。我会在 2.3 节进行解释说明，这里先不说。</p>
<p>到此，关于 <cache-ref> 节点的解析过程就分析完了。本节的内容不是很难理解，就不多说了。</cache-ref></p>
<h4 id="2-1-3-解析-节点"><a href="#2-1-3-解析-节点" class="headerlink" title="2.1.3 解析  节点"></a>2.1.3 解析 <resultMap> 节点</resultMap></h4><p>resultMap 是 MyBatis 框架中常用的特性，主要用于映射结果。resultMap 是 MyBatis 提供的一个强力武器，这一点官方文档中有所描述，这里引用一下。</p>
<blockquote>
<p>resultMap 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC ResultSets 数据提取代码中解放出来, 并在一些情形下允许你做一些 JDBC 不支持的事情。 实际上，在对复杂语句进行联合映射的时候，它很可能可以代替数千行的同等功能的代码。 ResultMap 的设计思想是，简单的语句不需要明确的结果映射，而复杂一点的语句只需要描述它们的关系就行了。</p>
</blockquote>
<p>如上描述，resultMap 元素是 MyBatis 中最重要最强大的元素，它可以把大家从 JDBC ResultSets 数据提取的工作中解放出来。通过 resultMap 和自动映射，可以让 MyBatis 帮助我们完成 ResultSet → Object 的映射，这将会大大提高了开发效率。关于 resultMap 的用法，我相信大家都比较熟悉了，所以这里我就不介绍了。当然，如果大家不熟悉也没关系，MyBatis 的<a href="http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html">官方文档</a>上对此进行了详细的介绍，大家不妨去看看。</p>
<p>好了，其他的就不多说了，下面开始分析 resultMap 配置的解析过程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- XMLMapperBuilder</span><br><span class="line">private void resultMapElements(List&lt;XNode&gt; list) throws Exception &#123;</span><br><span class="line">    // 遍历 &lt;resultMap&gt; 节点列表</span><br><span class="line">    for (XNode resultMapNode : list) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 解析 resultMap 节点</span><br><span class="line">            resultMapElement(resultMapNode);</span><br><span class="line">        &#125; catch (IncompleteElementException e) &#123;</span><br><span class="line">            // ignore, it will be retried</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private ResultMap resultMapElement(XNode resultMapNode) throws Exception &#123;</span><br><span class="line">    // 调用重载方法</span><br><span class="line">    return resultMapElement(resultMapNode, Collections.&lt;ResultMapping&gt;emptyList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private ResultMap resultMapElement(XNode resultMapNode, List&lt;ResultMapping&gt; additionalResultMappings) throws Exception &#123;</span><br><span class="line">    ErrorContext.instance().activity(&quot;processing &quot; + resultMapNode.getValueBasedIdentifier());</span><br><span class="line"></span><br><span class="line">    // 获取 id 和 type 属性</span><br><span class="line">    String id = resultMapNode.getStringAttribute(&quot;id&quot;, resultMapNode.getValueBasedIdentifier());</span><br><span class="line">    String type = resultMapNode.getStringAttribute(&quot;type&quot;,</span><br><span class="line">        resultMapNode.getStringAttribute(&quot;ofType&quot;,</span><br><span class="line">            resultMapNode.getStringAttribute(&quot;resultType&quot;,</span><br><span class="line">                resultMapNode.getStringAttribute(&quot;javaType&quot;))));</span><br><span class="line">    // 获取 extends 和 autoMapping</span><br><span class="line">    String extend = resultMapNode.getStringAttribute(&quot;extends&quot;);</span><br><span class="line">    Boolean autoMapping = resultMapNode.getBooleanAttribute(&quot;autoMapping&quot;);</span><br><span class="line"></span><br><span class="line">    // 解析 type 属性对应的类型</span><br><span class="line">    Class&lt;?&gt; typeClass = resolveClass(type);</span><br><span class="line">    Discriminator discriminator = null;</span><br><span class="line">    List&lt;ResultMapping&gt; resultMappings = new ArrayList&lt;ResultMapping&gt;();</span><br><span class="line">    resultMappings.addAll(additionalResultMappings);</span><br><span class="line"></span><br><span class="line">    // 获取并遍历 &lt;resultMap&gt; 的子节点列表</span><br><span class="line">    List&lt;XNode&gt; resultChildren = resultMapNode.getChildren();</span><br><span class="line">    for (XNode resultChild : resultChildren) &#123;</span><br><span class="line">        if (&quot;constructor&quot;.equals(resultChild.getName())) &#123;</span><br><span class="line">            // 解析 constructor 节点，并生成相应的 ResultMapping</span><br><span class="line">            processConstructorElement(resultChild, typeClass, resultMappings);</span><br><span class="line">        &#125; else if (&quot;discriminator&quot;.equals(resultChild.getName())) &#123;</span><br><span class="line">            // 解析 discriminator 节点</span><br><span class="line">            discriminator = processDiscriminatorElement(resultChild, typeClass, resultMappings);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">            List&lt;ResultFlag&gt; flags = new ArrayList&lt;ResultFlag&gt;();</span><br><span class="line">            if (&quot;id&quot;.equals(resultChild.getName())) &#123;</span><br><span class="line">                // 添加 ID 到 flags 集合中</span><br><span class="line">                flags.add(ResultFlag.ID);</span><br><span class="line">            &#125;</span><br><span class="line">            // 解析 id 和 property 节点，并生成相应的 ResultMapping</span><br><span class="line">            resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ResultMapResolver resultMapResolver = new ResultMapResolver(builderAssistant, id, typeClass, extend,</span><br><span class="line">        discriminator, resultMappings, autoMapping);</span><br><span class="line">    try &#123;</span><br><span class="line">        // 根据前面获取到的信息构建 ResultMap 对象</span><br><span class="line">        return resultMapResolver.resolve();</span><br><span class="line">    &#125; catch (IncompleteElementException e) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * 如果发生 IncompleteElementException 异常，</span><br><span class="line">         * 这里将 resultMapResolver 添加到 incompleteResultMaps 集合中</span><br><span class="line">         */ </span><br><span class="line">        configuration.addIncompleteResultMap(resultMapResolver);</span><br><span class="line">        throw e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码比较多，看起来有点复杂，这里总结一下：</p>
<ol>
<li>获取 <resultMap> 节点的各种属性</resultMap></li>
<li>遍历 <resultMap> 的子节点，并根据子节点名称执行相应的解析逻辑</resultMap></li>
<li>构建 ResultMap 对象</li>
<li>若构建过程中发生异常，则将 resultMapResolver 添加到 incompleteResultMaps 集合中</li>
</ol>
<p>如上流程，第1步和最后一步都是一些常规操作，无需过多解释。第2步和第3步则是接下来需要重点分析的操作，这其中，鉴别器 discriminator 不是很常用的特性，我觉得大家知道它有什么用就行了，所以就不分析了。下面先来分析 <id> 和 <result> 节点的解析逻辑。</result></id></p>
<h5 id="2-1-3-1-解析-和-节点"><a href="#2-1-3-1-解析-和-节点" class="headerlink" title="2.1.3.1 解析  和  节点"></a>2.1.3.1 解析 <id> 和 <result> 节点</result></id></h5><p>在 <resultMap> 节点中，子节点 <id> 和 <result> 都是常规配置，比较常见。相信大家对此也比较熟悉了，我就不多说了。下面我们直接分析这两个节点的解析过程。如下：</result></id></resultMap></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private ResultMapping buildResultMappingFromContext(XNode context, Class&lt;?&gt; resultType, List&lt;ResultFlag&gt; flags) throws Exception &#123;</span><br><span class="line">    String property;</span><br><span class="line">    // 根据节点类型获取 name 或 property 属性</span><br><span class="line">    if (flags.contains(ResultFlag.CONSTRUCTOR)) &#123;</span><br><span class="line">        property = context.getStringAttribute(&quot;name&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        property = context.getStringAttribute(&quot;property&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取其他各种属性</span><br><span class="line">    String column = context.getStringAttribute(&quot;column&quot;);</span><br><span class="line">    String javaType = context.getStringAttribute(&quot;javaType&quot;);</span><br><span class="line">    String jdbcType = context.getStringAttribute(&quot;jdbcType&quot;);</span><br><span class="line">    String nestedSelect = context.getStringAttribute(&quot;select&quot;);</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     * 解析 resultMap 属性，该属性出现在 &lt;association&gt; 和 &lt;collection&gt; 节点中。</span><br><span class="line">     * 若这两个节点不包含 resultMap 属性，则调用 processNestedResultMappings 方法</span><br><span class="line">     * 解析嵌套 resultMap。</span><br><span class="line">     */</span><br><span class="line">    String nestedResultMap = context.getStringAttribute(&quot;resultMap&quot;, processNestedResultMappings(context, Collections.&lt;ResultMapping&gt;emptyList()));</span><br><span class="line">    </span><br><span class="line">    String notNullColumn = context.getStringAttribute(&quot;notNullColumn&quot;);</span><br><span class="line">    String columnPrefix = context.getStringAttribute(&quot;columnPrefix&quot;);</span><br><span class="line">    String typeHandler = context.getStringAttribute(&quot;typeHandler&quot;);</span><br><span class="line">    String resultSet = context.getStringAttribute(&quot;resultSet&quot;);</span><br><span class="line">    String foreignColumn = context.getStringAttribute(&quot;foreignColumn&quot;);</span><br><span class="line">    boolean lazy = &quot;lazy&quot;.equals(context.getStringAttribute(&quot;fetchType&quot;, configuration.isLazyLoadingEnabled() ? &quot;lazy&quot; : &quot;eager&quot;));</span><br><span class="line"></span><br><span class="line">    // 解析 javaType、typeHandler 的类型以及枚举类型 JdbcType</span><br><span class="line">    Class&lt;?&gt; javaTypeClass = resolveClass(javaType);</span><br><span class="line">    Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandlerClass = (Class&lt;? extends TypeHandler&lt;?&gt;&gt;) resolveClass(typeHandler);</span><br><span class="line">    JdbcType jdbcTypeEnum = resolveJdbcType(jdbcType);</span><br><span class="line"></span><br><span class="line">    // 构建 ResultMapping 对象</span><br><span class="line">    return builderAssistant.buildResultMapping(resultType, property, column, javaTypeClass, jdbcTypeEnum, nestedSelect,</span><br><span class="line">        nestedResultMap, notNullColumn, columnPrefix, typeHandlerClass, flags, resultSet, foreignColumn, lazy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法主要用于获取 <id> 和 <result> 节点的属性，其中，resultMap 属性的解析过程要相对复杂一些。该属性存在于 <association> 和 <collection> 节点中。下面以 <association> 节点为例，演示该节点的两种配置方式，分别如下：</association></collection></association></result></id></p>
<p>第一种配置方式是通过 resultMap 属性引用其他的 <resultMap> 节点，配置如下：</resultMap></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;resultMap id=&quot;articleResult&quot; type=&quot;Article&quot;&gt;</span><br><span class="line">    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;</span><br><span class="line">    &lt;result property=&quot;title&quot; column=&quot;article_title&quot;/&gt;</span><br><span class="line">    &lt;!-- 引用 authorResult --&gt;</span><br><span class="line">    &lt;association property=&quot;article_author&quot; column=&quot;article_author_id&quot; javaType=&quot;Author&quot; resultMap=&quot;authorResult&quot;/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">&lt;resultMap id=&quot;authorResult&quot; type=&quot;Author&quot;&gt;</span><br><span class="line">    &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt;</span><br><span class="line">    &lt;result property=&quot;name&quot; column=&quot;author_name&quot;/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure>

<p>第二种配置方式是采取 resultMap 嵌套的方式进行配置，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;resultMap id=&quot;articleResult&quot; type=&quot;Article&quot;&gt;</span><br><span class="line">    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;</span><br><span class="line">    &lt;result property=&quot;title&quot; column=&quot;article_title&quot;/&gt;</span><br><span class="line">    &lt;!-- resultMap 嵌套 --&gt;</span><br><span class="line">    &lt;association property=&quot;article_author&quot; javaType=&quot;Author&quot;&gt;</span><br><span class="line">        &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt;</span><br><span class="line">        &lt;result property=&quot;name&quot; column=&quot;author_name&quot;/&gt;</span><br><span class="line">    &lt;/association&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure>

<p>如上配置，<association> 的子节点是一些结果映射配置，这些结果配置最终也会被解析成 ResultMap。我们可以看看解析过程是怎样的，如下：</association></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private String processNestedResultMappings(XNode context, List&lt;ResultMapping&gt; resultMappings) throws Exception &#123;</span><br><span class="line">    // 判断节点名称</span><br><span class="line">    if (&quot;association&quot;.equals(context.getName())</span><br><span class="line">        || &quot;collection&quot;.equals(context.getName())</span><br><span class="line">        || &quot;case&quot;.equals(context.getName())) &#123;</span><br><span class="line">        if (context.getStringAttribute(&quot;select&quot;) == null) &#123;</span><br><span class="line">            // resultMapElement 是解析 ResultMap 入口方法</span><br><span class="line">            ResultMap resultMap = resultMapElement(context, resultMappings);</span><br><span class="line">            // 返回 resultMap id</span><br><span class="line">            return resultMap.getId();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，<association> 的子节点由 resultMapElement 方法解析成 ResultMap，并在最后返回 <a href="http://resultmap.id/">resultMap.id</a>。对于 <resultMap> 节点，id 的值配置在该节点的 id 属性中。但 <association> 节点无法配置 id 属性，那么该 id 如何产生的呢？答案在 XNode 类的 getValueBasedIdentifier 方法中，这个方法具体逻辑我就不分析了。下面直接看一下以上配置中的 <association> 节点解析成 ResultMap 后的 id 值，如下：</association></association></resultMap></association></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id = mapper_resultMap[articleResult]_association[article_author]</span><br></pre></td></tr></table></figure>

<p>关于嵌套 resultMap 的解析逻辑就先分析到这，下面分析 ResultMapping 的构建过程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ResultMapping buildResultMapping(Class&lt;?&gt; resultType, String property, String column, Class&lt;?&gt; javaType,JdbcType jdbcType, </span><br><span class="line">    String nestedSelect, String nestedResultMap, String notNullColumn, String columnPrefix,Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandler, </span><br><span class="line">    List&lt;ResultFlag&gt; flags, String resultSet, String foreignColumn, boolean lazy) &#123;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 若 javaType 为空，这里根据 property 的属性进行解析。关于下面方法中的参数，</span><br><span class="line">     * 这里说明一下：</span><br><span class="line">     *   - resultType：即 &lt;resultMap type=&quot;xxx&quot;/&gt; 中的 type 属性</span><br><span class="line">     *   - property：即 &lt;result property=&quot;xxx&quot;/&gt; 中的 property 属性</span><br><span class="line">     */</span><br><span class="line">    Class&lt;?&gt; javaTypeClass = resolveResultJavaType(resultType, property, javaType);</span><br><span class="line"></span><br><span class="line">    // 解析 TypeHandler</span><br><span class="line">    TypeHandler&lt;?&gt; typeHandlerInstance = resolveTypeHandler(javaTypeClass, typeHandler);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 解析 column = &#123;property1=column1, property2=column2&#125; 的情况，</span><br><span class="line">     * 这里会将 column 拆分成多个 ResultMapping</span><br><span class="line">     */</span><br><span class="line">    List&lt;ResultMapping&gt; composites = parseCompositeColumnName(column);</span><br><span class="line"></span><br><span class="line">    // 通过建造模式构建 ResultMapping</span><br><span class="line">    return new ResultMapping.Builder(configuration, property, column, javaTypeClass)</span><br><span class="line">        .jdbcType(jdbcType)</span><br><span class="line">        .nestedQueryId(applyCurrentNamespace(nestedSelect, true))</span><br><span class="line">        .nestedResultMapId(applyCurrentNamespace(nestedResultMap, true))</span><br><span class="line">        .resultSet(resultSet)</span><br><span class="line">        .typeHandler(typeHandlerInstance)</span><br><span class="line">        .flags(flags == null ? new ArrayList&lt;ResultFlag&gt;() : flags)</span><br><span class="line">        .composites(composites)</span><br><span class="line">        .notNullColumns(parseMultipleColumnNames(notNullColumn))</span><br><span class="line">        .columnPrefix(columnPrefix)</span><br><span class="line">        .foreignColumn(foreignColumn)</span><br><span class="line">        .lazy(lazy)</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// -☆- ResultMapping.Builder</span><br><span class="line">public ResultMapping build() &#123;</span><br><span class="line">    // 将 flags 和 composites 两个集合变为不可修改集合</span><br><span class="line">    resultMapping.flags = Collections.unmodifiableList(resultMapping.flags);</span><br><span class="line">    resultMapping.composites = Collections.unmodifiableList(resultMapping.composites);</span><br><span class="line">    // 从 TypeHandlerRegistry 中获取相应 TypeHandler</span><br><span class="line">    resolveTypeHandler();</span><br><span class="line">    validate();</span><br><span class="line">    return resultMapping;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ResultMapping 的构建过程不是很复杂，首先是解析 javaType 类型，并创建 typeHandler 实例。然后处理复合 column。最后通过建造器构建 ResultMapping 实例。关于上面方法中出现的一些方法调用，这里接不跟下去分析了，大家可以自己看看。</p>
<p>到此关于 ResultMapping 的解析和构建过程就分析完了，总的来说，还是比较复杂的。不过再难也是人写的，静下心都可以看懂。好了，其他就不多说了，继续往下分析。</p>
<h5 id="2-1-3-2-解析-节点"><a href="#2-1-3-2-解析-节点" class="headerlink" title="2.1.3.2 解析  节点"></a>2.1.3.2 解析 <constructor> 节点</constructor></h5><p>一般情况下，我们所定义的实体类都是简单的 Java 对象，即 POJO。这种对象包含一些私有属性和相应的 getter&#x2F;setter 方法，通常这种 POJO 可以满足大部分需求。但如果你想使用<code>不可变类</code>存储查询结果，则就需要做一些改动。比如把 POJO 的 setter 方法移除，增加构造方法用于初始化成员变量。对于这种不可变的 Java 类，需要通过带有参数的构造方法进行初始化（反射也可以达到同样目的）。下面举个例子说明一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ArticleDO &#123;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    public ArticleDO(Integer id, String title, String content) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.title = title;</span><br><span class="line">        this.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，ArticleDO 的构造方法对应的配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;constructor&gt;</span><br><span class="line">    &lt;idArg column=&quot;id&quot; name=&quot;id&quot;/&gt;</span><br><span class="line">    &lt;arg column=&quot;title&quot; name=&quot;title&quot;/&gt;</span><br><span class="line">    &lt;arg column=&quot;content&quot; name=&quot;content&quot;/&gt;</span><br><span class="line">&lt;/constructor&gt;</span><br></pre></td></tr></table></figure>

<p>下面，分析 constructor 节点的解析过程。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void processConstructorElement(XNode resultChild, Class&lt;?&gt; resultType, List&lt;ResultMapping&gt; resultMappings) throws Exception &#123;</span><br><span class="line">    // 获取子节点列表</span><br><span class="line">    List&lt;XNode&gt; argChildren = resultChild.getChildren();</span><br><span class="line">    for (XNode argChild : argChildren) &#123;</span><br><span class="line">        List&lt;ResultFlag&gt; flags = new ArrayList&lt;ResultFlag&gt;();</span><br><span class="line">        // 向 flags 中添加 CONSTRUCTOR 标志</span><br><span class="line">        flags.add(ResultFlag.CONSTRUCTOR);</span><br><span class="line">        if (&quot;idArg&quot;.equals(argChild.getName())) &#123;</span><br><span class="line">            // 向 flags 中添加 ID 标志</span><br><span class="line">            flags.add(ResultFlag.ID);</span><br><span class="line">        &#125;</span><br><span class="line">        // 构建 ResultMapping，上一节已经分析过</span><br><span class="line">        resultMappings.add(buildResultMappingFromContext(argChild, resultType, flags));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，上面方法的逻辑并不复杂。首先是获取并遍历子节点列表，然后为每个子节点创建 flags 集合，并添加 CONSTRUCTOR 标志。对于 idArg 节点，额外添加 ID 标志。最后一步则是构建 ResultMapping，该步逻辑前面已经分析过，这里就不多说了。</p>
<p>分析完 <resultMap> 的子节点 <id>，<result> 以及 <constructor> 的解析过程，下面来看看 ResultMap 实例的构建过程。</constructor></result></id></resultMap></p>
<h5 id="2-1-3-3-ResultMap-对象构建过程分析"><a href="#2-1-3-3-ResultMap-对象构建过程分析" class="headerlink" title="2.1.3.3 ResultMap 对象构建过程分析"></a>2.1.3.3 ResultMap 对象构建过程分析</h5><p>前面用了不少的篇幅来分析 <resultMap> 子节点的解析过程。通过前面的分析，我们可知 <id>，<result> 等节点最终都被解析成了 ResultMapping。在得到这些 ResultMapping 后，紧接着要做的事情是构建 ResultMap。如果说 ResultMapping 与单条结果映射相对应，那 ResultMap 与什么对应呢？答案是…。答案暂时还不能说，我们到源码中去找寻吧。下面，让我们带着这个疑问开始本节的源码分析。</result></id></resultMap></p>
<p>前面分析了很多源码，大家可能都忘了 ResultMap 构建的入口了。这里再贴一下，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private ResultMap resultMapElement(XNode resultMapNode, List&lt;ResultMapping&gt; additionalResultMappings) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    // 获取 resultMap 节点中的属性</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    // 解析 resultMap 对应的类型</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    // 遍历 resultMap 节点的子节点，构建 ResultMapping 对象</span><br><span class="line">    // ...</span><br><span class="line">    </span><br><span class="line">    // 创建 ResultMap 解析器</span><br><span class="line">    ResultMapResolver resultMapResolver = new ResultMapResolver(builderAssistant, id, typeClass, extend,</span><br><span class="line">        discriminator, resultMappings, autoMapping);</span><br><span class="line">    try &#123;</span><br><span class="line">        // 根据前面获取到的信息构建 ResultMap 对象</span><br><span class="line">        return resultMapResolver.resolve();</span><br><span class="line">    &#125; catch (IncompleteElementException e) &#123;</span><br><span class="line">        configuration.addIncompleteResultMap(resultMapResolver);</span><br><span class="line">        throw e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，ResultMap 的构建逻辑分装在 ResultMapResolver 的 resolve 方法中，下面我从该方法进行分析。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- ResultMapResolver</span><br><span class="line">public ResultMap resolve() &#123;</span><br><span class="line">    return assistant.addResultMap(this.id, this.type, this.extend, this.discriminator, this.resultMappings, this.autoMapping);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法将构建 ResultMap 实例的任务委托给了 MapperBuilderAssistant 的 addResultMap，我们跟进到这个方法中看看。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- MapperBuilderAssistant</span><br><span class="line">public ResultMap addResultMap(</span><br><span class="line">    String id, Class&lt;?&gt; type, String extend, Discriminator discriminator,</span><br><span class="line">    List&lt;ResultMapping&gt; resultMappings, Boolean autoMapping) &#123;</span><br><span class="line">    </span><br><span class="line">    // 为 ResultMap 的 id 和 extend 属性值拼接命名空间</span><br><span class="line">    id = applyCurrentNamespace(id, false);</span><br><span class="line">    extend = applyCurrentNamespace(extend, true);</span><br><span class="line"></span><br><span class="line">    if (extend != null) &#123;</span><br><span class="line">        if (!configuration.hasResultMap(extend)) &#123;</span><br><span class="line">            throw new IncompleteElementException(&quot;Could not find a parent resultmap with id &#x27;&quot; + extend + &quot;&#x27;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        ResultMap resultMap = configuration.getResultMap(extend);</span><br><span class="line">        List&lt;ResultMapping&gt; extendedResultMappings = new ArrayList&lt;ResultMapping&gt;(resultMap.getResultMappings());</span><br><span class="line">        // 为拓展 ResultMappings 取出重复项</span><br><span class="line">        extendedResultMappings.removeAll(resultMappings);</span><br><span class="line">        </span><br><span class="line">        boolean declaresConstructor = false;</span><br><span class="line">        // 检测当前 resultMappings 集合中是否包含 CONSTRUCTOR 标志的元素</span><br><span class="line">        for (ResultMapping resultMapping : resultMappings) &#123;</span><br><span class="line">            if (resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR)) &#123;</span><br><span class="line">                declaresConstructor = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * 如果当前 &lt;resultMap&gt; 节点中包含 &lt;constructor&gt; 子节点，</span><br><span class="line">         * 则将拓展 ResultMapping 集合中的包含 CONSTRUCTOR 标志的元素移除</span><br><span class="line">         */</span><br><span class="line">        if (declaresConstructor) &#123;</span><br><span class="line">            Iterator&lt;ResultMapping&gt; extendedResultMappingsIter = extendedResultMappings.iterator();</span><br><span class="line">            while (extendedResultMappingsIter.hasNext()) &#123;</span><br><span class="line">                if (extendedResultMappingsIter.next().getFlags().contains(ResultFlag.CONSTRUCTOR)) &#123;</span><br><span class="line">                    extendedResultMappingsIter.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 将扩展 resultMappings 集合合并到当前 resultMappings 集合中</span><br><span class="line">        resultMappings.addAll(extendedResultMappings);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 构建 ResultMap</span><br><span class="line">    ResultMap resultMap = new ResultMap.Builder(configuration, id, type, resultMappings, autoMapping)</span><br><span class="line">        .discriminator(discriminator)</span><br><span class="line">        .build();</span><br><span class="line">    configuration.addResultMap(resultMap);</span><br><span class="line">    return resultMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法主要用于处理 resultMap 节点的 extend 属性，extend 不为空的话，这里将当前 resultMappings 集合和扩展 resultMappings 集合合二为一。随后，通过建造模式构建 ResultMap 实例。过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- ResultMap</span><br><span class="line">public ResultMap build() &#123;</span><br><span class="line">    if (resultMap.id == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;ResultMaps must have an id&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    resultMap.mappedColumns = new HashSet&lt;String&gt;();</span><br><span class="line">    resultMap.mappedProperties = new HashSet&lt;String&gt;();</span><br><span class="line">    resultMap.idResultMappings = new ArrayList&lt;ResultMapping&gt;();</span><br><span class="line">    resultMap.constructorResultMappings = new ArrayList&lt;ResultMapping&gt;();</span><br><span class="line">    resultMap.propertyResultMappings = new ArrayList&lt;ResultMapping&gt;();</span><br><span class="line">    final List&lt;String&gt; constructorArgNames = new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    for (ResultMapping resultMapping : resultMap.resultMappings) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * 检测 &lt;association&gt; 或 &lt;collection&gt; 节点</span><br><span class="line">         * 是否包含 select 和 resultMap 属性</span><br><span class="line">         */</span><br><span class="line">        resultMap.hasNestedQueries = resultMap.hasNestedQueries || resultMapping.getNestedQueryId() != null;</span><br><span class="line">        resultMap.hasNestedResultMaps =</span><br><span class="line">            resultMap.hasNestedResultMaps || (resultMapping.getNestedResultMapId() != null &amp;&amp; resultMapping.getResultSet() == null);</span><br><span class="line"></span><br><span class="line">        final String column = resultMapping.getColumn();</span><br><span class="line">        if (column != null) &#123;</span><br><span class="line">            // 将 colum 转换成大写，并添加到 mappedColumns 集合中</span><br><span class="line">            resultMap.mappedColumns.add(column.toUpperCase(Locale.ENGLISH));</span><br><span class="line">        &#125; else if (resultMapping.isCompositeResult()) &#123;</span><br><span class="line">            for (ResultMapping compositeResultMapping : resultMapping.getComposites()) &#123;</span><br><span class="line">                final String compositeColumn = compositeResultMapping.getColumn();</span><br><span class="line">                if (compositeColumn != null) &#123;</span><br><span class="line">                    resultMap.mappedColumns.add(compositeColumn.toUpperCase(Locale.ENGLISH));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 添加属性 property 到 mappedProperties 集合中</span><br><span class="line">        final String property = resultMapping.getProperty();</span><br><span class="line">        if (property != null) &#123;</span><br><span class="line">            resultMap.mappedProperties.add(property);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 检测当前 resultMapping 是否包含 CONSTRUCTOR 标志</span><br><span class="line">        if (resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR)) &#123;</span><br><span class="line">            // 添加 resultMapping 到 constructorResultMappings 中</span><br><span class="line">            resultMap.constructorResultMappings.add(resultMapping);</span><br><span class="line">            // 添加属性（constructor 节点的 name 属性）到 constructorArgNames 中</span><br><span class="line">            if (resultMapping.getProperty() != null) &#123;</span><br><span class="line">                constructorArgNames.add(resultMapping.getProperty());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 添加 resultMapping 到 propertyResultMappings 中</span><br><span class="line">            resultMap.propertyResultMappings.add(resultMapping);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (resultMapping.getFlags().contains(ResultFlag.ID)) &#123;</span><br><span class="line">            // 添加 resultMapping 到 idResultMappings 中</span><br><span class="line">            resultMap.idResultMappings.add(resultMapping);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (resultMap.idResultMappings.isEmpty()) &#123;</span><br><span class="line">        resultMap.idResultMappings.addAll(resultMap.resultMappings);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!constructorArgNames.isEmpty()) &#123;</span><br><span class="line">        // 获取构造方法参数列表，篇幅原因，这个方法不分析了</span><br><span class="line">        final List&lt;String&gt; actualArgNames = argNamesOfMatchingConstructor(constructorArgNames);</span><br><span class="line">        if (actualArgNames == null) &#123;</span><br><span class="line">            throw new BuilderException(&quot;Error in result map &#x27;&quot; + resultMap.id</span><br><span class="line">                + &quot;&#x27;. Failed to find a constructor in &#x27;&quot;</span><br><span class="line">                + resultMap.getType().getName() + &quot;&#x27; by arg names &quot; + constructorArgNames</span><br><span class="line">                + &quot;. There might be more info in debug log.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 对 constructorResultMappings 按照构造方法参数列表的顺序进行排序</span><br><span class="line">        Collections.sort(resultMap.constructorResultMappings, new Comparator&lt;ResultMapping&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(ResultMapping o1, ResultMapping o2) &#123;</span><br><span class="line">                int paramIdx1 = actualArgNames.indexOf(o1.getProperty());</span><br><span class="line">                int paramIdx2 = actualArgNames.indexOf(o2.getProperty());</span><br><span class="line">                return paramIdx1 - paramIdx2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将以下这些集合变为不可修改集合</span><br><span class="line">    resultMap.resultMappings = Collections.unmodifiableList(resultMap.resultMappings);</span><br><span class="line">    resultMap.idResultMappings = Collections.unmodifiableList(resultMap.idResultMappings);</span><br><span class="line">    resultMap.constructorResultMappings = Collections.unmodifiableList(resultMap.constructorResultMappings);</span><br><span class="line">    resultMap.propertyResultMappings = Collections.unmodifiableList(resultMap.propertyResultMappings);</span><br><span class="line">    resultMap.mappedColumns = Collections.unmodifiableSet(resultMap.mappedColumns);</span><br><span class="line">    return resultMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码看起来很复杂，实际上这是假象。以上代码主要做的事情就是将 ResultMapping 实例及属性分别存储到不同的集合中，仅此而已。ResultMap 中定义了五种不同的集合，下面分别介绍一下这几种集合。</p>
<table>
<thead>
<tr>
<th>集合名称</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>mappedColumns</td>
<td>用于存储 <id>、<result>、<idArg>、<arg> 节点 column 属性</arg></idArg></result></id></td>
</tr>
<tr>
<td>mappedProperties</td>
<td>用于存储 <id> 和 <result> 节点的 property 属性，或 <idArgs> 和 <arg> 节点的 name 属性</arg></idArgs></result></id></td>
</tr>
<tr>
<td>idResultMappings</td>
<td>用于存储 <id> 和 <idArg> 节点对应的 ResultMapping 对象</idArg></id></td>
</tr>
<tr>
<td>propertyResultMappings</td>
<td>用于存储 <id> 和 <result> 节点对应的 ResultMapping 对象</result></id></td>
</tr>
<tr>
<td>constructorResultMappings</td>
<td>用于存储 <idArgs> 和 <arg> 节点对应的 ResultMapping 对象</arg></idArgs></td>
</tr>
</tbody></table>
<p>上面干巴巴的描述不够直观。下面我们写点代码测试一下，并把这些集合的内容打印到控制台上，大家直观感受一下。先定义一个映射文件，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mapper namespace=&quot;xyz.coolblog.dao.ArticleDao&quot;&gt;</span><br><span class="line">    &lt;resultMap id=&quot;articleResult&quot; type=&quot;xyz.coolblog.model.Article&quot;&gt;</span><br><span class="line">        &lt;constructor&gt;</span><br><span class="line">            &lt;idArg column=&quot;id&quot; name=&quot;id&quot;/&gt;</span><br><span class="line">            &lt;arg column=&quot;title&quot; name=&quot;title&quot;/&gt;</span><br><span class="line">            &lt;arg column=&quot;content&quot; name=&quot;content&quot;/&gt;</span><br><span class="line">        &lt;/constructor&gt;</span><br><span class="line">        &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;</span><br><span class="line">        &lt;result property=&quot;author&quot; column=&quot;author&quot;/&gt;</span><br><span class="line">        &lt;result property=&quot;createTime&quot; column=&quot;create_time&quot;/&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>测试代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ResultMapTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void printResultMapInfo() throws Exception &#123;</span><br><span class="line">        Configuration configuration = new Configuration();</span><br><span class="line">        String resource = &quot;mapper/ArticleMapper.xml&quot;;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        XMLMapperBuilder builder = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">        builder.parse();</span><br><span class="line"></span><br><span class="line">        ResultMap resultMap = configuration.getResultMap(&quot;articleResult&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;\n-------------------+✨ mappedColumns ✨+--------------------&quot;);</span><br><span class="line">        System.out.println(resultMap.getMappedColumns());</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;\n------------------+✨ mappedProperties ✨+------------------&quot;);</span><br><span class="line">        System.out.println(resultMap.getMappedProperties());</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;\n------------------+✨ idResultMappings ✨+------------------&quot;);</span><br><span class="line">        resultMap.getIdResultMappings().forEach(rm -&gt; System.out.println(simplify(rm)));</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;\n---------------+✨ propertyResultMappings ✨+---------------&quot;);</span><br><span class="line">        resultMap.getPropertyResultMappings().forEach(rm -&gt; System.out.println(simplify(rm)));</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;\n-------------+✨ constructorResultMappings ✨+--------------&quot;);</span><br><span class="line">        resultMap.getConstructorResultMappings().forEach(rm -&gt; System.out.println(simplify(rm)));</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;\n-------------------+✨ resultMappings ✨+-------------------&quot;);</span><br><span class="line">        resultMap.getResultMappings().forEach(rm -&gt; System.out.println(simplify(rm)));</span><br><span class="line"></span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** 简化 ResultMapping 输出结果 */</span><br><span class="line">    private String simplify(ResultMapping resultMapping) &#123;</span><br><span class="line">        return String.format(&quot;ResultMapping&#123;column=&#x27;%s&#x27;, property=&#x27;%s&#x27;, flags=%s, ...&#125;&quot;,</span><br><span class="line">            resultMapping.getColumn(), resultMapping.getProperty(), resultMapping.getFlags());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，我们把5个集合转给你的内容都打印出来，结果如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15326221002503.jpg" alt="img"></p>
<p>如上，结果比较清晰明了，不需要过多解释了。我们参照上面配置文件及输出的结果，把 ResultMap 的大致轮廓画出来。如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15326238856556.jpg" alt="img"></p>
<p>到这里，<resultMap> 节点的解析过程就分析完了。总的来说，该节点的解析过程还是比较复杂的。好了，其他的就不多说了，继续后面的分析。</resultMap></p>
<h4 id="2-1-4-解析-节点"><a href="#2-1-4-解析-节点" class="headerlink" title="2.1.4 解析  节点"></a>2.1.4 解析 <sql> 节点</sql></h4><p><sql> 节点用来定义一些可重用的 SQL 语句片段，比如表名，或表的列名等。在映射文件中，我们可以通过 <include> 节点引用 <sql> 节点定义的内容。下面我来演示一下 <sql> 节点的使用方式，如下：</sql></sql></include></sql></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;sql id=&quot;table&quot;&gt;</span><br><span class="line">    article</span><br><span class="line">&lt;/sql&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;findOne&quot; resultType=&quot;Article&quot;&gt;</span><br><span class="line">    SELECT id, title FROM &lt;include refid=&quot;table&quot;/&gt; WHERE id = #&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;update id=&quot;update&quot; parameterType=&quot;Article&quot;&gt;</span><br><span class="line">    UPDATE &lt;include refid=&quot;table&quot;/&gt; SET title = #&#123;title&#125; WHERE id = #&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure>

<p>如上，上面配置中，<select> 和 <update> 节点通过 <include> 引入定义在 <sql> 节点中的表名。上面的配置比较常规，除了静态文本，<sql> 节点还支持属性占位符 ${}。比如：</sql></sql></include></update></select></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;sql id=&quot;table&quot;&gt;</span><br><span class="line">    $&#123;table_prefix&#125;_article</span><br><span class="line">&lt;/sql&gt;</span><br></pre></td></tr></table></figure>

<p>如果属性 table_prefix &#x3D; blog，那么 <sql> 节点中的内容最终为 blog_article。</sql></p>
<p>上面介绍了 <sql> 节点的用法，比较容易。下面分析一下 sql 节点的解析过程，如下：</sql></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void sqlElement(List&lt;XNode&gt; list) throws Exception &#123;</span><br><span class="line">    if (configuration.getDatabaseId() != null) &#123;</span><br><span class="line">        // 调用 sqlElement 解析 &lt;sql&gt; 节点</span><br><span class="line">        sqlElement(list, configuration.getDatabaseId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 再次调用 sqlElement，不同的是，这次调用，该方法的第二个参数为 null</span><br><span class="line">    sqlElement(list, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法需要大家注意一下，如果 Configuration 的 databaseId 不为空，sqlElement 方法会被调用了两次。第一次传入具体的 databaseId，用于解析带有 databaseId 属性，且属性值与此相等的 <sql> 节点。第二次传入的 databaseId 为空，用于解析未配置 databaseId 属性的 <sql> 节点。这里是个小细节，大家注意一下就好。我们继续往下分析。</sql></sql></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void sqlElement(List&lt;XNode&gt; list, String requiredDatabaseId) throws Exception &#123;</span><br><span class="line">    for (XNode context : list) &#123;</span><br><span class="line">        // 获取 id 和 databaseId 属性</span><br><span class="line">        String databaseId = context.getStringAttribute(&quot;databaseId&quot;);</span><br><span class="line">        String id = context.getStringAttribute(&quot;id&quot;);</span><br><span class="line"></span><br><span class="line">        // id = currentNamespace + &quot;.&quot; + id</span><br><span class="line">        id = builderAssistant.applyCurrentNamespace(id, false);</span><br><span class="line"></span><br><span class="line">        // 检测当前 databaseId 和 requiredDatabaseId 是否一致</span><br><span class="line">        if (databaseIdMatchesCurrent(id, databaseId, requiredDatabaseId)) &#123;</span><br><span class="line">            // 将 &lt;id, XNode&gt; 键值对缓存到 sqlFragments 中</span><br><span class="line">            sqlFragments.put(id, context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法逻辑比较简单，首先是获取 <sql> 节点的 id 和 databaseId 属性，然后为 id 属性值拼接命名空间。最后，通过检测当前 databaseId 和 requiredDatabaseId 是否一致，来决定保存还是忽略当前的 <sql> 节点。下面，我们来看一下 databaseId 的匹配逻辑是怎样的。</sql></sql></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private boolean databaseIdMatchesCurrent(String id, String databaseId, String requiredDatabaseId) &#123;</span><br><span class="line">    if (requiredDatabaseId != null) &#123;</span><br><span class="line">        // 当前 databaseId 和目标 databaseId 不一致时，返回 false</span><br><span class="line">        if (!requiredDatabaseId.equals(databaseId)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 如果目标 databaseId 为空，但当前 databaseId 不为空。两者不一致，返回 false</span><br><span class="line">        if (databaseId != null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        /*</span><br><span class="line">         * 如果当前 &lt;sql&gt; 节点的 id 与之前的 &lt;sql&gt; 节点重复，且先前节点 </span><br><span class="line">         * databaseId 不为空。则忽略当前节点，并返回 false</span><br><span class="line">         */</span><br><span class="line">        if (this.sqlFragments.containsKey(id)) &#123;</span><br><span class="line">            XNode context = this.sqlFragments.get(id);</span><br><span class="line">            if (context.getStringAttribute(&quot;databaseId&quot;) != null) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面总结一下 databaseId 的匹配规则。</p>
<ol>
<li>databaseId 与 requiredDatabaseId 不一致，即失配，返回 false</li>
<li>当前节点与之前的节点出现 id 重复的情况，若之前的 <sql> 节点 databaseId 属性不为空，返回 false</sql></li>
<li>若以上两条规则均匹配失败，此时返回 true</li>
</ol>
<p>在上面三条匹配规则中，第二条规则稍微难理解一点。这里简单分析一下，考虑下面这种配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- databaseId 不为空 --&gt;</span><br><span class="line">&lt;sql id=&quot;table&quot; databaseId=&quot;mysql&quot;&gt;</span><br><span class="line">    article</span><br><span class="line">&lt;/sql&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- databaseId 为空 --&gt;</span><br><span class="line">&lt;sql id=&quot;table&quot;&gt;</span><br><span class="line">    article</span><br><span class="line">&lt;/sql&gt;</span><br></pre></td></tr></table></figure>

<p>在上面配置中，两个 <sql> 节点的 id 属性值相同，databaseId 属性不一致。假设 configuration.databaseId &#x3D; mysql，第一次调用 sqlElement 方法，第一个 <sql> 节点对应的 XNode 会被放入到 sqlFragments 中。第二次调用 sqlElement 方法时，requiredDatabaseId 参数为空。由于 sqlFragments 中已包含了一个 id 节点，且该节点的 databaseId 不为空，此时匹配逻辑返回 false，第二个节点不会被保存到 sqlFragments。</sql></sql></p>
<p>上面的分析内容涉及到了 databaseId，关于 databaseId 的用途，这里简单介绍一下。databaseId 用于标明数据库厂商的身份，不同厂商有自己的 SQL 方言，MyBatis 可以根据 databaseId 执行不同 SQL 语句。databaseId 在 <sql> 节点中有什么用呢？这个问题也不难回答。<sql> 节点用于保存 SQL 语句片段，如果 SQL 语句片段中包含方言的话，那么该 <sql> 节点只能被同一 databaseId 的查询语句或更新语句引用。关于 databaseId，这里就介绍这么多。</sql></sql></sql></p>
<p>好了，本节内容先到这里。继续往下分析。</p>
<h4 id="2-1-5-解析-SQL-语句节点"><a href="#2-1-5-解析-SQL-语句节点" class="headerlink" title="2.1.5 解析 SQL 语句节点"></a>2.1.5 解析 SQL 语句节点</h4><p>前面分析了 <cache>、<cache-ref>、<resultMap> 以及 <sql> 节点，从这一节开始，我们要分析映射文件中剩余的几个节点，分别是 <select>、<insert>、<update> 以及 <delete> 等。这几个节点中存储的是相同的内容，都是 SQL 语句，所以这几个节点的解析过程也是相同的。在进行代码分析之前，这里需要特别说明一下：为了避免和 <sql> 节点混淆，同时也为了描述方便，这里把 <select>、<insert>、<update> 以及 <delete> 等节点统称为 SQL 语句节点。好了，下面开始本节的分析。</delete></update></insert></select></sql></delete></update></insert></select></sql></resultMap></cache-ref></cache></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void buildStatementFromContext(List&lt;XNode&gt; list) &#123;</span><br><span class="line">    if (configuration.getDatabaseId() != null) &#123;</span><br><span class="line">        // 调用重载方法构建 Statement</span><br><span class="line">        buildStatementFromContext(list, configuration.getDatabaseId());</span><br><span class="line">    &#125;</span><br><span class="line">    // 调用重载方法构建 Statement，requiredDatabaseId 参数为空</span><br><span class="line">    buildStatementFromContext(list, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void buildStatementFromContext(List&lt;XNode&gt; list, String requiredDatabaseId) &#123;</span><br><span class="line">    for (XNode context : list) &#123;</span><br><span class="line">        // 创建 Statement 建造类</span><br><span class="line">        final XMLStatementBuilder statementParser = new XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);</span><br><span class="line">        try &#123;</span><br><span class="line">            /*</span><br><span class="line">             * 解析 Statement 节点，并将解析结果存储到 </span><br><span class="line">             * configuration 的 mappedStatements 集合中</span><br><span class="line">             */</span><br><span class="line">            statementParser.parseStatementNode();</span><br><span class="line">        &#125; catch (IncompleteElementException e) &#123;</span><br><span class="line">            // 解析失败，将解析器放入 configuration 的 incompleteStatements 集合中</span><br><span class="line">            configuration.addIncompleteStatement(statementParser);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的解析方法没有什么实质性的解析逻辑，我们继续往下分析。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void parseStatementNode() &#123;</span><br><span class="line">    // 获取 id 和 databaseId 属性</span><br><span class="line">    String id = context.getStringAttribute(&quot;id&quot;);</span><br><span class="line">    String databaseId = context.getStringAttribute(&quot;databaseId&quot;);</span><br><span class="line"></span><br><span class="line">    // 根据 databaseId 进行检测，检测逻辑和上一节基本一致，这里不再赘述</span><br><span class="line">    if (!databaseIdMatchesCurrent(id, databaseId, this.requiredDatabaseId)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取各种属性</span><br><span class="line">    Integer fetchSize = context.getIntAttribute(&quot;fetchSize&quot;);</span><br><span class="line">    Integer timeout = context.getIntAttribute(&quot;timeout&quot;);</span><br><span class="line">    String parameterMap = context.getStringAttribute(&quot;parameterMap&quot;);</span><br><span class="line">    String parameterType = context.getStringAttribute(&quot;parameterType&quot;);</span><br><span class="line">    Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType);</span><br><span class="line">    String resultMap = context.getStringAttribute(&quot;resultMap&quot;);</span><br><span class="line">    String resultType = context.getStringAttribute(&quot;resultType&quot;);</span><br><span class="line">    String lang = context.getStringAttribute(&quot;lang&quot;);</span><br><span class="line">    LanguageDriver langDriver = getLanguageDriver(lang);</span><br><span class="line"></span><br><span class="line">    // 通过别名解析 resultType 对应的类型</span><br><span class="line">    Class&lt;?&gt; resultTypeClass = resolveClass(resultType);</span><br><span class="line">    String resultSetType = context.getStringAttribute(&quot;resultSetType&quot;);</span><br><span class="line">    </span><br><span class="line">    // 解析 Statement 类型，默认为 PREPARED</span><br><span class="line">    StatementType statementType = StatementType.valueOf(context.getStringAttribute(&quot;statementType&quot;, StatementType.PREPARED.toString()));</span><br><span class="line">    </span><br><span class="line">    // 解析 ResultSetType</span><br><span class="line">    ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType);</span><br><span class="line"></span><br><span class="line">    // 获取节点的名称，比如 &lt;select&gt; 节点名称为 select</span><br><span class="line">    String nodeName = context.getNode().getNodeName();</span><br><span class="line">    // 根据节点名称解析 SqlCommandType</span><br><span class="line">    SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));</span><br><span class="line">    boolean isSelect = sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line">    boolean flushCache = context.getBooleanAttribute(&quot;flushCache&quot;, !isSelect);</span><br><span class="line">    boolean useCache = context.getBooleanAttribute(&quot;useCache&quot;, isSelect);</span><br><span class="line">    boolean resultOrdered = context.getBooleanAttribute(&quot;resultOrdered&quot;, false);</span><br><span class="line"></span><br><span class="line">    // 解析 &lt;include&gt; 节点</span><br><span class="line">    XMLIncludeTransformer includeParser = new XMLIncludeTransformer(configuration, builderAssistant);</span><br><span class="line">    includeParser.applyIncludes(context.getNode());</span><br><span class="line"></span><br><span class="line">    // 解析 &lt;selectKey&gt; 节点</span><br><span class="line">    processSelectKeyNodes(id, parameterTypeClass, langDriver);</span><br><span class="line"></span><br><span class="line">    // 解析 SQL 语句</span><br><span class="line">    SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);</span><br><span class="line">    String resultSets = context.getStringAttribute(&quot;resultSets&quot;);</span><br><span class="line">    String keyProperty = context.getStringAttribute(&quot;keyProperty&quot;);</span><br><span class="line">    String keyColumn = context.getStringAttribute(&quot;keyColumn&quot;);</span><br><span class="line"></span><br><span class="line">    KeyGenerator keyGenerator;</span><br><span class="line">    String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">    keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, true);</span><br><span class="line">    if (configuration.hasKeyGenerator(keyStatementId)) &#123;</span><br><span class="line">        // 获取 KeyGenerator 实例</span><br><span class="line">        keyGenerator = configuration.getKeyGenerator(keyStatementId);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 创建 KeyGenerator 实例</span><br><span class="line">        keyGenerator = context.getBooleanAttribute(&quot;useGeneratedKeys&quot;,</span><br><span class="line">            configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType)) ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 构建 MappedStatement 对象，并将该对象存储到 </span><br><span class="line">     * Configuration 的 mappedStatements 集合中</span><br><span class="line">     */</span><br><span class="line">    builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,</span><br><span class="line">        fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,</span><br><span class="line">        resultSetTypeEnum, flushCache, useCache, resultOrdered,</span><br><span class="line">        keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码比较长，看起来有点复杂。不过如果大家耐心看一下源码，会发现，上面的代码中起码有一般的代码都是用来获取节点属性，以及解析部分属性等。抛去这部分代码，以上代码做的事情如下。</p>
<ol>
<li>解析 <include> 节点</include></li>
<li>解析 <selectKey> 节点</selectKey></li>
<li>解析 SQL，获取 SqlSource</li>
<li>构建 MappedStatement 实例</li>
</ol>
<p>以上流程对应的代码比较复杂，每个步骤都能分析出一些东西来。下面我会每个步骤都进行分析，首先来分析 <include> 节点的解析过程。</include></p>
<h5 id="2-1-5-1-解析-节点"><a href="#2-1-5-1-解析-节点" class="headerlink" title="2.1.5.1 解析  节点"></a>2.1.5.1 解析 <include> 节点</include></h5><p><include> 节点的解析逻辑封装在 applyIncludes 中，该方法的代码如下：</include></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void applyIncludes(Node source) &#123;</span><br><span class="line">    Properties variablesContext = new Properties();</span><br><span class="line">    Properties configurationVariables = configuration.getVariables();</span><br><span class="line">    if (configurationVariables != null) &#123;</span><br><span class="line">        // 将 configurationVariables 中的数据添加到 variablesContext 中</span><br><span class="line">        variablesContext.putAll(configurationVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 调用重载方法处理 &lt;include&gt; 节点</span><br><span class="line">    applyIncludes(source, variablesContext, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码创建了一个新的 Properties 对象，并将全局 Properties 添加到其中。这样做的原因是 applyIncludes 的重载方法会向 Properties 中添加新的元素，如果直接将全局 Properties 传给重载方法，会造成全局 Properties 被污染。这是个小细节，一般容易被忽视掉。其他没什么需要注意的了，我们继续往下看。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void applyIncludes(Node source, final Properties variablesContext, boolean included) &#123;</span><br><span class="line"></span><br><span class="line">    // ⭐️ 第一个条件分支</span><br><span class="line">    if (source.getNodeName().equals(&quot;include&quot;)) &#123;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * 获取 &lt;sql&gt; 节点。若 refid 中包含属性占位符 $&#123;&#125;，</span><br><span class="line">         * 则需先将属性占位符替换为对应的属性值</span><br><span class="line">         */</span><br><span class="line">        Node toInclude = findSqlFragment(getStringAttribute(source, &quot;refid&quot;), variablesContext);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * 解析 &lt;include&gt; 的子节点 &lt;property&gt;，并将解析结果与 variablesContext 融合，</span><br><span class="line">         * 然后返回融合后的 Properties。若 &lt;property&gt; 节点的 value 属性中存在占位符 $&#123;&#125;，</span><br><span class="line">         * 则将占位符替换为对应的属性值</span><br><span class="line">         */</span><br><span class="line">        Properties toIncludeContext = getVariablesContext(source, variablesContext);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * 这里是一个递归调用，用于将 &lt;sql&gt; 节点内容中出现的属性占位符 $&#123;&#125; 替换为对应的</span><br><span class="line">         * 属性值。这里要注意一下递归调用的参数：</span><br><span class="line">         * </span><br><span class="line">         *  - toInclude：&lt;sql&gt; 节点对象</span><br><span class="line">         *  - toIncludeContext：&lt;include&gt; 子节点 &lt;property&gt; 的解析结果与</span><br><span class="line">         *                      全局变量融合后的结果 </span><br><span class="line">         */</span><br><span class="line">        applyIncludes(toInclude, toIncludeContext, true);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * 如果 &lt;sql&gt; 和 &lt;include&gt; 节点不在一个文档中，</span><br><span class="line">         * 则从其他文档中将 &lt;sql&gt; 节点引入到 &lt;include&gt; 所在文档中</span><br><span class="line">         */</span><br><span class="line">        if (toInclude.getOwnerDocument() != source.getOwnerDocument()) &#123;</span><br><span class="line">            toInclude = source.getOwnerDocument().importNode(toInclude, true);</span><br><span class="line">        &#125;</span><br><span class="line">        // 将 &lt;include&gt; 节点替换为 &lt;sql&gt; 节点</span><br><span class="line">        source.getParentNode().replaceChild(toInclude, source);</span><br><span class="line">        while (toInclude.hasChildNodes()) &#123;</span><br><span class="line">            // 将 &lt;sql&gt; 中的内容插入到 &lt;sql&gt; 节点之前</span><br><span class="line">            toInclude.getParentNode().insertBefore(toInclude.getFirstChild(), toInclude);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * 前面已经将 &lt;sql&gt; 节点的内容插入到 dom 中了，</span><br><span class="line">         * 现在不需要 &lt;sql&gt; 节点了，这里将该节点从 dom 中移除</span><br><span class="line">         */</span><br><span class="line">        toInclude.getParentNode().removeChild(toInclude);</span><br><span class="line"></span><br><span class="line">    // ⭐️ 第二个条件分支</span><br><span class="line">    &#125; else if (source.getNodeType() == Node.ELEMENT_NODE) &#123;</span><br><span class="line">        if (included &amp;&amp; !variablesContext.isEmpty()) &#123;</span><br><span class="line">            NamedNodeMap attributes = source.getAttributes();</span><br><span class="line">            for (int i = 0; i &lt; attributes.getLength(); i++) &#123;</span><br><span class="line">                Node attr = attributes.item(i);</span><br><span class="line">                // 将 source 节点属性中的占位符 $&#123;&#125; 替换成具体的属性值</span><br><span class="line">                attr.setNodeValue(PropertyParser.parse(attr.getNodeValue(), variablesContext));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        NodeList children = source.getChildNodes();</span><br><span class="line">        for (int i = 0; i &lt; children.getLength(); i++) &#123;</span><br><span class="line">            // 递归调用</span><br><span class="line">            applyIncludes(children.item(i), variablesContext, included);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    // ⭐️ 第三个条件分支</span><br><span class="line">    &#125; else if (included &amp;&amp; source.getNodeType() == Node.TEXT_NODE &amp;&amp; !variablesContext.isEmpty()) &#123;</span><br><span class="line">        // 将文本（text）节点中的属性占位符 $&#123;&#125; 替换成具体的属性值</span><br><span class="line">        source.setNodeValue(PropertyParser.parse(source.getNodeValue(), variablesContext));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码如果从上往下读，不太容易看懂。因为上面的方法由三个条件分支，外加两个递归调用组成，代码的执行顺序并不是由上而下。要理解上面的代码，我们需要定义一些配置，并将配置带入到具体代码中，逐行进行演绎。不过，更推荐的方式是使用 IDE 进行单步调试。为了便于讲解，我把上面代码中的三个分支都用 ⭐️ 标记了出来，这个大家注意一下。好了，必要的准备工作做好了，下面开始演绎代码的执行过程。演绎所用的测试配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mapper namespace=&quot;xyz.coolblog.dao.ArticleDao&quot;&gt;</span><br><span class="line">    &lt;sql id=&quot;table&quot;&gt;</span><br><span class="line">        $&#123;table_name&#125;</span><br><span class="line">    &lt;/sql&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=&quot;findOne&quot; resultType=&quot;xyz.coolblog.dao.ArticleDO&quot;&gt;</span><br><span class="line">        SELECT</span><br><span class="line">            id, title</span><br><span class="line">        FROM</span><br><span class="line">            &lt;include refid=&quot;table&quot;&gt;</span><br><span class="line">                &lt;property name=&quot;table_name&quot; value=&quot;article&quot;/&gt;</span><br><span class="line">            &lt;/include&gt;</span><br><span class="line">        WHERE id = #&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>我们先来看一下 applyIncludes 方法第一次被调用时的状态，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参数值：</span><br><span class="line">source = &lt;select&gt; 节点</span><br><span class="line">节点类型：ELEMENT_NODE</span><br><span class="line">variablesContext = [ ]  // 无内容 </span><br><span class="line">included = false</span><br><span class="line"></span><br><span class="line">执行流程：</span><br><span class="line">1. 进入条件分支2</span><br><span class="line">2. 获取 &lt;select&gt; 子节点列表</span><br><span class="line">3. 遍历子节点列表，将子节点作为参数，进行递归调用</span><br></pre></td></tr></table></figure>

<p>第一次调用 applyIncludes 方法，source &#x3D; <select>，代码进入条件分支2。在该分支中，首先要获取 </select><select> 节点的子节点列表。可获取到的子节点如下：</select></p>
<table>
<thead>
<tr>
<th align="left">编号</th>
<th align="left">子节点</th>
<th align="left">类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">SELECT id, title FROM</td>
<td align="left">TEXT_NODE</td>
<td align="left">文本节点</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><include refid="table"></include></td>
<td align="left">ELEMENT_NODE</td>
<td align="left">普通节点</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">WHERE id &#x3D; #{id}</td>
<td align="left">TEXT_NODE</td>
<td align="left">文本节点</td>
</tr>
</tbody></table>
<p>在获取到子节点类列表后，接下来要做的事情是遍历列表，然后将子节点作为参数进行递归调用。在上面三个子节点中，子节点1和子节点3都是文本节点，调用过程一致。因此，下面我只会演示子节点1和子节点2的递归调用过程。先来演示子节点1的调用过程，如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15328770996894.jpg" alt="img"></p>
<p>节点1的调用过程比较简单，只有两层调用。然后我们在看一下子节点2的调用过程，如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15328770012708.jpg" alt="img"></p>
<p>上面是子节点2的调用过程，共有四层调用，略为复杂。大家自己也对着配置，把源码走一遍，然后记录每一次调用的一些状态，这样才能更好的理解 applyIncludes 方法的逻辑。</p>
<p>好了，本节内容先到这里，继续往下分析。</p>
<h5 id="2-1-5-2-解析-节点"><a href="#2-1-5-2-解析-节点" class="headerlink" title="2.1.5.2 解析  节点"></a>2.1.5.2 解析 <selectKey> 节点</selectKey></h5><p>对于一些不支持自增主键的数据库来说，我们在插入数据时，需要明确指定主键数据。以 Oracle 数据库为例，Oracle 数据库不支持自增主键，但它提供了自增序列工具。我们每次向数据库中插入数据时，可以先通过自增序列获取主键数据，然后再进行插入。这里涉及到两次数据库查询操作，我们不能在一个 <select> 节点中同时定义两个 select 语句，否者会导致 SQL 语句出错。对于这个问题，MyBatis 的 <selectKey> 可以很好的解决。下面我们看一段配置：</selectKey></select></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;insert id=&quot;saveAuthor&quot;&gt;</span><br><span class="line">    &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;BEFORE&quot;&gt;</span><br><span class="line">        select author_seq.nextval from dual</span><br><span class="line">    &lt;/selectKey&gt;</span><br><span class="line">    insert into Author</span><br><span class="line">        (id, name, password)</span><br><span class="line">    values</span><br><span class="line">        (#&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<p>在上面的配置中，查询语句会先于插入语句执行，这样我们就可以在插入时获取到主键的值。关于 <selectKey> 的用法，这里不过多介绍了。下面我们来看一下 <selectKey> 节点的解析过程。</selectKey></selectKey></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void processSelectKeyNodes(String id, Class&lt;?&gt; parameterTypeClass, LanguageDriver langDriver) &#123;</span><br><span class="line">    List&lt;XNode&gt; selectKeyNodes = context.evalNodes(&quot;selectKey&quot;);</span><br><span class="line">    if (configuration.getDatabaseId() != null) &#123;</span><br><span class="line">        // 解析 &lt;selectKey&gt; 节点，databaseId 不为空</span><br><span class="line">        parseSelectKeyNodes(id, selectKeyNodes, parameterTypeClass, langDriver, configuration.getDatabaseId());</span><br><span class="line">    &#125;</span><br><span class="line">    // 解析 &lt;selectKey&gt; 节点，databaseId 为空</span><br><span class="line">    parseSelectKeyNodes(id, selectKeyNodes, parameterTypeClass, langDriver, null);</span><br><span class="line">    // 将 &lt;selectKey&gt; 节点从 dom 树中移除</span><br><span class="line">    removeSelectKeyNodes(selectKeyNodes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中可以看出，<selectKey> 节点在解析完成后，会被从 dom 树中移除。这样后续可以更专注的解析 <insert> 或 <update> 节点中的 SQL，无需再额外处理 <selectKey> 节点。继续往下看。</selectKey></update></insert></selectKey></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void parseSelectKeyNodes(String parentId, List&lt;XNode&gt; list, Class&lt;?&gt; parameterTypeClass,</span><br><span class="line">    LanguageDriver langDriver, String skRequiredDatabaseId) &#123;</span><br><span class="line">    for (XNode nodeToHandle : list) &#123;</span><br><span class="line">        // id = parentId + !selectKey，比如 saveUser!selectKey</span><br><span class="line">        String id = parentId + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">        // 获取 &lt;selectKey&gt; 节点的 databaseId 属性</span><br><span class="line">        String databaseId = nodeToHandle.getStringAttribute(&quot;databaseId&quot;);</span><br><span class="line">        // 匹配 databaseId</span><br><span class="line">        if (databaseIdMatchesCurrent(id, databaseId, skRequiredDatabaseId)) &#123;</span><br><span class="line">            // 解析 &lt;selectKey&gt; 节点</span><br><span class="line">            parseSelectKeyNode(id, nodeToHandle, parameterTypeClass, langDriver, databaseId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void parseSelectKeyNode(String id, XNode nodeToHandle, Class&lt;?&gt; parameterTypeClass,</span><br><span class="line">    LanguageDriver langDriver, String databaseId) &#123;</span><br><span class="line"></span><br><span class="line">    // 获取各种属性</span><br><span class="line">    String resultType = nodeToHandle.getStringAttribute(&quot;resultType&quot;);</span><br><span class="line">    Class&lt;?&gt; resultTypeClass = resolveClass(resultType);</span><br><span class="line">    StatementType statementType = StatementType.valueOf(nodeToHandle.getStringAttribute(&quot;statementType&quot;, StatementType.PREPARED.toString()));</span><br><span class="line">    String keyProperty = nodeToHandle.getStringAttribute(&quot;keyProperty&quot;);</span><br><span class="line">    String keyColumn = nodeToHandle.getStringAttribute(&quot;keyColumn&quot;);</span><br><span class="line">    boolean executeBefore = &quot;BEFORE&quot;.equals(nodeToHandle.getStringAttribute(&quot;order&quot;, &quot;AFTER&quot;));</span><br><span class="line"></span><br><span class="line">    // 设置默认值</span><br><span class="line">    boolean useCache = false;</span><br><span class="line">    boolean resultOrdered = false;</span><br><span class="line">    KeyGenerator keyGenerator = NoKeyGenerator.INSTANCE;</span><br><span class="line">    Integer fetchSize = null;</span><br><span class="line">    Integer timeout = null;</span><br><span class="line">    boolean flushCache = false;</span><br><span class="line">    String parameterMap = null;</span><br><span class="line">    String resultMap = null;</span><br><span class="line">    ResultSetType resultSetTypeEnum = null;</span><br><span class="line"></span><br><span class="line">    // 创建 SqlSource</span><br><span class="line">    SqlSource sqlSource = langDriver.createSqlSource(configuration, nodeToHandle, parameterTypeClass);</span><br><span class="line">    /*</span><br><span class="line">     * &lt;selectKey&gt; 节点中只能配置 SELECT 查询语句，</span><br><span class="line">     * 因此 sqlCommandType 为 SqlCommandType.SELECT</span><br><span class="line">     */</span><br><span class="line">    SqlCommandType sqlCommandType = SqlCommandType.SELECT;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 构建 MappedStatement，并将 MappedStatement </span><br><span class="line">     * 添加到 Configuration 的 mappedStatements map 中</span><br><span class="line">     */</span><br><span class="line">    builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,</span><br><span class="line">        fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,</span><br><span class="line">        resultSetTypeEnum, flushCache, useCache, resultOrdered,</span><br><span class="line">        keyGenerator, keyProperty, keyColumn, databaseId, langDriver, null);</span><br><span class="line"></span><br><span class="line">    // id = namespace + &quot;.&quot; + id</span><br><span class="line">    id = builderAssistant.applyCurrentNamespace(id, false);</span><br><span class="line">    MappedStatement keyStatement = configuration.getMappedStatement(id, false);</span><br><span class="line">    // 创建 SelectKeyGenerator，并添加到 keyGenerators map 中</span><br><span class="line">    configuration.addKeyGenerator(id, new SelectKeyGenerator(keyStatement, executeBefore));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的源码比较长，但大部分代码都是一些基础代码，不是很难理解。以上代码比较重要的步骤如下：</p>
<ol>
<li>创建 SqlSource 实例</li>
<li>构建并缓存 MappedStatement 实例</li>
<li>构建并缓存 SelectKeyGenerator 实例</li>
</ol>
<p>在这三步中，第1步和第2步调用的是公共逻辑，其他地方也会调用，这两步对应的源码后续会分两节进行讲解。第3步则是创建一个 SelectKeyGenerator 实例，SelectKeyGenerator 创建的过程本身没什么好说的，所以就不多说了。下面分析一下 SqlSource 和 MappedStatement 实例的创建过程。</p>
<h5 id="2-1-5-3-解析-SQL-语句"><a href="#2-1-5-3-解析-SQL-语句" class="headerlink" title="2.1.5.3 解析 SQL 语句"></a>2.1.5.3 解析 SQL 语句</h5><p>前面分析了 <include> 和 <selectKey> 节点的解析过程，这两个节点解析完成后，都会以不同的方式从 dom 树中消失。所以目前的 SQL 语句节点由一些文本节点和普通节点组成，比如 <if>、<where> 等。那下面我们来看一下移除掉 <include> 和 <selectKey> 节点后的 SQL 语句节点是如何解析的。</selectKey></include></where></if></selectKey></include></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- XMLLanguageDriver</span><br><span class="line">public SqlSource createSqlSource(Configuration configuration, XNode script, Class&lt;?&gt; parameterType) &#123;</span><br><span class="line">    XMLScriptBuilder builder = new XMLScriptBuilder(configuration, script, parameterType);</span><br><span class="line">    return builder.parseScriptNode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// -☆- XMLScriptBuilder</span><br><span class="line">public SqlSource parseScriptNode() &#123;</span><br><span class="line">    // 解析 SQL 语句节点</span><br><span class="line">    MixedSqlNode rootSqlNode = parseDynamicTags(context);</span><br><span class="line">    SqlSource sqlSource = null;</span><br><span class="line">    // 根据 isDynamic 状态创建不同的 SqlSource</span><br><span class="line">    if (isDynamic) &#123;</span><br><span class="line">        sqlSource = new DynamicSqlSource(configuration, rootSqlNode);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        sqlSource = new RawSqlSource(configuration, rootSqlNode, parameterType);</span><br><span class="line">    &#125;</span><br><span class="line">    return sqlSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，SQL 语句的解析逻辑被封装在了 XMLScriptBuilder 类的 parseScriptNode 方法中。该方法首先会调用 parseDynamicTags 解析 SQL 语句节点，在解析过程中，会判断节点是是否包含一些动态标记，比如 ${} 占位符以及动态 SQL 节点等。若包含动态标记，则会将 isDynamic 设为 true。后续可根据 isDynamic 创建不同的 SqlSource。下面，我们来看一下 parseDynamicTags 方法的逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** 该方法用于初始化 nodeHandlerMap 集合，该集合后面会用到 */</span><br><span class="line">private void initNodeHandlerMap() &#123;</span><br><span class="line">    nodeHandlerMap.put(&quot;trim&quot;, new TrimHandler());</span><br><span class="line">    nodeHandlerMap.put(&quot;where&quot;, new WhereHandler());</span><br><span class="line">    nodeHandlerMap.put(&quot;set&quot;, new SetHandler());</span><br><span class="line">    nodeHandlerMap.put(&quot;foreach&quot;, new ForEachHandler());</span><br><span class="line">    nodeHandlerMap.put(&quot;if&quot;, new IfHandler());</span><br><span class="line">    nodeHandlerMap.put(&quot;choose&quot;, new ChooseHandler());</span><br><span class="line">    nodeHandlerMap.put(&quot;when&quot;, new IfHandler());</span><br><span class="line">    nodeHandlerMap.put(&quot;otherwise&quot;, new OtherwiseHandler());</span><br><span class="line">    nodeHandlerMap.put(&quot;bind&quot;, new BindHandler());</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">protected MixedSqlNode parseDynamicTags(XNode node) &#123;</span><br><span class="line">    List&lt;SqlNode&gt; contents = new ArrayList&lt;SqlNode&gt;();</span><br><span class="line">    NodeList children = node.getNode().getChildNodes();</span><br><span class="line">    // 遍历子节点</span><br><span class="line">    for (int i = 0; i &lt; children.getLength(); i++) &#123;</span><br><span class="line">        XNode child = node.newXNode(children.item(i));</span><br><span class="line">        if (child.getNode().getNodeType() == Node.CDATA_SECTION_NODE || child.getNode().getNodeType() == Node.TEXT_NODE) &#123;</span><br><span class="line">            // 获取文本内容</span><br><span class="line">            String data = child.getStringBody(&quot;&quot;);</span><br><span class="line">            TextSqlNode textSqlNode = new TextSqlNode(data);</span><br><span class="line">            // 若文本中包含 $&#123;&#125; 占位符，也被认为是动态节点</span><br><span class="line">            if (textSqlNode.isDynamic()) &#123;</span><br><span class="line">                contents.add(textSqlNode);</span><br><span class="line">                // 设置 isDynamic 为 true</span><br><span class="line">                isDynamic = true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 创建 StaticTextSqlNode</span><br><span class="line">                contents.add(new StaticTextSqlNode(data));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        // child 节点是 ELEMENT_NODE 类型，比如 &lt;if&gt;、&lt;where&gt; 等</span><br><span class="line">        &#125; else if (child.getNode().getNodeType() == Node.ELEMENT_NODE) &#123;</span><br><span class="line">            // 获取节点名称，比如 if、where、trim 等</span><br><span class="line">            String nodeName = child.getNode().getNodeName();</span><br><span class="line">            // 根据节点名称获取 NodeHandler</span><br><span class="line">            NodeHandler handler = nodeHandlerMap.get(nodeName);</span><br><span class="line">            /*</span><br><span class="line">             * 如果 handler 为空，表明当前节点对与 MyBatis 来说，是未知节点。</span><br><span class="line">             * MyBatis 无法处理这种节点，故抛出异常</span><br><span class="line">             */ </span><br><span class="line">            if (handler == null) &#123;</span><br><span class="line">                throw new BuilderException(&quot;Unknown element &lt;&quot; + nodeName + &quot;&gt; in SQL statement.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            // 处理 child 节点，生成相应的 SqlNode</span><br><span class="line">            handler.handleNode(child, contents);</span><br><span class="line"></span><br><span class="line">            // 设置 isDynamic 为 true</span><br><span class="line">            isDynamic = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new MixedSqlNode(contents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面方法的逻辑我前面已经说过，主要是用来判断节点是否包含一些动态标记，比如 ${} 占位符以及动态 SQL 节点等。这里，不管是动态 SQL 节点还是静态 SQL 节点，我们都可以把它们看成是 SQL 片段，一个 SQL 语句由多个 SQL 片段组成。在解析过程中，这些 SQL 片段被存储在 contents 集合中。最后，该集合会被传给 MixedSqlNode 构造方法，用于创建 MixedSqlNode 实例。从 MixedSqlNode 类名上可知，它会存储多种类型的 SqlNode。除了上面代码中已出现的几种 SqlNode 实现类，还有一些 SqlNode 实现类未出现在上面的代码中。但它们也参与了 SQL 语句节点的解析过程，这里我们来看一下这些幕后的 SqlNode 类。</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15328288854753.jpg" alt="img"></p>
<p>上面的 SqlNode 实现类用于处理不同的动态 SQL 逻辑，这些 SqlNode 是如何生成的呢？答案是由各种 NodeHandler 生成。我们再回到上面的代码中，可以看到这样一句代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">handler.handleNode(child, contents);</span><br></pre></td></tr></table></figure>

<p>该代码用于处理动态 SQL 节点，并生成相应的 SqlNode。下面来简单分析一下 WhereHandler 的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** 定义在 XMLScriptBuilder 中 */</span><br><span class="line">private class WhereHandler implements NodeHandler &#123;</span><br><span class="line"></span><br><span class="line">    public WhereHandler() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleNode(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents) &#123;</span><br><span class="line">        // 调用 parseDynamicTags 解析 &lt;where&gt; 节点</span><br><span class="line">        MixedSqlNode mixedSqlNode = parseDynamicTags(nodeToHandle);</span><br><span class="line">        // 创建 WhereSqlNode</span><br><span class="line">        WhereSqlNode where = new WhereSqlNode(configuration, mixedSqlNode);</span><br><span class="line">        // 添加到 targetContents</span><br><span class="line">        targetContents.add(where);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，handleNode 方法内部会再次调用 parseDynamicTags 解析 <where> 节点中的内容，这样又会生成一个 MixedSqlNode 对象。最终，整个 SQL 语句节点会生成一个具有树状结构的 MixedSqlNode。如下图：</where></p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15328318597125.jpg" alt="img"></p>
<p>到此，SQL 语句的解析过程就分析完了。现在，我们已经将 XML 配置解析了 SqlSource，但这还没有结束。SqlSource 中只能记录 SQL 语句信息，除此之外，这里还有一些额外的信息需要记录。因此，我们需要一个类能够同时存储 SqlSource 和其他的信息。这个类就是 MappedStatement。下面我们来看一下它的构建过程。</p>
<h5 id="2-1-5-4-构建-MappedStatement"><a href="#2-1-5-4-构建-MappedStatement" class="headerlink" title="2.1.5.4 构建 MappedStatement"></a>2.1.5.4 构建 MappedStatement</h5><p>SQL 语句节点可以定义很多属性，这些属性和属性值最终存储在 MappedStatement 中。下面我们看一下 MappedStatement 的构建过程是怎样的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public MappedStatement addMappedStatement(</span><br><span class="line">    String id, SqlSource sqlSource, StatementType statementType, </span><br><span class="line">    SqlCommandType sqlCommandType,Integer fetchSize, Integer timeout, </span><br><span class="line">    String parameterMap, Class&lt;?&gt; parameterType,String resultMap, </span><br><span class="line">    Class&lt;?&gt; resultType, ResultSetType resultSetType, boolean flushCache,</span><br><span class="line">    boolean useCache, boolean resultOrdered, KeyGenerator keyGenerator, </span><br><span class="line">    String keyProperty,String keyColumn, String databaseId, </span><br><span class="line">    LanguageDriver lang, String resultSets) &#123;</span><br><span class="line"></span><br><span class="line">    if (unresolvedCacheRef) &#123;</span><br><span class="line">        throw new IncompleteElementException(&quot;Cache-ref not yet resolved&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    id = applyCurrentNamespace(id, false);</span><br><span class="line">    boolean isSelect = sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line"></span><br><span class="line">    // 创建建造器，设置各种属性</span><br><span class="line">    MappedStatement.Builder statementBuilder = new MappedStatement.Builder(configuration, id, sqlSource, sqlCommandType)</span><br><span class="line">        .resource(resource).fetchSize(fetchSize).timeout(timeout)</span><br><span class="line">        .statementType(statementType).keyGenerator(keyGenerator)</span><br><span class="line">        .keyProperty(keyProperty).keyColumn(keyColumn).databaseId(databaseId)</span><br><span class="line">        .lang(lang).resultOrdered(resultOrdered).resultSets(resultSets)</span><br><span class="line">        .resultMaps(getStatementResultMaps(resultMap, resultType, id))</span><br><span class="line">        .flushCacheRequired(valueOrDefault(flushCache, !isSelect))</span><br><span class="line">        .resultSetType(resultSetType).useCache(valueOrDefault(useCache, isSelect))</span><br><span class="line">        .cache(currentCache);</span><br><span class="line"></span><br><span class="line">    // 获取或创建 ParameterMap</span><br><span class="line">    ParameterMap statementParameterMap = getStatementParameterMap(parameterMap, parameterType, id);</span><br><span class="line">    if (statementParameterMap != null) &#123;</span><br><span class="line">        statementBuilder.parameterMap(statementParameterMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 构建 MappedStatement，没有什么复杂逻辑，不跟下去了</span><br><span class="line">    MappedStatement statement = statementBuilder.build();</span><br><span class="line">    // 添加 MappedStatement 到 configuration 的 mappedStatements 集合中</span><br><span class="line">    configuration.addMappedStatement(statement);</span><br><span class="line">    return statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是 MappedStatement，没什么复杂的地方，就不多说了。</p>
<h4 id="2-1-6-小节"><a href="#2-1-6-小节" class="headerlink" title="2.1.6 小节"></a>2.1.6 小节</h4><p>本章分析了映射文件的解析过程，总的来说，本章的内容还是比较复杂的，逻辑太多。不过如果大家自己也能把映射文件的解析过程认真分析一遍，会对 MyBatis 有更深入的理解。分析过程很累，但是在此过程中会收获了很多东西，还是很开心的。好了，本章内容先到这里。后面还有一些代码需要分析，我们继续往后看。</p>
<h3 id="2-2-Mapper-接口绑定过程分析"><a href="#2-2-Mapper-接口绑定过程分析" class="headerlink" title="2.2 Mapper 接口绑定过程分析"></a>2.2 Mapper 接口绑定过程分析</h3><p>映射文件解析完成后，并不意味着整个解析过程就结束了。此时还需要通过命名空间绑定 mapper 接口，这样才能将映射文件中的 SQL 语句和 mapper 接口中的方法绑定在一起，后续即可通过调用 mapper 接口方法执行与之对应的 SQL 语句。下面我们来分析一下 mapper 接口的绑定过程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- XMLMapperBuilder</span><br><span class="line">private void bindMapperForNamespace() &#123;</span><br><span class="line">    // 获取映射文件的命名空间</span><br><span class="line">    String namespace = builderAssistant.getCurrentNamespace();</span><br><span class="line">    if (namespace != null) &#123;</span><br><span class="line">        Class&lt;?&gt; boundType = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 根据命名空间解析 mapper 类型</span><br><span class="line">            boundType = Resources.classForName(namespace);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        if (boundType != null) &#123;</span><br><span class="line">            // 检测当前 mapper 类是否被绑定过</span><br><span class="line">            if (!configuration.hasMapper(boundType)) &#123;</span><br><span class="line">                configuration.addLoadedResource(&quot;namespace:&quot; + namespace);</span><br><span class="line">                // 绑定 mapper 类</span><br><span class="line">                configuration.addMapper(boundType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// -☆- Configuration</span><br><span class="line">public &lt;T&gt; void addMapper(Class&lt;T&gt; type) &#123;</span><br><span class="line">    // 通过 MapperRegistry 绑定 mapper 类</span><br><span class="line">    mapperRegistry.addMapper(type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// -☆- MapperRegistry</span><br><span class="line">public &lt;T&gt; void addMapper(Class&lt;T&gt; type) &#123;</span><br><span class="line">    if (type.isInterface()) &#123;</span><br><span class="line">        if (hasMapper(type)) &#123;</span><br><span class="line">            throw new BindingException(&quot;Type &quot; + type + &quot; is already known to the MapperRegistry.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        boolean loadCompleted = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            /*</span><br><span class="line">             * 将 type 和 MapperProxyFactory 进行绑定，</span><br><span class="line">             * MapperProxyFactory 可为 mapper 接口生成代理类</span><br><span class="line">             */</span><br><span class="line">            knownMappers.put(type, new MapperProxyFactory&lt;T&gt;(type));</span><br><span class="line">            </span><br><span class="line">            // 创建注解解析器。在 MyBatis 中，有 XML 和 注解两种配置方式可选</span><br><span class="line">            MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);</span><br><span class="line">            // 解析注解中的信息</span><br><span class="line">            parser.parse();</span><br><span class="line">            loadCompleted = true;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (!loadCompleted) &#123;</span><br><span class="line">                knownMappers.remove(type);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是 Mapper 接口的绑定过程。这里简单一下：</p>
<ol>
<li>获取命名空间，并根据命名空间解析 mapper 类型</li>
<li>将 type 和 MapperProxyFactory 实例存入 knownMappers 中</li>
<li>解析注解中的信息</li>
</ol>
<p>以上步骤中，第3步的逻辑较多。如果大家看懂了映射文件的解析过程，那么注解的解析过程也就不难理解了，这里就不深入分析了。好了，Mapper 接口的绑定过程就先分析到这。</p>
<h3 id="2-3-处理未完成解析的节点"><a href="#2-3-处理未完成解析的节点" class="headerlink" title="2.3 处理未完成解析的节点"></a>2.3 处理未完成解析的节点</h3><p>在解析某些节点的过程中，如果这些节点引用了其他一些未被解析的配置，会导致当前节点解析工作无法进行下去。对于这种情况，MyBatis 的做法是抛出 IncompleteElementException 异常。外部逻辑会捕捉这个异常，并将节点对应的解析器放入 incomplet* 集合中。这个我在分析映射文件解析的过程中进行过相应注释，不知道大家有没有注意到。没注意到也没关系，待会我会举例说明。下面我们来看一下 MyBatis 是如何处理未完成解析的节点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- XMLMapperBuilder</span><br><span class="line">public void parse() &#123;</span><br><span class="line">    // 省略部分代码</span><br><span class="line">    </span><br><span class="line">    // 解析 mapper 节点</span><br><span class="line">    configurationElement(parser.evalNode(&quot;/mapper&quot;));</span><br><span class="line"></span><br><span class="line">    // 处理未完成解析的节点</span><br><span class="line">    parsePendingResultMaps();</span><br><span class="line">    parsePendingCacheRefs();</span><br><span class="line">    parsePendingStatements();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，parse 方法是映射文件的解析入口。在本章的开始，我贴过这个源码。从上面的源码中可以知道有三种节点在解析过程中可能会出现不能完成解析的情况。由于上面三个以 parsePending 开头的方法逻辑一致，所以下面我只会分析其中一个方法的源码。简单起见，这里选择分析 parsePendingCacheRefs 的源码。下面看一下如何配置映射文件会导致 <cache-ref> 节点无法完成解析。</cache-ref></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 映射文件1 --&gt;</span><br><span class="line">&lt;mapper namespace=&quot;xyz.coolblog.dao.Mapper1&quot;&gt;</span><br><span class="line">    &lt;!-- 引用映射文件2中配置的缓存 --&gt;</span><br><span class="line">    &lt;cache-ref namespace=&quot;xyz.coolblog.dao.Mapper2&quot;/&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 映射文件2 --&gt;</span><br><span class="line">&lt;mapper namespace=&quot;xyz.coolblog.dao.Mapper2&quot;&gt;</span><br><span class="line">    &lt;cache/&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>如上，假设 MyBatis 先解析映射文件1，然后再解析映射文件2。按照这样的解析顺序，映射文件1中的 <cache-ref> 节点就无法完成解析，因为它所引用的缓存还未被解析。当映射文件2解析完成后，MyBatis 会调用 parsePendingCacheRefs 方法处理在此之前未完成解析的 <cache-ref> 节点。具体的逻辑如下：</cache-ref></cache-ref></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void parsePendingCacheRefs() &#123;</span><br><span class="line">    // 获取 CacheRefResolver 列表</span><br><span class="line">    Collection&lt;CacheRefResolver&gt; incompleteCacheRefs = configuration.getIncompleteCacheRefs();</span><br><span class="line">    synchronized (incompleteCacheRefs) &#123;</span><br><span class="line">        Iterator&lt;CacheRefResolver&gt; iter = incompleteCacheRefs.iterator();</span><br><span class="line">        // 通过迭代器遍历列表</span><br><span class="line">        while (iter.hasNext()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                /*</span><br><span class="line">                 * 尝试解析 &lt;cache-ref&gt; 节点，若解析失败，则抛出 IncompleteElementException，</span><br><span class="line">                 * 此时下面的删除操作不会被执行</span><br><span class="line">                 */</span><br><span class="line">                iter.next().resolveCacheRef();</span><br><span class="line">                /*</span><br><span class="line">                 * 移除 CacheRefResolver 对象。如果代码能执行到此处，</span><br><span class="line">                 * 表明已成功解析了 &lt;cache-ref&gt; 节点</span><br><span class="line">                 */</span><br><span class="line">                iter.remove();</span><br><span class="line">            &#125; catch (IncompleteElementException e) &#123;</span><br><span class="line">                /*</span><br><span class="line">                 * 如果再次发生 IncompleteElementException 异常，表明当前映射文件中并没有 </span><br><span class="line">                 * &lt;cache-ref&gt; 所引用的缓存。有可能所引用的缓存在后面的映射文件中，所以这里</span><br><span class="line">                 * 不能将解析失败的 CacheRefResolver 从集合中删除</span><br><span class="line">                 */</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码不是很长，我也做了比较多的注释，应该不难理解。好了，关于未完成解析节点的解析过程就分析到这。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>本篇文章对映射文件的解析过程进行了较为详细的分析，全文篇幅比较大，写的也比较辛苦。本篇文章耗时7天完成，在这7天中，基本上一有空闲时间，就会用来写作。虽然很累，但是收获也很多。我目前正在努力的构建自己的知识体系，我觉得对于常用的技术，还是应该花一些时间和精力，去弄懂它的原理。这样以后才能走的更远，才能成为你想成为的样子。</p>
<p>好了，其他的就不多说了，本篇文章就到这吧。谢谢大家的阅读。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://book.douban.com/subject/27087564/">《MyBatis 技术内幕》- 徐郡明</a></li>
<li><a href="http://www.mybatis.org/mybatis-3/zh/index.html">MyBatis 官方文档</a></li>
</ul>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-BufferPool</title>
    <url>/2022/10/25/MySQL-BufferPool/</url>
    <content><![CDATA[<h1 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h1><p>先梳理出问题，再思考如何解决问题。</p>
<p>假设我们就是<code>InnoDB</code>，我们要如何去解决磁盘<code>IO</code>问题？</p>
<p>这个简单，做缓存就好了，所以<code>MySQL</code>需要申请一块内存空间，这块内存空间称为<code>Buffer Pool</code>。</p>
<p><img src="/2022/10/25/MySQL-BufferPool/17.png" alt="图片"></p>
<p><code>Buffer Pool</code>是申请下来了，但是<code>Buffer Pool</code>里面放什么，要怎么规划？</p>
<h2 id="缓存页"><a href="#缓存页" class="headerlink" title="缓存页"></a>缓存页</h2><p><code>MySQL</code>数据是以页为单位，每页默认<code>16KB</code>，称为数据页，在<code>Buffer Pool</code>里面会划分出若干<strong>个缓存页</strong>与数据页对应。</p>
<p><img src="/2022/10/25/MySQL-BufferPool/18.png" alt="图片"></p>
<p>感觉还少了点什么，我们如何知道缓存页对应那个数据页呢？</p>
<h2 id="描述数据"><a href="#描述数据" class="headerlink" title="描述数据"></a>描述数据</h2><p>所有还需要缓存页的元数据信息，可以称为<strong>描述数据</strong>，它与缓存页一一对应，包含一些所属表空间、数据页的编号、<code>Buffer Pool</code>中的地址等等。</p>
<p><img src="/2022/10/25/MySQL-BufferPool/19.png" alt="图片"></p>
<p>后续对数据的增删改查都是在<code>Buffer Pool</code>里操作</p>
<ul>
<li>查询：从磁盘加载到缓存，后续直接查缓存</li>
<li>插入：直接写入缓存</li>
<li>更新删除：缓存中存在直接更新，不存在加载数据页到缓存更新</li>
</ul>
<p>可能有小伙伴担心，<code>MySQL</code>宕机了，数据不就全丢了吗？</p>
<p>这个不用担心，因为<code>InnoDB</code>提供了<code>WAL</code>技术（Write-Ahead Logging），通过<code>redo log</code>让<code>MySQL</code>拥有了崩溃恢复能力。</p>
<p>再配合空闲时，会有异步线程做缓存页刷盘，保证数据的持久性与完整性。</p>
<p><img src="/2022/10/25/MySQL-BufferPool/20.png" alt="图片"></p>
<p>如果不能理解<code>redo log</code>是如何恢复数据的，可以看看阿星前面两篇文章</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDg2OTAxNg==&mid=2652054485&idx=1&sn=cd6bead326dc5f5d8cf6af16893e9676&scene=21#wechat_redirect">02.浅谈 MySQL InnoDB 的内存组件</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDg2OTAxNg==&mid=2652054699&idx=1&sn=018017d9f3a61ca284970bbf65ea5138&scene=21#wechat_redirect">03.聊聊redo log是什么？</a></li>
</ul>
<p>另外，直接更新数据的缓存页称为<strong>脏页</strong>，缓存页刷盘后称为<strong>干净页</strong></p>
<h2 id="Free链表"><a href="#Free链表" class="headerlink" title="Free链表"></a>Free链表</h2><p><code>MySQL</code>数据库启动时，按照设置的<code>Buffer Pool</code>大小，去找操作系统申请一块内存区域，作为<code>Buffer Pool</code>（<strong>假设申请了512MB</strong>）。</p>
<p>申请完毕后，会按照默认缓存页的<code>16KB</code>以及对应的<code>800Byte</code>的描述数据，在<code>Buffer Pool</code>中划分出来一个一个的缓存页和它们对应的描述数据。</p>
<p><img src="/2022/10/25/MySQL-BufferPool/21.png" alt="图片"></p>
<p><code>MySQL</code>运行起来后，会不停的执行增删改查，需要从磁盘读取一个一个的数据页放入<code>Buffer Pool</code>对应的缓存页里，把数据缓存起来，以后就可以在内存里执行增删改查。</p>
<p><img src="/2022/10/25/MySQL-BufferPool/22.png" alt="图片"></p>
<p>但是这个过程必然涉及一个问题，<strong>哪些缓存页是空闲的</strong>？</p>
<p>为了解决这个问题，我们使用链表结构，把空闲缓存页的<strong>描述数据</strong>放入链表中，这个链表称为<code>free</code>链表。</p>
<p>针对<code>free</code>链表我们要做如下设计</p>
<p><img src="/2022/10/25/MySQL-BufferPool/23.png" alt="图片"></p>
<ul>
<li>新增<code>free</code>基础节点</li>
<li>描述数据添加<code>free</code>节点指针</li>
</ul>
<p>最终呈现出来的，是由空闲缓存页的<strong>描述数据</strong>组成的<code>free</code>链表。</p>
<p><img src="/2022/10/25/MySQL-BufferPool/24.png" alt="图片"></p>
<p>有了<code>free</code>链表之后，我们只需要从<code>free</code>链表获取一个<strong>描述数据</strong>，就可以获取到对应的缓存页。</p>
<p><img src="/2022/10/25/MySQL-BufferPool/25.png" alt="图片"></p>
<p>往<strong>描述数据</strong>与<strong>缓存页</strong>写入数据后，就将该<strong>描述数据</strong>移出<code>free</code>链表。</p>
<h2 id="缓存页哈希表"><a href="#缓存页哈希表" class="headerlink" title="缓存页哈希表"></a>缓存页哈希表</h2><p>数据页是缓存进去了，但是又一个问题来了。</p>
<p>下次查询数据时，如何在<code>Buffer Pool</code>里快速定位到对应的缓存页呢？</p>
<p>难道需要一个<strong>非空闲的描述数据</strong>链表，再通过<strong>表空间号+数据页编号</strong>遍历查找吗？</p>
<p>这样做也可以实现，但是效率不太高，时间复杂度是<code>O(N)</code>。</p>
<p><img src="/2022/10/25/MySQL-BufferPool/26.png" alt="图片"></p>
<p>所以我们可以换一个结构，使用哈希表来缓存它们间的映射关系，时间复杂度是<code>O(1)</code>。</p>
<p><img src="/2022/10/25/MySQL-BufferPool/27.png" alt="图片"></p>
<p><strong>表空间号+数据页号</strong>，作为一个<code>key</code>，然后缓存页的地址作为<code>value</code>。</p>
<p>每次加载数据页到空闲缓存页时，就写入一条映射关系到<strong>缓存页哈希表</strong>中。</p>
<p><img src="/2022/10/25/MySQL-BufferPool/28.png" alt="图片"></p>
<p>后续的查询，就可以通过<strong>缓存页哈希表</strong>路由定位了。</p>
<h2 id="Flush链表"><a href="#Flush链表" class="headerlink" title="Flush链表"></a>Flush链表</h2><p>还记得之前有说过「<strong>空闲时会有异步线程做缓存页刷盘，保证数据的持久性与完整性</strong>」吗？</p>
<p>新问题来了，难道每次把<code>Buffer Pool</code>里所有的缓存页都刷入磁盘吗？</p>
<p>当然不能这样做，磁盘<code>IO</code>开销太大了，应该把<strong>脏页</strong>刷入磁盘才对（更新过的缓存页）。</p>
<p>可是我们怎么知道，那些缓存页是<strong>脏页</strong>？</p>
<p>很简单，参照<code>free</code>链表，弄个<code>flush</code>链表出来就好了，只要缓存页被更新，就将它的<strong>描述数据</strong>加入<code>flush</code>链表。</p>
<p>针对<code>flush</code>链表我们要做如下设计</p>
<ul>
<li>新增<code>flush</code>基础节点</li>
<li>描述数据添加<code>flush</code>节点指针</li>
</ul>
<p><img src="/2022/10/25/MySQL-BufferPool/29.png" alt="图片"></p>
<p>最终呈现出来的，是由更新过数据的缓存页<strong>描述数据</strong>组成的<code>flush</code>链表。</p>
<p><img src="/2022/10/25/MySQL-BufferPool/30.png" alt="图片"></p>
<p>后续异步线程都从<code>flush</code>链表刷缓存页，当<code>Buffer Pool</code>内存不足时，也会优先刷<code>flush</code>链表里的缓存页。</p>
<h2 id="LRU链表"><a href="#LRU链表" class="headerlink" title="LRU链表"></a>LRU链表</h2><p>目前看来<code>Buffer Pool</code>的功能已经比较完善了。</p>
<p><img src="/2022/10/25/MySQL-BufferPool/31.png" alt="图片"></p>
<p>但是仔细思考下，发现还有一个问题没处理。</p>
<p><code>MySQL</code>数据库随着系统的运行会不停的把磁盘上的数据页加载到空闲的缓存页里去，因此<code>free</code>链表中的空闲缓存页会越来越少，直到没有，最后磁盘的数据页无法加载。</p>
<p><img src="/2022/10/25/MySQL-BufferPool/32.png" alt="图片"></p>
<p>为了解决这个问题，我们需要淘汰缓存页，腾出空闲缓存页。</p>
<p>可是我们要优先淘汰那些缓存页？总不能一股脑直接全部淘汰吧？</p>
<p>这里就要借鉴<code>LRU</code>算法思想，把最少使用的缓存页淘汰（命中率低），提供<code>LRU</code>链表出来。</p>
<p>针对<code>LRU</code>链表我们要做如下设计</p>
<ul>
<li>新增<code>LRU</code>基础节点</li>
<li>描述数据添加<code>LRU</code>节点指针</li>
</ul>
<p><img src="/2022/10/25/MySQL-BufferPool/33.png" alt="图片"></p>
<p>实现思路也很简单，只要是查询或修改过缓存页，就把该缓存页的描述数据放入链表头部，也就说近期访问的数据一定在链表头部。</p>
<p><img src="/2022/10/25/MySQL-BufferPool/34.png" alt="图片"></p>
<p>当<code>free</code>链表为空的时候，直接淘汰<code>LRU</code>链表尾部缓存页即可。</p>
<h2 id="LRU链表优化"><a href="#LRU链表优化" class="headerlink" title="LRU链表优化"></a>LRU链表优化</h2><p>麻雀虽小五脏俱全，基本<code>Buffer Pool</code>里与缓存页相关的组件齐全了。</p>
<p><img src="/2022/10/25/MySQL-BufferPool/35.png" alt="图片"></p>
<p>但是缓存页淘汰这里还有点问题，如果仅仅只是使用<code>LRU</code>链表的机制，有两个场景会让<strong>热点数据</strong>被淘汰。</p>
<ul>
<li><strong>预读机制</strong></li>
<li><strong>全表扫描</strong></li>
</ul>
<p>预读机制是指<code>MySQL</code>加载数据页时，可能会把它相邻的数据页一并加载进来（局部性原理）。</p>
<p>这样会带来一个问题，预读进来的数据页，其实我们没有访问，但是它却排在前面。</p>
<p><img src="/2022/10/25/MySQL-BufferPool/36.png" alt="图片"></p>
<p>正常来说，淘汰缓存页时，应该把这个预读的淘汰，结果却把尾部的淘汰了，这是不合理的。</p>
<p>我们接着来看第二个场景全表扫描，如果<strong>表数据量大</strong>，大量的数据页会把空闲缓存页用完。</p>
<p>最终<code>LRU</code>链表前面都是全表扫描的数据，之前频繁访问的热点数据全部到队尾了，淘汰缓存页时就把<strong>热点数据页</strong>给淘汰了。</p>
<p><img src="/2022/10/25/MySQL-BufferPool/37.png" alt="图片"></p>
<p>为了解决上述的问题。</p>
<p>我们需要给<code>LRU</code>链表做冷热数据分离设计，把<code>LRU</code>链表按一定比例，分为冷热区域，热区域称为<code>young</code>区域，冷区域称为<code>old</code>区域。</p>
<p><strong>以7:3为例，young区域70%，old&#96;区域30%</strong></p>
<p><img src="/2022/10/25/MySQL-BufferPool/38.png" alt="图片"></p>
<p>如上图所示，数据页第一次加载进缓存页的时候，是先放入冷数据区域的头部，如果1秒后再次访问缓存页，则会移动到热区域的头部。</p>
<p>这样就保证了<strong>预读机制</strong>与<strong>全表扫描</strong>加载的数据都在链表队尾。</p>
<p><code>young</code>区域其实还可以做一个小优化，为了防止<code>young</code>区域节点频繁移动到表头。</p>
<p><code>young</code>区域前面<code>1/4</code>被访问不会移动到链表头部，只有后面的<code>3/4</code>被访问了才会。</p>
<blockquote>
<p>记住是按照某个比例将<code>LRU</code>链表分成两部分，不是某些节点固定是<code>young</code>区域的，某些节点固定是<code>old</code>区域的，随着程序的运行，某个节点所属的区域也可能发生变化。</p>
</blockquote>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>其实<code>MySQL</code>就是这样实现<code>Buffer Pool</code>缓存页的，只不过它里面的链表全<strong>是双向链表</strong>，阿星这里偷个懒，但是不影响理解思路。</p>
<p>读到这里，我相信大家对<code>Buffer Pool</code>缓存页有了深刻的认知，也知道从一个增删改查开始，如何缓存数据、定位缓存、缓存刷盘、缓存淘汰。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>OLTP</tag>
        <tag>数据库</tag>
        <tag>分库分表</tag>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis源码分析-配置文件解析过程</title>
    <url>/2022/10/25/MyBatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="1-本文速览"><a href="#1-本文速览" class="headerlink" title="1.本文速览"></a>1.本文速览</h2><p>由于本篇文章篇幅比较大，所以这里拿出一节对本文进行快速概括。本篇文章对 MyBatis 配置文件中常用配置的解析过程进行了较为详细的介绍和分析，包括但不限于<code>settings</code>，<code>typeAliases</code>和<code>typeHandlers</code>等，本文的篇幅也主要在对这三个配置解析过程的分析上。下面，我们来一起看一下本篇文章的目录结构。</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15321419781644.jpg" alt="img"></p>
<p>从目录上可以看出，2.3节、2.5节和2.8节的内容比较多。其中2.3节是关于<code>settings</code>配置解析过程的分析，除了对常规的 XML 解析过程分析，本节额外的分析了元信息类<code>MetaClass</code>源码的逻辑。2.5节则是详细分析了别名注册的过程，包含自动注册和手动注册别名等两种方式。2.8节则是详细介绍了类型处理器的注册过程，类型注册逻辑是封装在<code>TypeHandlerRegistry</code>类中的各个<code>register</code>重载方法中。由于重载方法比较多，且互为调用，调用关系比较复杂。为此，我专门画了一张方法调用关系图。这张图在分析类类型处理器注册那一块的源码时，会很有用。</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15321005084792.jpg" alt="img"></p>
<p>本文的2.9节主要用于分析 SQL 映射文件的解析过程。由于 SQL 映射文件解析的过程也很复杂，所以这里把2.9节独立成文，后续会进行更新。至于其他的章节，没什么太复杂的东西，就不一一叙述了。</p>
<p>以上就是 MyBatis 配置文件解析过程的速览，如果大家对以上所说内容比较熟悉了，那就不用往下看了。如果不了解，或是有兴趣的话，不妨阅读一下。本篇文章行文较长，除了对常规的 XML 解析过程进行分析，还额外分析了一些源码。如果能掌握本文所分析内容，我相信可以对 MyBatis 有更深入的了解。好了，其他的就不多说了，进入正题吧。</p>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>在上一篇<a href="http://www.coolblog.xyz/2018/07/16/MyBatis-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E5%AF%BC%E8%AF%BB/">文章</a>中，我介绍了 MyBatis 的一些基础知识，用于为本文及后续的源码分析文章进行铺垫。经过前面的铺垫，我觉得是时候后分析一下 MyBatis 源码了。在本篇文章中，我将从 MyBatis 解析配置文件的过程着手进行分析。并会在分析的过程中，向大家介绍一些配置的使用方式和用途。MyBatis 的配置比较丰富，很难在一篇文章中把所有配置的解析过程分析完。所以关于配置文件的解析，这里会分两篇文章进行讲解。本篇文章将会分析诸如<code>settings</code>，<code>typeAliases</code>以及<code>typeHandlers</code>等标签的解析过程。下一篇文章则会重点介绍 SQL 映射文件的解析过程。本系列文章所分析的源码版本为<code>3.4.6</code>，是 MyBatis 最新的版本。好了，其他的就不多说了，下面进入源码分析阶段。</p>
<h2 id="2-配置文件解析过程分析"><a href="#2-配置文件解析过程分析" class="headerlink" title="2.配置文件解析过程分析"></a>2.配置文件解析过程分析</h2><h3 id="2-1-配置文件解析入口"><a href="#2-1-配置文件解析入口" class="headerlink" title="2.1 配置文件解析入口"></a>2.1 配置文件解析入口</h3><p>在单独使用 MyBatis 时，第一步要做的事情就是根据配置文件构建<code>SqlSessionFactory</code>对象。相关代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String resource = &quot;mybatis-config.xml&quot;;</span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure>

<p>首先，我们使用 MyBatis 提供的工具类 Resources 加载配置文件，得到一个输入流。然后再通过 SqlSessionFactoryBuilder 对象的<code>build</code>方法构建 SqlSessionFactory 对象。所以这里的 build 方法是我们分析配置文件解析过程的入口方法。那下面我们来看一下这个方法的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- SqlSessionFactoryBuilder</span><br><span class="line">public SqlSessionFactory build(InputStream inputStream) &#123;</span><br><span class="line">    // 调用重载方法</span><br><span class="line">    return build(inputStream, null, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 创建配置文件解析器</span><br><span class="line">        XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">        // 调用 parse 方法解析配置文件，生成 Configuration 对象</span><br><span class="line">        return build(parser.parse());</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">        try &#123;</span><br><span class="line">        inputStream.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">        // Intentionally ignore. Prefer previous error.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public SqlSessionFactory build(Configuration config) &#123;</span><br><span class="line">    // 创建 DefaultSqlSessionFactory</span><br><span class="line">    return new DefaultSqlSessionFactory(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中，我们大致可以猜出 MyBatis 配置文件是通过<code>XMLConfigBuilder</code>进行解析的。不过目前这里还没有非常明确的解析逻辑，所以我们继续往下看。这次来看一下 XMLConfigBuilder 的<code>parse</code>方法，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- XMLConfigBuilder</span><br><span class="line">public Configuration parse() &#123;</span><br><span class="line">    if (parsed) &#123;</span><br><span class="line">        throw new BuilderException(&quot;Each XMLConfigBuilder can only be used once.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    parsed = true;</span><br><span class="line">    // 解析配置</span><br><span class="line">    parseConfiguration(parser.evalNode(&quot;/configuration&quot;));</span><br><span class="line">    return configuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里大家可以看到一些端倪了，注意一个 xpath 表达式 - <code>/configuration</code>。这个表达式代表的是 MyBatis 的<code>&lt;configuration/&gt;</code>标签，这里选中这个标签，并传递给<code>parseConfiguration</code>方法。我们继续跟下去。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void parseConfiguration(XNode root) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 解析 properties 配置</span><br><span class="line">        propertiesElement(root.evalNode(&quot;properties&quot;));</span><br><span class="line"></span><br><span class="line">        // 解析 settings 配置，并将其转换为 Properties 对象</span><br><span class="line">        Properties settings = settingsAsProperties(root.evalNode(&quot;settings&quot;));</span><br><span class="line"></span><br><span class="line">        // 加载 vfs</span><br><span class="line">        loadCustomVfs(settings);</span><br><span class="line"></span><br><span class="line">        // 解析 typeAliases 配置</span><br><span class="line">        typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));</span><br><span class="line"></span><br><span class="line">        // 解析 plugins 配置</span><br><span class="line">        pluginElement(root.evalNode(&quot;plugins&quot;));</span><br><span class="line"></span><br><span class="line">        // 解析 objectFactory 配置</span><br><span class="line">        objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));</span><br><span class="line"></span><br><span class="line">        // 解析 objectWrapperFactory 配置</span><br><span class="line">        objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));</span><br><span class="line"></span><br><span class="line">        // 解析 reflectorFactory 配置</span><br><span class="line">        reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;));</span><br><span class="line"></span><br><span class="line">        // settings 中的信息设置到 Configuration 对象中</span><br><span class="line">        settingsElement(settings);</span><br><span class="line"></span><br><span class="line">        // 解析 environments 配置</span><br><span class="line">        environmentsElement(root.evalNode(&quot;environments&quot;));</span><br><span class="line"></span><br><span class="line">        // 解析 databaseIdProvider，获取并设置 databaseId 到 Configuration 对象</span><br><span class="line">        databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));</span><br><span class="line"></span><br><span class="line">        // 解析 typeHandlers 配置</span><br><span class="line">        typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));</span><br><span class="line"></span><br><span class="line">        // 解析 mappers 配置</span><br><span class="line">        mapperElement(root.evalNode(&quot;mappers&quot;));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此，一个 MyBatis 的解析过程就出来了，每个配置的解析逻辑都封装在了相应的方法中。在下面分析过程中，我不打算按照方法调用的顺序进行分析，我会适当进行一定的调整。同时，MyBatis 中配置较多，对于一些不常用的配置，这里会略过。那下面我们开始进行分析吧。</p>
<h3 id="2-2-解析-properties-配置"><a href="#2-2-解析-properties-配置" class="headerlink" title="2.2 解析 properties 配置"></a>2.2 解析 properties 配置</h3><p>解析<code>properties</code>节点是由<code>propertiesElement</code>这个方法完成的，该方法的逻辑比较简单。在分析方法源码前，先来看一下 properties 节点的配置内容。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;properties resource=&quot;jdbc.properties&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;jdbc.username&quot; value=&quot;coolblog&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;hello&quot; value=&quot;world&quot;/&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure>

<p>在上面的配置中，我为 properties 节点配置了一个 resource 属性，以及两个子节点。下面我们参照上面的配置，来分析一下 propertiesElement 的逻辑。相关分析如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- XMLConfigBuilder</span><br><span class="line">private void propertiesElement(XNode context) throws Exception &#123;</span><br><span class="line">    if (context != null) &#123;</span><br><span class="line">        // 解析 propertis 的子节点，并将这些节点内容转换为属性对象 Properties</span><br><span class="line">        Properties defaults = context.getChildrenAsProperties();</span><br><span class="line">        // 获取 propertis 节点中的 resource 和 url 属性值</span><br><span class="line">        String resource = context.getStringAttribute(&quot;resource&quot;);</span><br><span class="line">        String url = context.getStringAttribute(&quot;url&quot;);</span><br><span class="line"></span><br><span class="line">        // 两者都不用空，则抛出异常</span><br><span class="line">        if (resource != null &amp;&amp; url != null) &#123;</span><br><span class="line">            throw new BuilderException(&quot;The properties element cannot specify both a URL and a resource based property file reference.  Please specify one or the other.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (resource != null) &#123;</span><br><span class="line">            // 从文件系统中加载并解析属性文件</span><br><span class="line">            defaults.putAll(Resources.getResourceAsProperties(resource));</span><br><span class="line">        &#125; else if (url != null) &#123;</span><br><span class="line">            // 通过 url 加载并解析属性文件</span><br><span class="line">            defaults.putAll(Resources.getUrlAsProperties(url));</span><br><span class="line">        &#125;</span><br><span class="line">        Properties vars = configuration.getVariables();</span><br><span class="line">        if (vars != null) &#123;</span><br><span class="line">            defaults.putAll(vars);</span><br><span class="line">        &#125;</span><br><span class="line">        parser.setVariables(defaults);</span><br><span class="line">        // 将属性值设置到 configuration 中</span><br><span class="line">        configuration.setVariables(defaults);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Properties getChildrenAsProperties() &#123;</span><br><span class="line">    Properties properties = new Properties();</span><br><span class="line">    // 获取并遍历子节点</span><br><span class="line">    for (XNode child : getChildren()) &#123;</span><br><span class="line">        // 获取 property 节点的 name 和 value 属性</span><br><span class="line">        String name = child.getStringAttribute(&quot;name&quot;);</span><br><span class="line">        String value = child.getStringAttribute(&quot;value&quot;);</span><br><span class="line">        if (name != null &amp;&amp; value != null) &#123;</span><br><span class="line">            // 设置属性到属性对象中</span><br><span class="line">            properties.setProperty(name, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return properties;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// -☆- XNode</span><br><span class="line">public List&lt;XNode&gt; getChildren() &#123;</span><br><span class="line">    List&lt;XNode&gt; children = new ArrayList&lt;XNode&gt;();</span><br><span class="line">    // 获取子节点列表</span><br><span class="line">    NodeList nodeList = node.getChildNodes();</span><br><span class="line">    if (nodeList != null) &#123;</span><br><span class="line">        for (int i = 0, n = nodeList.getLength(); i &lt; n; i++) &#123;</span><br><span class="line">            Node node = nodeList.item(i);</span><br><span class="line">            if (node.getNodeType() == Node.ELEMENT_NODE) &#123;</span><br><span class="line">                // 将节点对象封装到 XNode 中，并将 XNode 对象放入 children 列表中</span><br><span class="line">                children.add(new XNode(xpathParser, node, variables));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是 properties 节点解析的主要过程，不是很复杂。主要包含三个步骤，一是解析 properties 节点的子节点，并将解析结果设置到 Properties 对象中。二是从文件系统或通过网络读取属性配置，这取决于 properties 节点的 resource 和 url 是否为空。第二步对应的代码比较简单，这里就不分析了。有兴趣的话，大家可以自己去看看。最后一步则是将解析出的属性对象设置到 XPathParser 和 Configuration 对象中。</p>
<p>需要注意的是，propertiesElement 方法是先解析 properties 节点的子节点内容，后再从文件系统或者网络读取属性配置，并将所有的属性及属性值都放入到 defaults 属性对象中。这就会存在同名属性覆盖的问题，也就是从文件系统，或者网络上读取到的属性及属性值会覆盖掉 properties 子节点中同名的属性和及值。比如上面配置中的<code>jdbc.properties</code>内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdbc.driver=com.mysql.cj.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://localhost:3306/myblog?...</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=1234</span><br></pre></td></tr></table></figure>

<p>与 properties 子节点内容合并后，结果如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15318827908386.jpg" alt="img"></p>
<p>如上，原<code>jdbc.username</code>值为<code>coolblog</code>，现在被覆盖为了<code>root</code>。同名属性覆盖的问题需要大家注意一下，其他的就没什么了，继续往下分析。</p>
<h3 id="2-3-解析-settings-配置"><a href="#2-3-解析-settings-配置" class="headerlink" title="2.3 解析 settings 配置"></a>2.3 解析 settings 配置</h3><h4 id="2-3-1-settings-节点的解析过程"><a href="#2-3-1-settings-节点的解析过程" class="headerlink" title="2.3.1 settings 节点的解析过程"></a>2.3.1 settings 节点的解析过程</h4><p>settings 相关配置是 MyBatis 中非常重要的配置，这些配置用于调整 MyBatis 运行时的行为。settings 配置繁多，在对这些配置不熟悉的情况下，保持默认配置即可。关于 settings 相关配置，MyBatis 官网上进行了比较详细的描述，大家可以去了解一下。在本节中，暂时还用不到这些配置，所以即使不了解这些配置也没什么关系。下面先来看一个比较简单的配置，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>

<p>接下来，对照上面的配置，来分析源码。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- XMLConfigBuilder</span><br><span class="line">private Properties settingsAsProperties(XNode context) &#123;</span><br><span class="line">    if (context == null) &#123;</span><br><span class="line">        return new Properties();</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取 settings 子节点中的内容，getChildrenAsProperties 方法前面已分析过，这里不再赘述</span><br><span class="line">    Properties props = context.getChildrenAsProperties();</span><br><span class="line"></span><br><span class="line">    // 创建 Configuration 类的“元信息”对象</span><br><span class="line">    MetaClass metaConfig = MetaClass.forClass(Configuration.class, localReflectorFactory);</span><br><span class="line">    for (Object key : props.keySet()) &#123;</span><br><span class="line">        // 检测 Configuration 中是否存在相关属性，不存在则抛出异常</span><br><span class="line">        if (!metaConfig.hasSetter(String.valueOf(key))) &#123;</span><br><span class="line">            throw new BuilderException(&quot;The setting &quot; + key + &quot; is not known.  Make sure you spelled it correctly (case sensitive).&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return props;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，settingsAsProperties 方法看起来并不复杂，不过这是一个假象。在上面的代码中出现了一个陌生的类<code>MetaClass</code>，这个类是用来做什么的呢？答案是用来解析目标类的一些元信息，比如类的成员变量，getter&#x2F;setter 方法等。关于这个类的逻辑，待会我会详细解析。接下来，简单总结一下上面代码的逻辑。如下：</p>
<ol>
<li>解析 settings 子节点的内容，并将解析结果转成 Properties 对象</li>
<li>为 Configuration 创建<code>元信息</code>对象</li>
<li>通过 MetaClass 检测 Configuration 中是否存在某个属性的 setter 方法，不存在则抛异常</li>
<li>若通过 MetaClass 的检测，则返回 Properties 对象，方法逻辑结束</li>
</ol>
<p>下面，我们来重点关注一下第2步和第3步的流程。这两步流程对应的代码较为复杂，需要一点耐心阅读。好了，下面开始分析。</p>
<h4 id="2-3-2-元信息对象创建过程"><a href="#2-3-2-元信息对象创建过程" class="headerlink" title="2.3.2 元信息对象创建过程"></a>2.3.2 元信息对象创建过程</h4><p>元信息类<code>MetaClass</code>的构造方法为私有类型，所以不能直接创建，必须使用其提供的<code>forClass</code>方法进行创建。它的创建逻辑如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MetaClass &#123;</span><br><span class="line">    private final ReflectorFactory reflectorFactory;</span><br><span class="line">    private final Reflector reflector;</span><br><span class="line"></span><br><span class="line">    private MetaClass(Class&lt;?&gt; type, ReflectorFactory reflectorFactory) &#123;</span><br><span class="line">        this.reflectorFactory = reflectorFactory;</span><br><span class="line">        // 根据类型创建 Reflector</span><br><span class="line">        this.reflector = reflectorFactory.findForClass(type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static MetaClass forClass(Class&lt;?&gt; type, ReflectorFactory reflectorFactory) &#123;</span><br><span class="line">        // 调用构造方法</span><br><span class="line">        return new MetaClass(type, reflectorFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 省略其他方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码看起来很简单，不过这只是冰山一角。上面代码出现了两个新的类<code>ReflectorFactory</code>和<code>Reflector</code>，MetaClass 通过引入这些新类帮助它完成功能。下面我们看一下<code>hasSetter</code>方法的源码就知道是怎么回事了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- MetaClass</span><br><span class="line">public boolean hasSetter(String name) &#123;</span><br><span class="line">    // 属性分词器，用于解析属性名</span><br><span class="line">    PropertyTokenizer prop = new PropertyTokenizer(name);</span><br><span class="line">    // hasNext 返回 true，则表明 name 是一个复合属性，后面会进行分析</span><br><span class="line">    if (prop.hasNext()) &#123;</span><br><span class="line">        // 调用 reflector 的 hasSetter 方法</span><br><span class="line">        if (reflector.hasSetter(prop.getName())) &#123;</span><br><span class="line">            // 为属性创建创建 MetaClass</span><br><span class="line">            MetaClass metaProp = metaClassForProperty(prop.getName());</span><br><span class="line">            // 再次调用 hasSetter</span><br><span class="line">            return metaProp.hasSetter(prop.getChildren());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 调用 reflector 的 hasSetter 方法</span><br><span class="line">        return reflector.hasSetter(prop.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中，我们可以看出 MetaClass 中的 hasSetter 方法最终调用了 Reflector 的 hasSetter 方法。关于 Reflector 的 hasSetter 方法，这里先不分析，Reflector 这个类的逻辑较为复杂，本节会在随后进行详细说明。下面来简单介绍一下上面代码中出现的几个类：</p>
<ol>
<li>ReflectorFactory -&gt; 顾名思义，Reflector 的工厂类，兼有缓存 Reflector 对象的功能</li>
<li>Reflector -&gt; 反射器，用于解析和存储目标类中的元信息</li>
<li>PropertyTokenizer -&gt; 属性名分词器，用于处理较为复杂的属性名</li>
</ol>
<p>上面的描述比较简单，仅从上面的描述中，还不能让大家有更深入的理解。所以下面单独分析一下这几个类的逻辑，首先是<code>ReflectorFactory</code>。ReflectorFactory 是一个接口，MyBatis 中目前只有一个实现类<code>DefaultReflectorFactory</code>，它的分析如下：</p>
<h5 id="2-3-2-1-DefaultReflectorFactory-源码分析"><a href="#2-3-2-1-DefaultReflectorFactory-源码分析" class="headerlink" title="2.3.2.1 DefaultReflectorFactory 源码分析"></a>2.3.2.1 DefaultReflectorFactory 源码分析</h5><p>DefaultReflectorFactory 用于创建 Reflector，同时兼有缓存的功能，它的源码如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DefaultReflectorFactory implements ReflectorFactory &#123;</span><br><span class="line"></span><br><span class="line">    private boolean classCacheEnabled = true;</span><br><span class="line">    /** 目标类和反射器映射缓存 */</span><br><span class="line">    private final ConcurrentMap&lt;Class&lt;?&gt;, Reflector&gt; reflectorMap = new ConcurrentHashMap&lt;Class&lt;?&gt;, Reflector&gt;();</span><br><span class="line"></span><br><span class="line">    // 省略部分代码</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Reflector findForClass(Class&lt;?&gt; type) &#123;</span><br><span class="line">        // classCacheEnabled 默认为 true</span><br><span class="line">        if (classCacheEnabled) &#123;</span><br><span class="line">            // 从缓存中获取 Reflector 对象</span><br><span class="line">            Reflector cached = reflectorMap.get(type);</span><br><span class="line">            // 缓存为空，则创建一个新的 Reflector 实例，并放入缓存中</span><br><span class="line">            if (cached == null) &#123;</span><br><span class="line">                cached = new Reflector(type);</span><br><span class="line">                // 将 &lt;type, cached&gt; 映射缓存到 map 中，方便下次取用</span><br><span class="line">                reflectorMap.put(type, cached);</span><br><span class="line">            &#125;</span><br><span class="line">            return cached;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 创建一个新的 Reflector 实例</span><br><span class="line">            return new Reflector(type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，DefaultReflectorFactory 的<code>findForClass</code>方法逻辑不是很复杂，包含两个访存操作，和一个对象创建操作。代码注释的比较清楚了，就不多说了。接下来，来分析一下反射器 Reflector。</p>
<h5 id="2-3-2-2-Reflector-源码分析"><a href="#2-3-2-2-Reflector-源码分析" class="headerlink" title="2.3.2.2 Reflector 源码分析"></a>2.3.2.2 Reflector 源码分析</h5><p>本小节，我们来看一下 Reflector 的源码。Reflector 这个类的用途主要是是通过反射获取目标类的 getter 方法及其返回值类型，setter 方法及其参数值类型等元信息。并将获取到的元信息缓存到相应的集合中，供后续使用。Reflector 本身代码比较多，这里不能一一分析。本小节，我将会分析三部分逻辑，分别如下：</p>
<ol>
<li>Reflector 构造方法及成员变量分析</li>
<li>getter 方法解析过程</li>
<li>setter 方法解析过程</li>
</ol>
<p>下面我们按照这个步骤进行分析，先来分析 Reflector 构造方法。</p>
<p><strong>● Reflector 构造方法及成员变量分析</strong></p>
<p>Reflector 构造方法中包含了很多初始化逻辑，目标类的元信息解析过程也是在构造方法中完成的，这些元信息最终会被保存到 Reflector 的成员变量中。下面我们先来看看 Reflector 的构造方法和相关的成员变量定义，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Reflector &#123;</span><br><span class="line"></span><br><span class="line">    private final Class&lt;?&gt; type;</span><br><span class="line">    private final String[] readablePropertyNames;</span><br><span class="line">    private final String[] writeablePropertyNames;</span><br><span class="line">    private final Map&lt;String, Invoker&gt; setMethods = new HashMap&lt;String, Invoker&gt;();</span><br><span class="line">    private final Map&lt;String, Invoker&gt; getMethods = new HashMap&lt;String, Invoker&gt;();</span><br><span class="line">    private final Map&lt;String, Class&lt;?&gt;&gt; setTypes = new HashMap&lt;String, Class&lt;?&gt;&gt;();</span><br><span class="line">    private final Map&lt;String, Class&lt;?&gt;&gt; getTypes = new HashMap&lt;String, Class&lt;?&gt;&gt;();</span><br><span class="line">    private Constructor&lt;?&gt; defaultConstructor;</span><br><span class="line"></span><br><span class="line">    private Map&lt;String, String&gt; caseInsensitivePropertyMap = new HashMap&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">    public Reflector(Class&lt;?&gt; clazz) &#123;</span><br><span class="line">        type = clazz;</span><br><span class="line">        // 解析目标类的默认构造方法，并赋值给 defaultConstructor 变量</span><br><span class="line">        addDefaultConstructor(clazz);</span><br><span class="line"></span><br><span class="line">        // 解析 getter 方法，并将解析结果放入 getMethods 中</span><br><span class="line">        addGetMethods(clazz);</span><br><span class="line"></span><br><span class="line">        // 解析 setter 方法，并将解析结果放入 setMethods 中</span><br><span class="line">        addSetMethods(clazz);</span><br><span class="line"></span><br><span class="line">        // 解析属性字段，并将解析结果添加到 setMethods 或 getMethods 中</span><br><span class="line">        addFields(clazz);</span><br><span class="line"></span><br><span class="line">        // 从 getMethods 映射中获取可读属性名数组</span><br><span class="line">        readablePropertyNames = getMethods.keySet().toArray(new String[getMethods.keySet().size()]);</span><br><span class="line"></span><br><span class="line">        // 从 setMethods 映射中获取可写属性名数组</span><br><span class="line">        writeablePropertyNames = setMethods.keySet().toArray(new String[setMethods.keySet().size()]);</span><br><span class="line"></span><br><span class="line">        // 将所有属性名的大写形式作为键，属性名作为值，存入到 caseInsensitivePropertyMap 中</span><br><span class="line">        for (String propName : readablePropertyNames) &#123;</span><br><span class="line">            caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);</span><br><span class="line">        &#125;</span><br><span class="line">        for (String propName : writeablePropertyNames) &#123;</span><br><span class="line">            caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 省略其他方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，Reflector 的构造方法看起来略为复杂，不过好在一些比较复杂的逻辑都封装在了相应的方法中，这样整体的逻辑就比较清晰了。Reflector 构造方法所做的事情均已进行了注释，大家对照着注释先看一下。相关方法的细节待会会进行分析。看完构造方法，下面我来通过表格的形式，列举一下 Reflector 部分成员变量的用途。如下：</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>类型</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>readablePropertyNames</td>
<td>String[]</td>
<td>可读属性名称数组，用于保存 getter 方法对应的属性名称</td>
</tr>
<tr>
<td>writeablePropertyNames</td>
<td>String[]</td>
<td>可写属性名称数组，用于保存 setter 方法对应的属性名称</td>
</tr>
<tr>
<td>setMethods</td>
<td>Map&lt;String, Invoker&gt;</td>
<td>用于保存属性名称到 Invoke 的映射。setter 方法会被封装到 MethodInvoker 对象中，Invoke 实现类比较简单，大家自行分析</td>
</tr>
<tr>
<td>getMethods</td>
<td>Map&lt;String, Invoker&gt;</td>
<td>用于保存属性名称到 Invoke 的映射。同上，getter 方法也会被封装到 MethodInvoker 对象中</td>
</tr>
<tr>
<td>setTypes</td>
<td>Map&lt;String, Class&lt;?&gt;&gt;</td>
<td>用于保存 setter 对应的属性名与参数类型的映射</td>
</tr>
<tr>
<td>getTypes</td>
<td>Map&lt;String, Class&lt;?&gt;&gt;</td>
<td>用于保存 getter 对应的属性名与返回值类型的映射</td>
</tr>
<tr>
<td>caseInsensitivePropertyMap</td>
<td>Map&lt;String, String&gt;</td>
<td>用于保存大写属性名与属性名之间的映射，比如 &lt;NAME, name&gt;</td>
</tr>
</tbody></table>
<p>上面列举了一些集合变量，这些变量用于缓存各种原信息。关于这些变量，这里描述的不太好懂，主要是不太好解释。要想了解这些变量更多的细节，还是要深入到源码中。所以我们成热打铁，继续往下分析。</p>
<p><strong>● getter 方法解析过程</strong></p>
<p>getter 方法解析的逻辑被封装在了<code>addGetMethods</code>方法中，这个方法除了会解析形如<code>getXXX</code>的方法，同时也会解析<code>isXXX</code>方法。该方法的源码分析如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void addGetMethods(Class&lt;?&gt; cls) &#123;</span><br><span class="line">    Map&lt;String, List&lt;Method&gt;&gt; conflictingGetters = new HashMap&lt;String, List&lt;Method&gt;&gt;();</span><br><span class="line">    // 获取当前类，接口，以及父类中的方法。该方法逻辑不是很复杂，这里就不展开了</span><br><span class="line">    Method[] methods = getClassMethods(cls);</span><br><span class="line">    for (Method method : methods) &#123;</span><br><span class="line">        // getter 方法不应该有参数，若存在参数，则忽略当前方法</span><br><span class="line">        if (method.getParameterTypes().length &gt; 0) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        String name = method.getName();</span><br><span class="line">        // 过滤出以 get 或 is 开头的方法</span><br><span class="line">        if ((name.startsWith(&quot;get&quot;) &amp;&amp; name.length() &gt; 3)</span><br><span class="line">            || (name.startsWith(&quot;is&quot;) &amp;&amp; name.length() &gt; 2)) &#123;</span><br><span class="line">            // 将 getXXX 或 isXXX 等方法名转成相应的属性，比如 getName -&gt; name</span><br><span class="line">            name = PropertyNamer.methodToProperty(name);</span><br><span class="line">            /*</span><br><span class="line">             * 将冲突的方法添加到 conflictingGetters 中。考虑这样一种情况：</span><br><span class="line">             * </span><br><span class="line">             * getTitle 和 isTitle 两个方法经过 methodToProperty 处理，</span><br><span class="line">             * 均得到 name = title，这会导致冲突。</span><br><span class="line">             *</span><br><span class="line">             * 对于冲突的方法，这里先统一起存起来，后续再解决冲突</span><br><span class="line">             */</span><br><span class="line">            addMethodConflict(conflictingGetters, name, method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 解决 getter 冲突</span><br><span class="line">    resolveGetterConflicts(conflictingGetters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，addGetMethods 方法的执行流程如下：</p>
<ol>
<li>获取当前类，接口，以及父类中的方法</li>
<li>遍历上一步获取的方法数组，并过滤出以<code>get</code>和<code>is</code>开头的方法</li>
<li>将方法名转换成相应的属性名</li>
<li>将属性名和方法对象添加到冲突集合中</li>
<li>解决冲突</li>
</ol>
<p>在上面的执行流程中，前三步比较简单，大家自行分析吧。第4步也不复杂，下面我会把源码贴出来，大家看一下就能懂。在这几步中，第5步逻辑比较复杂，这一步逻辑我们重点关注一下。下面继续看源码吧。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** 添加属性名和方法对象到冲突集合中 */</span><br><span class="line">private void addMethodConflict(Map&lt;String, List&lt;Method&gt;&gt; conflictingMethods, String name, Method method) &#123;</span><br><span class="line">    List&lt;Method&gt; list = conflictingMethods.get(name);</span><br><span class="line">    if (list == null) &#123;</span><br><span class="line">        list = new ArrayList&lt;Method&gt;();</span><br><span class="line">        conflictingMethods.put(name, list);</span><br><span class="line">    &#125;</span><br><span class="line">    list.add(method);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">/** 解决冲突 */</span><br><span class="line">private void resolveGetterConflicts(Map&lt;String, List&lt;Method&gt;&gt; conflictingGetters) &#123;</span><br><span class="line">    for (Entry&lt;String, List&lt;Method&gt;&gt; entry : conflictingGetters.entrySet()) &#123;</span><br><span class="line">        Method winner = null;</span><br><span class="line">        String propName = entry.getKey();</span><br><span class="line">        for (Method candidate : entry.getValue()) &#123;</span><br><span class="line">            if (winner == null) &#123;</span><br><span class="line">                winner = candidate;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            // 获取返回值类型</span><br><span class="line">            Class&lt;?&gt; winnerType = winner.getReturnType();</span><br><span class="line">            Class&lt;?&gt; candidateType = candidate.getReturnType();</span><br><span class="line"></span><br><span class="line">            /* </span><br><span class="line">             * 两个方法的返回值类型一致，若两个方法返回值类型均为 boolean，则选取 isXXX 方法</span><br><span class="line">             * 为 winner。否则无法决定哪个方法更为合适，只能抛出异常</span><br><span class="line">             */</span><br><span class="line">            if (candidateType.equals(winnerType)) &#123;</span><br><span class="line">                if (!boolean.class.equals(candidateType)) &#123;</span><br><span class="line">                    throw new ReflectionException(</span><br><span class="line">                        &quot;Illegal overloaded getter method with ambiguous type for property &quot;</span><br><span class="line">                            + propName + &quot; in class &quot; + winner.getDeclaringClass()</span><br><span class="line">                            + &quot;. This breaks the JavaBeans specification and can cause unpredictable results.&quot;);</span><br><span class="line"></span><br><span class="line">                /*</span><br><span class="line">                 * 如果方法返回值类型为 boolean，且方法名以 &quot;is&quot; 开头，</span><br><span class="line">                 * 则认为候选方法 candidate 更为合适</span><br><span class="line">                 */</span><br><span class="line">                &#125; else if (candidate.getName().startsWith(&quot;is&quot;)) &#123;</span><br><span class="line">                    winner = candidate;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            /*</span><br><span class="line">             * winnerType 是 candidateType 的子类，类型上更为具体，</span><br><span class="line">             * 则认为当前的 winner 仍是合适的，无需做什么事情</span><br><span class="line">             */</span><br><span class="line">            &#125; else if (candidateType.isAssignableFrom(winnerType)) &#123;</span><br><span class="line"></span><br><span class="line">            /*</span><br><span class="line">             * candidateType 是 winnerType 的子类，此时认为 candidate 方法更为合适，</span><br><span class="line">             * 故将 winner 更新为 candidate</span><br><span class="line">             */</span><br><span class="line">            &#125; else if (winnerType.isAssignableFrom(candidateType)) &#123;</span><br><span class="line">                winner = candidate;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new ReflectionException(</span><br><span class="line">                    &quot;Illegal overloaded getter method with ambiguous type for property &quot;</span><br><span class="line">                        + propName + &quot; in class &quot; + winner.getDeclaringClass()</span><br><span class="line">                        + &quot;. This breaks the JavaBeans specification and can cause unpredictable results.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 将筛选出的方法添加到 getMethods 中，并将方法返回值添加到 getTypes 中</span><br><span class="line">        addGetMethod(propName, winner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void addGetMethod(String name, Method method) &#123;</span><br><span class="line">    if (isValidPropertyName(name)) &#123;</span><br><span class="line">        getMethods.put(name, new MethodInvoker(method));</span><br><span class="line">        // 解析返回值类型</span><br><span class="line">        Type returnType = TypeParameterResolver.resolveReturnType(method, type);</span><br><span class="line">        // 将返回值类型由 Type 转为 Class，并将转换后的结果缓存到 setTypes 中</span><br><span class="line">        getTypes.put(name, typeToClass(returnType));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是解除冲突的过程，代码有点长，不太容易看懂。这里大家只要记住解决冲突的规则即可理解上面代码的逻辑。相关规则如下：</p>
<ol>
<li>冲突方法的返回值类型具有继承关系，子类返回值对应的方法被认为是更合适的选择</li>
<li>冲突方法的返回值类型相同，如果返回值类型为<code>boolean</code>，那么以<code>is</code>开头的方法则是更合适的方法</li>
<li>冲突方法的返回值类型相同，但返回值类型非<code>boolean</code>，此时出现歧义，抛出异常</li>
<li>冲突方法的返回值类型不相关，无法确定哪个是更好的选择，此时直接抛异常</li>
</ol>
<p>分析完 getter 方法的解析过程，下面继续分析 setter 方法的解析过程。</p>
<p><strong>● setter 方法解析过程</strong></p>
<p>与 getter 方法解析过程相比，setter 方法的解析过程与此有一定的区别。主要体现在冲突出现的原因，以及冲突的解决方法上。那下面，我们深入源码来找出两者之间的区别。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void addSetMethods(Class&lt;?&gt; cls) &#123;</span><br><span class="line">    Map&lt;String, List&lt;Method&gt;&gt; conflictingSetters = new HashMap&lt;String, List&lt;Method&gt;&gt;();</span><br><span class="line">    // 获取当前类，接口，以及父类中的方法。该方法逻辑不是很复杂，这里就不展开了</span><br><span class="line">    Method[] methods = getClassMethods(cls);</span><br><span class="line">    for (Method method : methods) &#123;</span><br><span class="line">        String name = method.getName();</span><br><span class="line">        // 过滤出 setter 方法，且方法仅有一个参数</span><br><span class="line">        if (name.startsWith(&quot;set&quot;) &amp;&amp; name.length() &gt; 3) &#123;</span><br><span class="line">            if (method.getParameterTypes().length == 1) &#123;</span><br><span class="line">                name = PropertyNamer.methodToProperty(name);</span><br><span class="line">                /*</span><br><span class="line">                 * setter 方法发生冲突原因是：可能存在重载情况，比如：</span><br><span class="line">                 *     void setSex(int sex);</span><br><span class="line">                 *     void setSex(SexEnum sex);</span><br><span class="line">                 */</span><br><span class="line">                addMethodConflict(conflictingSetters, name, method);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 解决 setter 冲突</span><br><span class="line">    resolveSetterConflicts(conflictingSetters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码和注释中，我们可知道 setter 方法之间出现冲突的原因。即方法存在重载，方法重载导致<code>methodToProperty</code>方法解析出的属性名完全一致。而 getter 方法之间出现冲突的原因是<code>getXXX</code>和<code>isXXX</code>对应的属性名一致。既然冲突发生了，要进行调停，那接下来继续来看看调停冲突的逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void resolveSetterConflicts(Map&lt;String, List&lt;Method&gt;&gt; conflictingSetters) &#123;</span><br><span class="line">    for (String propName : conflictingSetters.keySet()) &#123;</span><br><span class="line">        List&lt;Method&gt; setters = conflictingSetters.get(propName);</span><br><span class="line">        /*</span><br><span class="line">         * 获取 getter 方法的返回值类型，由于 getter 方法不存在重载的情况，</span><br><span class="line">         * 所以可以用它的返回值类型反推哪个 setter 的更为合适</span><br><span class="line">         */</span><br><span class="line">        Class&lt;?&gt; getterType = getTypes.get(propName);</span><br><span class="line">        Method match = null;</span><br><span class="line">        ReflectionException exception = null;</span><br><span class="line">        for (Method setter : setters) &#123;</span><br><span class="line">            // 获取参数类型</span><br><span class="line">            Class&lt;?&gt; paramType = setter.getParameterTypes()[0];</span><br><span class="line">            if (paramType.equals(getterType)) &#123;</span><br><span class="line">                // 参数类型和返回类型一致，则认为是最好的选择，并结束循环</span><br><span class="line">                match = setter;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (exception == null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 选择一个更为合适的方法</span><br><span class="line">                    match = pickBetterSetter(match, setter, propName);</span><br><span class="line">                &#125; catch (ReflectionException e) &#123;</span><br><span class="line">                    match = null;</span><br><span class="line">                    exception = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 若 match 为空，表示没找到更为合适的方法，此时抛出异常</span><br><span class="line">        if (match == null) &#123;</span><br><span class="line">            throw exception;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 将筛选出的方法放入 setMethods 中，并将方法参数值添加到 setTypes 中</span><br><span class="line">            addSetMethod(propName, match);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 从两个 setter 方法中选择一个更为合适方法 */</span><br><span class="line">private Method pickBetterSetter(Method setter1, Method setter2, String property) &#123;</span><br><span class="line">    if (setter1 == null) &#123;</span><br><span class="line">        return setter2;</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt; paramType1 = setter1.getParameterTypes()[0];</span><br><span class="line">    Class&lt;?&gt; paramType2 = setter2.getParameterTypes()[0];</span><br><span class="line"></span><br><span class="line">    // 如果参数2可赋值给参数1，即参数2是参数1的子类，则认为参数2对应的 setter 方法更为合适</span><br><span class="line">    if (paramType1.isAssignableFrom(paramType2)) &#123;</span><br><span class="line">        return setter2;</span><br><span class="line">        </span><br><span class="line">    // 这里和上面情况相反</span><br><span class="line">    &#125; else if (paramType2.isAssignableFrom(paramType1)) &#123;</span><br><span class="line">        return setter1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 两种参数类型不相关，这里抛出异常</span><br><span class="line">    throw new ReflectionException(&quot;Ambiguous setters defined for property &#x27;&quot; + property + &quot;&#x27; in class &#x27;&quot;</span><br><span class="line">        + setter2.getDeclaringClass() + &quot;&#x27; with types &#x27;&quot; + paramType1.getName() + &quot;&#x27; and &#x27;&quot;</span><br><span class="line">        + paramType2.getName() + &quot;&#x27;.&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void addSetMethod(String name, Method method) &#123;</span><br><span class="line">    if (isValidPropertyName(name)) &#123;</span><br><span class="line">        setMethods.put(name, new MethodInvoker(method));</span><br><span class="line">        // 解析参数类型列表</span><br><span class="line">        Type[] paramTypes = TypeParameterResolver.resolveParamTypes(method, type);</span><br><span class="line">        // 将参数类型由 Type 转为 Class，并将转换后的结果缓存到 setTypes</span><br><span class="line">        setTypes.put(name, typeToClass(paramTypes[0]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于 setter 方法冲突的解析规则，这里也总结一下吧。如下：</p>
<ol>
<li>冲突方法的参数类型与 getter 的返回类型一致，则认为是最好的选择</li>
<li>冲突方法的参数类型具有继承关系，子类参数对应的方法被认为是更合适的选择</li>
<li>冲突方法的参数类型不相关，无法确定哪个是更好的选择，此时直接抛异常</li>
</ol>
<p>到此关于 setter 方法的解析过程就说完了。我在前面说过 MetaClass 的<code>hasSetter</code>最终调用了 Refactor 的<code>hasSetter</code>方法，那么现在是时候分析 Refactor 的<code>hasSetter</code>方法了。代码如下如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean hasSetter(String propertyName) &#123;</span><br><span class="line">    return setMethods.keySet().contains(propertyName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码如上，就两行，很简单，就不多说了。</p>
<h5 id="2-3-2-3-PropertyTokenizer-源码分析"><a href="#2-3-2-3-PropertyTokenizer-源码分析" class="headerlink" title="2.3.2.3 PropertyTokenizer 源码分析"></a>2.3.2.3 PropertyTokenizer 源码分析</h5><p>对于较为复杂的属性，需要进行进一步解析才能使用。那什么样的属性是复杂属性呢？来看个测试代码就知道了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MetaClassTest &#123;</span><br><span class="line"></span><br><span class="line">    private class Author &#123;</span><br><span class="line">        private Integer id;</span><br><span class="line">        private String name;</span><br><span class="line">        private Integer age;</span><br><span class="line">        /** 一个作者对应多篇文章 */</span><br><span class="line">        private Article[] articles;</span><br><span class="line"></span><br><span class="line">        // 省略 getter/setter</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private class Article &#123;</span><br><span class="line">        private Integer id;</span><br><span class="line">        private String title;</span><br><span class="line">        private String content;</span><br><span class="line">        /** 一篇文章对应一个作者 */</span><br><span class="line">        private Author author;</span><br><span class="line"></span><br><span class="line">        // 省略 getter/setter</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testHasSetter() &#123;</span><br><span class="line">        // 为 Author 创建元信息对象</span><br><span class="line">        MetaClass authorMeta = MetaClass.forClass(Author.class, new DefaultReflectorFactory());</span><br><span class="line">        System.out.println(&quot;------------☆ Author ☆------------&quot;);</span><br><span class="line">        System.out.println(&quot;id -&gt; &quot; + authorMeta.hasSetter(&quot;id&quot;));</span><br><span class="line">        System.out.println(&quot;name -&gt; &quot; + authorMeta.hasSetter(&quot;name&quot;));</span><br><span class="line">        System.out.println(&quot;age -&gt; &quot; + authorMeta.hasSetter(&quot;age&quot;));</span><br><span class="line">        // 检测 Author 中是否包含 Article[] 的 setter</span><br><span class="line">        System.out.println(&quot;articles -&gt; &quot; + authorMeta.hasSetter(&quot;articles&quot;));</span><br><span class="line">        System.out.println(&quot;articles[] -&gt; &quot; + authorMeta.hasSetter(&quot;articles[]&quot;));</span><br><span class="line">        System.out.println(&quot;title -&gt; &quot; + authorMeta.hasSetter(&quot;title&quot;));</span><br><span class="line"></span><br><span class="line">        // 为 Article 创建元信息对象</span><br><span class="line">        MetaClass articleMeta = MetaClass.forClass(Article.class, new DefaultReflectorFactory());</span><br><span class="line">        System.out.println(&quot;\n------------☆ Article ☆------------&quot;);</span><br><span class="line">        System.out.println(&quot;id -&gt; &quot; + articleMeta.hasSetter(&quot;id&quot;));</span><br><span class="line">        System.out.println(&quot;title -&gt; &quot; + articleMeta.hasSetter(&quot;title&quot;));</span><br><span class="line">        System.out.println(&quot;content -&gt; &quot; + articleMeta.hasSetter(&quot;content&quot;));</span><br><span class="line">        // 下面两个均为复杂属性，分别检测 Article 类中的 Author 类是否包含 id 和 name 的 setter 方法</span><br><span class="line">        System.out.println(&quot;author.id -&gt; &quot; + articleMeta.hasSetter(&quot;author.id&quot;));</span><br><span class="line">        System.out.println(&quot;author.name -&gt; &quot; + articleMeta.hasSetter(&quot;author.name&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，<code>Article</code>类中包含了一个<code>Author</code>引用。然后我们调用 articleMeta 的 hasSetter 检测<code>author.id</code>和<code>author.name</code>属性是否存在，我们的期望结果为 true。测试结果如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15318984293363.jpg" alt="img"></p>
<p>如上，标记⑤处的输出均为 true，我们的预期达到了。标记②处检测 Article 数组的是否存在 setter 方法，结果也均为 true。这说明 PropertyTokenizer 对数组和复合属性均进行了处理。那它是如何处理的呢？答案如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PropertyTokenizer implements Iterator&lt;PropertyTokenizer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private final String indexedName;</span><br><span class="line">    private String index;</span><br><span class="line">    private final String children;</span><br><span class="line"></span><br><span class="line">    public PropertyTokenizer(String fullname) &#123;</span><br><span class="line">        // 检测传入的参数中是否包含字符 &#x27;.&#x27;</span><br><span class="line">        int delim = fullname.indexOf(&#x27;.&#x27;);</span><br><span class="line">        if (delim &gt; -1) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * 以点位为界，进行分割。比如：</span><br><span class="line">             *    fullname = www.coolblog.xyz</span><br><span class="line">             *</span><br><span class="line">             * 以第一个点为分界符：</span><br><span class="line">             *    name = www</span><br><span class="line">             *    children = coolblog.xyz</span><br><span class="line">             */ </span><br><span class="line">            name = fullname.substring(0, delim);</span><br><span class="line">            children = fullname.substring(delim + 1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // fullname 中不存在字符 &#x27;.&#x27;</span><br><span class="line">            name = fullname;</span><br><span class="line">            children = null;</span><br><span class="line">        &#125;</span><br><span class="line">        indexedName = name;</span><br><span class="line">        // 检测传入的参数中是否包含字符 &#x27;[&#x27;</span><br><span class="line">        delim = name.indexOf(&#x27;[&#x27;);</span><br><span class="line">        if (delim &gt; -1) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * 获取中括号里的内容，比如：</span><br><span class="line">             *   1. 对于数组或List集合：[] 中的内容为数组下标，</span><br><span class="line">             *      比如 fullname = articles[1]，index = 1</span><br><span class="line">             *   2. 对于Map：[] 中的内容为键，</span><br><span class="line">             *      比如 fullname = xxxMap[keyName]，index = keyName</span><br><span class="line">             *</span><br><span class="line">             * 关于 index 属性的用法，可以参考 BaseWrapper 的 getCollectionValue 方法</span><br><span class="line">             */</span><br><span class="line">            index = name.substring(delim + 1, name.length() - 1);</span><br><span class="line"></span><br><span class="line">            // 获取分解符前面的内容，比如 fullname = articles[1]，name = articles</span><br><span class="line">            name = name.substring(0, delim);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 省略 getter</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return children != null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public PropertyTokenizer next() &#123;</span><br><span class="line">        // 对 children 进行再次切分，用于解析多重复合属性</span><br><span class="line">        return new PropertyTokenizer(children);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 省略部分方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是 PropertyTokenizer 的源码分析，注释的比较多，应该分析清楚了。大家如果看懂了上面的分析，那么可以自行举例进行测试，以加深理解。</p>
<h4 id="2-3-3-小结"><a href="#2-3-3-小结" class="headerlink" title="2.3.3 小结"></a>2.3.3 小结</h4><p>本节的篇幅比较大，大家看起来应该蛮辛苦的。本节为了分析 MetaClass 的 hasSetter 方法，把这个方法涉及到的源码均分析了一遍。其实，如果想简单点分析，我可以直接把 MetaClass 当成一个黑盒，然后用一句话告诉大家 hasSetter 方法有什么用即可。但是这样做我觉的文章太虚，没什么深度。关于 MetaClass 及相关源码大家第一次看可能会有点吃力，看不懂可以先放一放。后面多看几遍，动手写点测试代码调试一下，可以帮助理解。</p>
<p>好了，关于 setting 节点的解析过程就先分析到这里，我们继续往下分析。</p>
<h3 id="2-4-设置-settings-配置到-Configuration-中"><a href="#2-4-设置-settings-配置到-Configuration-中" class="headerlink" title="2.4 设置 settings 配置到 Configuration 中"></a>2.4 设置 settings 配置到 Configuration 中</h3><p>上一节讲了 settings 配置的解析过程，这些配置解析出来要有一个存放的地方，以使其他代码可以找到这些配置。这个存放地方就是 Configuration 对象，本节就来看一下这将 settings 配置设置到 Configuration 对象中的过程。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void settingsElement(Properties props) throws Exception &#123;</span><br><span class="line">    // 设置 autoMappingBehavior 属性，默认值为 PARTIAL</span><br><span class="line">    configuration.setAutoMappingBehavior(AutoMappingBehavior.valueOf(props.getProperty(&quot;autoMappingBehavior&quot;, &quot;PARTIAL&quot;)));</span><br><span class="line">    configuration.setAutoMappingUnknownColumnBehavior(AutoMappingUnknownColumnBehavior.valueOf(props.getProperty(&quot;autoMappingUnknownColumnBehavior&quot;, &quot;NONE&quot;)));</span><br><span class="line">    // 设置 cacheEnabled 属性，默认值为 true</span><br><span class="line">    configuration.setCacheEnabled(booleanValueOf(props.getProperty(&quot;cacheEnabled&quot;), true));</span><br><span class="line"></span><br><span class="line">    // 省略部分代码</span><br><span class="line"></span><br><span class="line">    // 解析默认的枚举处理器</span><br><span class="line">    Class&lt;? extends TypeHandler&gt; typeHandler = (Class&lt;? extends TypeHandler&gt;)resolveClass(props.getProperty(&quot;defaultEnumTypeHandler&quot;));</span><br><span class="line">    // 设置默认枚举处理器</span><br><span class="line">    configuration.setDefaultEnumTypeHandler(typeHandler);</span><br><span class="line">    configuration.setCallSettersOnNulls(booleanValueOf(props.getProperty(&quot;callSettersOnNulls&quot;), false));</span><br><span class="line">    configuration.setUseActualParamName(booleanValueOf(props.getProperty(&quot;useActualParamName&quot;), true));</span><br><span class="line">    </span><br><span class="line">    // 省略部分代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码处理调用 Configuration 的 setter 方法，就没太多逻辑了。这里来看一下上面出现的一个调用<code>resolveClass</code>，它的源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- BaseBuilder</span><br><span class="line">protected Class&lt;?&gt; resolveClass(String alias) &#123;</span><br><span class="line">    if (alias == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 通过别名解析</span><br><span class="line">        return resolveAlias(alias);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new BuilderException(&quot;Error resolving class. Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected final TypeAliasRegistry typeAliasRegistry;</span><br><span class="line"></span><br><span class="line">protected Class&lt;?&gt; resolveAlias(String alias) &#123;</span><br><span class="line">    // 通过别名注册器解析别名对于的类型 Class</span><br><span class="line">    return typeAliasRegistry.resolveAlias(alias);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里出现了一个新的类<code>TypeAliasRegistry</code>，大家对于它可能会觉得陌生，但是对于<code>typeAlias</code>应该不会陌生。TypeAliasRegistry 的用途就是将别名和类型进行映射，这样就可以用别名表示某个类了，方便使用。既然聊到了别名，那下面我们不妨看看别名的配置的解析过程。</p>
<h3 id="2-5-解析-typeAliases-配置"><a href="#2-5-解析-typeAliases-配置" class="headerlink" title="2.5 解析 typeAliases 配置"></a>2.5 解析 typeAliases 配置</h3><p>在 MyBatis 中，可以为我们自己写的有些类定义一个别名。这样在使用的时候，我们只需要输入别名即可，无需再把全限定的类名写出来。在 MyBatis 中，我们有两种方式进行别名配置。第一种是仅配置包名，让 MyBatis 去扫描包中的类型，并根据类型得到相应的别名。这种方式可配合 Alias 注解使用，即通过注解为某个类配置别名，而不是让 MyBatis 按照默认规则生成别名。这种方式的配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">    &lt;package name=&quot;xyz.coolblog.model1&quot;/&gt;</span><br><span class="line">    &lt;package name=&quot;xyz.coolblog.model2&quot;/&gt;</span><br><span class="line">&lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure>

<p>第二种方式是通过手动的方式，明确为某个类型配置别名。这种方式的配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">    &lt;typeAlias alias=&quot;article&quot; type=&quot;xyz.coolblog.model.Article&quot; /&gt;</span><br><span class="line">    &lt;typeAlias type=&quot;xyz.coolblog.model.Author&quot; /&gt;</span><br><span class="line">&lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure>

<p>对比这两种方式，第一种自动扫描的方式配置起来比较简单，缺点也不明显。唯一能想到缺点可能就是 MyBatis 会将某个包下所有符合要求的类的别名都解析出来，并形成映射关系。如果你不想让某些类被扫描，<br>这个好像做不到，没发现 MyBatis 提供了相关的排除机制。不过我觉得这并不是什么大问题，最多是多解析并缓存了一些别名到类型的映射，在时间和空间上产生了一些额外的消耗而已。当然，如果无法忍受这些消耗，可以使用第二种配置方式，通过手工的方式精确配置某些类型的别名。不过这种方式比较繁琐，特别是配置项比较多时。至于两种方式怎么选择，这个看具体的情况了。配置项非常少时，两种皆可。比较多的话，还是让 MyBatis 自行扫描吧。</p>
<p>以上介绍了两种不同的别名配置方式，下面我们来看一下两种不同的别名配置是怎样解析的。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- XMLConfigBuilder</span><br><span class="line">private void typeAliasesElement(XNode parent) &#123;</span><br><span class="line">    if (parent != null) &#123;</span><br><span class="line">        for (XNode child : parent.getChildren()) &#123;</span><br><span class="line">        	// ⭐️ 从指定的包中解析别名和类型的映射</span><br><span class="line">            if (&quot;package&quot;.equals(child.getName())) &#123;</span><br><span class="line">                String typeAliasPackage = child.getStringAttribute(&quot;name&quot;);</span><br><span class="line">                configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);</span><br><span class="line">                </span><br><span class="line">            // ⭐️ 从 typeAlias 节点中解析别名和类型的映射</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            	// 获取 alias 和 type 属性值，alias 不是必填项，可为空</span><br><span class="line">                String alias = child.getStringAttribute(&quot;alias&quot;);</span><br><span class="line">                String type = child.getStringAttribute(&quot;type&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                	// 加载 type 对应的类型</span><br><span class="line">                    Class&lt;?&gt; clazz = Resources.classForName(type);</span><br><span class="line"></span><br><span class="line">                    // 注册别名到类型的映射</span><br><span class="line">                    if (alias == null) &#123;</span><br><span class="line">                        typeAliasRegistry.registerAlias(clazz);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        typeAliasRegistry.registerAlias(alias, clazz);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                    throw new BuilderException(&quot;Error registering typeAlias for &#x27;&quot; + alias + &quot;&#x27;. Cause: &quot; + e, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，上面的代码通过一个<code>if-else</code>条件分支来处理两种不同的配置，这里我用⭐️标注了出来。下面我们来分别看一下这两种配置方式的解析过程，首先来看一下手动配置方式的解析过程。</p>
<h4 id="2-5-1-从-typeAlias-节点中解析并注册别名"><a href="#2-5-1-从-typeAlias-节点中解析并注册别名" class="headerlink" title="2.5.1 从 typeAlias 节点中解析并注册别名"></a>2.5.1 从 typeAlias 节点中解析并注册别名</h4><p>在别名的配置中，<code>type</code>属性是必须要配置的，而<code>alias</code>属性则不是必须的。这个在配置文件的 DTD 中有规定。如果使用者未配置 alias 属性，则需要 MyBatis 自行为目标类型生成别名。对于别名为空的情况，注册别名的任务交由<code>void registerAlias(Class&lt;?&gt;)</code>方法处理。若不为空，则由<code>void registerAlias(String, Class&lt;?&gt;)</code>进行别名注册。这两个方法的分析如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private final Map&lt;String, Class&lt;?&gt;&gt; TYPE_ALIASES = new HashMap&lt;String, Class&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line">public void registerAlias(Class&lt;?&gt; type) &#123;</span><br><span class="line">    // 获取全路径类名的简称</span><br><span class="line">    String alias = type.getSimpleName();</span><br><span class="line">    Alias aliasAnnotation = type.getAnnotation(Alias.class);</span><br><span class="line">    if (aliasAnnotation != null) &#123;</span><br><span class="line">        // 从注解中取出别名</span><br><span class="line">        alias = aliasAnnotation.value();</span><br><span class="line">    &#125;</span><br><span class="line">    // 调用重载方法注册别名和类型映射</span><br><span class="line">    registerAlias(alias, type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void registerAlias(String alias, Class&lt;?&gt; value) &#123;</span><br><span class="line">    if (alias == null) &#123;</span><br><span class="line">        throw new TypeException(&quot;The parameter alias cannot be null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 将别名转成小写</span><br><span class="line">    String key = alias.toLowerCase(Locale.ENGLISH);</span><br><span class="line">    /*</span><br><span class="line">     * 如果 TYPE_ALIASES 中存在了某个类型映射，这里判断当前类型与映射中的类型是否一致，</span><br><span class="line">     * 不一致则抛出异常，不允许一个别名对应两种类型</span><br><span class="line">     */</span><br><span class="line">    if (TYPE_ALIASES.containsKey(key) &amp;&amp; TYPE_ALIASES.get(key) != null &amp;&amp; !TYPE_ALIASES.get(key).equals(value)) &#123;</span><br><span class="line">        throw new TypeException(</span><br><span class="line">            &quot;The alias &#x27;&quot; + alias + &quot;&#x27; is already mapped to the value &#x27;&quot; + TYPE_ALIASES.get(key).getName() + &quot;&#x27;.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 缓存别名到类型映射</span><br><span class="line">    TYPE_ALIASES.put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，若用户为明确配置 alias 属性，MyBatis 会使用类名的小写形式作为别名。比如，全限定类名<code>xyz.coolblog.model.Author</code>的别名为<code>author</code>。若类中有<code>@Alias</code>注解，则从注解中取值作为别名。</p>
<p>上面的代码不是很复杂，注释的也比较清楚了，就不多说了。继续往下看。</p>
<h4 id="2-5-2-从指定的包中解析并注册别名"><a href="#2-5-2-从指定的包中解析并注册别名" class="headerlink" title="2.5.2 从指定的包中解析并注册别名"></a>2.5.2 从指定的包中解析并注册别名</h4><p>从指定的包中解析并注册别名过程主要由别名的解析和注册两步组成。下面来看一下相关代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void registerAliases(String packageName) &#123;</span><br><span class="line">    // 调用重载方法注册别名</span><br><span class="line">    registerAliases(packageName, Object.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void registerAliases(String packageName, Class&lt;?&gt; superType) &#123;</span><br><span class="line">    ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = new ResolverUtil&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">    /*</span><br><span class="line">     * 查找某个包下的父类为 superType 的类。从调用栈来看，这里的 </span><br><span class="line">     * superType = Object.class，所以 ResolverUtil 将查找所有的类。</span><br><span class="line">     * 查找完成后，查找结果将会被缓存到内部集合中。</span><br><span class="line">     */ </span><br><span class="line">    resolverUtil.find(new ResolverUtil.IsA(superType), packageName);</span><br><span class="line">    // 获取查找结果</span><br><span class="line">    Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; typeSet = resolverUtil.getClasses();</span><br><span class="line">    for (Class&lt;?&gt; type : typeSet) &#123;</span><br><span class="line">        // 忽略匿名类，接口，内部类</span><br><span class="line">        if (!type.isAnonymousClass() &amp;&amp; !type.isInterface() &amp;&amp; !type.isMemberClass()) &#123;</span><br><span class="line">            // 为类型注册别名 </span><br><span class="line">            registerAlias(type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码不多，相关流程也不复杂，可简单总结为下面两个步骤：</p>
<ol>
<li>查找指定包下的所有类</li>
<li>遍历查找到的类型集合，为每个类型注册别名</li>
</ol>
<p>在这两步流程中，第2步流程对应的代码上一节已经分析过了，这里不再赘述。第1步的功能理解起来不难，但是背后对应的代码有点多。限于篇幅原因，这里我不打算详细分析这一部分的代码，只做简单的流程总结。如下：</p>
<ol>
<li>通过 VFS（虚拟文件系统）获取指定包下的所有文件的路径名，<br>比如<code>xyz/coolblog/model/Article.class</code></li>
<li>筛选以<code>.class</code>结尾的文件名</li>
<li>将路径名转成全限定的类名，通过类加载器加载类名</li>
<li>对类型进行匹配，若符合匹配规则，则将其放入内部集合中</li>
</ol>
<p>以上就是类型资源查找的过程，并不是很复杂，大家有兴趣自己看看吧。</p>
<h4 id="2-5-3-注册-MyBatis-内部类及常见类型的别名"><a href="#2-5-3-注册-MyBatis-内部类及常见类型的别名" class="headerlink" title="2.5.3 注册 MyBatis 内部类及常见类型的别名"></a>2.5.3 注册 MyBatis 内部类及常见类型的别名</h4><p>最后，我们来看一下一些 MyBatis 内部类及一些常见类型的别名注册过程。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -☆- Configuration</span><br><span class="line">public Configuration() &#123;</span><br><span class="line">    // 注册事务工厂的别名</span><br><span class="line">    typeAliasRegistry.registerAlias(&quot;JDBC&quot;, JdbcTransactionFactory.class);</span><br><span class="line">    // 省略部分代码，下同</span><br><span class="line"></span><br><span class="line">    // 注册数据源的别名</span><br><span class="line">    typeAliasRegistry.registerAlias(&quot;POOLED&quot;, PooledDataSourceFactory.class);</span><br><span class="line"></span><br><span class="line">    // 注册缓存策略的别名</span><br><span class="line">    typeAliasRegistry.registerAlias(&quot;FIFO&quot;, FifoCache.class);</span><br><span class="line">    typeAliasRegistry.registerAlias(&quot;LRU&quot;, LruCache.class);</span><br><span class="line"></span><br><span class="line">    // 注册日志类的别名</span><br><span class="line">    typeAliasRegistry.registerAlias(&quot;SLF4J&quot;, Slf4jImpl.class);</span><br><span class="line">    typeAliasRegistry.registerAlias(&quot;LOG4J&quot;, Log4jImpl.class);</span><br><span class="line"></span><br><span class="line">    // 注册动态代理工厂的别名</span><br><span class="line">    typeAliasRegistry.registerAlias(&quot;CGLIB&quot;, CglibProxyFactory.class);</span><br><span class="line">    typeAliasRegistry.registerAlias(&quot;JAVASSIST&quot;, JavassistProxyFactory.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// -☆- TypeAliasRegistry</span><br><span class="line">public TypeAliasRegistry() &#123;</span><br><span class="line">    // 注册 String 的别名</span><br><span class="line">    registerAlias(&quot;string&quot;, String.class);</span><br><span class="line"></span><br><span class="line">    // 注册基本类型包装类的别名</span><br><span class="line">    registerAlias(&quot;byte&quot;, Byte.class);</span><br><span class="line">    // 省略部分代码，下同</span><br><span class="line"></span><br><span class="line">    // 注册基本类型包装类数组的别名</span><br><span class="line">    registerAlias(&quot;byte[]&quot;, Byte[].class);</span><br><span class="line">    </span><br><span class="line">    // 注册基本类型的别名</span><br><span class="line">    registerAlias(&quot;_byte&quot;, byte.class);</span><br><span class="line"></span><br><span class="line">    // 注册基本类型包装类的别名</span><br><span class="line">    registerAlias(&quot;_byte[]&quot;, byte[].class);</span><br><span class="line"></span><br><span class="line">    // 注册 Date, BigDecimal, Object 等类型的别名</span><br><span class="line">    registerAlias(&quot;date&quot;, Date.class);</span><br><span class="line">    registerAlias(&quot;decimal&quot;, BigDecimal.class);</span><br><span class="line">    registerAlias(&quot;object&quot;, Object.class);</span><br><span class="line"></span><br><span class="line">    // 注册 Date, BigDecimal, Object 等数组类型的别名</span><br><span class="line">    registerAlias(&quot;date[]&quot;, Date[].class);</span><br><span class="line">    registerAlias(&quot;decimal[]&quot;, BigDecimal[].class);</span><br><span class="line">    registerAlias(&quot;object[]&quot;, Object[].class);</span><br><span class="line"></span><br><span class="line">    // 注册集合类型的别名</span><br><span class="line">    registerAlias(&quot;map&quot;, Map.class);</span><br><span class="line">    registerAlias(&quot;hashmap&quot;, HashMap.class);</span><br><span class="line">    registerAlias(&quot;list&quot;, List.class);</span><br><span class="line">    registerAlias(&quot;arraylist&quot;, ArrayList.class);</span><br><span class="line">    registerAlias(&quot;collection&quot;, Collection.class);</span><br><span class="line">    registerAlias(&quot;iterator&quot;, Iterator.class);</span><br><span class="line"></span><br><span class="line">    // 注册 ResultSet 的别名</span><br><span class="line">    registerAlias(&quot;ResultSet&quot;, ResultSet.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我记得以前配置<code>&lt;select/&gt;</code>标签的<code>resultType</code>属性，由于不知道有别名这回事，傻傻的使用全限定类名进行配置。当时还觉得这样配置一定不会出错吧，很放心。现在想想有点搞笑。</p>
<p>好了，以上就是别名解析的全部流程，大家看懂了吗？如果觉得没啥障碍的话，那继续往下看呗。</p>
<h3 id="2-6-解析-plugins-配置"><a href="#2-6-解析-plugins-配置" class="headerlink" title="2.6 解析 plugins 配置"></a>2.6 解析 plugins 配置</h3><p>插件是 MyBatis 提供的一个拓展机制，通过插件机制我们可在 SQL 执行过程中的某些点上做一些自定义操作。实现一个插件需要比简单，首先需要让插件类实现<code>Interceptor</code>接口。然后在插件类上添加<code>@Intercepts</code>和<code>@Signature</code>注解，用于指定想要拦截的目标方法。MyBatis 允许拦截下面接口中的一些方法：</p>
<ul>
<li>Executor: update 方法，query 方法，flushStatements 方法，commit 方法，rollback 方法， getTransaction 方法，close 方法，isClosed 方法</li>
<li>ParameterHandler: getParameterObject 方法，setParameters 方法</li>
<li>ResultSetHandler: handleResultSets 方法，handleOutputParameters 方法</li>
<li>StatementHandler: prepare 方法，parameterize 方法，batch 方法，update 方法，query 方法</li>
</ul>
<p>比较常见的插件有分页插件、分表插件等，有兴趣的朋友可以去了解下。本节我们来分析一下插件的配置的解析过程，先来了解插件的配置。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">    &lt;plugin interceptor=&quot;xyz.coolblog.mybatis.ExamplePlugin&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;key&quot; value=&quot;value&quot;/&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure>

<p>解析过程分析如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void pluginElement(XNode parent) throws Exception &#123;</span><br><span class="line">    if (parent != null) &#123;</span><br><span class="line">        for (XNode child : parent.getChildren()) &#123;</span><br><span class="line">            String interceptor = child.getStringAttribute(&quot;interceptor&quot;);</span><br><span class="line">            // 获取配置信息</span><br><span class="line">            Properties properties = child.getChildrenAsProperties();</span><br><span class="line">            // 解析拦截器的类型，并创建拦截器</span><br><span class="line">            Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).newInstance();</span><br><span class="line">            // 设置属性</span><br><span class="line">            interceptorInstance.setProperties(properties);</span><br><span class="line">            // 添加拦截器到 Configuration 中</span><br><span class="line">            configuration.addInterceptor(interceptorInstance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，插件解析的过程还是比较简单的。首先是获取配置，然后再解析拦截器类型，并实例化拦截器。最后向拦截器中设置属性，并将拦截器添加到 Configuration 中。好了，关于插件配置的分析就先到这，继续往下分析。</p>
<h3 id="2-7-解析-environments-配置"><a href="#2-7-解析-environments-配置" class="headerlink" title="2.7 解析 environments 配置"></a>2.7 解析 environments 配置</h3><p>在 MyBatis 中，事务管理器和数据源是配置在 environments 中的。它们的配置大致如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">    &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">        &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">        &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;</span><br><span class="line">        &lt;/dataSource&gt;</span><br><span class="line">    &lt;/environment&gt;</span><br><span class="line">&lt;/environments&gt;</span><br></pre></td></tr></table></figure>

<p>接下来我们对照上面的配置进行分析，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private String environment;</span><br><span class="line"></span><br><span class="line">private void environmentsElement(XNode context) throws Exception &#123;</span><br><span class="line">    if (context != null) &#123;</span><br><span class="line">        if (environment == null) &#123;</span><br><span class="line">            // 获取 default 属性</span><br><span class="line">            environment = context.getStringAttribute(&quot;default&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        for (XNode child : context.getChildren()) &#123;</span><br><span class="line">            // 获取 id 属性</span><br><span class="line">            String id = child.getStringAttribute(&quot;id&quot;);</span><br><span class="line">            /*</span><br><span class="line">             * 检测当前 environment 节点的 id 与其父节点 environments 的属性 default </span><br><span class="line">             * 内容是否一致，一致则返回 true，否则返回 false</span><br><span class="line">             */</span><br><span class="line">            if (isSpecifiedEnvironment(id)) &#123;</span><br><span class="line">                // 解析 transactionManager 节点，逻辑和插件的解析逻辑很相似，不在赘述</span><br><span class="line">                TransactionFactory txFactory = transactionManagerElement(child.evalNode(&quot;transactionManager&quot;));</span><br><span class="line">                // 解析 dataSource 节点，逻辑和插件的解析逻辑很相似，不在赘述</span><br><span class="line">                DataSourceFactory dsFactory = dataSourceElement(child.evalNode(&quot;dataSource&quot;));</span><br><span class="line">                // 创建 DataSource 对象</span><br><span class="line">                DataSource dataSource = dsFactory.getDataSource();</span><br><span class="line">                Environment.Builder environmentBuilder = new Environment.Builder(id)</span><br><span class="line">                    .transactionFactory(txFactory)</span><br><span class="line">                    .dataSource(dataSource);</span><br><span class="line">                // 构建 Environment 对象，并设置到 configuration 中</span><br><span class="line">                configuration.setEnvironment(environmentBuilder.build());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>environments 配置的解析过程没什么特别之处，按部就班解析就行了，不多说了。</p>
<h3 id="2-8-解析-typeHandlers-配置"><a href="#2-8-解析-typeHandlers-配置" class="headerlink" title="2.8 解析 typeHandlers 配置"></a>2.8 解析 typeHandlers 配置</h3><p>在向数据库存储或读取数据时，我们需要将数据库字段类型和 Java 类型进行一个转换。比如数据库中有<code>CHAR</code>和<code>VARCHAR</code>等类型，但 Java 中没有这些类型，不过 Java 有<code>String</code>类型。所以我们在从数据库中读取 CHAR 和 VARCHAR 类型的数据时，就可以把它们转成 String 。在 MyBatis 中，数据库类型和 Java 类型之间的转换任务是委托给类型处理器<code>TypeHandler</code>去处理的。MyBatis 提供了一些常见类型的类型处理器，除此之外，我们还可以自定义类型处理器以非常见类型转换的需求。这里我就不演示自定义类型处理器的编写方法了，没用过或者不熟悉的同学可以 <a href="http://www.mybatis.org/mybatis-3/zh/configuration.html#typeHandlers">MyBatis 官方文档</a>，或者我在上一篇<a href="http://www.coolblog.xyz/2018/07/16/MyBatis-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E5%AF%BC%E8%AF%BB/">文章</a>中写的示例。</p>
<p>下面，我们来看一下类型处理器的配置方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 自动扫描 --&gt;</span><br><span class="line">&lt;typeHandlers&gt;</span><br><span class="line">    &lt;package name=&quot;xyz.coolblog.handlers&quot;/&gt;</span><br><span class="line">&lt;/typeHandlers&gt;</span><br><span class="line">&lt;!-- 手动配置 --&gt;</span><br><span class="line">&lt;typeHandlers&gt;</span><br><span class="line">    &lt;typeHandler jdbcType=&quot;TINYINT&quot;</span><br><span class="line">            javaType=&quot;xyz.coolblog.constant.ArticleTypeEnum&quot;</span><br><span class="line">            handler=&quot;xyz.coolblog.mybatis.ArticleTypeHandler&quot;/&gt;</span><br><span class="line">&lt;/typeHandlers&gt;</span><br></pre></td></tr></table></figure>

<p>使用自动扫描的方式注册类型处理器时，应使用<code>@MappedTypes</code>和<code>@MappedJdbcTypes</code>注解配置<code>javaType</code>和<code>jdbcType</code>。关于注解，这里就不演示了，比较简单，大家自行尝试。下面开始分析代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void typeHandlerElement(XNode parent) throws Exception &#123;</span><br><span class="line">    if (parent != null) &#123;</span><br><span class="line">        for (XNode child : parent.getChildren()) &#123;</span><br><span class="line">            // 从指定的包中注册 TypeHandler</span><br><span class="line">            if (&quot;package&quot;.equals(child.getName())) &#123;</span><br><span class="line">                String typeHandlerPackage = child.getStringAttribute(&quot;name&quot;);</span><br><span class="line">                // 注册方法 ①</span><br><span class="line">                typeHandlerRegistry.register(typeHandlerPackage);</span><br><span class="line"></span><br><span class="line">            // 从 typeHandler 节点中解析别名到类型的映射</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 获取 javaType，jdbcType 和 handler 等属性值</span><br><span class="line">                String javaTypeName = child.getStringAttribute(&quot;javaType&quot;);</span><br><span class="line">                String jdbcTypeName = child.getStringAttribute(&quot;jdbcType&quot;);</span><br><span class="line">                String handlerTypeName = child.getStringAttribute(&quot;handler&quot;);</span><br><span class="line"></span><br><span class="line">                // 解析上面获取到的属性值</span><br><span class="line">                Class&lt;?&gt; javaTypeClass = resolveClass(javaTypeName);</span><br><span class="line">                JdbcType jdbcType = resolveJdbcType(jdbcTypeName);</span><br><span class="line">                Class&lt;?&gt; typeHandlerClass = resolveClass(handlerTypeName);</span><br><span class="line"></span><br><span class="line">                // 根据 javaTypeClass 和 jdbcType 值的情况进行不同的注册策略</span><br><span class="line">                if (javaTypeClass != null) &#123;</span><br><span class="line">                    if (jdbcType == null) &#123;</span><br><span class="line">                        // 注册方法 ②</span><br><span class="line">                        typeHandlerRegistry.register(javaTypeClass, typeHandlerClass);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // 注册方法 ③</span><br><span class="line">                        typeHandlerRegistry.register(javaTypeClass, jdbcType, typeHandlerClass);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 注册方法 ④</span><br><span class="line">                    typeHandlerRegistry.register(typeHandlerClass);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中用于解析 XML 部分的代码比较简单，没什么需要特别说明的。除此之外，上面的代码中调用了4个不同的类型处理器注册方法。这些注册方法的逻辑不难理解，但是重载方法很多，上面调用的注册方法只是重载方法的一部分。由于重载太多且重载方法之间互相调用，导致这一块的代码有点凌乱。我一开始在整理这部分代码时，也很抓狂。后来没辙了，把重载方法的调用图画了出来，才理清了代码。一图胜千言，看图吧。</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15321005084792.jpg" alt="img"></p>
<p>在上面的调用图中，每个蓝色背景框下都有一个标签。每个标签上面都已一个编号，这些编号与上面代码中的标签是一致的。这里我把<code>蓝色背景框</code>内的方法称为<code>开始方法</code>，<code>红色背景框</code>内的方法称为<code>终点方法</code>，<code>白色背景框</code>内的方法称为<code>中间方法</code>。下面我会分析从每个开始方法向下分析，为了避免冗余分析，我会按照<code>③ → ② → ④ → ①</code>的顺序进行分析。大家在阅读代码分析时，可以参照上面的图片，辅助理解。好了，下面开始进行分析。</p>
<h4 id="2-8-1-register-Class-JdbcType-Class-方法分析"><a href="#2-8-1-register-Class-JdbcType-Class-方法分析" class="headerlink" title="2.8.1 register(Class, JdbcType, Class) 方法分析"></a>2.8.1 register(Class, JdbcType, Class) 方法分析</h4><p>当代码执行到此方法时，表示<code>javaTypeClass != null &amp;&amp; jdbcType != null</code>条件成立，即使用者明确配置了<code>javaType</code>和<code>jdbcType</code>属性的值。那下面我们来看一下该方法的分析。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void register(Class&lt;?&gt; javaTypeClass, JdbcType jdbcType, Class&lt;?&gt; typeHandlerClass) &#123;</span><br><span class="line">    // 调用终点方法</span><br><span class="line">    register(javaTypeClass, jdbcType, getInstance(javaTypeClass, typeHandlerClass));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 类型处理器注册过程的终点 */</span><br><span class="line">private void register(Type javaType, JdbcType jdbcType, TypeHandler&lt;?&gt; handler) &#123;</span><br><span class="line">    if (javaType != null) &#123;</span><br><span class="line">        // JdbcType 到 TypeHandler 的映射</span><br><span class="line">        Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; map = TYPE_HANDLER_MAP.get(javaType);</span><br><span class="line">        if (map == null || map == NULL_TYPE_HANDLER_MAP) &#123;</span><br><span class="line">            map = new HashMap&lt;JdbcType, TypeHandler&lt;?&gt;&gt;();</span><br><span class="line">            // 存储 javaType 到 Map&lt;JdbcType, TypeHandler&gt; 的映射</span><br><span class="line">            TYPE_HANDLER_MAP.put(javaType, map);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(jdbcType, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 存储所有的 TypeHandler</span><br><span class="line">    ALL_TYPE_HANDLERS_MAP.put(handler.getClass(), handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码只有两层调用，比较简单。同时，所谓的注册过程也就是把类型和处理器进行映射而已，没什么特别之处。关于这个方法就先分析到这里，继续往下分析。下面的方法对应注册方法②。</p>
<h4 id="2-8-2-register-Class-Class-方法分析"><a href="#2-8-2-register-Class-Class-方法分析" class="headerlink" title="2.8.2 register(Class, Class) 方法分析"></a>2.8.2 register(Class, Class) 方法分析</h4><p>当代码执行到此方法时，表示<code>javaTypeClass != null &amp;&amp; jdbcType == null</code>条件成立，即使用者仅设置了<code>javaType</code>属性的值。下面我们来看一下该方法的分析。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void register(Class&lt;?&gt; javaTypeClass, Class&lt;?&gt; typeHandlerClass) &#123;</span><br><span class="line">    // 调用中间方法 register(Type, TypeHandler)</span><br><span class="line">    register(javaTypeClass, getInstance(javaTypeClass, typeHandlerClass));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private &lt;T&gt; void register(Type javaType, TypeHandler&lt;? extends T&gt; typeHandler) &#123;</span><br><span class="line">    // 获取 @MappedJdbcTypes 注解</span><br><span class="line">    MappedJdbcTypes mappedJdbcTypes = typeHandler.getClass().getAnnotation(MappedJdbcTypes.class);</span><br><span class="line">    if (mappedJdbcTypes != null) &#123;</span><br><span class="line">        // 遍历 @MappedJdbcTypes 注解中配置的值</span><br><span class="line">        for (JdbcType handledJdbcType : mappedJdbcTypes.value()) &#123;</span><br><span class="line">            // 调用终点方法，参考上一小节的分析</span><br><span class="line">            register(javaType, handledJdbcType, typeHandler);</span><br><span class="line">        &#125;</span><br><span class="line">        if (mappedJdbcTypes.includeNullJdbcType()) &#123;</span><br><span class="line">            // 调用终点方法，jdbcType = null</span><br><span class="line">            register(javaType, null, typeHandler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 调用终点方法，jdbcType = null</span><br><span class="line">        register(javaType, null, typeHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码包含三层调用，其中终点方法的逻辑上一节已经分析过，这里不再赘述。上面的逻辑也比较简单，主要做的事情是尝试从注解中获取<code>JdbcType</code>的值。这个方法就分析这么多，下面分析注册方法④。</p>
<h4 id="2-8-3-register-Class-方法分析"><a href="#2-8-3-register-Class-方法分析" class="headerlink" title="2.8.3 register(Class) 方法分析"></a>2.8.3 register(Class) 方法分析</h4><p>当代码执行到此方法时，表示<code>javaTypeClass == null &amp;&amp; jdbcType != null</code>条件成立，即使用者未配置<code>javaType</code>和<code>jdbcType</code>属性的值。该方法的分析如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void register(Class&lt;?&gt; typeHandlerClass) &#123;</span><br><span class="line">    boolean mappedTypeFound = false;</span><br><span class="line">    // 获取 @MappedTypes 注解</span><br><span class="line">    MappedTypes mappedTypes = typeHandlerClass.getAnnotation(MappedTypes.class);</span><br><span class="line">    if (mappedTypes != null) &#123;</span><br><span class="line">        // 遍历 @MappedTypes 注解中配置的值</span><br><span class="line">        for (Class&lt;?&gt; javaTypeClass : mappedTypes.value()) &#123;</span><br><span class="line">            // 调用注册方法 ②</span><br><span class="line">            register(javaTypeClass, typeHandlerClass);</span><br><span class="line">            mappedTypeFound = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!mappedTypeFound) &#123;</span><br><span class="line">        // 调用中间方法 register(TypeHandler)</span><br><span class="line">        register(getInstance(null, typeHandlerClass));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public &lt;T&gt; void register(TypeHandler&lt;T&gt; typeHandler) &#123;</span><br><span class="line">    boolean mappedTypeFound = false;</span><br><span class="line">    // 获取 @MappedTypes 注解</span><br><span class="line">    MappedTypes mappedTypes = typeHandler.getClass().getAnnotation(MappedTypes.class);</span><br><span class="line">    if (mappedTypes != null) &#123;</span><br><span class="line">        for (Class&lt;?&gt; handledType : mappedTypes.value()) &#123;</span><br><span class="line">            // 调用中间方法 register(Type, TypeHandler)</span><br><span class="line">            register(handledType, typeHandler);</span><br><span class="line">            mappedTypeFound = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 自动发现映射类型</span><br><span class="line">    if (!mappedTypeFound &amp;&amp; typeHandler instanceof TypeReference) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            TypeReference&lt;T&gt; typeReference = (TypeReference&lt;T&gt;) typeHandler;</span><br><span class="line">            // 获取参数模板中的参数类型，并调用中间方法 register(Type, TypeHandler)</span><br><span class="line">            register(typeReference.getRawType(), typeHandler);</span><br><span class="line">            mappedTypeFound = true;</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!mappedTypeFound) &#123;</span><br><span class="line">        // 调用中间方法 register(Class, TypeHandler)</span><br><span class="line">        register((Class&lt;T&gt;) null, typeHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public &lt;T&gt; void register(Class&lt;T&gt; javaType, TypeHandler&lt;? extends T&gt; typeHandler) &#123;</span><br><span class="line">    // 调用中间方法 register(Type, TypeHandler)</span><br><span class="line">    register((Type) javaType, typeHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码比较多，不过不用太担心。不管是通过注解的方式，还是通过反射的方式，它们最终目的是为了解析出<code>javaType</code>的值。解析完成后，这些方法会调用中间方法<code>register(Type, TypeHandler)</code>，这个方法负责解析<code>jdbcType</code>，该方法上一节已经分析过。一个复杂解析 javaType，另一个负责解析 jdbcType，逻辑比较清晰了。那我们趁热打铁，继续分析下一个注册方法，编号为①。</p>
<h4 id="2-8-4-register-String-方法分析"><a href="#2-8-4-register-String-方法分析" class="headerlink" title="2.8.4 register(String) 方法分析"></a>2.8.4 register(String) 方法分析</h4><p>本节代码的主要是用于自动扫描类型处理器，并调用其他方法注册扫描结果。该方法的分析如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void register(String packageName) &#123;</span><br><span class="line">    ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = new ResolverUtil&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">    // 从指定包中查找 TypeHandler</span><br><span class="line">    resolverUtil.find(new ResolverUtil.IsA(TypeHandler.class), packageName);</span><br><span class="line">    Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; handlerSet = resolverUtil.getClasses();</span><br><span class="line">    for (Class&lt;?&gt; type : handlerSet) &#123;</span><br><span class="line">        // 忽略内部类，接口，抽象类等</span><br><span class="line">        if (!type.isAnonymousClass() &amp;&amp; !type.isInterface() &amp;&amp; !Modifier.isAbstract(type.getModifiers())) &#123;</span><br><span class="line">            // 调用注册方法 ④</span><br><span class="line">            register(type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码的逻辑比较简单，其中注册方法④已经在上一节分析过了，这里就不多说了。</p>
<h4 id="2-8-5-小结"><a href="#2-8-5-小结" class="headerlink" title="2.8.5 小结"></a>2.8.5 小结</h4><p>类型处理器的解析过程不复杂，但是注册过程由于重载方法间相互调用，导致调用路线比较复杂。这个时候需要想办法理清方法的调用路线，理清后，整个逻辑就清晰明了了。好了，关于类型处理器的解析过程就先分析到这。</p>
<h3 id="2-9-解析-mappers-配置"><a href="#2-9-解析-mappers-配置" class="headerlink" title="2.9 解析 mappers 配置"></a>2.9 解析 mappers 配置</h3><p>前面分析的都是 MyBatis 的一些配置，本节的内容原本是打算分析 mappers 节点的解析过程。但由于本文的篇幅已经很大了，加之 mappers 节点的过程也比较复杂。所以，关于本节的内容，我会独立成文，后面再进行更新。这里先告知大家一下。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>本文对 MyBatis 配置文件中部分配置的解析过程进行了详细的分析。本文所关注的点不局限于配置文件的解析过程，如果仅分析配置文件，那就简单多了。对于我来说，我更希望在分析配置文件的过程中，尽量把一些背景知识弄明白，这样才能对 MyBatis 有更多的了解。从本文的篇幅以及内容上来说，我觉得本篇文章达到了自己的预期。通过本文的分析，也使我加深了对 MyBatis 的理解。总的来说，收获还是比较多的。不过个人水平有限，若文章有错误不妥之处，也请大家多多指教。</p>
<p>本篇文章篇幅比较大，写起来还是很耗费精力的。如果大家觉得这篇文章还不错的话，不妨给个赞吧，算是对我的鼓励了。好了，本篇文章就到这里了，感谢大家的阅读。</p>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-LSM树介绍1</title>
    <url>/2022/10/25/MySQL-LSM%E6%A0%91%E4%BB%8B%E7%BB%8D1/</url>
    <content><![CDATA[<h2 id="关于LSM树"><a href="#关于LSM树" class="headerlink" title="关于LSM树"></a>关于LSM树</h2><p>LSM树，即日志结构合并树(Log-Structured Merge-Tree)。其实它并不属于一个具体的<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020">数据结构</a>，它更多是一种数据结构的设计思想。大多NoSQL数据库核心思想都是基于LSM来做的，只是具体的实现不同。所以本来不打算列入该系列，但是有朋友留言了好几次让我讲LSM树，那么就说一下LSM树。</p>
<h2 id="LSM树诞生背景"><a href="#LSM树诞生背景" class="headerlink" title="LSM树诞生背景"></a>LSM树诞生背景</h2><p>传统<a href="https://so.csdn.net/so/search?q=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&spm=1001.2101.3001.7020">关系型数据库</a>使用btree或一些变体作为存储结构，能高效进行查找。但保存在磁盘中时它也有一个明显的缺陷，那就是逻辑上相离很近但物理却可能相隔很远，这就可能造成大量的磁盘随机读写。随机读写比顺序读写慢很多，为了提升IO性能，我们需要一种能将随机操作变为顺序操作的机制，于是便有了LSM树。LSM树能让我们进行顺序写磁盘，从而大幅提升写操作，作为代价的是牺牲了一些读性能。</p>
<h2 id="关于磁盘IO"><a href="#关于磁盘IO" class="headerlink" title="关于磁盘IO"></a>关于磁盘IO</h2><p>磁盘读写时涉及到磁盘上数据查找，地址一般由柱面号、盘面号和块号三者构成。也就是说移动臂先根据柱面号移动到指定柱面，然后根据盘面号确定盘面的磁道，最后根据块号将指定的磁道段移动到磁头下，便可开始读写。</p>
<p>整个过程主要有三部分时间消耗，查找时间(seek time) +等待时间(latency time)+传输时间(transmission time) 。分别表示定位柱面的耗时、将块号指定磁道段移到磁头的耗时、将数据传到内存的耗时。整个磁盘IO最耗时的地方在查找时间，所以减少查找时间能大幅提升性能。</p>
<h2 id="LSM树原理"><a href="#LSM树原理" class="headerlink" title="LSM树原理"></a>LSM树原理</h2><p>LSM树由两个或以上的<a href="https://so.csdn.net/so/search?q=%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020">存储结构</a>组成，比如在论文中为了方便说明使用了最简单的两个存储结构。一个存储结构常驻内存中，称为C0 tree，具体可以是任何方便健值查找的数据结构，比如红黑树、map之类，甚至可以是跳表。另外一个存储结构常驻在硬盘中，称为C1 tree，具体结构类似B树。C1所有节点都是100%满的，节点的大小为磁盘块大小。</p>
<p><img src="/2022/10/25/MySQL-LSM%E6%A0%91%E4%BB%8B%E7%BB%8D1/20190626190938930.jpeg" alt="img"></p>
<h2 id="插入步骤"><a href="#插入步骤" class="headerlink" title="插入步骤"></a>插入步骤</h2><p>大体思路是：插入一条新纪录时，首先在日志文件中插入操作日志，以便后面恢复使用，日志是以append形式插入，所以速度非常快；将新纪录的索引插入到C0中，这里在内存中完成，不涉及磁盘IO操作；当C0大小达到某一阈值时或者每隔一段时间，将C0中记录滚动合并到磁盘C1中；对于多个存储结构的情况，当C1体量越来越大就向C2合并，以此类推，一直往上合并Ck。</p>
<p><img src="/2022/10/25/MySQL-LSM%E6%A0%91%E4%BB%8B%E7%BB%8D1/20190626190938954.jpeg" alt="img"></p>
<h2 id="合并步骤"><a href="#合并步骤" class="headerlink" title="合并步骤"></a>合并步骤</h2><p>合并过程中会使用两个块：emptying block和filling block。</p>
<p>从C1中读取未合并叶子节点，放置内存中的emptying block中。从小到大找C0中的节点，与emptying block进行合并排序，合并结果保存到filling block中，并将C0对应的节点删除。不断执行第2步操作，合并排序结果不断填入filling block中，当其满了则将其追加到磁盘的新位置上，注意是追加而不是改变原来的节点。合并期间如故宫emptying block使用完了则再从C1中读取未合并的叶子节点。C0和C1所有叶子节点都按以上合并完成后即完成一次合并。</p>
<h2 id="关于优化措施"><a href="#关于优化措施" class="headerlink" title="关于优化措施"></a>关于优化措施</h2><p>本文用图阐述LSM的基本原理，但实际项目中其实有很多优化策略，而且有很多针对LSM树优化的paper。比如使用布隆过滤器快速判断key是否存在，还有做一些额外的索引以帮助更快找到记录等等。</p>
<h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><p>向LSM树中插入</p>
<p>A E L R U</p>
<p>，首先会插入到内存中的C0树上，这里使用AVL树，插入“A”，先向磁盘日志文件追加记录，然后再插入C0，</p>
<p><img src="/2022/10/25/MySQL-LSM%E6%A0%91%E4%BB%8B%E7%BB%8D1/11.png" alt="img"></p>
<p>插入“E”，同样先追加日志再写内存，</p>
<p><img src="/2022/10/25/MySQL-LSM%E6%A0%91%E4%BB%8B%E7%BB%8D1/12.png" alt="img"></p>
<p>继续插入“L”，旋转后如下，</p>
<p><img src="/2022/10/25/MySQL-LSM%E6%A0%91%E4%BB%8B%E7%BB%8D1/13.png" alt="img"></p>
<p>插入“R”“U”，旋转后最终如下。</p>
<p><img src="/2022/10/25/MySQL-LSM%E6%A0%91%E4%BB%8B%E7%BB%8D1/14.png" alt="img"></p>
<p>假设此时触发合并，则因为C1还没有树，所以emptying block为空，直接从C0树中依次找最小的节点。filling block长度为4，这里假设磁盘块大小为4。</p>
<p>开始找最小的节点，并放到filling block中，</p>
<p><img src="/2022/10/25/MySQL-LSM%E6%A0%91%E4%BB%8B%E7%BB%8D1/15.png" alt="img"></p>
<p>继续找第二个节点，</p>
<p><img src="/2022/10/25/MySQL-LSM%E6%A0%91%E4%BB%8B%E7%BB%8D1/16.png" alt="img"></p>
<p>以此类推，填满filling block，</p>
<p><img src="/2022/10/25/MySQL-LSM%E6%A0%91%E4%BB%8B%E7%BB%8D1/17.png" alt="img"></p>
<p>开始写入磁盘，C1树，</p>
<p><img src="/2022/10/25/MySQL-LSM%E6%A0%91%E4%BB%8B%E7%BB%8D1/18.png" alt="img"></p>
<p>继续插入</p>
<p>B F N T</p>
<p>，先分别写日志，然后插入到内存的C0树中，</p>
<p><img src="/2022/10/25/MySQL-LSM%E6%A0%91%E4%BB%8B%E7%BB%8D1/19.png" alt="img"></p>
<p>假如此时进行合并，先加载C1的最左边叶子节点到emptying block，</p>
<p><img src="/2022/10/25/MySQL-LSM%E6%A0%91%E4%BB%8B%E7%BB%8D1/20.png" alt="img"></p>
<p>接着对C0树的节点和emptying block进行合并排序，首先是“A”进入filling block，</p>
<p><img src="/2022/10/25/MySQL-LSM%E6%A0%91%E4%BB%8B%E7%BB%8D1/21.png" alt="img"></p>
<p>然后是“B”，</p>
<p><img src="/2022/10/25/MySQL-LSM%E6%A0%91%E4%BB%8B%E7%BB%8D1/22.png" alt="img"></p>
<p>合并排序最终结果为，</p>
<p><img src="/2022/10/25/MySQL-LSM%E6%A0%91%E4%BB%8B%E7%BB%8D1/23.png" alt="img"></p>
<p>将filling block追加到磁盘的新位置，将原来的节点删除掉，</p>
<p><img src="/2022/10/25/MySQL-LSM%E6%A0%91%E4%BB%8B%E7%BB%8D1/24.png" alt="img"></p>
<p>继续合并排序，再次填满filling block，</p>
<p><img src="/2022/10/25/MySQL-LSM%E6%A0%91%E4%BB%8B%E7%BB%8D1/25.png" alt="img"></p>
<p>将filling block追加到磁盘的新位置，上一层的节点也要以磁盘块（或多个磁盘块）大小写入，尽量避开随机写。另外由于合并过程可能会导致上层节点的更新，可以暂时保存在内存，后面在适当时机写入。</p>
<p><img src="/2022/10/25/MySQL-LSM%E6%A0%91%E4%BB%8B%E7%BB%8D1/26.png" alt="img"></p>
<h2 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h2><p>查找总体思想是先找内存的C0树，找不到则找磁盘的C1树，然后是C2树，以此类推。</p>
<p>假如要找“B”，先找C0树，没找到。</p>
<p><img src="/2022/10/25/MySQL-LSM%E6%A0%91%E4%BB%8B%E7%BB%8D1/27.png" alt="img"></p>
<p>接着找C1树，从根节点开始，</p>
<p><img src="/2022/10/25/MySQL-LSM%E6%A0%91%E4%BB%8B%E7%BB%8D1/28.png" alt="img"></p>
<p>找到“B”。</p>
<p><img src="/2022/10/25/MySQL-LSM%E6%A0%91%E4%BB%8B%E7%BB%8D1/29.png" alt="img"></p>
<h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>删除操作为了能快速执行，主要是通过标记来实现，在内存中将要删除的记录标记一下，后面异步执行合并时将相应记录删除。</p>
<p>比如要删除“U”，假设标为#的表示删除，则C0树的“U”节点变为，</p>
<p><img src="/2022/10/25/MySQL-LSM%E6%A0%91%E4%BB%8B%E7%BB%8D1/30.png" alt="img"></p>
<p>而如果C0树不存在的记录，则在C0树中生成一个节点，并标为#，查找时就能在内存中得知该记录已被删除，无需去磁盘找了。比如要删除“B”，那么没有必要去磁盘执行删除操作，直接在C0树中插入一个“B”节点，并标为#。</p>
<p><img src="/2022/10/25/MySQL-LSM%E6%A0%91%E4%BB%8B%E7%BB%8D1/31.png" alt="img"></p>
<p>假如对写操作的吞吐量比较敏感，可采用日志策略（顺序读写，只追加不修改）来提升写性能。存在问题：数据查找需要倒序扫描，花费很多时间。比如，预写日志WAL，WAL的中心概念是数据文件（存储着表和索引）的修改必须在这些动作被日志记录之后才被写入，即在描述这些改变的日志记录被刷到持久存储以后。如果我们遵循这种过程，我们不需要在每个事务提交时刷写数据页面到磁盘，因为我们知道在发生崩溃时可以使用日志来恢复数据库：任何还没有被应用到数据页面的改变可以根据其日志记录重做（这是前滚恢复，也被称为REDO）。使用WAL可以显著降低磁盘的写次数，因为只有日志文件需要被刷出到磁盘以保证事务被提交，而被事务改变的每一个数据文件则不必被刷出。</p>
<p>其只是提高了写的性能，对于更为复杂的读性能，需要寻找其他的方法，其中有<strong>四种方法来提升读性能</strong>：</p>
<ul>
<li>二分查找: 将文件数据有序保存，使用二分查找来完成特定key的查找。</li>
<li>哈希：用哈希将数据分割为不同的bucket</li>
<li>B+树：使用B+树 或者 ISAM 等方法，可以减少外部文件的读取</li>
<li>外部文件： 将数据保存为日志，并创建一个hash或者查找树映射相应的文件。</li>
</ul>
<p>所有的四种方法都可以有效的提高了读操作的性能（最少提供了O(log(n)) )，但是，却丢失了日志文件超好的写性能，上面这些方法，都强加了总体的结构信息在数据上，数据被按照特定的方式放置，所以可以很快的找到特定的数据，但是却对写操作不友善，让写操作性能下降。更糟糕的是，当需要更新hash或者B+树的结构时，需要同时更新文件系统中特定的部分，这就是造成了比较慢的随机读写操作，这种随机的操作要尽量减少。</p>
<p>既要保证日志文件好的写性能，又要在一定程度上保证读性能，所以LSM-Tree应运而生。</p>
<p>下面块为引用<a href="https://www.cnblogs.com/yanghuahui/p/3483754.html%EF%BC%8C%E8%BF%9B%E8%A1%8C%E5%AF%B9%E6%AF%94">https://www.cnblogs.com/yanghuahui/p/3483754.html，进行对比</a></p>
<blockquote>
<p>讲LSM树之前，需要提下<strong>三种基本的存储引擎</strong>，这样才能清楚LSM树的由来：</p>
<ol>
<li>哈希存储引擎  是哈希表的持久化实现，支持增、删、改以及随机读取操作，但不支持顺序扫描，对应的存储系统为key-value存储系统。对于key-value的插入以及查询，哈希表的复杂度都是O(1)，明显比树的操作O(n)快,如果不需要有序的遍历数据，哈希表就是your Mr.Right</li>
<li>B树存储引擎是B树<a href="http://www.cnblogs.com/yanghuahui/p/3483047.html">（关于B树的由来，数据结构以及应用场景可以看之前一篇博文）</a>的持久化实现，不仅支持单条记录的增、删、读、改操作，还支持顺序扫描（B+树的叶子节点之间的指针），对应的存储系统就是关系数据库（Mysql等）。</li>
<li>LSM树（Log-Structured Merge Tree）存储引擎和B树存储引擎一样，同样支持增、删、读、改、顺序扫描操作。而且通过批量存储技术规避磁盘随机写入问题。当然凡事有利有弊，LSM树和B+树相比，LSM树牺牲了部分读性能，用来大幅提高写性能。</li>
</ol>
</blockquote>
<p><strong>LSM树（Log Structured Merge Tree，结构化合并树）</strong>的思想非常朴素，就是将对数据的修改增量保持在内存中，达到指定的大小限制后将这些修改操作批量写入磁盘（由此提升了写性能），是一种基于硬盘的数据结构，与B-tree相比，能显著地减少硬盘磁盘臂的开销。当然凡事有利有弊，LSM树和B+树相比，LSM树牺牲了部分读性能，用来大幅提高写性能。</p>
<p>读取时需要合并磁盘中的历史数据和内存中最近的修改操作,读取时可能需要先看是否命中内存，否则需要访问较多的磁盘文件（存储在磁盘中的是许多小批量数据，由此降低了部分读性能。但是磁盘中会定期做merge操作，合并成一棵大树，以优化读性能）。LSM树的优势在于有效地规避了磁盘随机写入问题，但读取时可能需要访问较多的磁盘文件。</p>
<p>代表数据库：nessDB、leveldb、hbase等</p>
<p>核心思想的核心就是放弃部分读能力，换取写入的最大化能力，放弃磁盘读性能来换取写的顺序性。极端的说，基于LSM树实现的HBase的写性能比Mysql高了一个数量级，读性能低了一个数量级。</p>
<h2 id="LSM操作"><a href="#LSM操作" class="headerlink" title="LSM操作"></a>LSM操作</h2><p>LSM树 插入数据可以看作是一个N阶合并树。数据写操作（包括插入、修改、删除也是写）都在内存中进行，</p>
<p>数据首先会插入内存中的树。当内存树的数据量超过设定阈值后，会进行合并操作。合并操作会从左至右便利内存中树的子节点 与 磁盘中树的子节点并进行合并，会用最新更新的数据覆盖旧的数据（或者记录为不同版本）。当被合并合并数据量达到磁盘的存储页大小时。会将合并后的数据持久化到磁盘，同时更新父节点对子节点的指针。</p>
<p>LSM树 读数据 磁盘中书的非子节点数据也被缓存到内存中。在需要进行读操作时，总是从内存中的排序树开始搜索，如果没有找到，就从磁盘上的排序树顺序查找。</p>
<p>在LSM树上进行一次数据更新不需要磁盘访问，在内存即可完成，速度远快于B+树。当数据访问以写操作为主，而读操作则集中在最近写入的数据上时，使用LSM树可以极大程度地减少磁盘的访问次数，加快访问速度。</p>
<p>LSM树 删除数据 前面讲了。LSM树所有操作都是在内存中进行的，那么删除并不是物理删除。而是一个逻辑删除，会在被删除的数据上打上一个标签，当内存中的数据达到阈值的时候，会与内存中的其他数据一起顺序写入磁盘。 这种操作会占用一定空间，但是LSM-Tree 提供了一些机制回收这些空间。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>OLTP</tag>
        <tag>数据库</tag>
        <tag>分库分表</tag>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis源码分析系列文章导读</title>
    <url>/2022/10/25/MyBatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E5%AF%BC%E8%AF%BB/</url>
    <content><![CDATA[<h2 id="1-本文速览"><a href="#1-本文速览" class="headerlink" title="1.本文速览"></a>1.本文速览</h2><p>本篇文章是我为接下来的 MyBatis 源码分析系列文章写的一个导读文章。本篇文章从 MyBatis 是什么（what），为什么要使用（why），以及如何使用（how）等三个角度进行了说明和演示。由于文章的篇幅比较大，这里特地拿出一章用于介绍本文的结构和内容。那下面我们来看一下本文的章节安排：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15317164264107.jpg" alt="img"></p>
<p>如上图，本文的大部分篇幅主要集中在了第3章和第4章。第3章演示了几种持久层技术的用法，并在此基础上，分析了各种技术的使用场景。通过分析 MyBatis 的使用场景，说明了为什么要使用 MyBatis 这个问题。第4章主要用于介绍 MyBatis 的两种不同的用法。在 4.1 节，演示单独使用 MyBatis 的过程，演示示例涉及<code>一对一</code>和<code>一对多</code>的查询场景。4.2 节则是介绍了 MyBatis 和 Spring 整合的过程，并在最后演示了如何在 Spring 中使用 MyBatis。除了这两章内容，本文的第2章和第5章内容比较少，就不介绍了。</p>
<p>以上就是本篇文章内容的预览，如果这些内容大家都掌握，那么就不必往下看了。当然，如果没掌握或者是有兴趣，那不妨继续往下阅读。好了，其他的就不多说了，咱们进入正题吧。</p>
<h2 id="2-什么是-MyBatis"><a href="#2-什么是-MyBatis" class="headerlink" title="2.什么是 MyBatis"></a>2.什么是 MyBatis</h2><p>MyBatis 的前身是 iBatis，其是 Apache 软件基金会下的一个开源项目。2010年该项目从 Apache 基金会迁出，并改名为 MyBatis。同期，iBatis 停止维护。</p>
<p>MyBatis 是一种半自动化的 Java 持久层框架（persistence framework），其通过注解或 XML 的方式将对象和 SQL 关联起来。之所以说它是半自动的，是因为和 Hibernate 等一些可自动生成 SQL 的 ORM(Object Relational Mapping) 框架相比，使用 MyBatis 需要用户自行维护 SQL。维护 SQL 的工作比较繁琐，但也有好处。比如我们可控制 SQL 逻辑，可对其进行优化，以提高效率。</p>
<p>MyBatis 是一个容易上手的持久层框架，使用者通过简单的学习即可掌握其常用特性的用法。这也是 MyBatis 被广泛使用的一个原因。</p>
<h2 id="3-为什么要使用-MyBatis"><a href="#3-为什么要使用-MyBatis" class="headerlink" title="3.为什么要使用 MyBatis"></a>3.为什么要使用 MyBatis</h2><p>我们在使用 Java 程序访问数据库时，有多种选择。比如我们可通过编写最原始的 JDBC 代码访问数据库，或是通过 Spring 提供的 JdbcTemplate 访问数据库。除此之外，我们还可以选择 Hibernate，或者本篇的主角 MyBatis 等。在有多个可选项的情况下，我们为什么选择 MyBatis 呢？要回答这个问题，我们需要将 MyBatis 与这几种数据库访问方式对比一下，高下立判。当然，技术之间通常没有高下之分。从应用场景的角度来说，符合应用场景需求的技术才是合适的选择。那下面我会通过写代码的方式，来比较一下这几种数据库访问技术的优缺点，并会在最后说明 MyBatis 的适用场景。</p>
<p>这里，先把本章所用到的一些公共类和配置贴出来，后面但凡用到这些资源的地方，大家可以到这里进行查看。本章所用到的类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Article</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略 getter/setter 和 toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据库相关配置放在了 jdbc.properties 文件中，详细内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jdbc.driver=com.mysql.cj.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql:<span class="comment">//localhost:3306/coolblog?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;rewriteBatchedStatements=TRUE</span></span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=****</span><br></pre></td></tr></table></figure>

<p>表记录如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15316471764330.jpg" alt="img"></p>
<p>下面先来演示 MyBatis 访问数据库的过程。</p>
<h3 id="3-1-使用-MyBatis-访问数据库"><a href="#3-1-使用-MyBatis-访问数据库" class="headerlink" title="3.1 使用 MyBatis 访问数据库"></a>3.1 使用 MyBatis 访问数据库</h3><p>前面说过，MyBatis 是一种半自动化的 Java 持久化框架，使用 MyBatis 需要用户自行维护 SQL。这里，我们把 SQL 放在 XML 中，文件名称为 ArticleMapper.xml。相关配置如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;mapper namespace=<span class="string">&quot;xyz.coolblog.dao.ArticleDao&quot;</span>&gt;</span><br><span class="line">    &lt;resultMap id=<span class="string">&quot;articleResult&quot;</span> type=<span class="string">&quot;xyz.coolblog.model.Article&quot;</span>&gt;</span><br><span class="line">        &lt;id property=<span class="string">&quot;id&quot;</span> column=<span class="string">&quot;id&quot;</span>/&gt;</span><br><span class="line">        &lt;result property=<span class="string">&quot;title&quot;</span> column=<span class="string">&quot;title&quot;</span>/&gt;</span><br><span class="line">        &lt;result property=<span class="string">&quot;author&quot;</span> column=<span class="string">&quot;author&quot;</span>/&gt;</span><br><span class="line">        &lt;result property=<span class="string">&quot;content&quot;</span> column=<span class="string">&quot;content&quot;</span>/&gt;</span><br><span class="line">        &lt;result property=<span class="string">&quot;createTime&quot;</span> column=<span class="string">&quot;create_time&quot;</span>/&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;select id=<span class="string">&quot;findByAuthorAndCreateTime&quot;</span> resultMap=<span class="string">&quot;articleResult&quot;</span>&gt;</span><br><span class="line">        SELECT</span><br><span class="line">            `id`, `title`, `author`, `content`, `create_time`</span><br><span class="line">        FROM</span><br><span class="line">            `article`</span><br><span class="line">        WHERE</span><br><span class="line">            `author` = #&#123;author&#125; AND `create_time` &gt; #&#123;createTime&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>上面的 SQL 用于从<code>article</code>表中查询出某个作者从某个时候到现在所写的文章记录。在 MyBatis 中，SQL 映射文件需要与数据访问接口对应起来，比如上面的配置对应<code>xyz.coolblog.dao.ArticleDao</code>接口，这个接口的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ArticleDao</span> &#123;</span><br><span class="line">    List&lt;Article&gt; <span class="title function_">findByAuthorAndCreateTime</span><span class="params">(<span class="meta">@Param(&quot;author&quot;)</span> String author, <span class="meta">@Param(&quot;createTime&quot;)</span> String createTime)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要想让 MyBatis 跑起来，还需要进行一些配置。比如配置数据源、配置 SQL 映射文件的位置信息等。本节所使用到的配置如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;properties resource=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;environments <span class="keyword">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span><br><span class="line">        &lt;environment id=<span class="string">&quot;development&quot;</span>&gt;</span><br><span class="line">            &lt;transactionManager type=<span class="string">&quot;JDBC&quot;</span>/&gt;</span><br><span class="line">            &lt;dataSource type=<span class="string">&quot;POOLED&quot;</span>&gt;</span><br><span class="line">                &lt;property name=<span class="string">&quot;driver&quot;</span> value=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br><span class="line">                &lt;property name=<span class="string">&quot;url&quot;</span> value=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br><span class="line">                &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br><span class="line">                &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource=<span class="string">&quot;mapper/ArticleMapper.xml&quot;</span>/&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>到此，MyBatis 所需的环境就配置好了。接下来把 MyBatis 跑起来吧，相关测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">        sqlSessionFactory = <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMyBatis</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ArticleDao</span> <span class="variable">articleDao</span> <span class="operator">=</span> session.getMapper(ArticleDao.class);</span><br><span class="line">            List&lt;Article&gt; articles = articleDao.findByAuthorAndCreateTime(<span class="string">&quot;coolblog.xyz&quot;</span>, <span class="string">&quot;2018-06-10&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            session.commit();</span><br><span class="line">            session.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的测试代码中，prepare 方法用于创建<code>SqlSessionFactory</code>工厂，该工厂的用途是创建<code>SqlSession</code>。通过 SqlSession，可为我们的数据库访问接口<code>ArticleDao</code>接口生成一个代理对象。MyBatis 会将接口方法<code>findByAuthorAndCreateTime</code>和 SQL 映射文件中配置的 SQL 关联起来，这样调用该方法等同于执行相关的 SQL。</p>
<p>上面的测试代码运行结果如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15314639013381.jpg" alt="img"></p>
<p>如上，大家在学习 MyBatis 框架时，可以配置一下 MyBatis 的日志，这样可把 MyBatis 的调试信息打印出来，方便观察 SQL 的执行过程。在上面的结果中，<code>==&gt;</code>符号所在的行表示向数据库中输入的 SQL 及相关参数。<code>&lt;==</code>符号所在的行则是表示 SQL 的执行结果。上面输入输出不难看懂，这里就不多说了。</p>
<p>关于 MyBatis 的优缺点，这里先不进行总结。后面演示其他的框架时再进行比较说明。</p>
<p>演示完 MyBatis，下面，我们来看看通过原始的 JDBC 直接访问数据库过程是怎样的。</p>
<h3 id="3-2-使用-JDBC-访问数据库"><a href="#3-2-使用-JDBC-访问数据库" class="headerlink" title="3.2 使用 JDBC 访问数据库"></a>3.2 使用 JDBC 访问数据库</h3><h4 id="3-2-1-JDBC-访问数据库的过程演示"><a href="#3-2-1-JDBC-访问数据库的过程演示" class="headerlink" title="3.2.1 JDBC 访问数据库的过程演示"></a>3.2.1 JDBC 访问数据库的过程演示</h4><p>在初学 Java 编程阶段，多数朋友应该都是通过直接写 JDBC 代码访问数据库。我这么说，大家应该没异议吧。这种方式的代码流程一般是加载数据库驱动，创建数据库连接对象，创建 SQL 执行语句对象，执行 SQL 和处理结果集等，过程比较固定。下面我们再手写一遍 JDBC 代码，回忆一下初学 Java 的场景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJdbc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/myblog?user=root&amp;password=1234&amp;useUnicode=true&amp;characterEncoding=UTF8&amp;useSSL=false&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">            conn = DriverManager.getConnection(url);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">author</span> <span class="operator">=</span> <span class="string">&quot;coolblog.xyz&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> <span class="string">&quot;2018.06.10&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id, title, author, content, create_time FROM article WHERE author = &#x27;&quot;</span> + author + <span class="string">&quot;&#x27; AND create_time &gt; &#x27;&quot;</span> + date + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql);</span><br><span class="line">            List&lt;Article&gt; articles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(rs.getRow());</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="type">Article</span> <span class="variable">article</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Article</span>();</span><br><span class="line">                article.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">                article.setTitle(rs.getString(<span class="string">&quot;title&quot;</span>));</span><br><span class="line">                article.setAuthor(rs.getString(<span class="string">&quot;author&quot;</span>));</span><br><span class="line">                article.setContent(rs.getString(<span class="string">&quot;content&quot;</span>));</span><br><span class="line">                article.setCreateTime(rs.getDate(<span class="string">&quot;create_time&quot;</span>));</span><br><span class="line">                articles.add(article);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Query SQL ==&gt; &quot;</span> + sql);</span><br><span class="line">            System.out.println(<span class="string">&quot;Query Result: &quot;</span>);</span><br><span class="line">            articles.forEach(System.out::println);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码比较简单，就不多说了。下面来看一下测试结果：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15314658525604.jpg" alt="img"></p>
<p>上面代码的步骤比较多，但核心步骤只有两部，分别是执行 SQL 和处理查询结果。从开发人员的角度来说，我们也只关心这两个步骤。如果每次为了执行某个 SQL 都要写很多额外的代码。比如打开驱动，创建数据库连接，就显得很繁琐了。当然我们可以将这些额外的步骤封装起来，这样每次调用封装好的方法即可。这样确实可以解决代码繁琐，冗余的问题。不过，使用 JDBC 并非仅会导致代码繁琐，冗余的问题。在上面的代码中，我们通过字符串对 SQL 进行拼接。这样做会导致两个问题，第一是拼接 SQL 可能会导致 SQL 出错，比如少了个逗号或者多了个单引号等。第二是将 SQL 写在代码中，如果要改动 SQL，就需要到代码中进行更改。这样做是不合适的，因为改动 Java 代码就需要重新编译 Java 文件，然后再打包发布。同时，将 SQL 和 Java 代码混在一起，会降低代码的可读性，不利于维护。关于拼接 SQL，是有相应的处理方法。比如可以使用 PreparedStatement，同时还可解决 SQL 注入的问题。</p>
<p>除了上面所说的问题，直接使用 JDBC 访问数据库还会有什么问题呢？这次我们将目光转移到执行结果的处理逻辑上。从上面的代码中可以看出，我们需要手动从 ResultSet 中取出数据，然后再设置到 Article 对象中。好在我们的 Article 属性不多，所以这样做看起来也没什么。假如 Article 对象有几十个属性，再用上面的方式接收查询结果，会非常的麻烦。而且可能还会因为属性太多，导致忘记设置某些属性。以上的代码还有一个问题，用户需要自行处理受检异常，这也是导致代码繁琐的一个原因。哦，还有一个问题，差点忘了。用户还需要手动管理数据库连接，开始要手动获取数据库连接。使用好后，又要手动关闭数据库连接。不得不说，真麻烦。</p>
<p>没想到直接使用 JDBC 访问数据库会有这么多的问题。如果在生产环境直接使用 JDBC，怕是要被 Leader 打死了。当然，视情况而定。如果项目非常小，且对数据库依赖比较低。直接使用 JDBC 也很方便，不用像 MyBatis 那样搞一堆配置了。</p>
<h4 id="3-2-2-MyBatis-VS-JDBC"><a href="#3-2-2-MyBatis-VS-JDBC" class="headerlink" title="3.2.2 MyBatis VS JDBC"></a>3.2.2 MyBatis VS JDBC</h4><p>上面说了一大堆 JDBC 的坏话，有点过意不去，所以下面来吐槽一下 MyBatis 吧。与 JDBC 相比，MyBatis 缺点比较明显，它的配置比较多，特别是 SQL 映射文件。如果一个大型项目中有几十上百个 Dao 接口，就需要有同等数量的 SQL 映射文件，这些映射文件需要用户自行维护。不过与 JDBC 相比，维护映射文件不是什么问题。不然如果把同等数量的 SQL 像 JDBC 那样写在代码中，那维护的代价才叫大，搞不好还会翻车。除了配置文件的问题，大家会发现使用 MyBatis 访问数据库好像过程也很繁琐啊。它的步骤大致如下：</p>
<ol>
<li>读取配置文件</li>
<li>创建 SqlSessionFactoryBuilder 对象</li>
<li>通过 SqlSessionFactoryBuilder 对象创建 SqlSessionFactory</li>
<li>通过 SqlSessionFactory 创建 SqlSession</li>
<li>为 Dao 接口生成代理类</li>
<li>调用接口方法访问数据库</li>
</ol>
<p>如上，如果每次执行一个 SQL 要经过上面几步，那和 JDBC 比较起来，也没什优势了。不过这里大家需要注意，SqlSessionFactoryBuilder 和 SqlSessionFactory 以及 SqlSession 等对象的作用域和生命周期是不一样的，这一点在 MyBatis 官方文档中说的比较清楚，我这里照搬一下。SqlSessionFactoryBuilder 对象用于构建 SqlSessionFactory，只要构建好，这个对象就可以丢弃了。SqlSessionFactory 是一个工厂类，一旦被创建就应该在应用运行期间一直存在，不应该丢弃或重建。SqlSession 不是线程安全的，所以不应被多线程共享。官方推荐的使用方式是有按需创建，用完即销毁。因此，以上步骤中，第1、2和第3步只需执行一次。第4和第5步需要进行多次创建。至于第6步，这一步是必须的。所以比较下来，MyBatis 的使用方式还是比 JDBC 简单的。同时，使用 MyBatis 无需处理受检异常，比如 SQLException。另外，把 SQL 写在配置文件中，进行集中管理，利于维护。同时将 SQL 从代码中剥离，在提高代码的可读性的同时，也避免拼接 SQL 可能会导致的错误。除了上面所说这些，MyBatis 会将查询结果转为相应的对象，无需用户自行处理 ResultSet。</p>
<p>总的来说，MyBatis 在易用性上要比 JDBC 好太多。不过这里拿 MyBatis 和 JDBC 进行对比并不太合适。JDBC 作为 Java 平台的数据库访问规范，它仅提供一种访问数据库的能力。至于使用者觉得 JDBC 流程繁琐，还要自行处理异常等问题，这些还真不怪 JDBC。比如 SQLException 这个异常，JDBC 没法处理啊，抛给调用者处理也是理所应当的。至于繁杂的步骤，这仅是从使用者的角度考虑的，从 JDBC 的角度来说，这里的每个步骤对于完成一个数据访问请求来说都是必须的。至于 MyBatis，它是构建在 JDBC 技术之上的，对访问数据库的操作进行了简化，方便用户使用。综上所述，JDBC 可看做是一种基础服务，MyBatis 则是构建在基础服务之上的框架，它们的目标是不同的。</p>
<h3 id="3-3-使用-Spring-JDBC-访问数据库"><a href="#3-3-使用-Spring-JDBC-访问数据库" class="headerlink" title="3.3 使用 Spring JDBC 访问数据库"></a>3.3 使用 Spring JDBC 访问数据库</h3><p>上一节演示了 JDBC 访问数据的过程，通过演示及分析，大家应该感受到了直接使用 JDBC 的一些痛点。为了解决其中的一些痛点，Spring JDBC 应运而生。Spring JDBC 在 JDBC 基础上，进行了比较薄的包装，易用性得到了不少提升。那下面我们来看看如何使用 Spring JDBC。</p>
<p>我们在使用 Spring JDBC 之前，需要进行一些配置。这里我把配置信息放在了 application.xml 文件中，后面写测试代码时，让容器去加载这个配置。配置内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如上，<code>JdbcTemplate</code>封装了一些访问数据库的方法，下面我们会通过此对象访问数据库。演示代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:application.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringJdbcTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSpringJdbc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">author</span> <span class="operator">=</span> <span class="string">&quot;coolblog.xyz&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> <span class="string">&quot;2018.06.10&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id, title, author, content, create_time FROM article WHERE author = &#x27;&quot;</span> + author + <span class="string">&quot;&#x27; AND create_time &gt; &#x27;&quot;</span> + date + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">        List&lt;Article&gt; articles = jdbcTemplate.query(sql, (rs, rowNum) -&gt; &#123;</span><br><span class="line">                    <span class="type">Article</span> <span class="variable">article</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Article</span>();</span><br><span class="line">                    article.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">                    article.setTitle(rs.getString(<span class="string">&quot;title&quot;</span>));</span><br><span class="line">                    article.setAuthor(rs.getString(<span class="string">&quot;author&quot;</span>));</span><br><span class="line">                    article.setContent(rs.getString(<span class="string">&quot;content&quot;</span>));</span><br><span class="line">                    article.setCreateTime(rs.getDate(<span class="string">&quot;create_time&quot;</span>));</span><br><span class="line">                    <span class="keyword">return</span> article;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Query SQL ==&gt; &quot;</span> + sql);</span><br><span class="line">        System.out.println(<span class="string">&quot;Spring JDBC Query Result: &quot;</span>);</span><br><span class="line">        articles.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15314961338827.jpg" alt="img"></p>
<p>从上面的代码中可以看得出，Spring JDBC 还是比较容易使用的。不过它也是存在一定缺陷的，比如 SQL 仍是写在代码中。又比如，对于较为复杂的结果（数据库返回的记录包含多列数据），需要用户自行处理 ResultSet 等。不过与 JDBC 相比，使用 Spring JDBC 无需手动加载数据库驱动，获取数据库连接，以及创建 Statement 对象等操作。总的来说，易用性上得到了不少的提升。</p>
<p>这里就不对比 Spring JDBC 和 MyBatis 的优缺点了。Spring JDBC 仅对 JDBC 进行了一层比较薄的封装，相关对比可以参考上一节的部分分析，这里不再赘述。</p>
<h3 id="3-4-使用-Hibernate-访问数据库"><a href="#3-4-使用-Hibernate-访问数据库" class="headerlink" title="3.4 使用 Hibernate 访问数据库"></a>3.4 使用 Hibernate 访问数据库</h3><p>本节会像之前的章节一样，我会先写代码进行演示，然后再对比 Hibernate 和 MyBatis 的区别。需要特别说明的是，我在工作中没有用过 Hibernate，对 Hibernate 也仅停留在了解的程度上。本节的测试代码都是现学现卖的，可能有些地方写的会有问题，或者不是最佳实践。所以关于测试代码，大家看看就好。若有不妥之处，也欢迎指出。</p>
<h4 id="3-4-1-Hibernate-访问数据库的过程演示"><a href="#3-4-1-Hibernate-访问数据库的过程演示" class="headerlink" title="3.4.1 Hibernate 访问数据库的过程演示"></a>3.4.1 Hibernate 访问数据库的过程演示</h4><p>使用 Hibernate，需要先进行环境配置，主要是关于数据库方面的配置。这里为了演示，我们简单配置一下。如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.driver_class&quot;</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.url&quot;</span>&gt;</span>jdbc:mysql://localhost:3306/myblog?useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf8<span class="symbol">&amp;amp;</span>autoReconnect=true<span class="symbol">&amp;amp;</span>rewriteBatchedStatements=TRUE<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.username&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.password&quot;</span>&gt;</span>****<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.dialect&quot;</span>&gt;</span>org.hibernate.dialect.MySQL5Dialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.show_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">&quot;mapping/Article.hbm.xml&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面再配置一下实体类和表之间的映射关系，也就是上面配置中出现的<code>Article.hbm.xml</code>。不过这个配置不是必须的，可用注解进行替换。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">&quot;xyz.coolblog.model&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">table</span>=<span class="string">&quot;article&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Article&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;title&quot;</span> <span class="attr">column</span>=<span class="string">&quot;title&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;content&quot;</span> <span class="attr">column</span>=<span class="string">&quot;content&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;createTime&quot;</span> <span class="attr">column</span>=<span class="string">&quot;create_time&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HibernateTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SessionFactory buildSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">        configuration.configure(<span class="string">&quot;hibernate.cfg.xml&quot;</span>);</span><br><span class="line">        buildSessionFactory = configuration.buildSessionFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        buildSessionFactory.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testORM</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------✨ ORM Query ✨--------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            session = buildSessionFactory.openSession();</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">            <span class="type">Article</span> <span class="variable">article</span> <span class="operator">=</span> session.get(Article.class, id);</span><br><span class="line">            System.out.println(<span class="string">&quot;ORM Query Result: &quot;</span>);</span><br><span class="line">            System.out.println(article);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(session)) &#123;</span><br><span class="line">                session.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHQL</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------✨ HQL Query ✨+--------------------------&quot;</span>);</span><br><span class="line">        <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            session = buildSessionFactory.openSession();</span><br><span class="line">            <span class="type">String</span> <span class="variable">hql</span> <span class="operator">=</span> <span class="string">&quot;from Article where author = :author and create_time &gt; :createTime&quot;</span>;</span><br><span class="line">            <span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> session.createQuery(hql);</span><br><span class="line">            query.setParameter(<span class="string">&quot;author&quot;</span>, <span class="string">&quot;coolblog.xyz&quot;</span>);</span><br><span class="line">            query.setParameter(<span class="string">&quot;createTime&quot;</span>, <span class="string">&quot;2018.06.10&quot;</span>);</span><br><span class="line"></span><br><span class="line">            List&lt;Article&gt; articles = query.list();</span><br><span class="line">            System.out.println(<span class="string">&quot;HQL Query Result: &quot;</span>);</span><br><span class="line">            articles.forEach(System.out::println);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(session)) &#123;</span><br><span class="line">                session.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJpaCriteria</span><span class="params">()</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------------✨ JPA Criteria ✨------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            session = buildSessionFactory.openSession();</span><br><span class="line">            <span class="type">CriteriaBuilder</span> <span class="variable">criteriaBuilder</span> <span class="operator">=</span> session.getCriteriaBuilder();</span><br><span class="line">            CriteriaQuery&lt;Article&gt; criteriaQuery = criteriaBuilder.createQuery(Article.class);</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 定义 FROM 子句</span></span><br><span class="line">            Root&lt;Article&gt; article = criteriaQuery.from(Article.class);</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 构建查询条件</span></span><br><span class="line">            <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy.MM.dd&quot;</span>);</span><br><span class="line">            <span class="type">Predicate</span> <span class="variable">greaterThan</span> <span class="operator">=</span> criteriaBuilder.greaterThan(article.get(<span class="string">&quot;createTime&quot;</span>), sdf.parse(<span class="string">&quot;2018.06.10&quot;</span>));</span><br><span class="line">            <span class="type">Predicate</span> <span class="variable">equal</span> <span class="operator">=</span> criteriaBuilder.equal(article.get(<span class="string">&quot;author&quot;</span>), <span class="string">&quot;coolblog.xyz&quot;</span>);</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 通过具有语义化的方法构建 SQL，等价于 SELECT ... FROM article WHERE ... AND ...</span></span><br><span class="line">            criteriaQuery.select(article).where(equal, greaterThan);</span><br><span class="line">    </span><br><span class="line">            Query&lt;Article&gt; query = session.createQuery(criteriaQuery);</span><br><span class="line">            List&lt;Article&gt; articles = query.getResultList();</span><br><span class="line">    </span><br><span class="line">            System.out.println(<span class="string">&quot;JPA Criteria Query Result: &quot;</span>);</span><br><span class="line">            articles.forEach(System.out::println);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(session)) &#123;</span><br><span class="line">                session.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我写了三种不同的查询方法，对于比较简单的查询，可以通过<code>OID</code>的方式进行，也就是<code>testORM</code>方法中对应的代码。这种方式不需要写 SQL，完全由 Hibernate 去生成。生成的 SQL 如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">select </span><br><span class="line">    article0_.id as id1_0_0_, </span><br><span class="line">    article0_.title as title2_0_0_, </span><br><span class="line">    article0_.author as author3_0_0_, </span><br><span class="line">    article0_.content as content4_0_0_, </span><br><span class="line">    article0_.create_time as create_t5_0_0_ </span><br><span class="line">from </span><br><span class="line">    article article0_ </span><br><span class="line">where </span><br><span class="line">    article0_.id=?</span><br></pre></td></tr></table></figure>

<p>第二种方式是通过<code>HQL</code>进行查询，查询过程对应测试类中的<code>testHQL</code>方法。这种方式需要写一点 HQL，并为其设置相应的参数。最终生成的 SQL 如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">select </span><br><span class="line">    article0_.id as id1_0_, </span><br><span class="line">    article0_.title as title2_0_, </span><br><span class="line">    article0_.author as author3_0_, </span><br><span class="line">    article0_.content as content4_0_, </span><br><span class="line">    article0_.create_time as create_t5_0_ </span><br><span class="line">from </span><br><span class="line">    article article0_ </span><br><span class="line">where </span><br><span class="line">    article0_.author=? and create_time&gt;?</span><br></pre></td></tr></table></figure>

<p>第三种方式是通过 JPA Criteria 进行查询，JPA Criteria 具有类型安全、面向对象和语义化的特点。使用 JPA Criteria，我们可以用写 Java 代码的方式进行数据库操作，无需手写 SQL。第二种方式和第三种方式进行的是同样的查询，所以生成的 SQL 区别不大，这里就不贴出来了。</p>
<p>下面看一下测试代码的运行结果：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15317290011780.jpg" alt="img"></p>
<h4 id="3-4-2-MyBatis-VS-Hibernate"><a href="#3-4-2-MyBatis-VS-Hibernate" class="headerlink" title="3.4.2 MyBatis VS Hibernate"></a>3.4.2 MyBatis VS Hibernate</h4><p>在 Java 中，就持久层框架来说，MyBatis 和 Hibernate 都是很热门的框架。关于这两个框架孰好孰坏，在网上也有很广泛的讨论。不过就像我前面说到那样，技术之间通常没有高低之分，适不适合才是应该关注的点。这两个框架之间的区别是比较大的，下面我们来聊聊。</p>
<p>从映射关系上来说，Hibernate 是把实体类（POJO）和表进行了关联，是一种完整的 ORM (O&#x2F;R mapping) 框架。而 MyBatis 则是将数据访问接口（Dao）与 SQL 进行了关联，本质上算是一种 SQL 映射。从使用的角度来说，使用 Hibernate 通常不需要写 SQL，让框架自己生成就可以了。但 MyBatis 则不行，再简单的数据库访问操作都需要有与之对应的 SQL。另一方面，由于 Hibernate 可自动生成 SQL，所以进行数据库移植时，代价要小一点。而由于使用 MyBatis 需要手写 SQL，不同的数据库在 SQL 上存在着一定的差异。这就导致进行数据库移植时，可能需要更改 SQL 的情况。不过好在移植数据库的情况很少见，可以忽略。</p>
<p>上面我从两个维度对 Hibernate 和 MyBatis 进行了对比，但目前也只是说了他们的一些不同点。下面我们来分析一下这两个框架的适用场景。</p>
<p>Hibernate 可自动生成 SQL，降低使用成本。但同时也要意识到，这样做也是有代价的，会损失灵活性。比如，如果我们需要手动优化 SQL，我们很难改变 Hibernate 生成的 SQL。因此对于 Hibernate 来说，它适用于一些需求比较稳定，变化比较小的项目，譬如 OA、CRM 等。</p>
<p>与 Hibernate 相反，MyBatis 需要手动维护 SQL，这会增加使用成本。但同时，使用者可灵活控制 SQL 的行为，这为改动和优化 SQL 提供了可能。所以 MyBatis 适合应用在一些需要快速迭代，需求变化大的项目中，这也就是为什么 MyBatis 在互联网公司中使用的比较广泛的原因。除此之外，MyBatis 还提供了插件机制，使用者可以按需定制插件。这也是 MyBatis 灵活性的一个体现。</p>
<p>分析到这里，大家应该清楚了两个框架之前的区别，以及适用场景。楼主目前在一家汽车相关的互联网公司，公司发展的比较快，项目迭代的也比较快，各种小需求也比较多。所以，相比之下，MyBatis 是一个比较合适的选择。</p>
<h3 id="3-5-本章小结"><a href="#3-5-本章小结" class="headerlink" title="3.5 本章小结"></a>3.5 本章小结</h3><p>本节用了大量的篇幅介绍常见持久层框架的用法，并进行了较为详细的分析和对比。看完这些，相信大家对这些框架应该也有了更多的了解。好了，其他的就不多说了，我们继续往下看吧。</p>
<h2 id="4-如何使用-MyBatis"><a href="#4-如何使用-MyBatis" class="headerlink" title="4.如何使用 MyBatis"></a>4.如何使用 MyBatis</h2><p>本章，我们一起来看一下 MyBatis 是如何使用的。在上一章，我简单演示了一下 MyBatis 的使用方法。不过，那个太简单了，本章我们来演示一个略为复杂的例子。不过，这个例子复杂度和真实的项目还是有差距，仅做演示使用。</p>
<p>本章包含两节内容，第一节演示单独使用 MyBatis 的过程，第二节演示 MyBatis 是如何和 Spring 进行整合的。那其他的就不多说了，下面开始演示。</p>
<h3 id="4-1-单独使用"><a href="#4-1-单独使用" class="headerlink" title="4.1 单独使用"></a>4.1 单独使用</h3><p>本节演示的场景是个人网站的作者和文章之间的关联场景。在一个网站中，一篇文章对应一名作者，一个作者对应多篇文章。下面我们来看一下<code>作者</code>和<code>文章</code>的定义，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorDO</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> SexEnum sex;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ArticleDO&gt; articles;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 getter/setter 和 toString</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArticleDO</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> ArticleTypeEnum type;</span><br><span class="line">    <span class="keyword">private</span> AuthorDO author;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 getter/setter 和 toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，AuthorDO 中包含了对一组 ArticleDO 的引用，这是一对多的关系。ArticleDO 中则包含了一个对 AuthorDO 的引用，这是一对一的关系。除此之外，这里使用了两个常量，一个用于表示性别，另一个用于表示文章类型，它们的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SexEnum</span> &#123;</span><br><span class="line">    MAN,</span><br><span class="line">    FEMALE,</span><br><span class="line">    UNKNOWN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ArticleTypeEnum</span> &#123;</span><br><span class="line">    JAVA(<span class="number">1</span>),</span><br><span class="line">    DUBBO(<span class="number">2</span>),</span><br><span class="line">    SPRING(<span class="number">4</span>),</span><br><span class="line">    MYBATIS(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line"></span><br><span class="line">    ArticleTypeEnum(<span class="type">int</span> code) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">code</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArticleTypeEnum <span class="title function_">find</span><span class="params">(<span class="type">int</span> code)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ArticleTypeEnum at : ArticleTypeEnum.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (at.code == code) &#123;</span><br><span class="line">                <span class="keyword">return</span> at;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本篇文章使用了两张表，分别用于存储文章和作者信息。这两种表的内容如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15317440267930.jpg" alt="img"></p>
<p>下面来看一下数据库访问层的接口定义，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ArticleDao</span> &#123;</span><br><span class="line">    ArticleDO <span class="title function_">findOne</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthorDao</span> &#123;</span><br><span class="line">    AuthorDO <span class="title function_">findOne</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与这两个接口对应的 SQL 被配置在了下面的两个映射文件中。我们先来看一下第一个映射文件 AuthorMapper.xml 的内容。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- AuthorMapper.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;xyz.coolblog.dao.AuthorDao&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;articleResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Article&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;article_id&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;title&quot;</span> <span class="attr">column</span>=<span class="string">&quot;title&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;type&quot;</span> <span class="attr">column</span>=<span class="string">&quot;type&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;content&quot;</span> <span class="attr">column</span>=<span class="string">&quot;content&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;createTime&quot;</span> <span class="attr">column</span>=<span class="string">&quot;create_time&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;authorResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Author&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">typeHandler</span>=<span class="string">&quot;org.apache.ibatis.type.EnumOrdinalTypeHandler&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;articles&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Article&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;articleResult&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findOne&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;authorResult&quot;</span>&gt;</span></span><br><span class="line">        SELECT</span><br><span class="line">            au.id, au.name, au.age, au.sex, au.email,</span><br><span class="line">            ar.id as article_id, ar.title, ar.type, ar.content, ar.create_time</span><br><span class="line">        FROM</span><br><span class="line">            author au, article ar</span><br><span class="line">        WHERE</span><br><span class="line">            au.id = ar.author_id AND au.id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意看上面的<code>&lt;resultMap/&gt;</code>配置，这个标签中包含了一个一对多的配置<code>&lt;collection/&gt;</code>，这个配置引用了一个 id 为<code>articleResult</code>的。除了要注意一对多的配置，这里还要下面这行配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">typeHandler</span>=<span class="string">&quot;org.apache.ibatis.type.EnumOrdinalTypeHandler&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>前面说过 AuthorDO 的<code>sex</code>属性是一个枚举，但这个属性在数据表中是以整型值进行存储的。所以向数据表写入或者查询数据时，要进行类型转换。写入时，需要将<code>SexEnum</code>转成<code>int</code>。查询时，则需要把<code>int</code>转成<code>SexEnum</code>。由于这两个是完全不同的类型，不能通过强转进行转换，所以需要使用一个中间类进行转换，这个中间类就是 <code>EnumOrdinalTypeHandler</code>。这个类会按照枚举顺序进行转换，比如在<code>SexEnum</code>中，<code>MAN</code>的顺序是<code>0</code>。存储时，EnumOrdinalTypeHandler 会将<code>MAN</code>替换为<code>0</code>。查询时，又会将<code>0</code>转换为<code>MAN</code>。除了<code>EnumOrdinalTypeHandler</code>，MyBatis 还提供了另一个枚举类型处理器<code>EnumTypeHandler</code>。这个则是按照枚举的字面值进行转换，比如该处理器将枚举<code>MAN</code>和字符串 “MAN” 进行相互转换。</p>
<p>上面简单分析了一下枚举类型处理器，接下来，继续往下看。下面是 ArticleMapper.xml 的配置内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- ArticleMapper.xml --&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;xyz.coolblog.dao.ArticleDao&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;resultMap id=<span class="string">&quot;authorResult&quot;</span> type=<span class="string">&quot;Author&quot;</span>&gt;</span><br><span class="line">        &lt;id property=<span class="string">&quot;id&quot;</span> column=<span class="string">&quot;author_id&quot;</span>/&gt;</span><br><span class="line">        &lt;result property=<span class="string">&quot;name&quot;</span> column=<span class="string">&quot;name&quot;</span>/&gt;</span><br><span class="line">        &lt;result property=<span class="string">&quot;age&quot;</span> column=<span class="string">&quot;age&quot;</span>/&gt;</span><br><span class="line">        &lt;result property=<span class="string">&quot;sex&quot;</span> column=<span class="string">&quot;sex&quot;</span> typeHandler=<span class="string">&quot;org.apache.ibatis.type.EnumOrdinalTypeHandler&quot;</span>/&gt;</span><br><span class="line">        &lt;result property=<span class="string">&quot;email&quot;</span> column=<span class="string">&quot;email&quot;</span>/&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    &lt;resultMap id=<span class="string">&quot;articleResult&quot;</span> type=<span class="string">&quot;Article&quot;</span>&gt;</span><br><span class="line">        &lt;id property=<span class="string">&quot;id&quot;</span> column=<span class="string">&quot;id&quot;</span> /&gt;</span><br><span class="line">        &lt;result property=<span class="string">&quot;title&quot;</span> column=<span class="string">&quot;title&quot;</span>/&gt;</span><br><span class="line">        &lt;result property=<span class="string">&quot;type&quot;</span> column=<span class="string">&quot;type&quot;</span> typeHandler=<span class="string">&quot;xyz.coolblog.mybatis.ArticleTypeHandler&quot;</span>/&gt;</span><br><span class="line">        &lt;result property=<span class="string">&quot;content&quot;</span> column=<span class="string">&quot;content&quot;</span>/&gt;</span><br><span class="line">        &lt;result property=<span class="string">&quot;createTime&quot;</span> column=<span class="string">&quot;create_time&quot;</span>/&gt;</span><br><span class="line">        &lt;association property=<span class="string">&quot;author&quot;</span> javaType=<span class="string">&quot;Author&quot;</span> resultMap=<span class="string">&quot;authorResult&quot;</span>/&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=<span class="string">&quot;findOne&quot;</span> resultMap=<span class="string">&quot;articleResult&quot;</span>&gt;</span><br><span class="line">        SELECT</span><br><span class="line">            ar.id, ar.author_id, ar.title, ar.type, ar.content, ar.create_time,</span><br><span class="line">            au.name, au.age, au.sex, au.email</span><br><span class="line">        FROM</span><br><span class="line">            article ar, author au</span><br><span class="line">        WHERE</span><br><span class="line">            ar.author_id = au.id AND ar.id = #&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>如上，ArticleMapper.xml 中包含了一个一对一的配置<code>&lt;association/&gt;</code>，这个配置引用了另一个 id 为<code>authorResult</code>的。除了一对一的配置外，这里还有一个自定义类型处理器<code>ArticleTypeHandler</code>需要大家注意。这个自定义类型处理器用于处理<code>ArticleTypeEnum</code>枚举类型。大家如果注意看前面贴的<code>ArticleTypeEnum</code>的源码，会发现每个枚举值有自己的编号定义。比如<code>JAVA</code>的编号为<code>1</code>，<code>DUBBO</code>的编号为<code>2</code>，<code>SPRING</code>的编号为<code>8</code>。所以这里我们不能再使用<code>EnumOrdinalTypeHandler</code>对<code>ArticleTypeHandler</code>进行类型转换，需要自定义一个类型转换器。那下面我们来看一下这个类型转换器的定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArticleTypeHandler</span> <span class="keyword">extends</span> <span class="title class_">BaseTypeHandler</span>&lt;ArticleTypeEnum&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="type">int</span> i, ArticleTypeEnum parameter, JdbcType jdbcType)</span></span><br><span class="line">        <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">// 获取枚举的 code 值，并设置到 PreparedStatement 中</span></span><br><span class="line">        ps.setInt(i, parameter.code());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ArticleTypeEnum <span class="title function_">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">// 从 ResultSet 中获取 code</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> rs.getInt(columnName);</span><br><span class="line">        <span class="comment">// 解析 code 对应的枚举，并返回</span></span><br><span class="line">        <span class="keyword">return</span> ArticleTypeEnum.find(code);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ArticleTypeEnum <span class="title function_">getNullableResult</span><span class="params">(ResultSet rs, <span class="type">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> rs.getInt(columnIndex);</span><br><span class="line">        <span class="keyword">return</span> ArticleTypeEnum.find(code);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ArticleTypeEnum <span class="title function_">getNullableResult</span><span class="params">(CallableStatement cs, <span class="type">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> cs.getInt(columnIndex);</span><br><span class="line">        <span class="keyword">return</span> ArticleTypeEnum.find(code);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于自定义类型处理器，可继承 BaseTypeHandler，并实现相关的抽象方法。上面的代码比较简单，我也进行了一些注释。应该比较好理解，这里就不多说了。</p>
<p>前面贴了实体类，数据访问类，以及 SQL 映射文件。最后还差一个 MyBatis 的配置文件，这里贴出来。如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-congif.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Article&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xyz.coolblog.model.ArticleDO&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xyz.coolblog.model.AuthorDO&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">&quot;xyz.coolblog.mybatis.ArticleTypeHandler&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;xyz.coolblog.constant.ArticleTypeEnum&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper/AuthorMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper/ArticleMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面通过一个表格简单解释配置中出现的一些标签。</p>
<table>
<thead>
<tr>
<th>标签名称</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>properties</td>
<td>用于配置全局属性，这样在配置文件中，可以通过占位符 ${} 进行属性值配置</td>
</tr>
<tr>
<td>typeAliases</td>
<td>用于定义别名。如上所示，这里把<code>xyz.coolblog.model.ArticleDO</code>的别名定义为<code>Article</code>，这样在 SQL 映射文件中，就可以直接使用别名，而不用每次都输入长长的全限定类名了</td>
</tr>
<tr>
<td>typeHandlers</td>
<td>用于定义全局的类型处理器，如果这里配置了，SQL 映射文件中就不需要再次进行配置。前面为了讲解需要，我在 SQL 映射文件中也配置了 ArticleTypeHandler，其实是多余的</td>
</tr>
<tr>
<td>environments</td>
<td>用于配置事务，以及数据源</td>
</tr>
<tr>
<td>mappers</td>
<td>用于配置 SQL 映射文件的位置信息</td>
</tr>
</tbody></table>
<p>以上仅介绍了一些比较常用的配置，更多的配置信息，建议大家去阅读<a href="http://www.mybatis.org/mybatis-3/zh/index.html">MyBatis 官方文档</a>。</p>
<p>到这里，我们把所有的准备工作都做完了。那么接下来，写点测试代码测试一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyBatisTest &#123;</span><br><span class="line"></span><br><span class="line">    private SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    public void prepare() throws IOException &#123;</span><br><span class="line">        String resource = &quot;mybatis-config.xml&quot;;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Test</span><br><span class="line">    public void testOne2One() &#123;</span><br><span class="line">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">        try &#123;</span><br><span class="line">            ArticleDao articleDao = session.getMapper(ArticleDao.class);</span><br><span class="line">            ArticleDO article = articleDao.findOne(1);</span><br><span class="line"></span><br><span class="line">            AuthorDO author = article.getAuthor();</span><br><span class="line">            article.setAuthor(null);</span><br><span class="line"></span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(&quot;author info:&quot;);</span><br><span class="line">            System.out.println(author);</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(&quot;articles info:&quot;);</span><br><span class="line">            System.out.println(article);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            session.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testOne2Many() &#123;</span><br><span class="line">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">        try &#123;</span><br><span class="line">            AuthorDao authorDao = session.getMapper(AuthorDao.class);</span><br><span class="line">            AuthorDO author = authorDao.findOne(1);</span><br><span class="line"></span><br><span class="line">            List&lt;ArticleDO&gt; arts = author.getArticles();</span><br><span class="line">            List&lt;ArticleDO&gt; articles = Arrays.asList(arts.toArray(new ArticleDO[arts.size()]));</span><br><span class="line">            arts.clear();</span><br><span class="line"></span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(&quot;author info:&quot;);</span><br><span class="line">            System.out.println(author);</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(&quot;articles info:&quot;);</span><br><span class="line">            articles.forEach(System.out::println);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            session.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个测试方法用于从数据库中查询某篇文章，以及相应作者的信息。它的运行结果如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15316547300303.jpg" alt="img"></p>
<p>第二个测试方法用于查询某位作者，及其所写的所有文章的信息。它的运行结果如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15316547483611.jpg" alt="img"></p>
<p>到此，MyBatis 的使用方法就介绍完了。由于我个人在平时的工作中，也知识使用了 MyBatis 的一些比较常用的特性，所以本节的内容也比较浅显。另外，由于演示示例比较简单，这里也没有演示 MyBatis 比较重要的一个特性 – <code>动态 SQL</code>。除了以上所述，有些特性由于没有比较好的场景去演示，这里也就不介绍了。比如 MyBatis 的插件机制，缓存等。对于一些较为生僻的特性，比如对象工厂，鉴别器。如果不是因为阅读了 MyBatis 的文档和一些书籍，我还真不知道它们的存在，孤陋寡闻了。所以，对于这部分特性，本文也不会进行说明。</p>
<p>综上所述，本节所演示的是一个比较简单的示例，并非完整示例，望周知。</p>
<h3 id="4-2-在-Spring-中使用"><a href="#4-2-在-Spring-中使用" class="headerlink" title="4.2 在 Spring 中使用"></a>4.2 在 Spring 中使用</h3><p>在上一节，我演示了单独使用 MyBatis 的过程。在实际开发中，我们一般都会将 MyBatis 和 Spring 整合在一起使用。这样，我们就可以通过 bean 注入的方式使用各种 Dao 接口。MyBatis 和 Spring 原本是两个完全不相关的框架，要想把两者整合起来，需要一个中间框架。这个框架一方面负责加载和解析 MyBatis 相关配置。另一方面，该框架还会通过 Spring 提供的拓展点，把各种 Dao 接口及其对应的对象放入 bean 工厂中。这样，我们才可以通过 bean 注入的方式获取到这些 Dao 接口对应的 bean。那么问题来了，具有如此能力的框架是谁呢？答案是<code>mybatis-spring</code>。那其他的不多说了，下面开始演示整合过程。</p>
<p>我的测试项目是基于 Maven 构建的，所以这里先来看一下 pom 文件的配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;project&gt;</span><br><span class="line">    &lt;!-- 省略项目坐标配置 --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;spring.version&gt;4.3.17.RELEASE&lt;/spring.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.4.6&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 省略其他依赖 --&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<p>为了减少配置文件所占的文章篇幅，上面的配置经过了一定的简化，这里只列出了 MyBatis 和 Spring 相关包的坐标。继续往下看，下面将 MyBatis 中的一些类配置到 Spring 的配置文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- application-mybatis.xml --&gt;</span><br><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;context:property-placeholder location=&quot;jdbc.properties&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置数据源 --&gt;</span><br><span class="line">    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.ibatis.datasource.pooled.PooledDataSource&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置 SqlSessionFactory --&gt;</span><br><span class="line">    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">        &lt;!-- 配置 mybatis-config.xml 路径 --&gt;</span><br><span class="line">        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;</span><br><span class="line">        &lt;!-- 给 SqlSessionFactory 配置数据源，这里引用上面的数据源配置 --&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">        &lt;!-- 配置 SQL 映射文件 --&gt;</span><br><span class="line">        &lt;property name=&quot;mapperLocations&quot; value=&quot;mapper/*.xml&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置 MapperScannerConfigurer --&gt;</span><br><span class="line">    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">        &lt;!-- 配置 Dao 接口所在的包 --&gt;</span><br><span class="line">        &lt;property name=&quot;basePackage&quot; value=&quot;xyz.coolblog.dao&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>如上，上面就是将 MyBatis 整合到 Spring 中所需的一些配置。这里，我们将数据源配置到 Spring 配置文件中。配置完数据源，接下来配置 SqlSessionFactory，SqlSessionFactory 的用途大家都知道，不用过多解释了。再接下来是配置 MapperScannerConfigurer，这个类顾名思义，用于扫描某个包下的数据访问接口，并将这些接口注册到 Spring 容器中。这样，我们就可以在其他的 bean 中注入 Dao 接口的实现类，无需再从 SqlSession 中获取接口实现类。至于 MapperScannerConfigurer 扫描和注册 Dao 接口的细节，这里先不说明，后续我会专门写一篇文章分析。</p>
<p>将 MyBatis 配置到 Spring 中后，为了让我们的程序正常运行，这里还需要为 MyBatis 提供一份配置。相关配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- mybatis-config.xml --&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;settings&gt;</span><br><span class="line">        &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;/settings&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;typeAliases&gt;</span><br><span class="line">        &lt;typeAlias alias=&quot;Article&quot; type=&quot;xyz.coolblog.model.ArticleDO&quot;/&gt;</span><br><span class="line">        &lt;typeAlias alias=&quot;Author&quot; type=&quot;xyz.coolblog.model.AuthorDO&quot;/&gt;</span><br><span class="line">    &lt;/typeAliases&gt;</span><br><span class="line"></span><br><span class="line">    &lt;typeHandlers&gt;</span><br><span class="line">        &lt;typeHandler handler=&quot;xyz.coolblog.mybatis.ArticleTypeHandler&quot; javaType=&quot;xyz.coolblog.constant.ArticleTypeEnum&quot;/&gt;</span><br><span class="line">    &lt;/typeHandlers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>这里的 mybatis-config.xml 和上一节的配置不太一样，移除了数据源和 SQL 映射文件路径的配置。需要注意的是，对于 <code>&lt;settings/&gt;</code> 必须配置在 mybatis-config.xml 中。其他的配置都不是必须项，可放在 Spring 的配置文件中，这里偷了个懒。</p>
<p>到此，Spring 整合 MyBatis 的配置工作就完成了，接下来写点测试代码跑跑看。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(&quot;classpath:application-mybatis.xml&quot;)</span><br><span class="line">public class SpringWithMyBatisTest implements ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">    private ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    /** 自动注入 AuthorDao，无需再通过 SqlSession 获取 */ </span><br><span class="line">    @Autowired</span><br><span class="line">    private AuthorDao authorDao;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ArticleDao articleDao;</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    public void printBeanInfo() &#123;</span><br><span class="line">        ListableBeanFactory lbf = applicationContext;</span><br><span class="line">        String[] beanNames = lbf.getBeanDefinitionNames();</span><br><span class="line">        Arrays.sort(beanNames);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(&quot;----------------☆ bean name ☆---------------&quot;);</span><br><span class="line">        Arrays.asList(beanNames).subList(0, 5).forEach(System.out::println);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        AuthorDao authorDao = (AuthorDao) applicationContext.getBean(&quot;authorDao&quot;);</span><br><span class="line">        ArticleDao articleDao = (ArticleDao) applicationContext.getBean(&quot;articleDao&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-------------☆ bean class info ☆--------------&quot;);</span><br><span class="line">        System.out.println(&quot;AuthorDao  Class: &quot; + authorDao.getClass());</span><br><span class="line">        System.out.println(&quot;ArticleDao Class: &quot; + articleDao.getClass());</span><br><span class="line">        System.out.println(&quot;\n--------xxxx---------xxxx---------xxx---------\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testOne2One() &#123;</span><br><span class="line">        ArticleDO article = articleDao.findOne(1);</span><br><span class="line"></span><br><span class="line">        AuthorDO author = article.getAuthor();</span><br><span class="line">        article.setAuthor(null);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(&quot;author info:&quot;);</span><br><span class="line">        System.out.println(author);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(&quot;articles info:&quot;);</span><br><span class="line">        System.out.println(article);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testOne2Many() &#123;</span><br><span class="line">        AuthorDO author = authorDao.findOne(1);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(&quot;author info:&quot;);</span><br><span class="line">        System.out.println(author);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(&quot;articles info:&quot;);</span><br><span class="line">        author.getArticles().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        this.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码，为了证明我们的整合配置生效了，上面专门写了一个方法，用于输出<code>ApplicationContext</code>中<code>bean</code>的信息。下面来看一下<code>testOne2One</code>测试方法的输出结果。</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15317070859295.jpg" alt="img"></p>
<p>如上所示，bean name 的前两行就是我们的 Dao 接口的名称，它们的实现类则是 JDK 的动态代理生成的。然后<code>testOne2One</code>方法也正常运行了，由此可知，我们的整合配置生效了。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>到此，本篇文章就接近尾声了。本篇文章对 MyBatis 是什么，为何要使用，以及如何使用等三个方面进行阐述和演示。总的来说，本文的篇幅应该说清楚了这三个问题。本篇文章的篇幅比较大，读起来应该比较辛苦。不过好在内容不难，理解起来应该没什么问题。本篇文章的篇幅超出了我之前的预期，文章太大，出错的概率也会随之上升。所以如果文章有错误的地方，希望大家能够指明。</p>
<p>好了，本篇文章就到这里了，感谢大家的阅读。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.mybatis.org/mybatis-3/zh/index.html">MyBatis 官方文档</a></li>
<li><a href="https://book.douban.com/subject/27074809/">《MyBatis从入门到精通》- 刘增辉</a></li>
<li><a href="https://www.zhihu.com/question/21104468">MyBatis和Hibernate相比，优势在哪里？- 知乎</a></li>
<li>mybatis 与 hibernate 的区别和应用场景 - 无法确定文章作者，就不贴链接了，请自行搜索</li>
</ul>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-leftjoin在on后添加条件</title>
    <url>/2022/10/25/MySQL-leftjoin%E5%9C%A8on%E5%90%8E%E6%B7%BB%E5%8A%A0%E6%9D%A1%E4%BB%B6/</url>
    <content><![CDATA[<p>前天写 SQL 时本想通过 A left B join on and 后面的条件来使查出的两条记录变成一条，奈何发现还是有两条。</p>
<p>后来发现 join on and 不会过滤结果记录条数，只会根据 and 后的条件是否显示 B 表的记录，A 表的记录一定会显示。</p>
<p>不管 and 后面的是 A.id&#x3D;1 还是 B.id&#x3D;1, 都显示出 A 表中所有的记录，并关联显示 B 中对应 A 表中 id 为 1 的记录或者 B 表中 id 为 1 的记录。</p>
<p>运行 sql :</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student s <span class="keyword">left</span> <span class="keyword">join</span> class c <span class="keyword">on</span> s.classId<span class="operator">=</span>c.id <span class="keyword">order</span> <span class="keyword">by</span> s.id</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/25/MySQL-leftjoin%E5%9C%A8on%E5%90%8E%E6%B7%BB%E5%8A%A0%E6%9D%A1%E4%BB%B6/62.png" alt="图片"></p>
<p>运行 sql :</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student s <span class="keyword">left</span> <span class="keyword">join</span> class c <span class="keyword">on</span> s.classId<span class="operator">=</span>c.id <span class="keyword">and</span> s.name<span class="operator">=</span>&quot;张三&quot; <span class="keyword">order</span> <span class="keyword">by</span> s.id</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/25/MySQL-leftjoin%E5%9C%A8on%E5%90%8E%E6%B7%BB%E5%8A%A0%E6%9D%A1%E4%BB%B6/63.png" alt="图片"></p>
<p>运行 sql :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from student s left join class c on s.classId=c.id and c.name=&quot;三年级三班&quot; order by s.id</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/25/MySQL-leftjoin%E5%9C%A8on%E5%90%8E%E6%B7%BB%E5%8A%A0%E6%9D%A1%E4%BB%B6/64.png" alt="图片"></p>
<p>数据库在通过连接两张或多张表来返回记录时，都会生成一张中间的临时表，然后再将这张临时表返回给用户。</p>
<p>在使用 left join 时，<strong>on</strong> 和 <strong>where</strong> 条件的区别如下：</p>
<ol>
<li>on 条件是在生成临时表时使用的条件，它不管 on 中的条件是否为真，都会返回左边表中的记录。</li>
<li>where 条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有 left join 的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。</li>
</ol>
<p>假设有两张表：</p>
<p>表 1：tab1</p>
<p><img src="/2022/10/25/MySQL-leftjoin%E5%9C%A8on%E5%90%8E%E6%B7%BB%E5%8A%A0%E6%9D%A1%E4%BB%B6/65.png" alt="图片"></p>
<p>表 2：tab2</p>
<p><img src="/2022/10/25/MySQL-leftjoin%E5%9C%A8on%E5%90%8E%E6%B7%BB%E5%8A%A0%E6%9D%A1%E4%BB%B6/66.png" alt="图片"></p>
<p>两条 SQL:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * form tab1 left join tab2 on (tab1.size = tab2.size) where tab2.name=’AAA’</span><br><span class="line">select * form tab1 left join tab2 on (tab1.size = tab2.size and tab2.name=’AAA’)</span><br></pre></td></tr></table></figure>

<p>第一条 SQL 的过程：</p>
<p>1、中间表 on 条件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tab1.size = tab2.size</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/25/MySQL-leftjoin%E5%9C%A8on%E5%90%8E%E6%B7%BB%E5%8A%A0%E6%9D%A1%E4%BB%B6/67.png" alt="图片"></p>
<p>2、再对中间表过滤 where 条件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tab2.name=’AAA’</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/25/MySQL-leftjoin%E5%9C%A8on%E5%90%8E%E6%B7%BB%E5%8A%A0%E6%9D%A1%E4%BB%B6/68.png" alt="图片"></p>
<p>第二条 SQL 的过程：</p>
<p>1、中间表 on 条件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tab1.size = tab2.size and tab2.name=’AAA’</span><br></pre></td></tr></table></figure>

<p>(条件不为真也会返回左表中的记录)</p>
<p><img src="/2022/10/25/MySQL-leftjoin%E5%9C%A8on%E5%90%8E%E6%B7%BB%E5%8A%A0%E6%9D%A1%E4%BB%B6/69.png" alt="图片"></p>
<p>其实以上结果的关键原因就是 left join,right join,full join 的特殊性，不管 on 上的条件是否为真都会返回 left 或 right 表中的记录，full 则具有 left 和 right 的特性的并集。而 inner jion 没这个特殊性，则条件放在 on 中和 where 中，返回的结果集是相同的。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>OLTP</tag>
        <tag>数据库</tag>
        <tag>分库分表</tag>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-LSM树介绍2</title>
    <url>/2022/10/25/MySQL-LSM%E6%A0%91%E4%BB%8B%E7%BB%8D2/</url>
    <content><![CDATA[<h1 id="存储系统中的算法：LSM-树设计原理"><a href="#存储系统中的算法：LSM-树设计原理" class="headerlink" title="存储系统中的算法：LSM 树设计原理"></a>存储系统中的算法：LSM 树设计原理</h1><p>我在上篇文章 <a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247498023&idx=1&sn=b3ca224a1e1e2bd0fdb733547a6dd6d5&scene=21#wechat_redirect">Apache Pulsar 的架构设计</a> 中介绍了 Pulsar 存算分离的架构，其中 broker 只负责计算，由 BookKeeper 负责底层的存储，我还画了这样一张图说明 BookKeeper 读写分离的设计：</p>
<p><img src="/2022/10/25/MySQL-LSM%E6%A0%91%E4%BB%8B%E7%BB%8D2/1.png" alt="图片"></p>
<p>但是再深究下去，<code>memtable</code>具体是以怎样的格式持久化到磁盘上的呢？又是用什么算法高效查找一条消息的呢？</p>
<p>通过学习相关资料，我发现 Apache BookKeeper 底层存储引擎用的是 Facebook 开源的 RocksDB，而 RocksDB 又是基于 Google 开源的 LevelDB 改造的，而 LevelDB 的核心是一个叫做 LSM 树（Log Structured Merge Tree）的结构。</p>
<p>LevelDB 整个库的代码只有几百 KB，所以我去研究了 LSM 树的代码实现，总结了这篇文章，带你了解 LSM 树的设计原理。</p>
<p>什么是 LSM 树呢？如果说到 B+ 树大家应该不陌生，像 MySQL 这样的关系型数据库底层一般用 B+ 树结构来存储数据。LSM 树其实就是另一种存储数据的结构，常见于日志存储系统中。</p>
<p>首先，我们先来聊聊存储系统。</p>
<h3 id="内存数据结构-vs-磁盘数据结构"><a href="#内存数据结构-vs-磁盘数据结构" class="headerlink" title="内存数据结构 vs 磁盘数据结构"></a>内存数据结构 vs 磁盘数据结构</h3><p>正如前文 <a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484852&idx=1&sn=85b50b8b0470bb4897e517955f4e5002&scene=21#wechat_redirect">学习数据结构和算法的框架思维</a> 所说，一切数据结构从根本上讲都是增删查改，但在具体实现上，磁盘数据结构和内存数据结构会有比较大的差异。</p>
<p>内存数据结构你直接 new 一个出来就行了，不用关心这个结构在内存中是如何布局的，这些都由操作系统和编程语言代劳了。</p>
<p>但磁盘就不一样，考虑到磁盘读取的操作效率相对比较低，且每次只能读取固定大小的磁盘数据，你要自己设计数据的存储布局，规定每个字节存什么信息，然后基于你设计的存储布局实现增删查改的 API，比较枯燥琐碎。</p>
<p>比如说，学过 MySQL 的话应该比较熟悉 B+ 树结构，但你肯定不容易看懂 B+ 树的代码。因为 B+ 树是磁盘数据结构，虽然原理上可以理解为 BST 的加强版，但考虑到数据文件格式的设计，真正的代码实现非常复杂。</p>
<p>所以一般来说，我们了解磁盘数据结构的原理，了解各个操作的时间复杂度就可以了，没必要特别纠结它的具体实现。</p>
<h3 id="数据可变-vs-数据不可变"><a href="#数据可变-vs-数据不可变" class="headerlink" title="数据可变 vs 数据不可变"></a>数据可变 vs 数据不可变</h3><p><strong>存储结构可以粗略分为两类：数据可变的和数据不可变的</strong>。所谓可变，就是说已经插入的数据还可以原地进行修改，不可变就是说已经插入的数据就不能再修改了。</p>
<p><strong>B 树是数据可变的代表结构</strong>（B+ 树等衍生结构都归为 B 树一族）。你就想想 BST 吧，数据存在节点上，我们可以随意插入、删除、修改 BST 中的节点。</p>
<p>B 树的理论增删查改性能和 BST 一样都是 logN，但 B 树的实际写入效率并不是特别高：</p>
<p>一方面是因为 B 树需要分裂合并等操作保证整棵树的平衡性，这里面涉及很多磁盘随机读写的操作，性能会比较差；另一方面考虑到并发场景，修改 B 树结构时需要比较复杂的锁机制保证并发安全，也会一定程度影响效率。</p>
<p><strong>综上，B 树的难点在于平衡性维护和并发控制，一般用在读多写少的场景</strong>。</p>
<p><strong>LSM 树是数据不可变的代表结构</strong>。你只能在尾部追加新数据，不能修改之前已经插入的数据。</p>
<p>如果不能修改以前的数据，是不是就不能提供删、查、改的操作 API 呢？其实是可以的。</p>
<p>我们只需要提供<code>set(key, val)</code>和<code>get(key)</code>两个 API 即可。查询操作靠<code>get(key)</code>，增删改操作都可以由<code>set(key, val)</code>实现：</p>
<p>如果<code>set</code>的<code>key</code>不存在就是新增键值对，如果已经存在，就是更新键值对；如果把<code>val</code>设置为一个特殊值（比如 null）就可以代表<code>key</code>被删掉了（墓碑机制）。</p>
<p>那么我对某个键<code>key</code>做了一系列操作后，我只要找到最近一次的操作，就能知道这个键当前的值是多少了。</p>
<p>从磁盘的角度来说，在尾部追加的写入效率非常高，因为不需要像 B 树那样维护复杂的树形结构嘛。但代价就是，查找效率肯定比较低，因为只能通过线性遍历去查找操作记录。</p>
<p>后面我会讲讲真正的 LSM 树如何针对读场景进行优化，但再怎么优化，肯定也达不到 B 树的读取效率。</p>
<p>同时，LSM 树还有一个明显弊端就是存在空间放大。在 B 树中一个键值对就占用一个节点，我更新这个键 100 次，它还是只占用一个节点。但在 LSM 树中，如果我更新一个键 100 次，就相当于写入了 100 条数据，会消耗更多空间。</p>
<p>后面会讲到，这个问题的解决方案是压实（compact），把操作序列中失效的历史操作消除掉，只保留最近的操作记录。</p>
<p><strong>综上，LSM 树的难点在于 compact 操作和读取数据时的效率优化，一般用在写多读少的场景</strong>。</p>
<h3 id="有序-vs-无序"><a href="#有序-vs-无序" class="headerlink" title="有序 vs 无序"></a>有序 vs 无序</h3><p>可以说，存储结构的有序程度直接决定了该类结构的读写性能上限。<strong>有序度越高，读性能越强，但相应的，维护有序性的成本也越高，写入性能也就会越差</strong>。</p>
<p>你看 B 树，作为 BST 的加强版，实际上是维护了所有数据的有序性，读取性能必然起飞，但写入性能你也别抱太大希望。</p>
<p>LSM 树不可能向 B 树那样维护所有数据的有序性，但可以维护局部数据的有序性，从而一定程度提升读性能。</p>
<h3 id="LSM-树的设计"><a href="#LSM-树的设计" class="headerlink" title="LSM 树的设计"></a>LSM 树的设计</h3><p>就我的理解，LSM 树其实不是一种数据结构，而是一种存储方案。这里面涉及三个重要的数据组件：<code>memtable</code>，<code>log</code>，<code>SSTable</code>，正如我在 <a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247498023&idx=1&sn=b3ca224a1e1e2bd0fdb733547a6dd6d5&scene=21#wechat_redirect">Apache Pulsar 的架构设计</a> 中画的这幅图：</p>
<p><img src="/2022/10/25/MySQL-LSM%E6%A0%91%E4%BB%8B%E7%BB%8D2/2.png" alt="图片"></p>
<p>其中<code>Journal</code>就是<code>log</code>，<code>Entry Log</code>就是若干<code>SSTable</code>的集合，叫法不同罢了。</p>
<p><code>memtable</code>是红黑树或者跳表这样的有序内存数据结构，起到缓存和排序的作用，把新写入的数据按照键的大小进行排序。当<code>memtable</code>到达一定大小之后，会被转化成<code>SSTable</code>格式刷入磁盘持久化存储。</p>
<p><code>SSTable</code>（Sorted String Table）说白了就是一个特殊格式的文件，其中的数据按照键的大小排列，你可以把它类比成一个有序数组。而 LSM 树，说白了就是若干<code>SSTable</code>的集合。</p>
<p><code>log</code>文件记录操作日志，在数据写入<code>memtable</code>的同时也会刷盘写入到<code>log</code>文件，作用是数据恢复。比如在<code>memtable</code>中的数据还没转化成<code>SSTable</code>持久化到磁盘时，如果突然断电，那么<code>memtable</code>里面的数据都会丢失，但有<code>log</code>文件在，就可以恢复这些数据。当然，等<code>memtable</code>中的数据成功转化成<code>SSTable</code>落盘之后，<code>log</code>文件中对应的操作日志就没必要存在了，可以被删除。</p>
<p>LSM 树的<code>set</code>写入过程并不复杂：写入<code>log</code>和<code>memtable</code>，最后转化成一个<code>SSTable</code>持久化到磁盘就行了。</p>
<p>最关键的应该是读取和 compact 的过程：<code>SSTable</code>要如何组织，才能快速<code>get</code>到一个<code>key</code>对应的<code>val</code>呢？如何定期对所有 SSTable 做 compact 瘦身呢？</p>
<p>其实有多种方案，其中比较常用的方案是按照层级组织<code>SSTable</code>：</p>
<p><img src="/2022/10/25/MySQL-LSM%E6%A0%91%E4%BB%8B%E7%BB%8D2/3.png" alt="图片"><a href="https://github.com/facebook/rocksdb/wiki/Leveled-Compaction">https://github.com/facebook/rocksdb/wiki/Leveled-Compaction</a></p>
<p>图中每个绿色方块代表一个<code>SSTable</code>，若干个<code>SSTable</code>构成一层，总共有若干层，每层能够容纳的<code>SSTable</code>数量上限依次递增。</p>
<p>新刷入的<code>SSTable</code>在第 0 层，如果某一层的<code>SSTable</code>个数超过上限，则会触发 compact 操作，从该层选出若干<code>SSTable</code>合并成一个更大的<code>SSTable</code>，移动下一层：</p>
<p><img src="/2022/10/25/MySQL-LSM%E6%A0%91%E4%BB%8B%E7%BB%8D2/4.png" alt="图片"><a href="https://github.com/facebook/rocksdb/wiki/Leveled-Compaction">https://github.com/facebook/rocksdb/wiki/Leveled-Compaction</a></p>
<p>每个<code>SSTable</code>就好比一个有序数组&#x2F;链表，多个<code>SSTable</code>的合并就是前文 <a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247492022&idx=1&sn=35f6cb8ab60794f8f52338fab3e5cda5&scene=21#wechat_redirect">链表双指针技巧汇总</a> 中合并多个有序链表的逻辑。</p>
<p>这样，越靠上层的数据越新，越靠下层的数据越旧，且算法保证同一层的若干<code>SSTable</code>的<code>key</code>不存在重叠：</p>
<p><img src="/2022/10/25/MySQL-LSM%E6%A0%91%E4%BB%8B%E7%BB%8D2/5.png" alt="图片"><a href="https://github.com/facebook/rocksdb/wiki/Leveled-Compaction">https://github.com/facebook/rocksdb/wiki/Leveled-Compaction</a></p>
<p>那么假设给一个目标键<code>key27</code>，我们只需要从上到下遍历层，并在每一层中使用 <a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485044&idx=1&sn=e6b95782141c17abe206bfe2323a4226&scene=21#wechat_redirect">二分查找算法</a> 找到键区间包含<code>key27</code>的<code>SSTable</code>，然后用布隆过滤器快速判断一下<code>key27</code>是否不存在这个<code>SSTable</code>中。如果可能存在，由于<code>SSTable</code>中的键也是有序的，可以再次运用 <a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485044&idx=1&sn=e6b95782141c17abe206bfe2323a4226&scene=21#wechat_redirect">二分查找算法</a> 在<code>SSTable</code>中找到键对应的值。</p>
<p>这样，借助 LSM 树的层级结构和<code>SSTable</code>的有序性，就能利用二分搜索提升查找效率，避免线性查找键值对。</p>
<p>以上就是本文的全部内容，LSM 树的设计思路比较易于理解，但实现起来还有不少细节，如果你对具体实现感兴趣，我可以推荐一些学习资料：</p>
<p>LevelDB 的代码仓库：</p>
<p><a href="https://github.com/google/leveldb/issues">https://github.com/google/leveldb/issues</a></p>
<p>RocksDB 的 wiki：</p>
<p><a href="https://github.com/facebook/rocksdb/wiki">https://github.com/facebook/rocksdb/wiki</a></p>
<p>《数据库系统内幕》和《精通 LevelDB》这两本书也不错：</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>OLTP</tag>
        <tag>数据库</tag>
        <tag>分库分表</tag>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-log</title>
    <url>/2022/10/25/MySQL-log/</url>
    <content><![CDATA[<p><code>MySQL</code> 日志 主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。其中，比较重要的还要属二进制日志 <code>binlog</code>（归档日志）和事务日志 <code>redo log</code>（重做日志）和 <code>undo log</code>（回滚日志）。</p>
<p><img src="/2022/10/25/MySQL-log/39.png" alt="图片"></p>
<p>今天就来聊聊 <code>redo log</code>（重做日志）、<code>binlog</code>（归档日志）、两阶段提交、<code>undo log</code> （回滚日志）。</p>
<h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p><code>redo log</code>（重做日志）是<code>InnoDB</code>存储引擎独有的，它让<code>MySQL</code>拥有了崩溃恢复能力。</p>
<p>比如 <code>MySQL</code> 实例挂了或宕机了，重启时，<code>InnoDB</code>存储引擎会使用<code>redo log</code>恢复数据，保证数据的持久性与完整性。</p>
<p><img src="/2022/10/25/MySQL-log/40.png" alt="图片"></p>
<p><code>MySQL</code> 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 <code>Buffer Pool</code> 中。</p>
<p>后续的查询都是先从 <code>Buffer Pool</code> 中找，没有命中再去硬盘加载，减少硬盘 <code>IO</code> 开销，提升性能。</p>
<p>更新表数据的时候，也是如此，发现 <code>Buffer Pool</code> 里存在要更新的数据，就直接在 <code>Buffer Pool</code> 里更新。</p>
<p>然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（<code>redo log buffer</code>）里，接着刷盘到 <code>redo log</code> 文件里。</p>
<p><img src="/2022/10/25/MySQL-log/41.png" alt="图片"></p>
<p>理想情况，事务一提交就会进行刷盘操作，但实际上，刷盘的时机是根据策略来进行的。</p>
<blockquote>
<p>小贴士：每条 redo 记录由“表空间号+数据页号+偏移量+修改数据长度+具体修改的数据”组成</p>
</blockquote>
<h3 id="刷盘时机"><a href="#刷盘时机" class="headerlink" title="刷盘时机"></a>刷盘时机</h3><p><code>InnoDB</code> 存储引擎为 <code>redo log</code> 的刷盘策略提供了 <code>innodb_flush_log_at_trx_commit</code> 参数，它支持三种策略：</p>
<ul>
<li><strong>0</strong> ：设置为 0 的时候，表示每次事务提交时不进行刷盘操作</li>
<li><strong>1</strong> ：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）</li>
<li><strong>2</strong> ：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache</li>
</ul>
<p><code>innodb_flush_log_at_trx_commit</code> 参数默认为 1 ，也就是说当事务提交时会调用 <code>fsync</code> 对 redo log 进行刷盘</p>
<p>另外，<code>InnoDB</code> 存储引擎有一个后台线程，每隔<code>1</code> 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存（<code>page cache</code>），然后调用 <code>fsync</code> 刷盘。</p>
<p><img src="/2022/10/25/MySQL-log/42.png" alt="图片"></p>
<p>也就是说，一个没有提交事务的 <code>redo log</code> 记录，也可能会刷盘。</p>
<p><strong>为什么呢？</strong></p>
<p>因为在事务执行过程 <code>redo log</code> 记录是会写入<code>redo log buffer</code> 中，这些 <code>redo log</code> 记录会被后台线程刷盘。</p>
<p><img src="/2022/10/25/MySQL-log/43.png" alt="图片"></p>
<p>除了后台线程每秒<code>1</code>次的轮询操作，还有一种情况，当 <code>redo log buffer</code>占用的空间即将达到 <code>innodb_log_buffer_size</code> 一半的时候，后台线程会主动刷盘。</p>
<p>下面是不同刷盘策略的流程图。</p>
<h4 id="innodb-flush-log-at-trx-commit-x3D-0"><a href="#innodb-flush-log-at-trx-commit-x3D-0" class="headerlink" title="innodb_flush_log_at_trx_commit&#x3D;0"></a>innodb_flush_log_at_trx_commit&#x3D;0</h4><p><img src="/2022/10/25/MySQL-log/44.png" alt="图片"></p>
<p>为<code>0</code>时，如果<code>MySQL</code>挂了或宕机可能会有<code>1</code>秒数据的丢失。</p>
<h4 id="innodb-flush-log-at-trx-commit-x3D-1"><a href="#innodb-flush-log-at-trx-commit-x3D-1" class="headerlink" title="innodb_flush_log_at_trx_commit&#x3D;1"></a>innodb_flush_log_at_trx_commit&#x3D;1</h4><p><img src="/2022/10/25/MySQL-log/45.png" alt="图片"></p>
<p>为<code>1</code>时， 只要事务提交成功，<code>redo log</code>记录就一定在硬盘里，不会有任何数据丢失。</p>
<p>如果事务执行期间<code>MySQL</code>挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。</p>
<h4 id="innodb-flush-log-at-trx-commit-x3D-2"><a href="#innodb-flush-log-at-trx-commit-x3D-2" class="headerlink" title="innodb_flush_log_at_trx_commit&#x3D;2"></a>innodb_flush_log_at_trx_commit&#x3D;2</h4><p><img src="/2022/10/25/MySQL-log/46.png" alt="图片"></p>
<p>为<code>2</code>时， 只要事务提交成功，<code>redo log buffer</code>中的内容只写入文件系统缓存（<code>page cache</code>）。</p>
<p>如果仅仅只是<code>MySQL</code>挂了不会有任何数据丢失，但是宕机可能会有<code>1</code>秒数据的丢失。</p>
<h3 id="日志文件组"><a href="#日志文件组" class="headerlink" title="日志文件组"></a>日志文件组</h3><p>硬盘上存储的 <code>redo log</code> 日志文件不只一个，而是以一个<strong>日志文件组</strong>的形式出现的，每个的<code>redo</code>日志文件大小都是一样的。</p>
<p>比如可以配置为一组<code>4</code>个文件，每个文件的大小是 <code>1GB</code>，整个 <code>redo log</code>日志文件组可以记录<code>4G</code>的内容。</p>
<p>它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写，如下图所示。</p>
<p><img src="/2022/10/25/MySQL-log/47.png" alt="图片"></p>
<p>在个<strong>日志文件组</strong>中还有两个重要的属性，分别是 <code>write pos、checkpoint</code></p>
<ul>
<li><strong>write pos</strong> 是当前记录的位置，一边写一边后移</li>
<li><strong>checkpoint</strong> 是当前要擦除的位置，也是往后推移</li>
</ul>
<p>每次刷盘 <code>redo log</code> 记录到<strong>日志文件组</strong>中，<code>write pos</code> 位置就会后移更新。</p>
<p>每次 <code>MySQL</code> 加载<strong>日志文件组</strong>恢复数据时，会清空加载过的 <code>redo log</code> 记录，并把 <code>checkpoint</code> 后移更新。</p>
<p><code>write pos</code> 和 <code>checkpoint</code> 之间的还空着的部分可以用来写入新的 <code>redo log</code> 记录。</p>
<p><img src="/2022/10/25/MySQL-log/48.png" alt="图片"></p>
<p>如果 <code>write pos</code> 追上 <code>checkpoint</code> ，表示<strong>日志文件组</strong>满了，这时候不能再写入新的 <code>redo log</code> 记录，<code>MySQL</code> 得停下来，清空一些记录，把 <code>checkpoint</code> 推进一下。</p>
<p><img src="/2022/10/25/MySQL-log/49.png" alt="图片"></p>
<h3 id="redo-log-小结"><a href="#redo-log-小结" class="headerlink" title="redo log 小结"></a>redo log 小结</h3><p>相信大家都知道 <code>redo log</code> 的作用和它的刷盘时机、存储形式。</p>
<p>现在我们来思考一个问题：<strong>只要每次把修改后的数据页直接刷盘不就好了，还有 <code>redo log</code> 什么事？</strong></p>
<p>它们不都是刷盘么？差别在哪里？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 Byte = 8bit</span><br><span class="line">1 KB = 1024 Byte</span><br><span class="line">1 MB = 1024 KB</span><br><span class="line">1 GB = 1024 MB</span><br><span class="line">1 TB = 1024 GB</span><br></pre></td></tr></table></figure>

<p>实际上，数据页大小是<code>16KB</code>，刷盘比较耗时，可能就修改了数据页里的几 <code>Byte</code> 数据，有必要把完整的数据页刷盘吗？</p>
<p>而且数据页刷盘是随机写，因为一个数据页对应的位置可能在硬盘文件的随机位置，所以性能是很差。</p>
<p>如果是写 <code>redo log</code>，一行记录可能就占几十 <code>Byte</code>，只包含表空间号、数据页号、磁盘文件偏移 量、更新值，再加上是顺序写，所以刷盘速度很快。</p>
<p>所以用 <code>redo log</code> 形式记录修改内容，性能会远远超过刷数据页的方式，这也让数据库的并发能力更强。</p>
<blockquote>
<p>其实内存的数据页在一定时机也会刷盘，我们把这称为页合并，讲 <code>Buffer Pool</code>的时候会对这块细说</p>
</blockquote>
<h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p><code>redo log</code> 它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 <code>InnoDB</code> 存储引擎。</p>
<p>而 <code>binlog</code> 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于<code>MySQL Server</code> 层。</p>
<p>不管用什么存储引擎，只要发生了表数据更新，都会产生 <code>binlog</code> 日志。</p>
<p>那 <code>binlog</code> 到底是用来干嘛的？</p>
<p>可以说<code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性。</p>
<p><img src="/2022/10/25/MySQL-log/50.png" alt="图片"></p>
<p><code>binlog</code>会记录所有涉及更新数据的逻辑操作，并且是顺序写。</p>
<h3 id="记录格式"><a href="#记录格式" class="headerlink" title="记录格式"></a>记录格式</h3><p><code>binlog</code> 日志有三种格式，可以通过<code>binlog_format</code>参数指定。</p>
<ul>
<li><strong>statement</strong></li>
<li><strong>row</strong></li>
<li><strong>mixed</strong></li>
</ul>
<p>指定<code>statement</code>，记录的内容是<code>SQL</code>语句原文，比如执行一条<code>update T set update_time=now() where id=1</code>，记录的内容如下。</p>
<p><img src="/2022/10/25/MySQL-log/51.png" alt="图片"></p>
<p>同步数据时，会执行记录的<code>SQL</code>语句，但是有个问题，<code>update_time=now()</code>这里会获取当前系统时间，直接执行会导致与原库的数据不一致。</p>
<p>为了解决这种问题，我们需要指定为<code>row</code>，记录的内容不再是简单的<code>SQL</code>语句了，还包含操作的具体数据，记录内容如下。</p>
<p><img src="/2022/10/25/MySQL-log/52.png" alt="图片"></p>
<p><code>row</code>格式记录的内容看不到详细信息，要通过<code>mysqlbinlog</code>工具解析出来。</p>
<p><code>update_time=now()</code>变成了具体的时间<code>update_time=1627112756247</code>，条件后面的@1、@2、@3 都是该行数据第 1 个~3 个字段的原始值（<strong>假设这张表只有 3 个字段</strong>）。</p>
<p>这样就能保证同步数据的一致性，通常情况下都是指定为<code>row</code>，这样可以为数据库的恢复与同步带来更好的可靠性。</p>
<p>但是这种格式，需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗<code>IO</code>资源，影响执行速度。</p>
<p>所以就有了一种折中的方案，指定为<code>mixed</code>，记录的内容是前两者的混合。</p>
<p><code>MySQL</code>会判断这条<code>SQL</code>语句是否可能引起数据不一致，如果是，就用<code>row</code>格式，否则就用<code>statement</code>格式。</p>
<h3 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h3><p><code>binlog</code>的写入时机也非常简单，事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把<code>binlog cache</code>写到<code>binlog</code>文件中。</p>
<p>因为一个事务的<code>binlog</code>不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code>。</p>
<p>我们可以通过<code>binlog_cache_size</code>参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（<code>Swap</code>）。</p>
<p><code>binlog</code>日志刷盘流程如下</p>
<p><img src="/2022/10/25/MySQL-log/53.png" alt="图片"></p>
<ul>
<li><strong>上图的 write，是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快</strong></li>
<li><strong>上图的 fsync，才是将数据持久化到磁盘的操作</strong></li>
</ul>
<p><code>write</code>和<code>fsync</code>的时机，可以由参数<code>sync_binlog</code>控制，默认是<code>0</code>。</p>
<p>为<code>0</code>的时候，表示每次提交事务都只<code>write</code>，由系统自行判断什么时候执行<code>fsync</code>。</p>
<p><img src="/2022/10/25/MySQL-log/54.png" alt="图片"></p>
<p>虽然性能得到提升，但是机器宕机，<code>page cache</code>里面的 binglog 会丢失。</p>
<p>为了安全起见，可以设置为<code>1</code>，表示每次提交事务都会执行<code>fsync</code>，就如同<strong>binlog 日志刷盘流程</strong>一样。</p>
<p>最后还有一种折中方式，可以设置为<code>N(N&gt;1)</code>，表示每次提交事务都<code>write</code>，但累积<code>N</code>个事务后才<code>fsync</code>。</p>
<p><img src="/2022/10/25/MySQL-log/55.png" alt="图片"></p>
<p>在出现<code>IO</code>瓶颈的场景里，将<code>sync_binlog</code>设置成一个比较大的值，可以提升性能。</p>
<p>同样的，如果机器宕机，会丢失最近<code>N</code>个事务的<code>binlog</code>日志。</p>
<h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><p><code>redo log</code>（重做日志）让<code>InnoDB</code>存储引擎拥有了崩溃恢复能力。</p>
<p><code>binlog</code>（归档日志）保证了<code>MySQL</code>集群架构的数据一致性。</p>
<p>虽然它们都属于持久化的保证，但是则重点不同。</p>
<p>在执行更新语句过程，会记录<code>redo log</code>与<code>binlog</code>两块日志，以基本的事务为单位，<code>redo log</code>在事务执行过程中可以不断写入，而<code>binlog</code>只有在提交事务时才写入，所以<code>redo log</code>与<code>binlog</code>的写入时机不一样。</p>
<p><img src="/2022/10/25/MySQL-log/56.png" alt="图片"></p>
<p>回到正题，<code>redo log</code>与<code>binlog</code>两份日志之间的逻辑不一致，会出现什么问题？</p>
<p>我们以<code>update</code>语句为例，假设<code>id=2</code>的记录，字段<code>c</code>值是<code>0</code>，把字段<code>c</code>值更新成<code>1</code>，<code>SQL</code>语句为<code>update T set c=1 where id=2</code>。</p>
<p>假设执行过程中写完<code>redo log</code>日志后，<code>binlog</code>日志写期间发生了异常，会出现什么情况呢？</p>
<p><img src="/2022/10/25/MySQL-log/57.png" alt="图片"></p>
<p>由于<code>binlog</code>没写完就异常，这时候<code>binlog</code>里面没有对应的修改记录。因此，之后用<code>binlog</code>日志恢复数据时，就会少这一次更新，恢复出来的这一行<code>c</code>值是<code>0</code>，而原库因为<code>redo log</code>日志恢复，这一行<code>c</code>值是<code>1</code>，最终数据不一致。</p>
<p><img src="/2022/10/25/MySQL-log/58.png" alt="图片"></p>
<p>为了解决两份日志之间的逻辑一致问题，<code>InnoDB</code>存储引擎使用<strong>两阶段提交</strong>方案。</p>
<p>原理很简单，将<code>redo log</code>的写入拆成了两个步骤<code>prepare</code>和<code>commit</code>，这就是<strong>两阶段提交</strong>。</p>
<p><img src="/2022/10/25/MySQL-log/59.png" alt="图片"></p>
<p>使用<strong>两阶段提交</strong>后，写入<code>binlog</code>时发生异常也不会有影响，因为<code>MySQL</code>根据<code>redo log</code>日志恢复数据时，发现<code>redo log</code>还处于<code>prepare</code>阶段，并且没有对应<code>binlog</code>日志，就会回滚该事务。</p>
<p><img src="/2022/10/25/MySQL-log/60.png" alt="图片"></p>
<p>再看一个场景，<code>redo log</code>设置<code>commit</code>阶段发生异常，那会不会回滚事务呢？</p>
<p><img src="/2022/10/25/MySQL-log/61.png" alt="图片"></p>
<p>并不会回滚事务，它会执行上图框住的逻辑，虽然<code>redo log</code>是处于<code>prepare</code>阶段，但是能通过事务<code>id</code>找到对应的<code>binlog</code>日志，所以<code>MySQL</code>认为是完整的，就会提交事务恢复数据。</p>
<h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><blockquote>
<p>这部分内容为 JavaGuide 的补充：</p>
</blockquote>
<p>我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，在 MySQL 中，恢复机制是通过 <strong>回滚日志（undo log）</strong> 实现的，所有事务进行的修改都会先先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</p>
<p>另外，<code>MVCC</code> 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，<code>InnoDB</code> 通过数据行的 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>这部分内容为 JavaGuide 的补充：</p>
</blockquote>
<p>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</p>
<p><code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>OLTP</tag>
        <tag>数据库</tag>
        <tag>分库分表</tag>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-书籍-MySQL是怎样运行的</title>
    <url>/2022/10/25/MySQL-%E4%B9%A6%E7%B1%8D-MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/</url>
    <content><![CDATA[<p>MySQL-书籍-MySQL是怎样运行的</p>
<div class="pdf-container" data-target="./MySQL是怎样运行的.pdf" data-height="1000px"></div>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>OLTP</tag>
        <tag>数据库</tag>
        <tag>分库分表</tag>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-分库分表range-hash方案</title>
    <url>/2022/10/25/MySQL-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8range-hash%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>中大型项目中，一旦遇到数据量比较大，小伙伴应该都知道就应该对数据进行拆分了。有垂直和水平两种。</p>
<p>垂直拆分比较简单，也就是本来一个数据库，数据量大之后，从业务角度进行拆分多个库。如下图，独立的拆分出订单库和用户库。</p>
<p><img src="/2022/10/25/MySQL-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8range-hash%E6%96%B9%E6%A1%88/1.png" alt="图片"></p>
<p>水平拆分的概念，是同一个业务数据量大之后，进行水平拆分。</p>
<p><img src="/2022/10/25/MySQL-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8range-hash%E6%96%B9%E6%A1%88/2.png" alt="图片"></p>
<p>上图中订单数据达到了4000万，我们也知道mysql单表存储量推荐是百万级，如果不进行处理，mysql单表数据太大，会导致性能变慢。使用方案可以参考数据进行水平拆分。把4000万数据拆分4张表或者更多。当然也可以分库，再分表；把压力从数据库层级分开。</p>
<p><strong>二、分库分表方案</strong></p>
<h5 id="分库分表方案中有常用的方案，hash取模和range范围方案；分库分表方案最主要就是路由算法，把路由的key按照指定的算法进行路由存放。下边来介绍一下两个方案的特点。"><a href="#分库分表方案中有常用的方案，hash取模和range范围方案；分库分表方案最主要就是路由算法，把路由的key按照指定的算法进行路由存放。下边来介绍一下两个方案的特点。" class="headerlink" title="分库分表方案中有常用的方案，hash取模和range范围方案；分库分表方案最主要就是路由算法，把路由的key按照指定的算法进行路由存放。下边来介绍一下两个方案的特点。"></a>分库分表方案中有常用的方案，hash取模和range范围方案；分库分表方案最主要就是路由算法，把路由的key按照指定的算法进行路由存放。下边来介绍一下两个方案的特点。</h5><h1 id="1、hash取模方案"><a href="#1、hash取模方案" class="headerlink" title="1、hash取模方案"></a><strong>1、hash取模方案</strong></h1><p><img src="/2022/10/25/MySQL-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8range-hash%E6%96%B9%E6%A1%88/3.png" alt="图片"></p>
<p>在我们设计系统之前，可以先预估一下大概这几年的订单量，如：4000万。每张表我们可以容纳1000万，也我们可以设计4张表进行存储。</p>
<blockquote>
<p>那具体如何路由存储的呢？hash的方案就是对指定的路由key（如：id）对分表总数进行取模，上图中，id&#x3D;12的订单，对4进行取模，也就是会得到0，那此订单会放到0表中。id&#x3D;13的订单，取模得到为1，就会放到1表中。为什么对4取模，是因为分表总数是4。</p>
</blockquote>
<ul>
<li>优点：</li>
</ul>
<p>订单数据可以均匀的放到那4张表中，这样此订单进行操作时，就不会有热点问题。</p>
<blockquote>
<p>热点的含义：热点的意思就是对订单进行操作集中到1个表中，其他表的操作很少。</p>
<p>订单有个特点就是时间属性，一般用户操作订单数据，都会集中到这段时间产生的订单。如果这段时间产生的订单 都在同一张订单表中，那就会形成热点，那张表的压力会比较大。</p>
</blockquote>
<ul>
<li>缺点：</li>
</ul>
<p>将来的数据迁移和扩容，会很难。</p>
<p>如：业务发展很好，订单量很大，超出了4000万的量，那我们就需要增加分表数。如果我们增加4个表</p>
<p><img src="/2022/10/25/MySQL-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8range-hash%E6%96%B9%E6%A1%88/4.png" alt="图片"></p>
<blockquote>
<p>一旦我们增加了分表的总数，取模的基数就会变成8，以前id&#x3D;12的订单按照此方案就会到4表中查询，但之前的此订单时在0表的，这样就导致了数据查不到。就是因为取模的基数产生了变化。</p>
</blockquote>
<p>遇到这个情况，我们小伙伴想到的方案就是做数据迁移，把之前的4000万数据，重新做一个hash方案，放到新的规划分表中。也就是我们要做数据迁移。这个是很痛苦的事情。有些小公司可以接受晚上停机迁移，但大公司是不允许停机做数据迁移的。</p>
<blockquote>
<p>当然做数据迁移可以结合自己的公司的业务，做一个工具进行，不过也带来了很多工作量，每次扩容都要做数据迁移</p>
</blockquote>
<p>那有没有不需要做数据迁移的方案呢，我们看下面的方案</p>
<h1 id="2、range范围方案"><a href="#2、range范围方案" class="headerlink" title="2、range范围方案"></a><strong>2、range范围方案</strong></h1><p>range方案也就是以范围进行拆分数据。</p>
<p><img src="/2022/10/25/MySQL-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8range-hash%E6%96%B9%E6%A1%88/5.png" alt="图片"></p>
<p>range方案比较简单，就是把一定范围内的订单，存放到一个表中；如上图id&#x3D;12放到0表中，id&#x3D;1300万的放到1表中。设计这个方案时就是前期把表的范围设计好。通过id进行路由存放。</p>
<ul>
<li>优点</li>
</ul>
<p>我们小伙伴们想一下，此方案是不是有利于将来的扩容，不需要做数据迁移。即时再增加4张表，之前的4张表的范围不需要改变，id&#x3D;12的还是在0表，id&#x3D;1300万的还是在1表，新增的4张表他们的范围肯定是 大于 4000万之后的范围划分的。</p>
<ul>
<li>缺点</li>
</ul>
<p>有热点问题，我们想一下，因为id的值会一直递增变大，那这段时间的订单是不是会一直在某一张表中，如id&#x3D;1000万 ～ id&#x3D;2000万之间，这段时间产生的订单是不是都会集中到此张表中，这个就导致1表过热，压力过大，而其他的表没有什么压力。</p>
<h1 id="3、总结："><a href="#3、总结：" class="headerlink" title="3、总结："></a><strong>3、总结：</strong></h1><p>hash取模方案：没有热点问题，但扩容迁移数据痛苦</p>
<p>range方案：不需要迁移数据，但有热点问题。</p>
<p>那有什么方案可以做到两者的优点结合呢？，即不需要迁移数据，又能解决数据热点的问题呢？</p>
<p>其实还有一个现实需求，能否根据服务器的性能以及存储高低，适当均匀调整存储呢？</p>
<p><img src="/2022/10/25/MySQL-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8range-hash%E6%96%B9%E6%A1%88/6.png" alt="图片"></p>
<p><strong>三、方案思路</strong></p>
<p>hash是可以解决数据均匀的问题，range可以解决数据迁移问题，那我们可以不可以两者相结合呢？利用这两者的特性呢？</p>
<p>我们考虑一下数据的扩容代表着，路由key（如id）的值变大了，这个是一定的，那我们先保证数据变大的时候，首先用range方案让数据落地到一个范围里面。这样以后id再变大，那以前的数据是不需要迁移的。</p>
<p>但又要考虑到数据均匀，那是不是可以在一定的范围内数据均匀的呢？因为我们每次的扩容肯定会事先设计好这次扩容的范围大小，我们只要保证这次的范围内的数据均匀是不是就ok了。</p>
<p><img src="/2022/10/25/MySQL-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8range-hash%E6%96%B9%E6%A1%88/7.png" alt="图片"></p>
<p><strong>四、方案设计</strong></p>
<h1 id="我们先定义一个group组概念，这组里面包含了一些分库以及分表，如下图"><a href="#我们先定义一个group组概念，这组里面包含了一些分库以及分表，如下图" class="headerlink" title="我们先定义一个group组概念，这组里面包含了一些分库以及分表，如下图"></a>我们先定义一个group组概念，这组里面包含了一些分库以及分表，如下图</h1><p><img src="/2022/10/25/MySQL-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8range-hash%E6%96%B9%E6%A1%88/8.png" alt="图片"></p>
<p>上图有几个关键点：</p>
<blockquote>
<p>1）id&#x3D;0～4000万肯定落到group01组中</p>
<p>2）group01组有3个DB，那一个id如何路由到哪个DB？</p>
<p>3）根据hash取模定位DB，那模数为多少？模数要为所有此group组DB中的表数，上图总表数为10。为什么要去表的总数？而不是DB总数3呢？</p>
<p>4）如id&#x3D;12，id%10&#x3D;2；那值为2，落到哪个DB库呢？这是设计是前期设定好的，那怎么设定的呢？</p>
<p>5）一旦设计定位哪个DB后，就需要确定落到DB中的哪张表呢？</p>
</blockquote>
<p><img src="/2022/10/25/MySQL-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8range-hash%E6%96%B9%E6%A1%88/9.png" alt="图片"></p>
<p><strong>五、核心主流程</strong></p>
<p><img src="/2022/10/25/MySQL-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8range-hash%E6%96%B9%E6%A1%88/10.png" alt="图片"></p>
<p>按照上面的流程，我们就可以根据此规则，定位一个id，我们看看有没有避免热点问题。</p>
<p>我们看一下，id在【0，1000万】范围内的，根据上面的流程设计，1000万以内的id都均匀的分配到DB_0,DB_1,DB_2三个数据库中的Table_0表中，为什么可以均匀，因为我们用了hash的方案，对10进行取模。</p>
<blockquote>
<p>上面我们也提了疑问，为什么对表的总数10取模，而不是DB的总数3进行取模？我们看一下为什么DB_0是4张表，其他两个DB_1是3张表？</p>
</blockquote>
<p>在我们安排服务器时，有些服务器的性能高，存储高，就可以安排多存放些数据，有些性能低的就少放点数据。如果我们取模是按照DB总数3，进行取模，那就代表着【0，4000万】的数据是平均分配到3个DB中的，那就不能够实现按照服务器能力适当分配了。</p>
<p>按照Table总数10就能够达到，看如何达到：</p>
<p><img src="/2022/10/25/MySQL-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8range-hash%E6%96%B9%E6%A1%88/11.png" alt="图片"></p>
<p>上图中我们对10进行取模，如果值为【0，1，2，3】就路由到DB_0，【4，5，6】路由到DB_1，【7，8，9】路由到DB_2。现在小伙伴们有没有理解，这样的设计就可以把多一点的数据放到DB_0中，其他2个DB数据量就可以少一点。</p>
<p>DB_0承担了4&#x2F;10的数据量，DB_1承担了3&#x2F;10的数据量，DB_2也承担了3&#x2F;10的数据量。整个Group01承担了【0，4000万】的数据量。</p>
<blockquote>
<p>注意：小伙伴千万不要被DB_1或DB_2中table的范围也是0～4000万疑惑了，这个是范围区间，也就是id在哪些范围内，落地到哪个表而已。</p>
</blockquote>
<p>上面一大段的介绍，就解决了热点的问题，以及可以按照服务器指标，设计数据量的分配。</p>
<p><img src="/2022/10/25/MySQL-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8range-hash%E6%96%B9%E6%A1%88/12.png" alt="图片"></p>
<p><strong>六、如何扩容</strong></p>
<h5 id="其实上面设计思路理解了，扩容就已经出来了；那就是扩容的时候再设计一个group02组，定义好此group的数据范围就ok了。"><a href="#其实上面设计思路理解了，扩容就已经出来了；那就是扩容的时候再设计一个group02组，定义好此group的数据范围就ok了。" class="headerlink" title="其实上面设计思路理解了，扩容就已经出来了；那就是扩容的时候再设计一个group02组，定义好此group的数据范围就ok了。"></a>其实上面设计思路理解了，扩容就已经出来了；那就是扩容的时候再设计一个group02组，定义好此group的数据范围就ok了。</h5><p><img src="/2022/10/25/MySQL-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8range-hash%E6%96%B9%E6%A1%88/13.png" alt="图片"></p>
<p>因为是新增的一个group01组，所以就没有什么数据迁移概念，完全是新增的group组，而且这个group组照样就防止了热点，也就是【4000万，5500万】的数据，都均匀分配到三个DB的table_0表中，【5500万～7000万】数据均匀分配到table_1表中。</p>
<p><strong>七、系统设计</strong></p>
<p><img src="/2022/10/25/MySQL-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8range-hash%E6%96%B9%E6%A1%88/14.png" alt="图片"></p>
<p>思路确定了，设计是比较简单的，就3张表，把group，DB，table之间建立好关联关系就行了。</p>
<p><img src="/2022/10/25/MySQL-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8range-hash%E6%96%B9%E6%A1%88/15.png" alt="图片"></p>
<p>group和DB的关系</p>
<p><img src="/2022/10/25/MySQL-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8range-hash%E6%96%B9%E6%A1%88/16.png" alt="图片"></p>
<p><strong>table和db的关系</strong></p>
<p>上面的表关联其实是比较简单的，只要原理思路理顺了，就ok了。小伙伴们在开发的时候不要每次都去查询三张关联表，可以保存到缓存中（本地jvm缓存），这样不会影响性能。</p>
<p><img src="/2022/10/25/MySQL-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8range-hash%E6%96%B9%E6%A1%88/17.png" alt="图片"></p>
<p>一旦需要扩容，小伙伴是不是要增加一下group02关联关系，那应用服务需要重新启动吗？</p>
<p>简单点的话，就凌晨配置，重启应用服务就行了。但如果是大型公司，是不允许的，因为凌晨也有订单的。那怎么办呢？本地jvm缓存怎么更新呢？</p>
<p>其实方案也很多，可以使用用zookeeper，也可以使用分布式配置，这里是比较推荐使用分布式配置中心的，可以将这些数据配置到分布式配置中心去。</p>
<p>到此为止，整体的方案介绍结束，希望对小伙伴们有所帮助。谢谢！！！</p>
<blockquote>
<p>这边隐含了一个关键点，那就是路由key（如：id）的值是非常关键的，要求一定是有序的，自增的，这个就涉及到分布式唯一id的方案。</p>
</blockquote>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>OLTP</tag>
        <tag>数据库</tag>
        <tag>分库分表</tag>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-内存组件</title>
    <url>/2022/10/25/MySQL-%E5%86%85%E5%AD%98%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>MySQL</code>中执行一条<code>SQL</code>语句，相应表数据的读写都是由存储引擎去做（<strong>更新数据、查询数据</strong>）。</p>
<p>在这个过程，存储引擎需要决策一些事情</p>
<ul>
<li><strong>数据是从内存查还是从硬盘查</strong></li>
<li><strong>数据是更新在内存，还是硬盘</strong></li>
<li><strong>内存的数据什么时候同步到硬盘</strong></li>
</ul>
<p>所以存储引擎会按照内部逻辑与内存、硬盘交互。</p>
<p><img src="/2022/10/25/MySQL-%E5%86%85%E5%AD%98%E7%BB%84%E4%BB%B6/9.png" alt="图片"></p>
<p>我们可以按需选择存储引擎，比如常见的 <code>InnoDB、MyISAM、Memory</code>等等。</p>
<p><img src="/2022/10/25/MySQL-%E5%86%85%E5%AD%98%E7%BB%84%E4%BB%B6/10.png" alt="图片"></p>
<p>众多存储引擎中，<code>InnoDB</code>是最为常用的，从 <code>MySQL5.5.8</code> 版本开始，<code>InnoDB</code>是默认的存储引擎。</p>
<h1 id="InnoDB简介"><a href="#InnoDB简介" class="headerlink" title="InnoDB简介"></a>InnoDB简介</h1><p><code>InnoDB</code>存储引擎支持事务，其设计目标主要面向在线事务处理（<code>OLTP</code>）的应用。</p>
<p>特点是行锁设计、支持<code>MVCC</code>、外键，提供一致性非锁定读，同时本身设计能够最有效的利用内存和<code>CPU</code>，是 <code>MySQL</code> 最常用的存储引擎。</p>
<h1 id="InnoDB的重要内存结构"><a href="#InnoDB的重要内存结构" class="headerlink" title="InnoDB的重要内存结构"></a>InnoDB的重要内存结构</h1><p><img src="/2022/10/25/MySQL-%E5%86%85%E5%AD%98%E7%BB%84%E4%BB%B6/11.png" alt="图片"></p>
<p><code>InnoDB</code>存储引擎在内存中有两个非常重要的组件，分别是缓冲池（<code>Buffer Pool</code>）和重做日志缓存（<code>redo log buffer</code>）。</p>
<h2 id="Buffer-Pool简介"><a href="#Buffer-Pool简介" class="headerlink" title="Buffer Pool简介"></a>Buffer Pool简介</h2><p>缓冲池（<code>Buffer Pool</code>）里面会缓存很多的数据，比如数据页、索引页、锁信息等等。</p>
<p><code>MySQL</code>表数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 <code>Buffer Pool</code> 中。</p>
<p>后续的查询先从 <code>Buffer Pool</code> 中找，没有命中再去硬盘加载，减少硬盘 <code>IO</code> 开销，提升性能。</p>
<p>更新表数据的时，如果 <code>Buffer Pool</code> 里命中数据，就直接在 <code>Buffer Pool</code> 里更新。</p>
<p><img src="/2022/10/25/MySQL-%E5%86%85%E5%AD%98%E7%BB%84%E4%BB%B6/12.png" alt="图片"></p>
<p>总之 <code>Buffer Pool</code> 会缓存很多的数据，以便后续的查询与更新。</p>
<blockquote>
<p>小贴士：这里只是用数据页举例帮助大家理解，大家千万不要认为 <code>Buffer Pool</code> 里面只有数据页，它只是占 <code>Buffer Pool</code> 大部分空间，关于 <code>Buffer Pool</code> 更多细节，后续会有专门的文章讲解。</p>
</blockquote>
<h2 id="redo-log-buffer简介"><a href="#redo-log-buffer简介" class="headerlink" title="redo log buffer简介"></a>redo log buffer简介</h2><p>接着思考一个问题，假设我们把 <code>Buffer Pool</code> 中某个数据页的某条数据修改了，但是硬盘的数据还未同步，此时数据是不一致的，如果 <code>MySQL</code> 宕机了，数据就丢失了。</p>
<p><img src="/2022/10/25/MySQL-%E5%86%85%E5%AD%98%E7%BB%84%E4%BB%B6/13.png" alt="图片"></p>
<p>这可怎么办呢。</p>
<p>为了保证数据的持久性，<code>InnoDB</code>存储引擎加入了 <code>redo</code> 日志功能，也叫重做日志。</p>
<p>每当我们对表数据进行更新时，会把“在某个数据页上做了什么修改”记录到重做日志缓存（<code>redo log buffer</code>）里。</p>
<p>当事务提交时，会把 <code>redo log buffer</code> 清空，刷盘到 <code>redo</code> 日志文件。</p>
<p><img src="/2022/10/25/MySQL-%E5%86%85%E5%AD%98%E7%BB%84%E4%BB%B6/14.png" alt="图片"></p>
<p>这样 <code>MySQL</code> 宕机了也没关系，因为重启后会根据 <code>redo</code> 日志去恢复数据。</p>
<p><img src="/2022/10/25/MySQL-%E5%86%85%E5%AD%98%E7%BB%84%E4%BB%B6/16.png" alt="图片"></p>
<blockquote>
<p>小贴士：redo日志细节也很多，本文只做个介绍，后续会有专门的文章讲解。</p>
</blockquote>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>其实不难发现，缓冲池（<code>Buffer Pool</code>）和重做日志缓存（<code>redo log buffer</code>），它们都是为了减少硬盘 <code>IO</code> 开销。</p>
<p>因为 <code>Buffer Pool</code> 与 <code>redo</code> 日志涉及内容较多，后面会出两篇文章单独讲。</p>
<p>今天讲的这些内容全是在给后面的文章做铺垫，大家先知道它们是干嘛的，留个印象就行了。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>OLTP</tag>
        <tag>数据库</tag>
        <tag>分库分表</tag>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-携程分库分表解决方案</title>
    <url>/2022/10/25/MySQL-%E6%90%BA%E7%A8%8B%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h2><p>随着国际火车票业务的高速发展，订单量快速增长，单数据库瓶颈层面的问题逐渐显露，常规的数据库优化已无法达到期望的效果。同时，原先的底层数据库设计，也存在一些历史遗留问题，比如存在部分无用字段、表通过自增主键关联和各个应用直连数据库等问题。</p>
<p>为此，经过讨论后，我们决定对订单库进行分库分表，同时对订单表进行重构，进而从根本上解决这些问题。</p>
<h2 id><a href="#" class="headerlink" title></a></h2><h2 id="二、问题挑战"><a href="#二、问题挑战" class="headerlink" title="二、问题挑战"></a><strong>二、问题挑战</strong></h2><p>目标确定后，实践起来可不轻松，出现了很多的问题和挑战。这里列举一些典型问题，大致可以分为两大类：分库分表通用问题、具体业务关联问题。</p>
<p><strong>分库分表通用问题</strong></p>
<ul>
<li>如何切分，垂直分还是水平分？分片的键，如何选取？</li>
<li>如何根据键值路由到对应库、对应表？</li>
<li>采用什么中间件，代理方式还是中间件的方式？</li>
<li>跨库操作等问题，如跨库事务和跨库关联？</li>
<li>数据扩容问题，后续如何进行扩容？</li>
</ul>
<p><strong>具体业务关联问题</strong></p>
<ul>
<li>各个应用直连数据如何解决？</li>
<li>如何进行平滑过渡？</li>
<li>历史数据如何恰当迁移？</li>
</ul>
<h2 id="-1"><a href="#-1" class="headerlink" title></a></h2><h2 id="三、方案选型"><a href="#三、方案选型" class="headerlink" title="三、方案选型"></a><strong>三、方案选型</strong></h2><h3 id="-2"><a href="#-2" class="headerlink" title></a></h3><h3 id="3-1-如何切分"><a href="#3-1-如何切分" class="headerlink" title="3.1 如何切分"></a><strong>3.1 如何切分</strong></h3><p>切分方式，一般分为垂直分库、垂直分表、水平分库和水平分表四种，如何选择，一般是根据自己的业务需求决定。</p>
<p>我们的目标是要从根本上解决数据量大、单机性能问题等问题，垂直方式并不能满足需求，所以我们选取了水平分库+水平分表的切分方式。</p>
<h3 id="-3"><a href="#-3" class="headerlink" title></a></h3><h3 id="3-2-分片键选取"><a href="#3-2-分片键选取" class="headerlink" title="3.2 分片键选取"></a><strong>3.2 分片键选取</strong></h3><p>一般是根据自己的实际业务，来选择字段来作为分片的键，同时可以结合考虑数据的热点问题 、分布问题。比如订单系统，不能根据国家字段进行分片，否则可能会出现某些国家很多的订单记录，某些国家几乎没有订单记录，进而数据分布不均。相对正确的方式，比如订单类系统，可以选择订单ID；会员系统，可以选择会员ID。</p>
<h3 id="-4"><a href="#-4" class="headerlink" title></a></h3><h3 id="3-3-如何路由"><a href="#3-3-如何路由" class="headerlink" title="3.3 如何路由"></a><strong>3.3 如何路由</strong></h3><p>选定了分片的键之后，接下来需要探讨的问题，就是如何路由到具体的数据库和具体的表。以分片键路由到具体某一个数据库为例，常见的路由方式如下：</p>
<h4 id="-5"><a href="#-5" class="headerlink" title></a></h4><h4 id="映射路由"><a href="#映射路由" class="headerlink" title="映射路由"></a><strong>映射路由</strong></h4><p>映射路由，即新增一个库，新建一个路由映射表，存储分片键值和对应的库之间的映射关系。比如，键值为 1001，映射到 db01 这个数据库，如下图所示：</p>
<p><img src="/2022/10/25/MySQL-%E6%90%BA%E7%A8%8B%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/18.png" alt="图片"></p>
<p>映射方式，优点是映射方式可任意调整，扩容简单，但是存在一个比较严重的不足，就是映射库中的映射表的数据量异常巨大。我们本来的目标是要实现分库分表的功能，可是现在，映射库映射表相当于回到了分库分表之前的状态。所以，我们在实践中，没有采取这种方式。</p>
<h4 id="-6"><a href="#-6" class="headerlink" title></a></h4><h4 id="分组路由"><a href="#分组路由" class="headerlink" title="分组路由"></a><strong>分组路由</strong></h4><p>分组路由，即对分片的键值，进行分组，每组对应到一个具体的数据库。比如，键值为 1000到2000，则存储到 db01 这个数据库，如下图所示：</p>
<p><img src="/2022/10/25/MySQL-%E6%90%BA%E7%A8%8B%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/19.png" alt="图片"></p>
<p>分组方式，优点是扩容简单，实现简单，但是也存在一个比较严重的不足，是数据分布热点问题，比如在某一个时间内，分片键值为2001，则在将来一段时间内，所有的数据流量，全部打到某一个库（db02）。这个问题，在互联网环境下，也比较严重，比如在一些促销活动中，订单量会有一个明显的飙升，这时候各个数据库不能达到分摊流量的效果，只有一个库在接收流量，会回到分库分表之前的状态。所以，我们也没有采取这种方式。</p>
<h4 id="-7"><a href="#-7" class="headerlink" title></a></h4><h4 id="哈希路由"><a href="#哈希路由" class="headerlink" title="哈希路由"></a><strong>哈希路由</strong></h4><p>哈希路由，即对分片的键值，进行哈希，然后根据哈希结果，对应到一个具体的数据库。比如，键值为 1000，对其取哈希的结果为 01，则存储到 db01 这个数据库，如下图所示：</p>
<p><img src="/2022/10/25/MySQL-%E6%90%BA%E7%A8%8B%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/20.png" alt="图片"></p>
<p>哈希方式，优点是分布均匀，无热点问题，但是反过来，数据扩容比较麻烦。因为在扩容过程中，需要调整哈希函数，随之带出一个数据迁移问题。互联网环境下，迁移过程中往往不能进行停服，所以就需要类似多库双写等方式进行过渡，比较麻烦。所以，在实践中也没有采取这种方式。</p>
<h4 id="-8"><a href="#-8" class="headerlink" title></a></h4><h4 id="分组哈希路由"><a href="#分组哈希路由" class="headerlink" title="分组哈希路由"></a><strong>分组哈希路由</strong></h4><p>分组哈希路由，即对分片的键值，先进行分组，后再进行哈希。如下图所示：</p>
<p><img src="/2022/10/25/MySQL-%E6%90%BA%E7%A8%8B%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/21.png" alt="图片"></p>
<p>在实践中，我们结合了前面的几种方式，借鉴了他们的优点不足，而采用了此种方式。因为分组方式，能很方便的进行扩容，解决了数据扩容问题；哈希方式，能解决分布相对均匀，无单点数据库热点问题。</p>
<h3 id="-9"><a href="#-9" class="headerlink" title></a></h3><h3 id="3-4-技术中间件"><a href="#3-4-技术中间件" class="headerlink" title="3.4 技术中间件"></a><strong>3.4 技术中间件</strong></h3><p>分库分表的中间件选取，在行业内的方案还是比较多的，公司也有自己的实现。根据实现方式的不同，可以分为代理和非代理方式，下面列举了一些业界常见的中间件，如下表（截至于2021-04-08）：</p>
<p><img src="/2022/10/25/MySQL-%E6%90%BA%E7%A8%8B%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/22.png" alt="图片"></p>
<p>我们为什么最终选择了 Sharding-Sphere 呢？主要从这几个因素考虑：</p>
<h4 id="-10"><a href="#-10" class="headerlink" title></a></h4><h4 id="技术环境"><a href="#技术环境" class="headerlink" title="技术环境"></a><strong>技术环境</strong></h4><ul>
<li>我们团队是Java体系下的，对Java中间件有一些偏爱</li>
<li>更偏向于轻量级组件，可以深入研究的组件</li>
<li>可能会需要一些个性定制化</li>
</ul>
<h4 id="-11"><a href="#-11" class="headerlink" title></a></h4><h4 id="专业程度"><a href="#专业程度" class="headerlink" title="专业程度"></a><strong>专业程度</strong></h4><ul>
<li>取决于中间件由哪个团队进行维护，是否是名师打造，是否是行业标杆</li>
<li>更新迭代频率，最好是更新相对频繁，维护较积极的</li>
<li>流行度问题，偏向于流行度广、社区活跃的中间件</li>
<li>性能问题，性能能满足我们的要求</li>
</ul>
<h4 id="-12"><a href="#-12" class="headerlink" title></a></h4><h4 id="使用成本"><a href="#使用成本" class="headerlink" title="使用成本"></a><strong>使用成本</strong></h4><ul>
<li>学习成本、入门成本和定制改造成本</li>
<li>弱浸入性，对业务能较少浸入</li>
<li>现有技术栈下的迁移成本，我们当前技术栈是SSM体系下</li>
</ul>
<h4 id="-13"><a href="#-13" class="headerlink" title></a></h4><h4 id="运维成本"><a href="#运维成本" class="headerlink" title="运维成本"></a><strong>运维成本</strong></h4><ul>
<li>高可用、高稳定性</li>
<li>减少硬件资源，不希望再单独引入一个代理中间件，还要考虑运维成本</li>
<li>丰富的埋点、完善的监控</li>
</ul>
<h2 id="-14"><a href="#-14" class="headerlink" title></a></h2><h2 id="四、业务实践"><a href="#四、业务实践" class="headerlink" title="四、业务实践"></a><strong>四、业务实践</strong></h2><p>在业务实践中，我们经历了从新库新表的设计，分库分表自建代理、服务收口、上游订单应用迁移，历史数据迁移等过程。</p>
<h3 id="-15"><a href="#-15" class="headerlink" title></a></h3><h3 id="4-1-新表模型"><a href="#4-1-新表模型" class="headerlink" title="4.1 新表模型"></a><strong>4.1 新表模型</strong></h3><p>为了建立分库分表下的关联关系，和更加合理有效的结构，我们新申请了订单分库分表的几个库，设计了一套全新的表结构。表名以年份结尾、规范化表字段、适当增删了部分字段、不使用自增主键关联，采用业务唯一键进行关联等。</p>
<p>表结构示例如下图：</p>
<p><img src="/2022/10/25/MySQL-%E6%90%BA%E7%A8%8B%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/23.png" alt="图片"></p>
<h3 id="4-2-服务收口"><a href="#4-2-服务收口" class="headerlink" title="4.2 服务收口"></a><strong>4.2 服务收口</strong></h3><p>自建了一个分库分表数据库的服务代理 Dal-Sharding。每一个需要操作订单库的服务，都要通过代理服务进行操作数据库，达到服务的一个收口效果。同时，屏蔽了分库分表的复杂性，规范数据库的基本增删改查方法。</p>
<p><img src="/2022/10/25/MySQL-%E6%90%BA%E7%A8%8B%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/24.png" alt="图片"></p>
<h3 id="4-3-平滑过渡"><a href="#4-3-平滑过渡" class="headerlink" title="4.3 平滑过渡"></a><strong>4.3 平滑过渡</strong></h3><p>应用迁移过程中，为了保证应用的平滑过渡，我们新增了一些同步逻辑，来保证应用的顺利迁移，在应用迁移前后，对应用没有任何影响。未迁移的应用，可以读取到迁移后应用写入的订单数据；迁移后的应用，能读取到未迁移应用写入的订单数据。同时，统一实现了此逻辑，减少各个应用的迁移成本。</p>
<p><strong>新老库双读</strong></p>
<p>顾名思义，就是在读取的时候，两个库可能都要进行读取，即优先读取新库，如果能读到记录，直接返回；否则，再次读取老库记录，并返回结果。</p>
<p>双读的基本过程如下：</p>
<p><img src="/2022/10/25/MySQL-%E6%90%BA%E7%A8%8B%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/25.png" alt="图片"></p>
<p>新老库双读，保证了应用迁移过程中读取的低成本，上游应用不需要关心数据来源于新的库还是老的库，只要关心数据的读取即可，减少了切换新库和分库分表的逻辑，极大的减少了迁移的工作量。</p>
<p>实践过程中，我们通过切面实现双读逻辑，将双读逻辑放入到切面中进行，减小新库的读取逻辑的侵入，方便后面实现对双读逻辑的移除调整。</p>
<p>同时，新增一些配置，比如可以控制到哪些表需要进行双读，那些表不需要双读等。</p>
<p><strong>新老库双写</strong></p>
<p>新老库双写，就是在写入新库成功后，异步写入到老库中。双写使得新老库都同时存在这些订单数据，尚未迁移通过代理服务操作数据库的应用得以正常的运作。</p>
<p>双写的基本过程如下：</p>
<p><img src="/2022/10/25/MySQL-%E6%90%BA%E7%A8%8B%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/26.png" alt="图片"></p>
<p>双写其实有较多的方案，比如基于数据库的日志，通过监听解析数据库日志实现同步；也可以通过切面，实现双写；还可以通过定时任务进行同步；另外，结合到我们自己的订单业务，我们还可以通过订单事件（比如创单成功、出票成功、退票成功等），进行双写，同步数据到老库中。</p>
<p>目前，我们经过考虑，没有通过数据库日志来实现，因为这样相当于把逻辑下沉到了数据库层面，从实现上不够灵活，同时，可能还会涉及到一些权限、排期等问题。实践中，我们采取其他三种方式，互补形式，进行双写。异步切面双写，保证了最大的时效性；订单事件，保证了核心节点的一致性；定时任务，保证了最终的一致性。</p>
<p>跟双读一样，我们也支持配置控制到哪些表需要进行双写，那些表不需要双写等。</p>
<p><strong>过渡迁移</strong></p>
<p>有了前面的双读双写作为基础，迁移相对容易实行，我们采取逐个迁移的方式，比如，按照服务、按照渠道和按照供应进行迁移，将迁移工作进行拆解，减少影响面，追求稳健。一般分为三步走方式：</p>
<p>1）第一阶段，先在新对接的供应商中进行迁移新库，因为新上线的供应商，订单量最少，同时哪怕出现了问题，不至于影响到之前的业务。</p>
<p>2）再次迁移量比较少的线上业务，此类订单，有一些量，但是追求稳定，不能因为切换新库而产生影响。所以，将此类业务放到了第二阶段中进行。</p>
<p>3）最后一步是，将量较大的业务，逐渐迁移到新库中，此类业务，需要在在有前面的保证后，方能进行迁移，保证订单的正常进行。</p>
<p><img src="/2022/10/25/MySQL-%E6%90%BA%E7%A8%8B%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/27.png" alt="图片"></p>
<h3 id="-16"><a href="#-16" class="headerlink" title></a></h3><h3 id="4-4-数据迁移"><a href="#4-4-数据迁移" class="headerlink" title="4.4 数据迁移"></a><strong>4.4 数据迁移</strong></h3><p>数据迁移，即将数据，从老库迁移到新库，是新老库切换的一个必经过程。迁移的常规思路，一般是每个表一个个进行迁移，结合业务，我们没有采取此做法，而是从订单维度进行迁移。</p>
<p>举个例子：假如订单库有Order表、OrderStation表、OrderFare表三个表，我们没有采取一个一个表分别进行迁移，而是根据订单号，以每一个订单的信息，进行同步。</p>
<p>大致过程如下：</p>
<p>1）开启一个定时任务，查询订单列表，取得订单号等基本订单信息。</p>
<p>2）根据这个订单号，去分别查询订单的其他信息，取得一个完整的订单信息。</p>
<p>3）校验订单是否已经完成同步，之前完成同步了则直接跳过，否则继续执行下一个订单号。</p>
<p>4）将老库的完整的订单信息，映射成新库的对应的模型。</p>
<p>5）将新的订单信息，同步写入到新库各个表中。</p>
<p>6）继续执行下一个订单号，直到所有的订单号都完全同步结束。</p>
<p><img src="/2022/10/25/MySQL-%E6%90%BA%E7%A8%8B%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/28.png" alt="图片"></p>
<h3 id="-17"><a href="#-17" class="headerlink" title></a></h3><h3 id="4-5-完成效果"><a href="#4-5-完成效果" class="headerlink" title="4.5 完成效果"></a><strong>4.5 完成效果</strong></h3><p>订单库经过一个全新的重构，目前已经在线上稳定运行，效果显著，达到了我们想要的效果。</p>
<ul>
<li>服务收口，将分库分表逻辑，收口到了一个服务中；</li>
<li>接口统一管理，统一对敏感字段进行加密；</li>
<li>功能灵活，提供丰富的功能，支持定制化；</li>
<li>分库分表路由透明，且基于主流技术，易于上手；</li>
<li>完善的监控，支持到表维度的监控；</li>
</ul>
<h2 id="-18"><a href="#-18" class="headerlink" title></a></h2><h2 id="五、常见问题总结"><a href="#五、常见问题总结" class="headerlink" title="五、常见问题总结"></a><strong>五、</strong>常见问题总结</h2><h3 id="-19"><a href="#-19" class="headerlink" title></a></h3><h3 id="5-1-分库分表典型问题"><a href="#5-1-分库分表典型问题" class="headerlink" title="5.1 分库分表典型问题"></a><strong>5.1 分库分表典型问题</strong></h3><p><strong>问题1</strong>：如何进行跨库操作，关联查询，跨库事务？</p>
<p><strong>回答：</strong>对于跨库操作，在订单主流程应用中，我们目前是禁止了比如跨库查询、跨库事务等操作的。对于跨库事务，因为根据订单号、创建年份路由，都是会路由到同一个数据库中，也不会存在跨库事务。同样对于跨库关联查询，也不会存在，往往都是根据订单来进行查询。同时，也可以适当进行冗余，比如存储车站编码的同时，多存储一个车站名称字段。</p>
<p><strong>问题2</strong>：如何进行分页查询？</p>
<p><strong>回答</strong>：目前在订单主流程应用中的分页查询，我们直接采用了Sharding-JDBC提供的最原始的分页方式，直接按照正常的分页SQL，来进行查询分页即可。理由：主流程订单服务，比如出票系统，往往都是查询前面几页的订单，直接查询即可，不会存在很深的翻页。当然，对于要求较高的分页查询，可以去实现二次查询，来实现更加高效的分页查询。</p>
<p><strong>问题3</strong>：如何支持很复杂的统计查询？</p>
<p><strong>回答</strong>：专门增加了一个宽表，来满足那些很复杂查询的需求，将常用的查询信息，全部落到此表中，进而可以快速得到这些复杂查询的结果。</p>
<h3 id="-20"><a href="#-20" class="headerlink" title></a></h3><h3 id="5-2-API方法问题"><a href="#5-2-API方法问题" class="headerlink" title="5.2 API方法问题"></a><strong>5.2 API方法问题</strong></h3><p><strong>问题：</strong>服务收口后，如何满足业务各种不同的查询条件？</p>
<p><strong>回答：</strong>我们的API方法，相对固定，一般查询类只有两个方法，根据订单号查询，和根据Condition查询条件进行查询。对于各种不同的查询条件，则通过新增Condition的字段属性来实现，而不会新增各种查询方法。</p>
<h3 id="-21"><a href="#-21" class="headerlink" title></a></h3><h3 id="5-3-均匀问题"><a href="#5-3-均匀问题" class="headerlink" title="5.3 均匀问题"></a><strong>5.3 均匀问题</strong></h3><p><strong>问题：</strong>在不同group中，数据会存在分布不均匀，存在热点问题？</p>
<p><strong>回答：</strong>是的，比如运行5年后，我们拓展成了3个group，每一个group中存在3个库，那么此时，读写最多的应该是第三个group。不过这种分布不均匀问题和热点问题，是可接受的，相当于前面的两个group，可以作为历史归档group，目前主要使用的group为第三个group。</p>
<p>随着业务的发展，你可以进行调配，比如业务发展迅速，那么相对合理的分配，往往不会是每个group是3个库，更可能是应该是，越往后group内的库越多。同时，因为每个group内是存在多个库，与之前的某一个库的热点问题是存在本质差别，而不用担心将单数据库瓶颈问题，可以通过加库来实现扩展。</p>
<h3 id="-22"><a href="#-22" class="headerlink" title></a></h3><h3 id="5-4-Group内路由问题"><a href="#5-4-Group内路由问题" class="headerlink" title="5.4 Group内路由问题"></a><strong>5.4 Group内路由问题</strong></h3><p><strong>问题：</strong>对于仅根据订单号查询，在group内的路由过程是读取group内所有的表吗？</p>
<p><strong>回答：</strong>根据目前的设计，是的。目前是按年份分组，订单号不会存储其他信息，采用携程统一方式生成，也就是如果根据订单号查询，我们并不知道是存在于哪个表，则需要查询group内所有的表。对于此类问题，通常推荐做法是，可以适当增加因子，在订单号中，存储创建年份信息，这样就可以知道对应那个表了；也可以年份适当进行延伸，比如每5年一次分表，那么这样调整后，一个group内的表应该相对很少，可以极大加快查询效能。</p>
<h3 id="-23"><a href="#-23" class="headerlink" title></a></h3><h3 id="5-5-异步双写问题"><a href="#5-5-异步双写问题" class="headerlink" title="5.5 异步双写问题"></a><strong>5.5 异步双写问题</strong></h3><p><strong>问题</strong>：为什么双写过程，采用了多种方式结合的方式？</p>
<p><strong>回答</strong>：首先，切面方式，能最大限度满足订单同步的时效性。但是，在实践过程中，我们发现，异步切面双写，会存在多线程并发问题。因为在老库中，表的关联关系依赖于数据库的自增ID，依赖于表的插入顺序，会存在关联失败的情况。所以，单纯依靠切面同步还不够，还需要更加稳健的方式，即定时任务（订单事件是不可靠消息事件，即可能会存在丢失情况）的方式，来保证数据库的一致性。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>OLTP</tag>
        <tag>数据库</tag>
        <tag>分库分表</tag>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-架构介绍简介</title>
    <url>/2022/10/25/MySQL-%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>目前大部分的后端开发人员对<code>MySQL</code>的理解可能停留在一个黑盒子阶段。</p>
<p>对<code>MySQL</code>基本使用没什么问题，比如建库、建表、建索引，执行各种增删改查。</p>
<p>所有很多后端开发人员眼中的<code>MySQL</code>如下图所示</p>
<p><img src="/2022/10/25/MySQL-%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D%E7%AE%80%E4%BB%8B/1.png" alt="图片"></p>
<p>导致在实际工作中碰到<code>MySQL</code>中死锁异常、<code>SQL</code>性能太差、异常报错等问题时，直接百度搜索。</p>
<p>然后跟着博客捣鼓就解决了，可能自己都没搞明白里面的原理。</p>
<p>为了解决这种<strong>知其然而不知其所以然</strong>的问题，阿星的<strong>重学MySQL系列</strong>会带着大家去探索MySQL底层原理的方方面面。</p>
<p>这样大家碰到<code>MySQL</code>的一些异常或者问题时，能够直戳本质，快速地定位解决。</p>
<h1 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h1><p>系统（客户端）访问<code>MySQL</code>服务器前，做的第一件事就是建立<code>TCP</code>连接。</p>
<p>经过三次握手建立连接成功后，<code>MySQL</code>服务器对<code>TCP</code>传输过来的账号密码做身份认证、权限获取。</p>
<ul>
<li><strong>用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行</strong></li>
<li><strong>用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限</strong></li>
</ul>
<p>接着我们来思考一个问题</p>
<p>一个系统只会和<code>MySQL</code>服务器建立一个连接吗？</p>
<p>只能有一个系统和<code>MySQL</code>服务器建立连接吗？</p>
<p>当然不是，多个系统都可以和<code>MySQL</code>服务器建立连接，每个系统建立的连接肯定不止一个。</p>
<p>所以，为了解决<code>TCP</code>无限创建与<code>TCP</code>频繁创建销毁带来的资源耗尽、性能下降问题。</p>
<p><code>MySQL</code>服务器里有专门的<code>TCP</code>连接池限制接数，采用长连接模式复用<code>TCP</code>连接，来解决上述问题。</p>
<p><img src="/2022/10/25/MySQL-%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D%E7%AE%80%E4%BB%8B/2.png" alt="图片"></p>
<p><code>TCP</code>连接收到请求后，必须要分配给一个线程去执行，所以还会有个线程池，去走后面的流程。</p>
<p>这些内容我们都归纳到<code>MySQL</code>的<strong>连接管理</strong>组件中。</p>
<p>所以<strong>连接管理</strong>的职责是负责认证、管理连接、获取权限信息。</p>
<h1 id="解析与优化"><a href="#解析与优化" class="headerlink" title="解析与优化"></a>解析与优化</h1><p>经过了连接管理，现在<code>MySQL</code>服务器已经获取到<code>SQL</code>字符串。</p>
<p>如果是查询语句，<code>MySQL</code>服务器会使用<code>select SQL</code>字符串作为<code>key</code>。</p>
<p>去缓存中获取，命中缓存，直接返回结果（<strong>返回前需要做权限验证</strong>），未命中执行后面的阶段，这个步骤叫<strong>查询缓存</strong>。</p>
<p><img src="/2022/10/25/MySQL-%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D%E7%AE%80%E4%BB%8B/3.png" alt="图片"></p>
<p>需要注意，<code>select SQL</code>字符串要完全匹配，有任何不同的地方都会导致缓存不被命中（<strong>空格、注释、大小写、某些系统函数</strong>）。</p>
<blockquote>
<p>小贴士：虽然查询缓存有时可以提升系统性能，但也不得不因维护这块缓存而造成一些开销，从MySQL 5.7.20开始，不推荐使用查询缓存，并在MySQL 8.0中删除。</p>
</blockquote>
<p>没有命中缓存，或者非<code>select SQL</code>就来到<strong>分析器</strong>阶段了。</p>
<p>因为系统发送过来的只是一段文本字符串，所以<code>MySQL</code>服务器要按照<code>SQL</code>语法对这段文本进行解析。</p>
<p><img src="/2022/10/25/MySQL-%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D%E7%AE%80%E4%BB%8B/4.png" alt="图片"></p>
<p>如果你的<code>SQL</code>字符串不符合语法规范，就会收到<code>You have an error in your SQL syntax</code>错误提醒</p>
<p>通过了<strong>分析器</strong>，说明<code>SQL</code>字符串符合语法规范，现在<code>MySQL</code>服务器要执行<code>SQL</code>语句了。</p>
<p><code>MySQL</code>服务器要怎么执行呢？</p>
<p>你需要产出执行计划，交给<code>MySQL</code>服务器执行，所以来到了<strong>优化器</strong>阶段。</p>
<p><img src="/2022/10/25/MySQL-%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D%E7%AE%80%E4%BB%8B/15png.png" alt="图片"></p>
<p>优化器不仅仅只是生成执行计划这么简单，这个过程它会帮你优化<code>SQL</code>语句。</p>
<p>如<strong>外连接转换为内连接、表达式简化、子查询转为连接、连接顺序、索引选择</strong>等一堆东西，优化的结果就是执行计划。</p>
<p>截止到现在，还没有真正去读写真实的表，仅仅只是产出了一个执行计划。</p>
<p>于是就进入了<strong>执行器</strong>阶段，<code>MySQL</code>服务器终于要执行<code>SQL</code>语句了。</p>
<p><img src="/2022/10/25/MySQL-%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D%E7%AE%80%E4%BB%8B/5.png" alt="图片"></p>
<p>开始执行的时候，要先判断一下对这个表有没有相应的权限，如果没有，就会返回权限错误。</p>
<p>如果有权限，根据执行计划调用存储引擎<code>API</code>对表进行的读写。</p>
<p><img src="/2022/10/25/MySQL-%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D%E7%AE%80%E4%BB%8B/6.png" alt="图片"></p>
<p>存储引擎<code>API</code>只是抽象接口，下面还有个<strong>存储引擎层</strong>，具体实现还是要看表选择的存储引擎。</p>
<p>讲到这里，上面提到的<strong>查询缓存、分析器、优化器、执行器</strong>都可以归纳到<code>MySQL</code>的<strong>解析与优化</strong>组件中。</p>
<p>所以<strong>解析与优化</strong>的职责如下：</p>
<ul>
<li><strong>缓存</strong></li>
<li><strong>SQL语法解析验证</strong></li>
<li><strong>SQL优化并生成执行计划</strong></li>
<li><strong>根据执行计划调用存储引擎接口</strong></li>
</ul>
<p><img src="/2022/10/25/MySQL-%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D%E7%AE%80%E4%BB%8B/7.png" alt="图片"></p>
<p>其中<strong>连接管理</strong>与<strong>解析与优化</strong>处于<code>MySQL</code>架构中的<code>Server</code>层。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>在学习任何知识前，先不要着急的陷入细节，而是先了解大致脉络，有个全局观，之后再去深入相关的细节。</p>
<p><code>MySql</code>架构分为<code>Servce</code>层与<strong>存储引擎</strong>层。</p>
<p><strong>连接管理、解析与优化</strong>这些并不涉及读写表数据的组件划分到<code>Servce</code>层，读写表数据而是交给<strong>存储引擎层</strong>来做。</p>
<p>通过这种架构设计，我们发现<code>Servce</code>层其实就是公用层，<strong>存储引擎层</strong>就是多态层，按需选择具体的存储引擎。</p>
<p>再细想下，它和<strong>模板方法设计模式</strong>一摸一样，它们的执行流程是固定的，<code>Servce</code>层等于公用模板函数，<strong>存储引擎层</strong>等于抽象模板函数，按需子类实现。</p>
<p>阿星最后以一张<code>MySQL</code>简化版的架构图结束本文，我们下期再见~</p>
<p><img src="/2022/10/25/MySQL-%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D%E7%AE%80%E4%BB%8B/8.png" alt="图片"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>OLTP</tag>
        <tag>数据库</tag>
        <tag>分库分表</tag>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-锁</title>
    <url>/2022/10/25/MySQL-%E9%94%81/</url>
    <content><![CDATA[<p>– ACID 原子性、一致性、隔离性、持久性<br>–脏读：其中一个事务读取到另外一个事务已修改但未提交的数据。<br>–不可重复读：其中一个事务读取到另外一个事务已经提交的数据，针对于update和delete，对于事务来说前后读取不一致。<br>–幻读：其中一个事务读取到另外一个事务已经提交的新增数据，针对于insert，对于事务来说前后读取数据总数不一致。</p>
<h3 id="事务隔离级别的实现方式"><a href="#事务隔离级别的实现方式" class="headerlink" title="事务隔离级别的实现方式"></a>事务隔离级别的实现方式</h3><p><strong>LBCC</strong>：Lock- Based Concurrent control</p>
<p><strong>MVCC</strong>：Multi-Version Concurrent control</p>
<p>按照InnoDB可以按照两种维度进行锁的划分：1.Lock Mode 2.锁的算法</p>
<p><img src="/2022/10/25/MySQL-%E9%94%81/99.png" alt="截屏2021-09-05 下午7.20.37"></p>
<p><img src="/2022/10/25/MySQL-%E9%94%81/100.png" alt="截屏2021-09-05 下午7.22.48"></p>
<p><img src="/2022/10/25/MySQL-%E9%94%81/101.png" alt="截屏2021-09-05 下午7.24.52"></p>
<h1 id="锁的模式"><a href="#锁的模式" class="headerlink" title="锁的模式"></a>锁的模式</h1><p>Lock Mode ：<strong>共享锁和排它锁属于行锁，意向锁属于表锁</strong>。</p>
<p>对于<strong>UPDATE、DELETE、INSERT</strong>语句，<strong>InnoDB会自动给涉及数据集加排他锁(X)</strong></p>
<p>MyISAM在执行查询语句SELECT前，会自动给涉及的所有表加读锁，在执行<strong>增、删、改</strong>操作前，会自动给涉及的表加写锁，这个过程并不需要用户干预</p>
<p><img src="/2022/10/25/MySQL-%E9%94%81/102.png" alt="截屏2021-09-05 下午7.30.05"></p>
<p>增加读锁的目的是保证当前正在查询的数据不能被修改。</p>
<p><img src="/2022/10/25/MySQL-%E9%94%81/103.png" alt="截屏2021-09-05 下午9.27.36"></p>
<p><img src="/2022/10/25/MySQL-%E9%94%81/104.png" alt="截屏2021-09-05 下午9.34.18"></p>
<p>意向锁是在添加行锁时自动添加的，意向锁为表锁，当我们需要操作整个表时，例如将员工表中员工工资都涨一千元，这个时候肯定全表操作，加表锁，但在加表锁之前首先需要保证里面的数据目前没有正在修改的情况，即没有锁定的资源，如何判断目前没有锁定的资源呢？这个时候就是看是否有意向锁了，如果有意向锁说明目前数据有正在锁定的情况，不能加表锁。如果不通过意向锁判定，就需要一条一条数据判断了，会非常影响效率。</p>
<h2 id="锁的算法"><a href="#锁的算法" class="headerlink" title="锁的算法"></a>锁的算法</h2><p><img src="/2022/10/25/MySQL-%E9%94%81/105.png" alt="截屏2021-09-05 下午9.47.33"></p>
<p><img src="/2022/10/25/MySQL-%E9%94%81/106.png" alt="截屏2021-09-05 下午9.49.09"></p>
<p>对于update精准匹配都会加记录锁，例如<code>update user set age=24 where id=1;</code></p>
<p><img src="/2022/10/25/MySQL-%E9%94%81/107.png" alt="截屏2021-09-05 下午9.56.28"></p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">UPDATE</span> my_table_innodb <span class="keyword">set</span> age<span class="operator">=</span><span class="number">26</span> <span class="keyword">WHERE</span> id<span class="operator">&gt;</span><span class="number">0</span> <span class="keyword">and</span> id<span class="operator">&lt;</span><span class="number">7</span>;</span><br><span class="line"><span class="keyword">COMMIT</span></span><br><span class="line"><span class="keyword">ROLLBACK</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> my_table_innodb <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="string">&#x27;xll&#x27;</span>,<span class="number">23</span>,<span class="number">332</span>,<span class="number">1</span>);<span class="comment">-- 由于前一个事务的间隙锁的存在，因此插入不进去，在一定程度上解决了幻    																													读的问题；</span></span><br><span class="line"><span class="keyword">COMMIT</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/25/MySQL-%E9%94%81/108.png" alt="截屏2021-09-05 下午10.14.40"></p>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p><img src="/2022/10/25/MySQL-%E9%94%81/109.png" alt="截屏2021-09-05 下午10.26.35"></p>
<p><img src="/2022/10/25/MySQL-%E9%94%81/110.png" alt="截屏2021-09-05 下午10.51.09"></p>
<p>innodb引擎会有个事务管理器，会对每个事务都生成一个自增的事务ID，必定会按照生成的事务的顺序递增的，transaction_id,而每行修改的数据都有自己的row trx_id,这个row trx_id继承之transaction_id，因此当事务中行数据修改后，其中快照就是记录当前数据的row trx_id最大值，就是up_limit_id.</p>
<p><img src="/2022/10/25/MySQL-%E9%94%81/111.png" alt="截屏2021-09-05 下午10.55.55"></p>
<p><img src="/2022/10/25/MySQL-%E9%94%81/112.png" alt="截屏2021-09-05 下午11.01.34"></p>
<p>1.当事务C提交了事务，那么此时事务C的row_trx_id&#x3D;1002(图中错误)</p>
<p>2.事务B进行修改时<strong>当事务中进行查询的时候会触发快照读，当进行修改的时候会触发</strong>，会读取当前的事务C提交的数据，最新版本的数据，这个时候再进行修改操作，修改后会记录row_trx_id&#x3D;1001，mysql会记录最新的版本为a ge&#x3D;20 版本为1001</p>
<p>3.事务B再进行读取的时候，会进行版本号比对，发现最新版本的版本号和自己的版本号一致，因此读取最新的版本数据，即为20</p>
<p>4.事务A此时没有提交过数据，会去找mysql中记录此数据的版本号对应，此时事务A中记录的最大版本号为999，因此它会读取版本号为999的数据</p>
<p>扩展知识点：</p>
<p><img src="/2022/10/25/MySQL-%E9%94%81/113.png" alt="截屏2021-09-05 下午11.18.54"></p>
<p>mysql针对于非主键进行加锁，例如这种二级索引都会加间隙锁，因此在进行<code>select * from test1 where number=3 for update;</code>时会进行锁1-3，3-8的数据。</p>
<p><img src="/2022/10/25/MySQL-%E9%94%81/114.png" alt="截屏2021-09-05 下午11.23.07"></p>
<p><img src="/2022/10/25/MySQL-%E9%94%81/115.png" alt="截屏2021-09-05 下午11.28.20"></p>
<p><code>select * from test1</code> 查看执行计划发现是走了number的索引，因此，mysql执行时直接走了覆盖索引，因为走number索引直接拿到全表数据。</p>
<p>幻读<br>首先MySQL事务隔离级别默认是RR（可重复读），但是会导致幻读问题。</p>
<p>幻读是啥？<br>事务A按照一定条件进行数据读取，期间事务B插入了相同搜索条件的新数据，事务A再次按照原先条件进行读取时，发现了事务B 新插入的数据称为幻读。</p>
<p>例如，test表如下：</p>
<table>
<thead>
<tr>
<th>Id</th>
<th>Name</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>11</td>
</tr>
<tr>
<td>2</td>
<td>22</td>
</tr>
</tbody></table>
<p>事务如下：</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>事务1</th>
<th>事务2</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td>select * from test;</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>insert into test value(3,33);</td>
</tr>
<tr>
<td>T4</td>
<td>select * from test;</td>
<td></td>
</tr>
<tr>
<td>T5</td>
<td>update test set name&#x3D;‘333’ where id &#x3D; 3;</td>
<td></td>
</tr>
<tr>
<td>T6</td>
<td>select * from test;</td>
<td></td>
</tr>
<tr>
<td>T7</td>
<td>commit;</td>
<td></td>
</tr>
</tbody></table>
<p>事务1开启事务，select只有两行记录，在T3时刻，事务2插入一条数据并且马上提交，在T4时刻再次select读到与T2时刻一样的数据，到这是没有问题的，满足可重复读。<br>在T5时刻update一条没有的数据，却执行成功了，在T6时刻select却发现多了一个记录，这就出现幻读的现象。</p>
<p>Select…For Update语句的语法与select语句相同，只是在select语句的后面加FOR UPDATE 子句。</p>
<p>该语句用来锁定特定的行（如果有where子句，就是满足where条件的那些行）。当这些行被锁定后，其他会话可以选择这些行，但不能更改或删除这些行，直到该语句的事务被commit语句或rollback语句结束为止。</p>
<p>某个会话使用update 时，会对该行加排他锁，其他会话需要update时都需要等待</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>OLTP</tag>
        <tag>数据库</tag>
        <tag>分库分表</tag>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-阿里巴巴中台战略-数据库分库分表之异构索引表</title>
    <url>/2022/10/25/MySQL-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E4%B8%AD%E5%8F%B0%E6%88%98%E7%95%A5-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B9%8B%E5%BC%82%E6%9E%84%E7%B4%A2%E5%BC%95%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="异构索引表"><a href="#异构索引表" class="headerlink" title="异构索引表"></a><strong>异构索引表</strong></h3><p>基于订单数据的分库分表场景,对订单id取模虽然很好地满足了订单数据均匀地保存在数据库中的需求，但在买家查看自己订单的业务场景中，就出现了全表扫描的情况，买家查看自己订单的请求是非常频繁的，就必然给数据库带来扩展和性能的问题，有违“尽量减少事务边界”这一原则。</p>
<p>针对这类场景问题，最常用的是采用“<strong>异构索引表</strong>”的方式解决，即采用异步机制将原表的每一次创建或更新，都换另一个维度保存一份完整的数据表或索引表。这是另一种解决思路：拿空间换时间。</p>
<p>也就是应用在穿件或更新一条订单ID为分库分表键的订单数据时，也会再保存一份按照买家ID为分库分表键的订单索引数据，其结果就是同一买家的所有订单索引表都保存在同一数据库中，即创建了异构索引表。</p>
<p>这时买家test1在获取订单信息进行页面展示时，应用对于数据库的访问流程就发生了如下图的变化。</p>
<p><img src="/2022/10/25/MySQL-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E4%B8%AD%E5%8F%B0%E6%88%98%E7%95%A5-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B9%8B%E5%BC%82%E6%9E%84%E7%B4%A2%E5%BC%95%E8%A1%A8/1.png" alt="img"></p>
<p>在有了订单索引表后，应用首先会凭借当前买家id(以图中test1为例)，进行如下流程：</p>
<p>·    首先到订单索引表中搜索出test1的所有订单索引表（步骤1），</p>
<p>·    因为步骤2的sql请求中带了以buyer_id的分库分表键，所以一次是效率最高的单库访问，</p>
<p>·    获取到了买家test1的所有订单索引表列表并由DRDS返回到前端应用（步骤3和4），</p>
<p>·    应用在拿到返回的索引列表后，获取到订单id列表（1，5，8），</p>
<p>·    再发送一次获取真正订单列表的请求（步骤5），</p>
<p>·    同样在步骤6的sql语句的条件中带了分库分表键order_id的列表值，所以DRDS可以精确地将此SQL请求发送到对应订单id的数据库中，而不会出现全表扫描的情况。最终通过两次访问效率最高的sql请求代替了之前的需要进行全表扫描的问题。</p>
<p><img src="/2022/10/25/MySQL-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E4%B8%AD%E5%8F%B0%E6%88%98%E7%95%A5-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B9%8B%E5%BC%82%E6%9E%84%E7%B4%A2%E5%BC%95%E8%A1%A8/2.png" alt="img"></p>
<p>·    那么为什么不是将订单的完整数据按照买家id维度进行一次分库保存，这样就只需要进行一次按照买家id维度进行数据库的访问就获取到订单的信息了？</p>
<p>其实淘宝的订单数据就是在异构索引表中全复制的，即订单按照买家id维度进行分库分表的订单索引表跟以订单id维度进行分库分表的订单表中的字段完全一样，这样确实避免了多一次的数据库访问。但一般来说，应用可能会按照多个维度创建多个异构索引表，如果全部采用全复制的方法会带来大量的数据冗余，从而增加不少数据存储成本。</p>
<p>     另外，在某些场景中，在获取主业务的列表时，可能需要依赖此业务表所在数据库的子业务表信息，比如订单示例中的主、子订单，因为是以订单id的维度进行分库分表，所以该订单相关的子订单、订单明细表都会保存在同一个数据库中，如果我们仅仅是对主订单信息进行查询获取包含了子订单信息的订单列表时，就会出现跨库join的问题，其对分布数据层带来的不良影响其实跟之前所说的全表扫描是一样的。所以还是建议采用仅仅做异构索引表的方式，而不是数据全复制。</p>
<p>     实现对数据的异构索引创建有多种实现方式，</p>
<p>\1.  一种是数据库层采用数据复制的方式实现；</p>
<p>\2.  另一种是如图所示，在应用层实现，在这一层实现异构索引数据的创建，就必然会带来分布式事务的问题。另一种是如图所示，在应用层实现，在这一层实现异构索引数据的创建，就必然会带来分布式事务的问题。</p>
<p><img src="/2022/10/25/MySQL-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E4%B8%AD%E5%8F%B0%E6%88%98%E7%95%A5-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B9%8B%E5%BC%82%E6%9E%84%E7%B4%A2%E5%BC%95%E8%A1%A8/3.png" alt="img"></p>
<p>这里给大家介绍的是目前阿里内部使用的方式，命名为精卫（精卫填海）。精卫是一个基于Mysql的实时数据复制框架，也可以认为是一个Mysql的数据触发器+分发管道。</p>
<p>精卫通过抽取器（Extractor）获取到订单数据创建在Mysql数据库中产生的binlog日志，并转换为event对象，然后通过过滤器Filter（比如字段过滤、转换等）或基于接口自定义开发的过滤对event对象中的数据进行处理，最终对分发器Applier将结果转换为发给DRDS的sql语句。通过精卫实现异构索引数据的过程如图</p>
<p><img src="/2022/10/25/MySQL-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E4%B8%AD%E5%8F%B0%E6%88%98%E7%95%A5-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B9%8B%E5%BC%82%E6%9E%84%E7%B4%A2%E5%BC%95%E8%A1%A8/4.png" alt="img"></p>
<h4 id="多线程管道实现"><a href="#多线程管道实现" class="headerlink" title="多线程管道实现"></a><strong>多线程管道实现</strong></h4><p>     在精卫早期，数据的同步均采用单线程管道任务模式。但是随着业务的发展，需要同步的数据量越来越大，单纯的单线程管道任务已成为系统瓶颈，后来开发了对多线程的支持。</p>
<p>     但多线程管道就会带来数据同步的问题。在对binlog数据进行多线程并行处理后，就不能保证在源数据库中执行的SQL语句在目标数据库的顺序一致，这样在某些场景中一定会出现数据不一致性的问题。对于这个问题，目前精卫中提供的解决思路是保证同一条记录或针对同一分库分表发生的数据同步按照顺序执行。</p>
<p>     如果最后发送到分布式数据层的SQL语句中没有分库分表键，则通过对“库名+表名+主键值”哈希后对线程数取模，这样就能让同一条记录的数据同步事件处理都会在同一线程中顺序执行，保证了该记录多次变更的顺序性，但是不能保证不同记录间的顺序。如果sql语句中有分库键，则通过“库名+分库键值”哈希后对线程取模，效果是保证不同逻辑表针对相同分库逻辑的记录变化顺序。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>OLTP</tag>
        <tag>数据库</tag>
        <tag>分库分表</tag>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-基础总结</title>
    <url>/2022/10/25/MySQL-%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="一、为什么要学习数据库"><a href="#一、为什么要学习数据库" class="headerlink" title="一、为什么要学习数据库"></a>一、为什么要学习数据库</h2><p>数据库的好处<br>    1.持久化数据到本地<br>    2.可以实现结构化查询，方便管理</p>
<h2 id="二、数据库的相关概念"><a href="#二、数据库的相关概念" class="headerlink" title="二、数据库的相关概念"></a>二、数据库的相关概念</h2><pre><code>1、DB：数据库，保存一组有组织的数据的容器
2、DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据
3、SQL:结构化查询语言，用于和DBMS通信的语言
</code></pre>
<h2 id="三、数据库存储数据的特点"><a href="#三、数据库存储数据的特点" class="headerlink" title="三、数据库存储数据的特点"></a>三、数据库存储数据的特点</h2><pre><code>1、将数据放到表中，表再放到库中
2、一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。
3、表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。
4、表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性”
5、表中的数据是按行存储的，每一行类似于java中的“对象”。
</code></pre>
<h2 id="四、初始MySQL"><a href="#四、初始MySQL" class="headerlink" title="四、初始MySQL"></a>四、初始MySQL</h2><h3 id="MySQL产品的介绍"><a href="#MySQL产品的介绍" class="headerlink" title="MySQL产品的介绍"></a>MySQL产品的介绍</h3><h3 id="MySQL产品的安装"><a href="#MySQL产品的安装" class="headerlink" title="MySQL产品的安装"></a>MySQL产品的安装</h3><h3 id="MySQL服务的启动和停止"><a href="#MySQL服务的启动和停止" class="headerlink" title="MySQL服务的启动和停止"></a>MySQL服务的启动和停止</h3><pre><code>方式一：计算机——右击管理——服务
方式二：通过管理员身份运行
net start 服务名（启动服务）
net stop 服务名（停止服务）
</code></pre>
<h3 id="MySQL服务的登录和退出"><a href="#MySQL服务的登录和退出" class="headerlink" title="MySQL服务的登录和退出"></a>MySQL服务的登录和退出</h3><pre><code>方式一：通过mysql自带的客户端
只限于root用户

方式二：通过windows自带的客户端
登录：
    mysql 【-h主机名 -P端口号 】-u用户名 -p密码

退出：
    exit或ctrl+C
</code></pre>
<h3 id="MySQL的常见命令和语法规范"><a href="#MySQL的常见命令和语法规范" class="headerlink" title="MySQL的常见命令和语法规范"></a>MySQL的常见命令和语法规范</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.查看当前所有的数据库</span><br><span class="line">show databases;</span><br><span class="line">2.打开指定的库</span><br><span class="line">use 库名</span><br><span class="line">3.查看当前库的所有表</span><br><span class="line"></span><br><span class="line">show tables;</span><br><span class="line">4.查看其它库的所有表</span><br><span class="line">show tables from 库名;</span><br><span class="line">5.创建表</span><br><span class="line">create table 表名(</span><br><span class="line"></span><br><span class="line">	列名 列类型,</span><br><span class="line">	列名 列类型，</span><br><span class="line">	。。。</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">6.查看表结构</span><br><span class="line">desc 表名;</span><br><span class="line"></span><br><span class="line">7.查看服务器的版本</span><br><span class="line">方式一：登录到mysql服务端</span><br><span class="line">select version();</span><br><span class="line">方式二：没有登录到mysql服务端</span><br><span class="line">mysql --version</span><br><span class="line">或</span><br><span class="line">mysql --V</span><br><span class="line"></span><br><span class="line">MySQL的语法规范</span><br><span class="line">	1.不区分大小写,但建议关键字大写，表名、列名小写</span><br><span class="line">	2.每条命令最好用分号结尾</span><br><span class="line">	3.每条命令根据需要，可以进行缩进 或换行</span><br><span class="line">	4.注释</span><br><span class="line">		单行注释：#注释文字</span><br><span class="line">		单行注释：-- 注释文字</span><br><span class="line">		多行注释：/* 注释文字  */</span><br><span class="line">	</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h2 id="五、DQL语言的学习"><a href="#五、DQL语言的学习" class="headerlink" title="五、DQL语言的学习"></a>五、DQL语言的学习</h2><h2 id><a href="#" class="headerlink" title></a></h2><h4 id="SQL的语言分类"><a href="#SQL的语言分类" class="headerlink" title="SQL的语言分类"></a>SQL的语言分类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DQL（Data Query Language）：数据查询语言</span><br><span class="line">		select </span><br><span class="line">	DML(Data Manipulate Language):数据操作语言</span><br><span class="line">		insert 、update、delete</span><br><span class="line">	DDL（Data Define Languge）：数据定义语言</span><br><span class="line">		create、drop、alter</span><br><span class="line">	TCL（Transaction Control Language）：事务控制语言</span><br><span class="line">		commit、rollback</span><br></pre></td></tr></table></figure>

<h4 id="SQL的常见命令"><a href="#SQL的常见命令" class="headerlink" title="SQL的常见命令"></a>SQL的常见命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show databases； 查看所有的数据库</span><br><span class="line">use 库名； 打开指定 的库</span><br><span class="line">show tables ; 显示库中的所有表</span><br><span class="line">show tables from 库名;显示指定库中的所有表</span><br><span class="line">create table 表名(</span><br><span class="line">	字段名 字段类型,	</span><br><span class="line">	字段名 字段类型</span><br><span class="line">); 创建表</span><br><span class="line"></span><br><span class="line">desc 表名; 查看指定表的结构</span><br><span class="line">select * from 表名;显示表中的所有数据</span><br></pre></td></tr></table></figure>



<h3 id="进阶1：基础查询"><a href="#进阶1：基础查询" class="headerlink" title="进阶1：基础查询"></a>进阶1：基础查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">	SELECT 要查询的东西</span><br><span class="line">	【FROM 表名】;</span><br></pre></td></tr></table></figure>

<pre><code>类似于Java中 :System.out.println(要打印的东西);
特点：
①通过select查询完的结果 ，是一个虚拟的表格，不是真实存在
② 要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数
</code></pre>
<h3 id="进阶2：条件查询"><a href="#进阶2：条件查询" class="headerlink" title="进阶2：条件查询"></a>进阶2：条件查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">条件查询：根据条件过滤原始表的数据，查询到想要的数据</span><br><span class="line">	语法：</span><br><span class="line">	select </span><br><span class="line">		要查询的字段|表达式|常量值|函数</span><br><span class="line">	from </span><br><span class="line">		表</span><br><span class="line">	where </span><br><span class="line">		条件 ;</span><br></pre></td></tr></table></figure>



<pre><code>分类：
一、条件表达式
    示例：salary&gt;10000
    条件运算符：
    &gt; &lt; &gt;= &lt;= = != &lt;&gt;

二、逻辑表达式
示例：salary&gt;10000 &amp;&amp; salary&lt;20000

逻辑运算符：

    and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false
    or(||)：两个条件只要有一个成立，结果为true，否则为false
    not(!)：如果条件成立，则not后为false，否则为true

三、模糊查询
示例：last_name like &#39;a%&#39;
</code></pre>
<h3 id="进阶3：排序查询"><a href="#进阶3：排序查询" class="headerlink" title="进阶3：排序查询"></a>进阶3：排序查询</h3><pre><code>语法：
select
    要查询的东西
from
    表
where 
    条件

order by 排序的字段|表达式|函数|别名 【asc|desc】
</code></pre>
<p>​	</p>
<h3 id="进阶4：常见函数"><a href="#进阶4：常见函数" class="headerlink" title="进阶4：常见函数"></a>进阶4：常见函数</h3><h4 id="一、单行函数"><a href="#一、单行函数" class="headerlink" title="一、单行函数"></a>一、单行函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、字符函数</span><br><span class="line">	concat拼接</span><br><span class="line">	substr截取子串</span><br><span class="line">	upper转换成大写</span><br><span class="line">	lower转换成小写</span><br><span class="line">	trim去前后指定的空格和字符</span><br><span class="line">	ltrim去左边空格</span><br><span class="line">	rtrim去右边空格</span><br><span class="line">	replace替换</span><br><span class="line">	lpad左填充</span><br><span class="line">	rpad右填充</span><br><span class="line">	instr返回子串第一次出现的索引</span><br><span class="line">	length 获取字节个数</span><br><span class="line">	</span><br><span class="line">2、数学函数</span><br><span class="line">	round 四舍五入</span><br><span class="line">	rand 随机数</span><br><span class="line">	floor向下取整</span><br><span class="line">	ceil向上取整</span><br><span class="line">	mod取余</span><br><span class="line">	truncate截断</span><br><span class="line">3、日期函数</span><br><span class="line">	now当前系统日期+时间</span><br><span class="line">	curdate当前系统日期</span><br><span class="line">	curtime当前系统时间</span><br><span class="line">	str_to_date 将字符转换成日期</span><br><span class="line">	date_format将日期转换成字符</span><br><span class="line">4、流程控制函数</span><br><span class="line">	if 处理双分支</span><br><span class="line">	case语句 处理多分支</span><br><span class="line">		情况1：处理等值判断</span><br><span class="line">		情况2：处理条件判断</span><br><span class="line">5、其他函数</span><br><span class="line">	version版本</span><br><span class="line">	database当前库</span><br><span class="line">	user当前连接用户</span><br></pre></td></tr></table></figure>

<p>​	</p>
<h4 id="二、分组函数"><a href="#二、分组函数" class="headerlink" title="二、分组函数"></a>二、分组函数</h4><pre><code>    sum 求和
    max 最大值
    min 最小值
    avg 平均值
    count 计数

    特点：
    1、以上五个分组函数都忽略null值，除了count(*)
    2、sum和avg一般用于处理数值型
        max、min、count可以处理任何数据类型
    3、都可以搭配distinct使用，用于统计去重后的结果
    4、count的参数可以支持：
        字段、*、常量值，一般放1

       建议使用 count(*)
</code></pre>
<h3 id="进阶5：分组查询"><a href="#进阶5：分组查询" class="headerlink" title="进阶5：分组查询"></a>进阶5：分组查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">	select 查询的字段，分组函数</span><br><span class="line">	from 表</span><br><span class="line">	group by 分组的字段</span><br></pre></td></tr></table></figure>

<pre><code>特点：
1、可以按单个字段分组
2、和分组函数一同查询的字段最好是分组后的字段！！！！
3、分组筛选
            针对的表		位置					关键字
分组前筛选：	原始表			group by的前面			where
分组后筛选：	分组后的结果集		group by的后面		 having

4、可以按多个字段分组，字段之间用逗号隔开
5、可以支持排序
6、having后可以支持别名
</code></pre>
<h3 id="进阶6：多表连接查询"><a href="#进阶6：多表连接查询" class="headerlink" title="进阶6：多表连接查询"></a>进阶6：多表连接查询</h3><pre><code>笛卡尔乘积：如果连接条件省略或无效则会出现
解决办法：添加上连接条件
</code></pre>
<h4 id="一、传统模式下的连接-：等值连接——非等值连接"><a href="#一、传统模式下的连接-：等值连接——非等值连接" class="headerlink" title="一、传统模式下的连接 ：等值连接——非等值连接"></a>一、传统模式下的连接 ：等值连接——非等值连接</h4><pre><code>1.等值连接的结果 = 多个表的交集
2.n表连接，至少需要n-1个连接条件
3.多个表不分主次，没有顺序要求
4.一般为表起别名，提高阅读性和性能
</code></pre>
<h4 id="二、sql99语法：通过join关键字实现连接"><a href="#二、sql99语法：通过join关键字实现连接" class="headerlink" title="二、sql99语法：通过join关键字实现连接"></a>二、sql99语法：通过join关键字实现连接</h4><pre><code>含义：1999年推出的sql语法
支持：
等值连接、非等值连接 （内连接）
外连接
交叉连接

语法：

select 字段，...
from 表1
【inner|left outer|right outer|cross】join 表2 on  连接条件
【inner|left outer|right outer|cross】join 表3 on  连接条件
【where 筛选条件】
【group by 分组字段】
【having 分组后的筛选条件】
【order by 排序的字段或表达式】

好处：语句上，连接条件和筛选条件实现了分离，简洁明了！
</code></pre>
<h4 id="三、自连接"><a href="#三、自连接" class="headerlink" title="三、自连接"></a>三、自连接</h4><h5 id="案例：查询员工名和直接上级的名称"><a href="#案例：查询员工名和直接上级的名称" class="headerlink" title="案例：查询员工名和直接上级的名称"></a>案例：查询员工名和直接上级的名称</h5><h5 id="sql99"><a href="#sql99" class="headerlink" title="sql99"></a>sql99</h5><pre><code>SELECT e.last_name,m.last_name
FROM employees e
JOIN employees m 
ON e.`manager_id`=m.`employee_id`;
</code></pre>
<h5 id="sql92"><a href="#sql92" class="headerlink" title="sql92"></a>sql92</h5><pre><code>SELECT e.last_name,m.last_name
FROM employees e,employees m 
WHERE e.`manager_id`=m.`employee_id`;
</code></pre>
<h3 id="进阶7：子查询"><a href="#进阶7：子查询" class="headerlink" title="进阶7：子查询"></a>进阶7：子查询</h3><p>含义：</p>
<pre><code>一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询
在外面的查询语句，称为主查询或外查询
</code></pre>
<p>特点：</p>
<pre><code>1、子查询都放在小括号内
2、子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧
3、子查询优先于主查询执行，主查询使用了子查询的执行结果
4、子查询根据查询结果的行数不同分为以下两类：
① 单行子查询
    结果集只有一行
    一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;= 
    非法使用子查询的情况：
    a、子查询的结果为一组值
    b、子查询的结果为空
    
② 多行子查询
    结果集有多行
    一般搭配多行操作符使用：any、all、in、not in
    in： 属于子查询结果中的任意一个就行
    any和all往往可以用其他查询代替
</code></pre>
<h5 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h5><h5 id="1-标量子查询★"><a href="#1-标量子查询★" class="headerlink" title="1.标量子查询★"></a>1.标量子查询★</h5><h5 id="案例1：谁的工资比-Abel-高"><a href="#案例1：谁的工资比-Abel-高" class="headerlink" title="案例1：谁的工资比 Abel 高?"></a>案例1：谁的工资比 Abel 高?</h5><pre><code>①查询Abel的工资
SELECT salary
FROM employees
WHERE last_name = &#39;Abel&#39;

②查询员工的信息，满足 salary&gt;①结果
SELECT *
FROM employees
WHERE salary&gt;(

    SELECT salary
    FROM employees
    WHERE last_name = &#39;Abel&#39;

);  
</code></pre>
<h5 id="案例2：返回job-id与141号员工相同，salary比143号员工多的员工-姓名，job-id-和工资"><a href="#案例2：返回job-id与141号员工相同，salary比143号员工多的员工-姓名，job-id-和工资" class="headerlink" title="案例2：返回job_id与141号员工相同，salary比143号员工多的员工 姓名，job_id 和工资"></a>案例2：返回job_id与141号员工相同，salary比143号员工多的员工 姓名，job_id 和工资</h5><pre><code>①查询141号员工的job_id
SELECT job_id
FROM employees
WHERE employee_id = 141

②查询143号员工的salary
SELECT salary
FROM employees
WHERE employee_id = 143

③查询员工的姓名，job_id 和工资，要求job_id=①并且salary&gt;②

SELECT last_name,job_id,salary
FROM employees
WHERE job_id = (
    SELECT job_id
    FROM employees
    WHERE employee_id = 141
) AND salary&gt;(
    SELECT salary
    FROM employees
    WHERE employee_id = 143

);
</code></pre>
<h5 id="2-列子查询（多行子查询）★"><a href="#2-列子查询（多行子查询）★" class="headerlink" title="2.列子查询（多行子查询）★"></a>2.列子查询（多行子查询）★</h5><h5 id="案例1：返回其它工种中比job-id为‘IT-PROG’工种任一工资低的员工的员工号、姓名、job-id-以及salary"><a href="#案例1：返回其它工种中比job-id为‘IT-PROG’工种任一工资低的员工的员工号、姓名、job-id-以及salary" class="headerlink" title="案例1：返回其它工种中比job_id为‘IT_PROG’工种任一工资低的员工的员工号、姓名、job_id 以及salary"></a>案例1：返回其它工种中比job_id为‘IT_PROG’工种任一工资低的员工的员工号、姓名、job_id 以及salary</h5><pre><code>①查询job_id为‘IT_PROG’部门任一工资

SELECT DISTINCT salary
FROM employees
WHERE job_id = &#39;IT_PROG&#39;

②查询员工号、姓名、job_id 以及salary，salary&lt;(①)的任意一个
SELECT last_name,employee_id,job_id,salary
FROM employees
WHERE salary&lt;ANY(
    SELECT DISTINCT salary
    FROM employees
    WHERE job_id = &#39;IT_PROG&#39;

) AND job_id&lt;&gt;&#39;IT_PROG&#39;;

或
SELECT last_name,employee_id,job_id,salary
FROM employees
WHERE salary&lt;(
    SELECT MAX(salary)
    FROM employees
    WHERE job_id = &#39;IT_PROG&#39;

) AND job_id&lt;&gt;&#39;IT_PROG&#39;;
</code></pre>
<h5 id="3、行子查询（结果集一行多列或多行多列）"><a href="#3、行子查询（结果集一行多列或多行多列）" class="headerlink" title="3、行子查询（结果集一行多列或多行多列）"></a>3、行子查询（结果集一行多列或多行多列）</h5><h5 id="案例：查询员工编号最小并且工资最高的员工信息"><a href="#案例：查询员工编号最小并且工资最高的员工信息" class="headerlink" title="案例：查询员工编号最小并且工资最高的员工信息"></a>案例：查询员工编号最小并且工资最高的员工信息</h5><pre><code>SELECT * 
FROM employees
WHERE (employee_id,salary)=(
    SELECT MIN(employee_id),MAX(salary)
    FROM employees
);
</code></pre>
<h4 id="二、select后面"><a href="#二、select后面" class="headerlink" title="二、select后面"></a>二、select后面</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">仅仅支持标量子查询</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h4 id="案例：查询每个部门的员工个数"><a href="#案例：查询每个部门的员工个数" class="headerlink" title="案例：查询每个部门的员工个数"></a>案例：查询每个部门的员工个数</h4><p>案例：查询每个部门的员工个数</p>
<pre><code>SELECT d.*,(

    SELECT COUNT(*)
    FROM employees e
    WHERE e.department_id = d.`department_id`
 ) 个数
 FROM departments d;
</code></pre>
<h4 id="三、exists后面（相关子查询）"><a href="#三、exists后面（相关子查询）" class="headerlink" title="三、exists后面（相关子查询）"></a>三、exists后面（相关子查询）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">语法：</span><br><span class="line">exists(完整的查询语句)</span><br><span class="line">结果：</span><br><span class="line">1或0</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>



<pre><code>SELECT EXISTS(SELECT employee_id FROM employees WHERE salary=300000);
</code></pre>
<h3 id="进阶8：分页查询"><a href="#进阶8：分页查询" class="headerlink" title="进阶8：分页查询"></a>进阶8：分页查询</h3><p>应用场景：</p>
<pre><code>实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句
</code></pre>
<p>语法：</p>
<pre><code>select 字段|表达式,...
from 表
【where 条件】
【group by 分组字段】
【having 条件】
【order by 排序的字段】
limit 【起始的条目索引，】条目数;
</code></pre>
<p>特点：</p>
<pre><code>1.起始条目索引从0开始

2.limit子句放在查询语句的最后

3.公式：select * from  表 limit （page-1）*sizePerPage,sizePerPage
假如:
每页显示条目数sizePerPage
要显示的页数 page
</code></pre>
<h3 id="进阶9：联合查询"><a href="#进阶9：联合查询" class="headerlink" title="进阶9：联合查询"></a>进阶9：联合查询</h3><p>引入：<br>    union 联合、合并</p>
<p>语法：</p>
<pre><code>select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】
select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】
select 字段|常量|表达式|函数 【from 表】 【where 条件】 union  【all】
.....
select 字段|常量|表达式|函数 【from 表】 【where 条件】
</code></pre>
<p>特点：</p>
<pre><code>1、多条查询语句的查询的列数必须是一致的
2、多条查询语句的查询的列的类型几乎相同
3、union代表去重，union all代表不去重
</code></pre>
<h2 id="六、DML语言的学习"><a href="#六、DML语言的学习" class="headerlink" title="六、DML语言的学习"></a>六、DML语言的学习</h2><h3 id="插入语句"><a href="#插入语句" class="headerlink" title="插入语句"></a>插入语句</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">	insert into 表名(字段名，...)</span><br><span class="line">	values(值1，...);</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<pre><code>1、字段类型和值类型一致或兼容，而且一一对应
2、可以为空的字段，可以不用插入值，或用null填充
3、不可以为空的字段，必须插入值
4、字段个数和值的个数必须一致
5、字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致
</code></pre>
<h3 id="修改语句"><a href="#修改语句" class="headerlink" title="修改语句"></a>修改语句</h3><pre><code>修改单表语法：
update 表名 set 字段=新值,字段=新值
【where 条件】
修改多表语法：
update 表1 别名1,表2 别名2
set 字段=新值，字段=新值
where 连接条件
and 筛选条件
</code></pre>
<h3 id="删除语句"><a href="#删除语句" class="headerlink" title="删除语句"></a>删除语句</h3><h4 id="方式1：delete语句"><a href="#方式1：delete语句" class="headerlink" title="方式1：delete语句"></a>方式1：delete语句</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单表的删除： ★</span><br><span class="line">	delete from 表名 【where 筛选条件】</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">多表的删除：</span><br><span class="line">	delete 别名1，别名2</span><br><span class="line">	from 表1 别名1，表2 别名2</span><br><span class="line">	where 连接条件</span><br><span class="line">	and 筛选条件;</span><br></pre></td></tr></table></figure>

<h4 id="方式2：truncate语句"><a href="#方式2：truncate语句" class="headerlink" title="方式2：truncate语句"></a>方式2：truncate语句</h4><pre><code>truncate table 表名
</code></pre>
<h4 id="两种方式的区别【面试题】"><a href="#两种方式的区别【面试题】" class="headerlink" title="两种方式的区别【面试题】"></a>两种方式的区别【面试题】</h4><pre><code>1.truncate不能加where条件，而delete可以加where条件
2.truncate的效率高一丢丢
3.truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始
    delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始
4.truncate删除不能回滚，delete删除可以回滚
</code></pre>
<h2 id="七、DDL语言的学习"><a href="#七、DDL语言的学习" class="headerlink" title="七、DDL语言的学习"></a>七、DDL语言的学习</h2><h3 id="库和表的管理"><a href="#库和表的管理" class="headerlink" title="库和表的管理"></a>库和表的管理</h3><h4 id="库的管理："><a href="#库的管理：" class="headerlink" title="库的管理："></a>库的管理：</h4><pre><code>一、创建库
create database 库名
二、删除库
drop database 库名
</code></pre>
<h4 id="表的管理："><a href="#表的管理：" class="headerlink" title="表的管理："></a>表的管理：</h4><h5 id="1-创建表"><a href="#1-创建表" class="headerlink" title="1.创建表"></a>1.创建表</h5><pre><code>CREATE TABLE IF NOT EXISTS stuinfo(
    stuId INT,
    stuName VARCHAR(20),
    gender CHAR,
    bornDate DATETIME
);
DESC studentinfo;
</code></pre>
<h5 id="2-修改表-alter"><a href="#2-修改表-alter" class="headerlink" title="2.修改表 alter"></a>2.修改表 alter</h5><pre><code>语法：ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;

①修改字段名
ALTER TABLE studentinfo CHANGE  COLUMN sex gender CHAR;

②修改表名
ALTER TABLE stuinfo RENAME [TO]  studentinfo;

③修改字段类型和列级约束
ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;

④添加字段
ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20) first;

⑤删除字段
ALTER TABLE studentinfo DROP COLUMN email;
</code></pre>
<p>​	</p>
<h5 id="3-删除表"><a href="#3-删除表" class="headerlink" title="3.删除表"></a>3.删除表</h5><pre><code>DROP TABLE [IF EXISTS] studentinfo;
</code></pre>
<h5 id="4-复制表"><a href="#4-复制表" class="headerlink" title="4.复制表"></a>4.复制表</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.仅仅复制表的结构</span><br><span class="line">	CREATE TABLE 新表名 LIKE 旧表名;</span><br><span class="line"></span><br><span class="line">2.复制表的结构+数据</span><br><span class="line">	CREATE TABLE 新表名 </span><br><span class="line">	SELECT * FROM 旧表名;</span><br><span class="line"></span><br><span class="line">3.只复制部分数据</span><br><span class="line">	CREATE TABLE 新表名</span><br><span class="line">	SELECT id,au_name</span><br><span class="line">	FROM 旧表名 </span><br><span class="line">	WHERE nation=&#x27;中国&#x27;;</span><br><span class="line">	</span><br><span class="line">4.仅仅复制某些字段</span><br><span class="line">	CREATE TABLE 新表名 </span><br><span class="line">	SELECT id,au_name</span><br><span class="line">	FROM 旧表名</span><br><span class="line">	WHERE 0;</span><br></pre></td></tr></table></figure>



<h3 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h3><pre><code>整型：	  Tinyint 1个字节
        Smallint 2个字节
        Mediumint 3个字节
        Int、Integer 4个字节
        Bigint   8个字节
特点：
① 如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字
② 如果插入的数值超出了整型的范围,会报out of range异常，并且插入临界值
③ 如果不设置长度，会有默认的长度
长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用！

小数：
    分类：
    1.浮点型
    float(M,D)
    double(M,D)
    2.定点型
    dec(M，D)
    decimal(M,D)
    
    特点：
    
    ①
    M：整数部位+小数部位
    D：小数部位
    如果超过范围，则插入临界值
    
    ②
    M和D都可以省略
    如果是decimal，则M默认为10，D默认为0
    如果是float和double，则会根据插入的数值的精度来决定精度
    
    ③定点型的精确度较高，如果要求插入数值的精度较高如货币运算等则考虑使用

字符型：
特点：
        写法			M的意思							特点			空间的耗费		效率
char	char(M)		最大的字符数，可以省略，默认为1	固定长度的字符		比较耗费		   高
varchar varchar(M)	最大的字符数，不可以省略		可变长度的字符			比较节省		  低


日期型：
分类：
    date只保存日期
    time 只保存时间
    year只保存年
    
    datetime保存日期+时间
    timestamp保存日期+时间
特点：
            字节		范围		              时区等的影响
datetime    8		1000——9999	                  不受
timestamp	4	    1970-2038	                    受
</code></pre>
<p>​	</p>
<h3 id="常见约束"><a href="#常见约束" class="headerlink" title="常见约束"></a>常见约束</h3><pre><code>NOT NULL
DEFAULT
UNIQUE
CHECK
PRIMARY KEY
FOREIGN KEY
分类：六大约束
    NOT NULL：非空，用于保证该字段的值不能为空
    比如姓名、学号等
    DEFAULT:默认，用于保证该字段有默认值
    比如性别
    PRIMARY KEY:主键，用于保证该字段的值具有唯一性，并且非空
    比如学号、员工编号等
    UNIQUE:唯一，用于保证该字段的值具有唯一性，可以为空
    比如座位号
    CHECK:检查约束【mysql中不支持】
    比如年龄、性别
    FOREIGN KEY:外键，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值
        在从表添加外键约束，用于引用主表中某列的值
    比如学生表的专业编号，员工表的部门编号，员工表的工种编号
</code></pre>
<p>​	</p>
<pre><code>添加约束的时机：
        1.创建表时
        2.修改表时
        
约束的添加分类：
    列级约束：
            六大约束语法上都支持，但外键约束没有效果
    表级约束：
            除了非空、默认，其他的都支持
</code></pre>
<p>​			</p>
<h5 id="主键和唯一的大对比："><a href="#主键和唯一的大对比：" class="headerlink" title="主键和唯一的大对比："></a>主键和唯一的大对比：</h5><pre><code>        保证唯一性  是否允许为空    一个表中可以有多少个   是否允许组合
    主键	√		    ×				至多有1个           √，但不推荐
    唯一	√			√				可以有多个          √，但不推荐
外键：
    1、要求在从表设置外键关系
    2、从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求
    3、主表的关联列必须是一个key（一般是主键或唯一）
    4、插入数据时，先插入主表，再插入从表
        删除数据时，先删除从表，再删除主表
</code></pre>
<p>​	</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看stuinfo中的所有索引，包括主键、外键、唯一</span><br><span class="line">SHOW INDEX FROM stuinfo;</span><br></pre></td></tr></table></figure>

<h5 id="2-添加表级约束"><a href="#2-添加表级约束" class="headerlink" title="2.添加表级约束"></a>2.添加表级约束</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">语法：在各个字段的最下面</span><br><span class="line"> 【constraint 约束名】 约束类型(字段名) </span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<pre><code>DROP TABLE IF EXISTS stuinfo;
CREATE TABLE stuinfo(
    id INT,
    stuname VARCHAR(20),
    gender CHAR(1),
    seat INT,
    age INT,
    majorid INT,
CONSTRAINT pk PRIMARY KEY(id),#主键
CONSTRAINT uq UNIQUE(seat),#唯一键
CONSTRAINT ck CHECK(gender =&#39;男&#39; OR gender  = &#39;女&#39;),#检查
CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)#外键
);
</code></pre>
<h5 id="二、修改表时添加约束"><a href="#二、修改表时添加约束" class="headerlink" title="二、修改表时添加约束"></a>二、修改表时添加约束</h5><pre><code>1、添加列级约束
alter table 表名 modify column 字段名 字段类型 新约束;

2、添加表级约束
alter table 表名 add 【constraint 约束名】 约束类型(字段名) 【外键的引用】;	*/
    1.添加非空约束
    ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20)  NOT NULL;
    2.添加默认约束
    ALTER TABLE stuinfo MODIFY COLUMN age INT DEFAULT 18;
3.添加主键
    ①列级约束
    ALTER TABLE stuinfo MODIFY COLUMN id INT PRIMARY KEY;
    ②表级约束
    ALTER TABLE stuinfo ADD PRIMARY KEY(id);
    
4.添加唯一
①列级约束
ALTER TABLE stuinfo MODIFY COLUMN seat INT UNIQUE;
②表级约束
ALTER TABLE stuinfo ADD UNIQUE(seat);

5.添加外键
ALTER TABLE stuinfo ADD CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id); 
</code></pre>
<p>​	</p>
<h5 id="三、修改表时删除约束"><a href="#三、修改表时删除约束" class="headerlink" title="三、修改表时删除约束"></a>三、修改表时删除约束</h5><pre><code>1.删除非空约束
ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NULL;

2.删除默认约束
ALTER TABLE stuinfo MODIFY COLUMN age INT ;

3.删除主键
ALTER TABLE stuinfo DROP PRIMARY KEY;

4.删除唯一
ALTER TABLE stuinfo DROP INDEX seat;

5.删除外键
ALTER TABLE stuinfo DROP FOREIGN KEY fk_stuinfo_major;

SHOW INDEX FROM stuinfo;
</code></pre>
<h5 id="标识列"><a href="#标识列" class="headerlink" title="标识列"></a>标识列</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">又称为自增长列</span><br><span class="line">含义：可以不用手动的插入值，系统提供默认的序列值</span><br><span class="line">	特点：</span><br><span class="line">	1、标识列必须和主键搭配吗？不一定，但要求是一个key</span><br><span class="line">	2、一个表可以有几个标识列？至多一个！</span><br><span class="line">	3、标识列的类型只能是数值型</span><br><span class="line">	4、标识列可以通过 SET auto_increment_increment=3;设置步长</span><br><span class="line">		可以通过 手动插入值，设置起始值</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	*/</span><br></pre></td></tr></table></figure>



<h2 id="八、TCL语言的学习"><a href="#八、TCL语言的学习" class="headerlink" title="八、TCL语言的学习"></a>八、TCL语言的学习</h2><h3 id="事务和事务处理"><a href="#事务和事务处理" class="headerlink" title="事务和事务处理"></a>事务和事务处理</h3><h4 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h4><h5 id="含义"><a href="#含义" class="headerlink" title="含义:"></a>含义:</h5><pre><code>通过一组逻辑操作单元（一组DML——sql语句），将数据从一种状态切换到另外一种状态
</code></pre>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（ACID）</span><br><span class="line">	原子性：要么都执行，要么都回滚</span><br><span class="line">	一致性：保证数据的状态操作前和操作后保持一致</span><br><span class="line">	隔离性：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰</span><br><span class="line">	持久性：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改</span><br></pre></td></tr></table></figure>

<h5 id="相关步骤："><a href="#相关步骤：" class="headerlink" title="相关步骤："></a>相关步骤：</h5><pre><code>1、开启事务
2、编写事务的一组逻辑操作单元（多条sql语句）
3、提交事务或回滚事务
</code></pre>
<h5 id="事务的分类："><a href="#事务的分类：" class="headerlink" title="事务的分类："></a>事务的分类：</h5><pre><code>一、隐式事务，没有明显的开启和结束事务的标志
比如
insert、update、delete语句本身就是一个事务

二、显式事务，具有明显的开启和结束事务的标志
        1、开启事务
            取消自动提交事务的功能

        2、编写事务的一组逻辑操作单元（多条sql语句）
            insert
            update
            delete
    
        3、提交事务或回滚事务
</code></pre>
<h5 id="使用到的关键字："><a href="#使用到的关键字：" class="headerlink" title="使用到的关键字："></a>使用到的关键字：</h5><pre><code>set autocommit=0;
start transaction;
commit;
rollback;

savepoint  断点
commit to 断点
rollback to 断点
</code></pre>
<h5 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别:"></a>事务的隔离级别:</h5><h5 id="事务并发问题如何发生？"><a href="#事务并发问题如何发生？" class="headerlink" title="事务并发问题如何发生？"></a>事务并发问题如何发生？</h5><pre><code>当多个事务同时操作同一个数据库的相同数据时
</code></pre>
<h5 id="事务的并发问题有哪些？"><a href="#事务的并发问题有哪些？" class="headerlink" title="事务的并发问题有哪些？"></a>事务的并发问题有哪些？</h5><pre><code>脏读：一个事务读取到了另外一个事务未提交的数据
不可重复读：同一个事务中，多次读取到的数据不一致（因为中间有进程修改了值并且提交）
幻读：事务A 按照一定条件进行数据读取，期间事务B 插入了相同搜索条件的新数据，事务A再次按照原先条件进行读取时，发现了事务B 新插入的数据称为幻读
    如果事务A 按一定条件搜索 期间事务B 删除了符合条件的某一条数据，导致事务A 再次读取时数据少了一条。这种情况归为 不可重复读
</code></pre>
<h5 id="如何避免事务的并发问题？"><a href="#如何避免事务的并发问题？" class="headerlink" title="如何避免事务的并发问题？"></a>如何避免事务的并发问题？</h5><pre><code>通过设置事务的隔离级别
1、READ UNCOMMITTED 读未提交
2、READ COMMITTED 读已提交 可以避免脏读
3、REPEATABLE READ 可重复读 可以避免脏读、不可重复读和一部分幻读
4、SERIALIZABLE 可串行化 可以避免脏读、不可重复读和幻读

    事务的隔离级别：
                  脏读		不可重复读	幻读
read uncommitted：√				√		√
read committed：  ×				√		√
repeatable read： ×				×		√
serializable	  ×             ×       ×
</code></pre>
<p>​	</p>
<pre><code>mysql中默认 第三个隔离级别 repeatable read
oracle中默认第二个隔离级别 read committed

设置隔离级别：
set session|global  transaction isolation level 隔离级别名;

查看隔离级别：
select @@tx_isolation;
</code></pre>
<p>   九、视图的讲解</p>
<h4 id="含义："><a href="#含义：" class="headerlink" title="含义："></a>含义：</h4><pre><code>理解成一张虚拟的表
</code></pre>
<h4 id="视图和表的区别："><a href="#视图和表的区别：" class="headerlink" title="视图和表的区别："></a>视图和表的区别：</h4><pre><code>    使用方式	占用物理空间

视图	完全相同	不占用，仅仅保存的是sql逻辑

表	完全相同	占用
</code></pre>
<h4 id="视图的好处："><a href="#视图的好处：" class="headerlink" title="视图的好处："></a>视图的好处：</h4><pre><code>1、sql语句提高重用性，效率高
2、和表实现了分离，提高了安全性
</code></pre>
<h3 id="视图的创建"><a href="#视图的创建" class="headerlink" title="视图的创建"></a>视图的创建</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">	CREATE VIEW  视图名</span><br><span class="line">	AS</span><br><span class="line">	查询语句;</span><br></pre></td></tr></table></figure>



<pre><code>例如：1.查询姓名中包含a字符的员工名、部门名和工种信息
①创建
CREATE VIEW myv1
AS

SELECT last_name,department_name,job_title
FROM employees e
JOIN departments d ON e.department_id  = d.department_id
JOIN jobs j ON j.job_id  = e.job_id;

②使用
SELECT * FROM myv1 WHERE last_name LIKE &#39;%a%&#39;;
</code></pre>
<p>​	</p>
<h3 id="视图的增删改查"><a href="#视图的增删改查" class="headerlink" title="视图的增删改查"></a>视图的增删改查</h3><pre><code>1、查看视图的数据 ★
SELECT * FROM my_v4;
SELECT * FROM my_v1 WHERE last_name=&#39;Partners&#39;;

2、插入视图的数据
INSERT INTO my_v4(last_name,department_id) VALUES(&#39;虚竹&#39;,90);

3、修改视图的数据
UPDATE my_v4 SET last_name =&#39;梦姑&#39; WHERE last_name=&#39;虚竹&#39;;

4、删除视图的数据
DELETE FROM my_v4;
</code></pre>
<p>​	</p>
<h3 id="某些视图不能更新"><a href="#某些视图不能更新" class="headerlink" title="某些视图不能更新"></a>某些视图不能更新</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">包含以下关键字的sql语句：分组函数、distinct、group  by、having、union或者union all</span><br><span class="line">	常量视图</span><br><span class="line">	Select中包含子查询</span><br><span class="line">	join</span><br><span class="line">	from一个不能更新的视图</span><br><span class="line">	where子句的子查询引用了from子句中的表</span><br></pre></td></tr></table></figure>



<h3 id="视图逻辑的更新"><a href="#视图逻辑的更新" class="headerlink" title="视图逻辑的更新"></a>视图逻辑的更新</h3><pre><code>方式一：
    CREATE OR REPLACE VIEW test_v7
    AS
    SELECT last_name FROM employees
    WHERE employee_id&gt;100;
    
方式二:
ALTER VIEW test_v7
AS
SELECT employee_id FROM employees;

SELECT * FROM test_v7;
</code></pre>
<h3 id="视图的删除"><a href="#视图的删除" class="headerlink" title="视图的删除"></a>视图的删除</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP VIEW test_v1,test_v2,test_v3;</span><br></pre></td></tr></table></figure>



<h3 id="视图结构的查看"><a href="#视图结构的查看" class="headerlink" title="视图结构的查看"></a>视图结构的查看</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESC test_v7;</span><br><span class="line">	SHOW CREATE VIEW test_v7;</span><br></pre></td></tr></table></figure>

<h2 id="十、变量"><a href="#十、变量" class="headerlink" title="十、变量"></a>十、变量</h2><h3 id="一、全局变量"><a href="#一、全局变量" class="headerlink" title="一、全局变量"></a>一、全局变量</h3><h5 id="作用域：针对于所有会话（连接）有效，但不能跨重启"><a href="#作用域：针对于所有会话（连接）有效，但不能跨重启" class="headerlink" title="作用域：针对于所有会话（连接）有效，但不能跨重启"></a>作用域：针对于所有会话（连接）有效，但不能跨重启</h5><pre><code>查看所有全局变量
SHOW GLOBAL VARIABLES;
查看满足条件的部分系统变量
SHOW GLOBAL VARIABLES LIKE &#39;%char%&#39;;
查看指定的系统变量的值
SELECT @@global.autocommit;
为某个系统变量赋值
SET @@global.autocommit=0;
SET GLOBAL autocommit=0;
</code></pre>
<h3 id="二、会话变量"><a href="#二、会话变量" class="headerlink" title="二、会话变量"></a>二、会话变量</h3><h5 id="作用域：针对于当前会话（连接）有效"><a href="#作用域：针对于当前会话（连接）有效" class="headerlink" title="作用域：针对于当前会话（连接）有效"></a>作用域：针对于当前会话（连接）有效</h5><pre><code>查看所有会话变量
SHOW SESSION VARIABLES;
查看满足条件的部分会话变量
SHOW SESSION VARIABLES LIKE &#39;%char%&#39;;
查看指定的会话变量的值
SELECT @@autocommit;
SELECT @@session.tx_isolation;
为某个会话变量赋值
SET @@session.tx_isolation=&#39;read-uncommitted&#39;;
SET SESSION tx_isolation=&#39;read-committed&#39;;
</code></pre>
<h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><h4 id="一、用户变量"><a href="#一、用户变量" class="headerlink" title="一、用户变量"></a>一、用户变量</h4><h5 id="声明并初始化："><a href="#声明并初始化：" class="headerlink" title="声明并初始化："></a>声明并初始化：</h5><pre><code>SET @变量名=值;
SET @变量名:=值;
SELECT @变量名:=值;
</code></pre>
<h5 id="赋值："><a href="#赋值：" class="headerlink" title="赋值："></a>赋值：</h5><pre><code>方式一：一般用于赋简单的值
SET 变量名=值;
SET 变量名:=值;
SELECT 变量名:=值;


方式二：一般用于赋表 中的字段值
SELECT 字段名或表达式 INTO 变量
FROM 表;
</code></pre>
<h5 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h5><pre><code>select @变量名;
</code></pre>
<h4 id="二、局部变量"><a href="#二、局部变量" class="headerlink" title="二、局部变量"></a>二、局部变量</h4><h5 id="声明："><a href="#声明：" class="headerlink" title="声明："></a>声明：</h5><pre><code>declare 变量名 类型 【default 值】;
</code></pre>
<h5 id="赋值：-1"><a href="#赋值：-1" class="headerlink" title="赋值："></a>赋值：</h5><pre><code>方式一：一般用于赋简单的值
SET 变量名=值;
SET 变量名:=值;
SELECT 变量名:=值;


方式二：一般用于赋表 中的字段值
SELECT 字段名或表达式 INTO 变量
FROM 表;
</code></pre>
<h5 id="使用：-1"><a href="#使用：-1" class="headerlink" title="使用："></a>使用：</h5><pre><code>select 变量名
</code></pre>
<h5 id="二者的区别："><a href="#二者的区别：" class="headerlink" title="二者的区别："></a>二者的区别：</h5><pre><code>            作用域				定义位置			语法
用户变量	当前会话		会话的任何地方			加@符号，不用指定类型  
局部变量	定义它的BEGIN END中 	BEGIN END的第一句话	一般不用加@,需要指定类型
</code></pre>
<h2 id="十一、存储过程和函数"><a href="#十一、存储过程和函数" class="headerlink" title="十一、存储过程和函数"></a>十一、存储过程和函数</h2><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><h4 id="含义：一组经过预先编译的sql语句的集合"><a href="#含义：一组经过预先编译的sql语句的集合" class="headerlink" title="含义：一组经过预先编译的sql语句的集合"></a>含义：一组经过预先编译的sql语句的集合</h4><h5 id="好处："><a href="#好处：" class="headerlink" title="好处："></a>好处：</h5><pre><code>1、提高了sql语句的重用性，减少了开发程序员的压力
2、提高了效率
3、减少了传输次数
</code></pre>
<h5 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h5><pre><code>1、无返回无参
2、仅仅带in类型，无返回有参
3、仅仅带out类型，有返回无参
4、既带in又带out，有返回有参
5、带inout，有返回有参
注意：in、out、inout都可以在一个存储过程中带多个
</code></pre>
<h4 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h4><h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><pre><code>create procedure 存储过程名(in|out|inout 参数名  参数类型,...)
begin
    存储过程体

end
</code></pre>
<h5 id="类似于方法："><a href="#类似于方法：" class="headerlink" title="类似于方法："></a>类似于方法：</h5><pre><code>修饰符 返回类型 方法名(参数类型 参数名,...)&#123;

    方法体;
&#125;
</code></pre>
<h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><pre><code>1、需要设置新的结束标记
delimiter 新的结束标记
示例：
delimiter $

CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名  参数类型,...)
BEGIN
    sql语句1;
    sql语句2;

END $

2、存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end

3、参数前面的符号的意思
in:该参数只能作为输入 （该参数不能做返回值）
out：该参数只能作为输出（该参数只能做返回值）
inout：既能做输入又能做输出
</code></pre>
<h4 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h4><p>​	</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call 存储过程名(实参列表)</span><br></pre></td></tr></table></figure>



<h5 id="案例：-1"><a href="#案例：-1" class="headerlink" title="案例："></a>案例：</h5><pre><code>1.创建带in模式参数的存储过程
案例1：创建存储过程实现 根据女神名，查询对应的男神信息

CREATE PROCEDURE myp2(IN beautyName VARCHAR(20))
DELIMITER $
BEGIN
    SELECT bo.*
    FROM boys bo
    RIGHT JOIN beauty b ON bo.id = b.boyfriend_id
    WHERE b.name=beautyName;
END $

调用
CALL myp2(&#39;柳岩&#39;)$
</code></pre>
<p>​	<br>​	<br>​	</p>
<pre><code>案例2 ：创建存储过程实现，用户是否登录成功

CREATE PROCEDURE myp4(IN username VARCHAR(20),IN PASSWORD VARCHAR(20))
BEGIN
    DECLARE result INT DEFAULT 0;#声明并初始化
    
    SELECT COUNT(*) INTO result#赋值
    FROM admin
    WHERE admin.username = username
    AND admin.password = PASSWORD;
    
    SELECT IF(result&gt;0,&#39;成功&#39;,&#39;失败&#39;);#使用
END $

#调用
CALL myp3(&#39;张飞&#39;,&#39;8888&#39;)$
</code></pre>
<h4 id="三、删除存储过程"><a href="#三、删除存储过程" class="headerlink" title="三、删除存储过程"></a>三、删除存储过程</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：drop procedure 存储过程名</span><br><span class="line">		DROP PROCEDURE p1;</span><br></pre></td></tr></table></figure>



<h4 id="四、查看存储过程的信息"><a href="#四、查看存储过程的信息" class="headerlink" title="四、查看存储过程的信息"></a>四、查看存储过程的信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESC myp2;×//错误</span><br><span class="line">SHOW CREATE PROCEDURE  myp2;</span><br></pre></td></tr></table></figure>



<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h4><p>学过的函数：LENGTH、SUBSTR、CONCAT等<br>语法：</p>
<pre><code>CREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回类型
BEGIN
    函数体

END
</code></pre>
<h4 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 函数名（实参列表）</span><br></pre></td></tr></table></figure>



<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><pre><code>案例1：根据部门名，返回该部门的平均工资
CREATE FUNCTION myf3(deptName VARCHAR(20)) RETURNS DOUBLE
BEGIN
    DECLARE sal DOUBLE ;
    SELECT AVG(salary) INTO sal
    FROM employees e
    JOIN departments d ON e.department_id = d.department_id
    WHERE d.department_name=deptName;
    RETURN sal;
END $

SELECT myf3(&#39;IT&#39;)$
</code></pre>
<h5 id="函数和存储过程的区别"><a href="#函数和存储过程的区别" class="headerlink" title="函数和存储过程的区别"></a>函数和存储过程的区别</h5><pre><code>        关键字		调用语法	返回值			应用场景
函数		FUNCTION	SELECT 函数()	只能是一个		一般用于查询结果为一个值并返回时，当有返回值而														且仅仅一个
存储过程	PROCEDURE	CALL 存储过程()	可以有0个或多个		一般用于更新
</code></pre>
<h2 id="十二、流程控制结构"><a href="#十二、流程控制结构" class="headerlink" title="十二、流程控制结构"></a>十二、流程控制结构</h2><h3 id="一、if函数"><a href="#一、if函数" class="headerlink" title="一、if函数"></a>一、if函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：if(条件，值1，值2)</span><br></pre></td></tr></table></figure>


<pre><code>特点：可以用在任何位置
</code></pre>
<h3 id="二、case语句"><a href="#二、case语句" class="headerlink" title="二、case语句"></a>二、case语句</h3><h5 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h5><pre><code>情况一：类似于switch
case 表达式
when 值1 then 结果1或语句1(如果是语句，需要加分号) 
when 值2 then 结果2或语句2(如果是语句，需要加分号)
...
else 结果n或语句n(如果是语句，需要加分号)
end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）

情况二：类似于多重if
case 
when 条件1 then 结果1或语句1(如果是语句，需要加分号) 
when 条件2 then 结果2或语句2(如果是语句，需要加分号)
...
else 结果n或语句n(如果是语句，需要加分号)
end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）
</code></pre>
<h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><pre><code>可以用在任何位置
</code></pre>
<h3 id="三、if-elseif语句"><a href="#三、if-elseif语句" class="headerlink" title="三、if elseif语句"></a>三、if elseif语句</h3><h5 id="语法：-2"><a href="#语法：-2" class="headerlink" title="语法："></a>语法：</h5><pre><code>if 情况1 then 语句1;
elseif 情况2 then 语句2;
...
else 语句n;
end if;
</code></pre>
<h5 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h5><pre><code>只能用在begin end中！！！！！！！！！！！！！！！
</code></pre>
<p>三者比较：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">				应用场合</span><br><span class="line">if函数			简单双分支</span><br><span class="line">case结构		等值判断 的多分支</span><br><span class="line">if结构		区间判断 的多分支</span><br></pre></td></tr></table></figure>



<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>语法：</p>
<pre><code>【标签：】WHILE 循环条件  DO
    循环体
END WHILE 【标签】;
</code></pre>
<p>特点：</p>
<pre><code>只能放在BEGIN END里面

如果要搭配leave跳转语句，需要使用标签，否则可以不用标签

leave类似于java中的break语句，跳出所在循环！！！
</code></pre>
<h5 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h5><pre><code>/*一、已知表stringcontent
    其中字段：
    id 自增长
    content varchar(20)
向该表插入指定个数的，随机的字符串
*/
DROP TABLE IF EXISTS stringcontent;
CREATE TABLE stringcontent(
    id INT PRIMARY KEY AUTO_INCREMENT,
    content VARCHAR(20)
    
);
DELIMITER $
CREATE PROCEDURE test_randstr_insert(IN insertCount INT)
BEGIN
    DECLARE i INT DEFAULT 1;
    DECLARE str VARCHAR(26) DEFAULT &#39;abcdefghijklmnopqrstuvwxyz&#39;;
    DECLARE startIndex INT;#代表初始索引
    DECLARE len INT;#代表截取的字符长度
    WHILE i&lt;=insertcount DO
        SET startIndex=FLOOR(RAND()*26+1);#代表初始索引，随机范围1-26
        SET len=FLOOR(RAND()*(20-startIndex+1)+1);#代表截取长度，随机范围1-（20-startIndex+1）
        INSERT INTO stringcontent(content) VALUES(SUBSTR(str,startIndex,len));
        SET i=i+1;
    END WHILE;

END $

CALL test_randstr_insert(10)$
</code></pre>
<h2 id="十三、数据库三大范式"><a href="#十三、数据库三大范式" class="headerlink" title="十三、数据库三大范式"></a>十三、数据库三大范式</h2><p> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  1NF:字段不可再分,原子性。  </span><br><span class="line">  2NF:满足第二范式( 2NF )必须先满足第一范式( 1NF )。 一个表只能说明一个事物。非主键属性必须完全依赖于主键属性。  </span><br><span class="line">  3NF:满足第三范式( 3NF ) 必须先满足第二范式( 2NF ) 。每 列都与主键有直接关系,不存在传递依赖。 任何非主属性不依赖于其它 非主属性。</span><br></pre></td></tr></table></figure>



<h2 id="十四、MySQL的架构介绍"><a href="#十四、MySQL的架构介绍" class="headerlink" title="十四、MySQL的架构介绍"></a>十四、MySQL的架构介绍</h2><h3 id="1-MySql简介"><a href="#1-MySql简介" class="headerlink" title="1.MySql简介"></a>1.MySql简介</h3><pre><code>    概述：
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20210411155649356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="2-MySQL逻辑架构介绍"><a href="#2-MySQL逻辑架构介绍" class="headerlink" title="2.MySQL逻辑架构介绍"></a>2.MySQL逻辑架构介绍</h3><p><img src="https://img-blog.csdnimg.cn/20210411155659392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411155708243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="1-Connectors"><a href="#1-Connectors" class="headerlink" title="1.Connectors"></a>1.Connectors</h5><p>指的是不同语言中与SQL的交互</p>
<h5 id="2-Management-Serveices-amp-Utilities："><a href="#2-Management-Serveices-amp-Utilities：" class="headerlink" title="2 Management Serveices &amp; Utilities："></a>2 Management Serveices &amp; Utilities：</h5><p>系统管理和控制工具</p>
<h5 id="3-Connection-Pool-连接池"><a href="#3-Connection-Pool-连接池" class="headerlink" title="3 Connection Pool: 连接池"></a>3 Connection Pool: 连接池</h5><p>管理缓冲用户连接，线程处理等需要缓存的需求。<br>负责监听对 MySQL Server 的各种请求，接收连接请求，转发所有连接请求到线程管理模块。每一个连接上 MySQL Server 的客户端请求都会被分配（或创建）一个连接线程为其单独服务。而连接线程的主要工作就是负责 MySQL Server 与客户端的通信，<br>接受客户端的命令请求，传递 Server 端的结果信息等。线程管理模块则负责管理维护这些连接线程。包括线程的创建，线程的 cache 等。</p>
<h5 id="4-SQL-Interface-SQL接口。"><a href="#4-SQL-Interface-SQL接口。" class="headerlink" title="4 SQL Interface: SQL接口。"></a>4 SQL Interface: SQL接口。</h5><p>接受用户的SQL命令，并且返回用户需要查询的结果。比如select from就是调用SQL Interface</p>
<h5 id="5-Parser-解析器。"><a href="#5-Parser-解析器。" class="headerlink" title="5 Parser: 解析器。"></a>5 Parser: 解析器。</h5><p>SQL命令传递到解析器的时候会被解析器验证和解析。解析器是由Lex和YACC实现的，是一个很长的脚本。<br>在 MySQL中我们习惯将所有 Client 端发送给 Server 端的命令都称为 query ，在 MySQL Server 里面，连接线程接收到客户端的一个 Query 后，会直接将该 query 传递给专门负责将各种 Query 进行分类然后转发给各个对应的处理模块。<br>主要功能：<br>a . 将SQL语句进行语义和语法的分析，分解成数据结构，然后按照不同的操作类型进行分类，然后做出针对性的转发到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。<br>b.  如果在分解构成中遇到错误，那么就说明这个sql语句是不合理的</p>
<h5 id="6-Optimizer-查询优化器。"><a href="#6-Optimizer-查询优化器。" class="headerlink" title="6 Optimizer: 查询优化器。"></a>6 Optimizer: 查询优化器。</h5><p>SQL语句在查询之前会使用查询优化器对查询进行优化。就是优化客户端请求的 query（sql语句） ，根据客户端请求的 query 语句，和数据库中的一些统计信息，在一系列算法的基础上进行分析，得出一个最优的策略，告诉后面的程序如何取得这个 query 语句的结果<br>他使用的是“选取-投影-联接”策略进行查询。<br>       用一个例子就可以理解： select uid,name from user where gender &#x3D; 1;<br>       这个select 查询先根据where 语句进行选取，而不是先将表全部查询出来以后再进行gender过滤<br>       这个select查询先根据uid和name进行属性投影，而不是将属性全部取出以后再进行过滤<br>       将这两个查询条件联接起来生成最终查询结果</p>
<h5 id="7-Cache和Buffer：-查询缓存。"><a href="#7-Cache和Buffer：-查询缓存。" class="headerlink" title="7 Cache和Buffer： 查询缓存。"></a>7 Cache和Buffer： 查询缓存。</h5><p>他的主要功能是将客户端提交 给MySQL 的 Select 类 query 请求的返回结果集 cache 到内存中，与该 query 的一个 hash 值 做一个对应。该 Query 所取数据的基表发生任何数据的变化之后， MySQL 会自动使该 query 的Cache 失效。在读写比例非常高的应用系统中， Query Cache 对性能的提高是非常显著的。当然它对内存的消耗也是非常大的。<br>如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等</p>
<h5 id="8-、存储引擎接口"><a href="#8-、存储引擎接口" class="headerlink" title="8 、存储引擎接口"></a>8 、存储引擎接口</h5><p>存储引擎接口模块可以说是 MySQL 数据库中最有特色的一点了。目前各种数据库产品中，基本上只有 MySQL 可以实现其底层数据存储引擎的插件式管理。这个模块实际上只是 一个抽象类，但正是因为它成功地将各种数据处理高度抽象化，才成就了今天 MySQL 可插拔存储引擎的特色。<br>     从图2还可以看出，MySQL区别于其他数据库的最重要的特点就是其插件式的表存储引擎。MySQL插件式的存储引擎架构提供了一系列标准的管理和服务支持，这些标准与存储引擎本身无关，可能是每个数据库系统本身都必需的，如SQL分析器和优化器等，而存储引擎是底层物理结构的实现，每个存储引擎开发者都可以按照自己的意愿来进行开发。<br>    注意：存储引擎是基于表的，而不是数据库。</p>
<h3 id="3-MySQL存储引擎"><a href="#3-MySQL存储引擎" class="headerlink" title="3.MySQL存储引擎"></a>3.MySQL存储引擎</h3><h4 id="查看命令："><a href="#查看命令：" class="headerlink" title="查看命令："></a>查看命令：</h4><p><img src="https://img-blog.csdnimg.cn/20210411155720301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="MyISAM和InnoDB区别："><a href="#MyISAM和InnoDB区别：" class="headerlink" title="MyISAM和InnoDB区别："></a>MyISAM和InnoDB区别：</h4><p><img src="https://img-blog.csdnimg.cn/2021041115581833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="十五、索引优化分析"><a href="#十五、索引优化分析" class="headerlink" title="十五、索引优化分析"></a>十五、索引优化分析</h2><h3 id="1-索引简介"><a href="#1-索引简介" class="headerlink" title="1.索引简介"></a>1.索引简介</h3><h5 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h5><p>MySQL官方对索引的定义为：索引(Index)是帮助MySQL高效获取数据的数据结构。可以得到索引的本质：索引是数据结构。可以简单理解为”排好序的快速查找数据结构”。</p>
<p>结论：数据本身之外,数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，<br>这样就可以在这些数据结构的基础上实现高级查找算法,这种数据结构就是索引。</p>
<p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以文件形式存储在硬盘上。</p>
<h5 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h5><p>通过索引列对数据进行排序，降低数据排序成本，降低了CPU的消耗</p>
<h5 id="劣势："><a href="#劣势：" class="headerlink" title="劣势："></a>劣势：</h5><p>1.实际上索引也是一张表，该表保存了主键和索引字段，并指向实体表的记录,所以索引列也是要占用空间的。</p>
<p>2.虽然索引大大提高了查询速度，同时却会降低更新表的速度,如果对表INSERT,UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。</p>
<p>3.索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立优秀的索引，或优化查询语句。</p>
<h5 id="mysql索引分类"><a href="#mysql索引分类" class="headerlink" title="mysql索引分类"></a>mysql索引分类</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单值索引：即一个索引只包含单个列，一个表可以有多个单列索引</span><br><span class="line"></span><br><span class="line">唯一索引：索引列的值必须唯一，但允许有空值</span><br><span class="line"></span><br><span class="line">复合索引：即一个索引包含多个列</span><br></pre></td></tr></table></figure>

<h5 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建：</span><br><span class="line">1.CREATE [UNIQUE] INDEX  indexName ON mytable(columnname(length));</span><br><span class="line">	//如果是CHAR,VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定length。</span><br><span class="line">2.ALTER mytable ADD [UNIQUE]  INDEX [indexName] ON(columnname(length));</span><br><span class="line"></span><br><span class="line">删除：</span><br><span class="line">DROP INDEX [indexName] ON mytable;</span><br><span class="line"></span><br><span class="line">查看：</span><br><span class="line">SHOW INDEX FROM table_name\G</span><br></pre></td></tr></table></figure>

<h5 id="使用Alter命令："><a href="#使用Alter命令：" class="headerlink" title="使用Alter命令："></a>使用Alter命令：</h5><p><img src="https://img-blog.csdnimg.cn/20210411155839351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="mysql索引结构："><a href="#mysql索引结构：" class="headerlink" title="mysql索引结构："></a>mysql索引结构：</h5><h5 id="BTree："><a href="#BTree：" class="headerlink" title="BTree："></a>BTree：</h5><p>B树（Balance Tree）是一种多路平衡查找树，他的<strong>每一个节点最多包含M个孩子，M就是B树的阶。</strong>M的大小取决于磁盘页的大小。</p>
<p><strong>B-树就是B树，中间的横线不是减号，所以不要读成B减树。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210411155855390.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h5><p>一个m阶的B+树具有如下几个特征：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。</span><br><span class="line"></span><br><span class="line">2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</span><br><span class="line"></span><br><span class="line">3.每个父节点的元素都同时存在于子节点中，是子节点中的最大（或最小）元素。</span><br><span class="line"></span><br><span class="line">4.根节点的最大元素是整个B+树的最大元素。</span><br><span class="line"></span><br><span class="line">5.由于父节点的元素都包含在子节点，因此所有叶子节点包括了全部的元素信息。</span><br><span class="line"></span><br><span class="line">6.每个叶子节点都带有指向下一个节点的指针，形成一个有序链表。</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210411155909604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="B树索引："><a href="#B树索引：" class="headerlink" title="B树索引："></a>B树索引：</h5><p><img src="https://img-blog.csdnimg.cn/20210411155924705.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="B-树索引："><a href="#B-树索引：" class="headerlink" title="B+树索引："></a>B+树索引：</h5><p><img src="https://img-blog.csdnimg.cn/20210411155937575.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="其中MyISAM和InnoDB存储引擎都采用B-树索引，但底层实现方式不同"><a href="#其中MyISAM和InnoDB存储引擎都采用B-树索引，但底层实现方式不同" class="headerlink" title="其中MyISAM和InnoDB存储引擎都采用B+树索引，但底层实现方式不同"></a>其中MyISAM和InnoDB存储引擎都采用B+树索引，但底层实现方式不同</h5><p>InnoDB实现方式：其中叶子节点存储数据和键值即是原表中数据（聚集索引）</p>
<p><img src="https://img-blog.csdnimg.cn/20210411155950110.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>MyISAM实现方式：其中叶子节点存储键值和数据表中对应数据的物理地址（非聚集索引）</p>
<p><img src="https://img-blog.csdnimg.cn/20210411160002102.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="Hash索引："><a href="#Hash索引：" class="headerlink" title="Hash索引："></a>Hash索引：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.只能使用=或&lt;=&gt;操作符的等式比较</span><br><span class="line"></span><br><span class="line">2.优化器不能使用hash索引来加速order by操作</span><br><span class="line"></span><br><span class="line">3.mysql不能确定在两个值之间大约有多少行。如果将一个myisam表改为hash索引的memory表，会影响一些查询的执行效率。</span><br><span class="line"></span><br><span class="line">4.只能使用整个关键字来搜索一行</span><br></pre></td></tr></table></figure>

<p> hash index是基于哈希表实现的，只有精确匹配索引所有列的查询才会生效。对于每一行数据，存储引擎都会对所有的索引列计算一个hash code,并将有的hash code存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p>
<p><img src="https://img-blog.csdnimg.cn/20210411160206238.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引"></a>哪些情况需要创建索引</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.主键自动建立唯一索引</span><br><span class="line"></span><br><span class="line">2.频繁作为查询的条件的字段应该创建索引</span><br><span class="line"></span><br><span class="line">3.查询中与其他表关联的字段，外键关系建立索引</span><br><span class="line"></span><br><span class="line">4.频繁更新的字段不适合创建索引</span><br><span class="line"></span><br><span class="line">5.Where条件里用不到的字段不创建索引</span><br><span class="line"></span><br><span class="line">6.单间/组合索引的选择问题，who？（在高并发下倾向创建组合索引）</span><br><span class="line"></span><br><span class="line">7.查询中排序的字段，排序字段若通过索引去访问将大大提高排序的速度</span><br><span class="line"></span><br><span class="line">8.查询中统计或者分组字段</span><br></pre></td></tr></table></figure>

<h5 id="哪些情况不要创建索引"><a href="#哪些情况不要创建索引" class="headerlink" title="哪些情况不要创建索引"></a>哪些情况不要创建索引</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.表记录太少</span><br><span class="line"></span><br><span class="line">2.经常增删改的表</span><br><span class="line"></span><br><span class="line">3.数据重复且分布平均的表字段，因此应该只为经常查询和经常排序的数据列建立索引。注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。</span><br></pre></td></tr></table></figure>







<h1 id="01-索引是什么？"><a href="#01-索引是什么？" class="headerlink" title="01 索引是什么？"></a>01 索引是什么？</h1><p><strong>索引是一种数据结构，它的出现就是为了提高数据查询的效率，就像一本书的目录</strong>。想想一本书几百页，没有目录估计找得够呛的。举个通俗点的例子，我在知乎刷到的，比喻得很妙。</p>
<blockquote>
<p>我们从小就用的新华字典，里面的声母查询方式就是聚簇索引。偏旁部首就是二级索引 偏旁部首 + 笔画就是联合索引。</p>
</blockquote>
<p>索引本身也是占用磁盘空间的（想想一本书中的目录也是占用页数的，你就知道了），它主要<strong>以文件的形式存在于磁盘中</strong>。</p>
<h2 id="1-1-索引的优缺点"><a href="#1-1-索引的优缺点" class="headerlink" title="1.1 索引的优缺点"></a>1.1 索引的优缺点</h2><p><strong>优点</strong></p>
<ul>
<li>提高查询语句的执行效率，减少 IO 操作的次数</li>
<li>创建唯一性索引，可以保证数据库表中每一行数据的唯一性</li>
<li>加了索引的列会进行排序（一本书的章节顺序不就是按照目录来排嘛），在使用分组和排序子句进行查询时，可以显著减少查询中分组和排序的时间</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>索引需要占物理空间</li>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</li>
<li>当对表中的数据进行增删改查是，索引也要动态的维护，这样就降低了数据的更新效率</li>
</ul>
<h2 id="1-2-索引的分类"><a href="#1-2-索引的分类" class="headerlink" title="1.2 索引的分类"></a>1.2 索引的分类</h2><p><strong>主键索引</strong></p>
<p>一种特殊的唯一索引，不允许有空值。(主键约束 &#x3D; 唯一索引 + 非空值)</p>
<p><strong>唯一索引</strong></p>
<p>索引列中的值必须是唯一的，但是允许为空值。</p>
<p><strong>普通索引</strong></p>
<p>MySQL 中的加索引类型，没啥限制。<strong>允许空值和重复值，纯粹为了提高查询效率而存在</strong>。</p>
<p><strong>单列索引</strong></p>
<p>没啥好说的，就是索引的列数量只有一个，每个表可以有多个单列索引。</p>
<p><strong>组合索引</strong></p>
<p>多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。注意，使用它的时候需要遵守<strong>最左匹配原则</strong>。多个列作为查询条件时，组合索引在工作中很常用。</p>
<p><strong>全文索引</strong></p>
<p>只能在文本内容，也就是 TEXT、CHAR、VARCHAR 数据类型的列上建全文索引。有人说创建单列索引不就完了吗？考虑一种情况：当这列的内容很长时，用 like 查询就会很慢，这是就适合建全文索引。</p>
<p><strong>前缀索引</strong></p>
<p>还是只能作用于文本内容，也就是 TEXT、CHAR、VARCHAR 数据类型的列上建前缀索引，它可以指定索引列的长度，它是这样写的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 在 x_test 的 x_name 列上创建一个长度为 4 的前缀索引</span><br><span class="line">alter table x_test add index(x_name(4));</span><br></pre></td></tr></table></figure>

<p>这个长度是根据实际情况来定的。长了太占用空间，短了不起效果。比如：我有个表的 x_name 的第一个字符几乎都是一样的（假设都是 1），如果创建索引的长度 &#x3D; 1，执行以下查询的时候就可能比原来更糟。<strong>因为数据库里面太多第一个字符 &#x3D; 1 的列了，所以选的时候尽量选择数据开始有差别的长度</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM x_test WHERE x_name = &#x27;1892008.205824857823401.800099203178258.8904820949682635656.62526521254&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>空间索引</strong></p>
<p>MySQL 在 5.7 之后的版本支持了空间索引，而且支持 OpenGIS 几何数据模型。MySQL 在空间索引这方面遵循 OpenGIS 几何数据模型规则。</p>
<h1 id="02-索引的内存模型"><a href="#02-索引的内存模型" class="headerlink" title="02 索引的内存模型"></a>02 索引的内存模型</h1><p><strong>实现索引的方式有很多种，这里先介绍下最常见的三种：哈希表、有序数组、二叉树，其中二叉树又分为二叉查找树、平衡二叉树、B 树以及 B+ 树，从而说明为啥 InnDB 选择了 B+ 树</strong>？为了方便作图举例我先建个表，建表语句如下：user 有两列，一列是身份证号，还有一列是名称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS `user`(</span><br><span class="line">   `id_card` INT(6) NOT NULL,</span><br><span class="line">   `name` VARCHAR(100) NOT NULL,</span><br><span class="line">   PRIMARY KEY ( `id_card` )</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<h2 id="2-1-哈希表"><a href="#2-1-哈希表" class="headerlink" title="2.1 哈希表"></a>2.1 哈希表</h2><p>HashMap 相信大家都用过，哈希表就是一种以键值对存储数据的结构。在 MySQL 中 key 用于存储索引列，value 就是某行的数据或者是它的磁盘地址。</p>
<p>用过 HashMap 的你可能知道了，当多个 key 经过哈希函数换算之后会出现同一个值，这种情况下就会 value 值的结构就是个链表。假设现在让你通过身份证号找名字，这时它的哈希表索引结构是这样的：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411160225839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>从上图可知，user2 和 user4 哈希出来的 key 值都是 M，这个时候 value 的值就是个链表。如果你要查 id_card &#x3D; 66688 的人，步骤是：先将 66688 通过哈希函数算出 M，然后按顺序遍历链表，找到 user2。</p>
<p>你可能注意到了上图中四个 id_card 的值并不是递增的，所以增加新 user 时速度会很快，往后追加就好。但又因为不是有序的，做区间查询的速度就会很慢。</p>
<p>所以，<strong>哈希表结构适用于只有等值查询的场景，不适合范围查询</strong>。</p>
<h2 id="2-2-有序数组"><a href="#2-2-有序数组" class="headerlink" title="2.2 有序数组"></a>2.2 有序数组</h2><p>为了解决区间查询速度慢的问题，有序数组应运而生。它的等值和范围查询都很快。还是上面根据身份号找用户的例子，这时候的索引结构是这样的：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411160246468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>身份证号递增且不重复从而有以上有序数组，这是如果你要查 id_card &#x3D; 66666 的用户，用二分法就可以啦，复杂度是 O (log (N))。</p>
<p>这数组还支持范围查询，还是用二分查找法，如果你要查区间 [12345,66666] 的用户，只需要二分查找出 id_card 大于等于 12345 且小于 66666 的用户即可。</p>
<p>单看查询效率，有序数组简直完美，但是如果我们要新增数据就很很难受了。假设你要新增 id_card &#x3D; 12346 的用户，那就只能把后面的数据都往后挪一个位置，成本太高了。</p>
<p>所以<strong>有序数组只适用于存储一些不怎么变的数据，比如一些过去的年份数据</strong>。</p>
<h2 id="2-3-二叉搜索树"><a href="#2-3-二叉搜索树" class="headerlink" title="2.3 二叉搜索树"></a>2.3 二叉搜索树</h2><p>二叉搜索树，也称二叉查找树，或二叉排序树。其定义也比较简单，要么是一颗空树，要么就是具有如下性质的二叉树：<strong>每个节点只有两个分叉，左子树所有节点值比右子树小，每个节点的左、右子树也是一个小的二叉树，且没有健值相等的节点</strong>。</p>
<p>说概览有点懵，先上个图。一般的二叉搜索树长这样：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411160302761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>之所以设计成二叉有序的结构是因为可以利用二分查找法，它的插入和查找的时间复杂度都是 O (log (N))，但是最坏情况下，它的时间复杂度是 O (n)，原因是在插入和删除的时候树没有保持平衡。比如顺拐的二叉树：</p>
<p>![顺拐的二叉搜索树</p>
<p>所以<strong>这种情况下，树的查询时间复杂度都变高，而且也不稳定</strong>。</p>
<h2 id="2-4-平衡二叉树"><a href="#2-4-平衡二叉树" class="headerlink" title="2.4 平衡二叉树"></a>2.4 平衡二叉树</h2><p><strong>平衡二叉树也叫 AVL 树，它与二叉查找树的区别在于</strong>平衡 <strong>，它任意的左右子树之间的高度差不大于 1</strong>。我做了个对比，如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411160320733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>平衡二叉树与二叉查找树对比</p>
<p>这样就很开心了，根据平衡二叉树的特点。它的查询时间复杂度是 O (log (N))，当然为了维护平衡它更新的时间复杂度也是 O (log (N))。貌似完美？但是还有问题。</p>
<p>学过数据结构都知道，时间复杂度与树高相关。你想想假设现在有一颗 100 万节点的平衡二叉树，树高 20。一次查询需要访问 20 个数据块。而根据计算机组成原理得知，从磁盘读一个数据快平均需要 10ms 的寻址时间。<strong>PS：索引不止存在内存中，还会写到磁盘上，所以优化的核心在于减少磁盘的 IO 次数</strong>。</p>
<p>也就是说，对于一个 100 万行的表，如果使用平衡二叉树来存储，单独访问一行可能需要 20 个 10ms 的时间，也就是 0.2s，这很难受了。</p>
<p>此外，平衡二叉树不支持快速的范围查询，范围查询时需要从根节点多次遍历，查询效率真心不高。</p>
<p>所以，<strong>大多数的数据库存储也并不使用平衡二叉树</strong>。</p>
<h2 id="2-5-B-树"><a href="#2-5-B-树" class="headerlink" title="2.5 B 树"></a>2.5 B 树</h2><p>上面分析我们知道了，查询慢是因为树高，要多次访问磁盘。为了让一个查询尽量少触及磁盘。我们可以降低树的高度，既然有二叉。那我们多分几个叉，树的高度不就降低了？所以，这时就用到了 B 树（你心里没点吗？哈哈哈）。</p>
<blockquote>
<p>在 MySQL 的 InnoDB 存储引擎一次 IO 会读取的一页（默认一页 16K）的数据量，而二叉树一次 IO 有效数据量只有 16 字节，空间利用率极低。为了最大化利用一次 IO 空间，一个简单的想法是在每个节点存储多个元素，在每个节点尽可能多的存储数据。每个节点可以存储 1000 个索引（16k&#x2F;16&#x3D;1000），这样就将二叉树改造成了多叉树，通过增加树的叉树，将树从高瘦变为矮胖。构建 1 百万条数据，树的高度只需要 2 层就可以（1000*1000&#x3D;1 百万），也就是说只需要 2 次磁盘 IO 就可以查询到数据。磁盘 IO 次数变少了，查询数据的效率也就提高了。</p>
</blockquote>
<p>B 树也叫 B- 树，一颗 m 阶（m 表示这棵树最多有多少个分叉）的 B 树。特点是：</p>
<ul>
<li>每个非叶子节点并且非根节点最少有 m&#x2F;2 个（向上取整），即内部节点的子节点个数最少也有 m&#x2F;2 个。</li>
<li>根节点至少有两个子节点，每个内节点（非叶子节点就是内节点）最多有 m 个分叉。</li>
<li>B 树的所有节点都存储数据，一个节点包含多个元素，比如健值和数据，节点中的健值从小到大排序。</li>
<li>叶子节点都在同一层，高度一致并且它们之间没有指针相连。</li>
</ul>
<p>3 阶的 B 树结构如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411160346114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>B 树索引</p>
<ul>
<li>等值查询</li>
</ul>
<p>在这样的结构下我们找值等于 48  的数据，还是使用二分查找法。它的查询路径是这样的：数据库 1-&gt; 数据块 3-&gt; 数据块 9。一共经过三次磁盘 IO，而同样数据量情况下，用平衡二叉树存储的树高肯定是更高的。它的 IO 次数显然是更高的。所以说 B 树其实是加快了查询效率。</p>
<ul>
<li>范围查询</li>
</ul>
<p>不知道大家注意到没有？B 树的叶子节点，并没有指针相连。意味着如果是范围查询，比如我查 41~ 58 的数据。</p>
<p>首先，二分查找法访问：数据块 1-&gt; 数据块 3-&gt; 数据块 9，找到 41；然后再回去从根节点遍历：数据块 1-&gt; 数据块 3-&gt; 数据块 10，找到 58，一共经历了 6 次 IO 查询才算是完成，这样查询的效率就慢了很多。</p>
<p>它还存在以下问题：</p>
<blockquote>
<p>\1. 叶子节点无指针相连，所以范围查询增加了磁盘 IO 次数，降低了查询效率。</p>
</blockquote>
<blockquote>
<p>\2. 如果 data 存储的是行记录，行的大小随着列数的增多，所占空间会变大。这时，一个页中可存储的数据量就会变少，树相应就会变高，磁盘 IO 次数就会变大。</p>
</blockquote>
<p>所以说，<strong>B 树还有优化的空间</strong>。</p>
<h2 id="2-6-B-树"><a href="#2-6-B-树" class="headerlink" title="2.6 B+ 树"></a>2.6 B+ 树</h2><p>B+ 树其实是从 B 树衍生过来的。它与 B 树有两个区别：</p>
<ul>
<li>B+ 树的非叶子节点不存放数据，只存放健值。</li>
<li>B + 树的叶子节点之间存在双向指针相连，而且是双向有序链表</li>
</ul>
<p>它的数据结构如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/2021041116040483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>B + 树索引</p>
<p>由上图得知，B+ 树的数据都存放在叶子节点上。所以每次查询我们都需要检索到叶子节点才能把数据查出来。有人说了，那这不变慢了吗？B 树不一定要检索到叶子节点呀。</p>
<p>其实不然，因为 B+ 的非叶子节点不再存储数据。所以它可以存更多的索引，也即理论上 B+ 树的树高会比 B 树更低。从这个角度来说，与其为了非叶子结点上能存储值而选择 B 树，倒不如选择 B+ 树，降低树高。</p>
<p>我们通过分析来看看 B+ 树靠不靠谱。</p>
<ul>
<li><strong>等值查询</strong></li>
</ul>
<p>在这样的结构下我们找值等于 48  的数据，还是使用二分查找法。它的查询路径是这样的：数据块 1-&gt; 数据块 3-&gt; 数据块 9。一共经过三次磁盘 IO，这没毛病。</p>
<ul>
<li><strong>范围查询</strong></li>
</ul>
<p>比如我查 41~ 49 的数据。首先二分查找访问：数据库 1-&gt; 数据块 3-&gt; 数据块 8。一样经过了三次磁盘 IO，找到 41 缓存到结果集。</p>
<p>但由于叶子节点是个双向有序链表，这个时候只需要往后走。将 49 所在的数据块 9 加载到内存遍历，找到 49，查询结束，只走了 4 次磁盘 IO。</p>
<p>这里可以看出对于范围查询来说，相比于 B 树要走一遍老路，B+ 树就显得高效很多。</p>
<p>所以，<strong>B+ 树中等值和范围查询都支持快速查。这样 MySQL 就选择了 B+ 树作为索引的内存模型</strong>。</p>
<h1 id="03-MySQL-的索引是如何执行的？"><a href="#03-MySQL-的索引是如何执行的？" class="headerlink" title="03 MySQL 的索引是如何执行的？"></a>03 MySQL 的索引是如何执行的？</h1><p>好了，可以作为所索引内存模型的数据结构都分析了一遍。最终 MySQL 还是选择了 B+ 树作为索引内存模型。那 B+ 树在具体的引擎中是怎么发挥作用的呢？一起来看看</p>
<h2 id="3-1-InnDB-索引"><a href="#3-1-InnDB-索引" class="headerlink" title="3.1 InnDB 索引"></a>3.1 InnDB 索引</h2><p>首先是 InnDB 索引，篇幅原因，我就聊聊主键索引和普通索引。</p>
<h3 id="3-1-1-主键索引"><a href="#3-1-1-主键索引" class="headerlink" title="3.1.1 主键索引"></a>3.1.1 主键索引</h3><p>主键索引又叫聚簇索引，它使用 B+ 树构建，叶子节点存储的是数据表的某一行数据。当表没有创建主键索引是，InnDB 会自动创建一个 ROWID 字段用于构建聚簇索引。规则如下：</p>
<blockquote>
<ol>
<li>在表上定义主键 PRIMARY KEY，InnoDB 将主键索引用作聚簇索引。</li>
<li>如果表没有定义主键，InnoDB 会选择第一个不为 NULL 的唯一索引列用作聚簇索引。</li>
<li>如果以上两个都没有，InnoDB 会使用一个 6 字节长整型的隐式字段 ROWID 字段构建聚簇索引。该 ROWID 字段会在插入新行时自动递增。</li>
</ol>
</blockquote>
<p>多说无益，以下面的 Student 表为例，它的 id 是主键，age 列为普通索引。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `student`  (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,</span><br><span class="line">  `age` int(11) NULL DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE,</span><br><span class="line">  INDEX `index_age`(`age`) USING BTREE</span><br><span class="line">) ENGINE = InnoDB AUTO_INCREMENT = 66 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;</span><br></pre></td></tr></table></figure>

<p>表数据如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411162528506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411160534479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>主键索引结构图</p>
<ul>
<li><strong>主键索引等值查询 sql</strong>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from student where id = 38;</span><br></pre></td></tr></table></figure>

<p>过程如下：</p>
<ul>
<li>第一次磁盘 IO：从根节点检索，将数据块 1 加载到内存，比较 38 &lt; 44，走左边。</li>
<li>第二次磁盘 IO：将左边数据块 2 加载到内存，比较 8&lt;37&lt;38，走右边。</li>
<li>第三次磁盘 IO：将右边数据块 6 加载到内存，比较 37&lt;38，38&#x3D;38。查询完毕，将数据返回客户端。</li>
</ul>
<p>流程图：<strong>3 次磁盘 IO</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210411160548566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>流程图</p>
<ul>
<li><strong>主键索引范围查询 sql</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from student where id between 38 and 44;</span><br></pre></td></tr></table></figure>

<p>前面也介绍说了，B+ 树因为叶子节点有双向指针，范围查询可以直接利用双向有序链表。</p>
<p>过程如下：</p>
<ul>
<li>第一次磁盘 IO：从根节点检索，将数据块 1 加载到内存，比较 38 &lt; 44，走左边。</li>
<li>第二次磁盘 IO：将左边数据块 2 加载到内存，比较 8&lt;37&lt;38，走右边。</li>
<li>第三次磁盘 IO：将右边数据块 6 加载到内存，比较 37&lt;38，38&#x3D;38。走右边。</li>
<li>第四次磁盘 IO：将右边数据块 7 加载到内存，比较 38&lt;44&#x3D;44。查询完毕，将数据返回客户端。</li>
</ul>
<p>流程图：<strong>一共四次磁盘 IO</strong></p>
<p><img src="https://img-blog.csdnimg.cn/2021041116060651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>流程图</p>
<h3 id="3-1-2-普通索引"><a href="#3-1-2-普通索引" class="headerlink" title="3.1.2 普通索引"></a>3.1.2 普通索引</h3><ul>
<li><strong>普通索引等值查询 sql</strong></li>
</ul>
<p>在 InnDB 中，B+ 树普通索引不存储数据，只存储数据的主键值。比如本表中的 age，它的索引结构就是这样的：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411160632213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>普通索引</p>
<p>执行以下查询语句，它的流程又是怎样的呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from student where age = 48;</span><br></pre></td></tr></table></figure>

<p>使用普通索引需要检索两次索引。第一次检索普通索引找出 age &#x3D; 48 得到主键值，再使用主键到主键索引中检索获得数据。这个过程称为回表。</p>
<p>也就是说，基于非主键索引的查询需要多扫描一遍索引树。因此，我们应该尽量使用主键查询。</p>
<p>过程如下：</p>
<ul>
<li>第一次磁盘 IO：从根节点检索，将数据块 1 加载到内存，比较 48 &lt; 54，走左边。</li>
<li>第二次磁盘 IO：将左边数据块 2 加载到内存，比较 28&lt;47&lt;48，走右边。</li>
<li>第三次磁盘 IO：将右边数据块 6 加载到内存，比较 47&lt;48，48&#x3D;48。得到主键 38。</li>
<li>第四次磁盘 IO：从根节点检索，将根节点加载到内存，比较 38 &lt; 44，走左边。</li>
<li>第五次磁盘 IO：将左边数据块 2 加载到内存，比较 8&lt;37&lt;38，走右边。</li>
<li>第六次磁盘 IO：将右边数据块 6 加载到内存，比较 37&lt;38，38&#x3D;38。查询完毕，将数据返回客户端。</li>
</ul>
<p>流程图：<strong>一共 6 次磁盘 IO</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/2021041116065296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>流程图</p>
<h3 id="3-1-3-组合索引"><a href="#3-1-3-组合索引" class="headerlink" title="3.1.3 组合索引"></a>3.1.3 组合索引</h3><p>如果为每一种查询都设计一个索引，索引是不是太多了？如果我现在要根据学生的姓名去查它的年龄。假设这个需求出现的概览很低，但我们也不能让它走全表扫描吧？</p>
<p>但是为一个不频繁的需求创建一个（姓名）索引是不是有点浪费了？那该咋做呢？我们可以建个（name，age）的联合索引来解决呀。组合索引的结构如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411160710562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>组合索引结构</p>
<p>执行以下查询语句，它的流程又是怎样的呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from student where name = &#x27;二狗5&#x27; and age = 48;</span><br></pre></td></tr></table></figure>

<p>过程如下：</p>
<ul>
<li>第一次磁盘 IO：从根节点检索，将数据块 1 加载到内存，比较 二狗 5 &lt; 二狗 6，走左边。</li>
<li>第二次磁盘 IO：将左边数据块 2 加载到内存，比较 二狗 2 &lt; 二狗 4 &lt; 二狗 5，走右边。</li>
<li>第三次磁盘 IO：将右边数据块 6 加载到内存，比较 二狗 4 &lt; 二狗 5，二狗 5 &#x3D; 二狗 5。得到主键 38。</li>
<li>第四次磁盘 IO：从根节点检索，将根节点加载到内存，比较 38 &lt; 44，走左边。</li>
<li>第五次磁盘 IO：将左边数据块 2 加载到内存，比较 8&lt;37&lt;38，走右边。</li>
<li>第六次磁盘 IO：将右边数据块 6 加载到内存，比较 37&lt;38，38&#x3D;38。查询完毕，将数据返回客户端。</li>
</ul>
<p>流程图：<strong>一共六次磁盘 IO</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210411160726140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>组合索引执行流程</p>
<h3 id="3-1-4-最左匹配原则"><a href="#3-1-4-最左匹配原则" class="headerlink" title="3.1.4 最左匹配原则"></a>3.1.4 最左匹配原则</h3><p>最左前缀匹配原则和联合索引的<strong>索引存储结构和检索方式</strong>是有关系的。</p>
<p>在组合索引树中，最底层的叶子节点按照第一列 name  列从左到右递增排列，但是 age 列是无序的，age 列只有在 name 列值相等的情况下小范围内递增有序。</p>
<p>就像上面的查询，B+ 树会先比较 name 列来确定下一步应该搜索的方向，往左还是往右。如果 name 列相同再比较 age 列。但是如果查询条件没有 name 列，B + 树就不知道第一步应该从哪个节点查起，<strong>这就是所谓的最左匹配原则</strong>。</p>
<p>可以说创建的 idx_name_age (name,age) 索引，相当于创建了 (name)、（name,age）两个索引。、</p>
<p>组合索引的最左前缀匹配原则：使用组合索引查询时，mysql 会一直向右匹配直至遇到范围查询 (&gt;、&lt;、between、like) 就停止匹配。</p>
<h3 id="3-1-5-覆盖索引"><a href="#3-1-5-覆盖索引" class="headerlink" title="3.1.5 覆盖索引"></a>3.1.5 覆盖索引</h3><p>覆盖索引是一种很常用的优化手段。因为在上面普通索引的例子中，由于查询结果所需要的数据只在主键索引上有，所以不得不回表。那么有没有可能经过索引优化，避免回表呢？比如改成这样子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select age from student where age = 48;</span><br></pre></td></tr></table></figure>

<p>在上面普通索引例子中，如果我只需要 age 字段，那是不是意味着我们查询到普通索引的叶子节点就可以直接返回了，而不需要回表。这种情况就是覆盖索引。</p>
<p>看下执行计划：</p>
<p>覆盖索引的情况：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411160741466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>覆盖索引</p>
<p>未覆盖索引的情况：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411160755436.png#pic_center" alt="在这里插入图片描述"><br>未覆盖索引</p>
<h2 id="3-2-myisam-索引"><a href="#3-2-myisam-索引" class="headerlink" title="3.2 myisam 索引"></a>3.2 myisam 索引</h2><p>还是上面那张 student 表，建表语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `student`  (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,</span><br><span class="line">  `age` int(11) NULL DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE,</span><br><span class="line">  INDEX `index_age`(`age`) USING BTREE</span><br><span class="line">) ENGINE = MyISAM AUTO_INCREMENT = 66 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-1-主键索引"><a href="#3-2-1-主键索引" class="headerlink" title="3.2.1 主键索引"></a>3.2.1 主键索引</h3><p>与 InnDB 不同的是 myisam 的数据文件和索引文件是分开存储的。<strong>它的叶子节点存的是健值，数据是索引所在行的磁盘地址</strong>。它的结构如下：表 student 的索引文件存放在 student.MYI 中，数据文件存储在 student.MYD 中。</p>
<p><img src="https://img-blog.csdnimg.cn/20210411160809438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>myisam 主键索引结构</p>
<ul>
<li><strong>主键索引等值查询</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from student where id = 38;</span><br></pre></td></tr></table></figure>

<p>它的具体执行流程如下：</p>
<ul>
<li>第一次磁盘 IO：从根节点检索，将数据块 1 加载到内存，比较 38 &lt; 44，走左边。</li>
<li>第二次磁盘 IO：将左边数据块 2 加载到内存，比较 8&lt;37&lt;38，走右边。</li>
<li>第三次磁盘 IO：将右边数据块 6 加载到内存，比较 37&lt;38，38&#x3D;38。得到索引所在行的内存地址。</li>
<li>第四次磁盘 IO：根据地址到数据文件 student.MYD 中获取对应的行记录。</li>
</ul>
<p>流程图：<strong>一共 4 次磁盘 IO</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20210411160823703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>myisam 主键等值查询流程</p>
<ul>
<li><strong>主键索引范围查询</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from student where id between 38 and 44;</span><br></pre></td></tr></table></figure>

<p>过程如下：</p>
<ul>
<li>第一次磁盘 IO：从根节点检索，将数据块 1 加载到内存，比较 38 &lt; 44，走左边。</li>
<li>第二次磁盘 IO：将左边数据块 2 加载到内存，比较 8&lt;37&lt;38，走右边。</li>
<li>第三次磁盘 IO：将右边数据块 6 加载到内存，比较 37&lt;38，38&#x3D;38。得到索引所在行的内存地址。</li>
<li>第四次磁盘 IO：根据地址到数据文件 student.MYD 中获取主键 38 对应的行记录。</li>
<li>第五次磁盘 IO：将右边数据块 7 加载到内存，比较 38&lt;44&#x3D;44。得到索引所在行的内存地址。</li>
<li>第六次磁盘 IO：根据地址到数据文件 student.MYD 中获取主键 44 对应的行记录。</li>
</ul>
<h3 id="3-2-2-普通索引"><a href="#3-2-2-普通索引" class="headerlink" title="3.2.2 普通索引"></a>3.2.2 普通索引</h3><p>在 MyISAM 中，辅助索引和主键索引的结构是一样的，没有任何区别，叶子节点的数据存储的都是行记录的磁盘地址。<strong>只是主键索引的键值是唯一的，而辅助索引的键值可以重复</strong>。</p>
<p>查询数据时，由于辅助索引的键值不唯一，可能存在多个拥有相同的记录，所以即使是等值查询，也需要按照范围查询的方式在辅助索引树中检索数据。</p>
<h2 id="3-3-索引的使用技巧"><a href="#3-3-索引的使用技巧" class="headerlink" title="3.3 索引的使用技巧"></a>3.3 索引的使用技巧</h2><h3 id="3-3-1-避免回表"><a href="#3-3-1-避免回表" class="headerlink" title="3.3.1 避免回表"></a>3.3.1 避免回表</h3><p>上面说了，回表的原因是因为查询结果所需要的数据只在主键索引上有，所以不得不回表。回表必然会影响性能。那怎么避免呢？</p>
<p><strong>使用覆盖索引</strong>，举个栗子：还是上面的 student ，它的一条 sql 在业务上很常用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select id, name, age from student where name = &#x27;二狗2&#x27;;</span><br></pre></td></tr></table></figure>

<p>而 student 表的其他字段使用频率远低于它，在这种情况下，如果我们在建立 name 字段的索引的时候，并不是使用单一索引，而是使用联合索引（name，age）这样的话再执行这个查询语句就可以根据辅助索引查询到的结果获取当前语句的完整数据。</p>
<p>这样就有效避免了通过回表再获取 age 的数据。喏，<strong>这就是一个典型的用覆盖索引的优化策略减少回表的情况</strong>。</p>
<h3 id="3-3-2-联合索引的使用"><a href="#3-3-2-联合索引的使用" class="headerlink" title="3.3.2 联合索引的使用"></a>3.3.2 联合索引的使用</h3><p>联合索引，在建立索引的时候，尽量在多个单列索引上判断下是否可以使用联合索引。联合索引的使用不仅可以节省空间，还可以更容易的使用到索引覆盖。比如上面的 student 表，我就建了 (name,age) 和 age 索引。</p>
<p>联合索引的创建原则，在创建联合索引的时候因该把频繁使用的列、区分度高的列放在前面，频繁使用代表索引利用率高，区分度高代表筛选粒度大。</p>
<p>也可以在常需要作为查询返回的字段上增加到联合索引中，如果在联合索引上增加一个字段而使用到了覆盖索引，这种情况下应该使用联合索引。</p>
<p>联合索引的使用</p>
<ul>
<li>考虑当前是否已经存在多个可以合并的单列索引，如果有，那么将当前多个单列索引创建为一个联合索引。</li>
<li>当前索引存在频繁使用作为返回字段的列，这个时候就可以考虑当前列是否可以加入到当前已经存在索引上，使其查询语句可以使用到覆盖索引。</li>
</ul>
<h3 id="3-3-3-索引下推"><a href="#3-3-3-索引下推" class="headerlink" title="3.3.3 索引下推"></a>3.3.3 索引下推</h3><p>现在我的表数据是这样的：加了一个 sex 列。</p>
<p><img src="https://img-blog.csdnimg.cn/2021041116083927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>数据表</p>
<p>说到满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。这时，你可能要问，那些不符合最左前缀的部分，会怎么样呢？</p>
<p>我们还是以学生表的联合索引（name，age）为例。如果现在有一个需求：检索出表中 “名字第一个字是二，而且年龄是 38 岁的所有男生”。那么，SQL 语句是这么写的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from student where name like &#x27;张%&#x27; and age=38 and sex=&#x27;男&#x27;;</span><br></pre></td></tr></table></figure>

<p>根据前缀索引规则，所以这个语句在搜索索引树的时候，只能用 “张”，找到三个满足条件的记录（图中红框数据）。当然，这还不错，总比全表扫描要好。</p>
<p>然后呢？当然是判断其他条件是否满足。</p>
<p>在 MySQL5.6 之前，只能从满足条件的记录 id&#x3D;18 开始一个个回表。到主键索引上找出数据行，再对比字段</p>
<p>而 MySQL 5.6 引入的索引下推优化（index condition pushdown），<strong>可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。</p>
<p>它的整个执行的流程图是这样的：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411160858667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>索引下推</p>
<p>InnoDB 在（name，age）索引内部就判断了 age 是否等于 38，对于不等于 38 的记录，直接判断并跳过。在我们的这个例子中，只需要对 id&#x3D;18 和 id&#x3D;65 这两条记录回表取数据判断，就只需要回表 2 次，这就是所谓的索引下推。</p>
<h3 id="2-性能分析"><a href="#2-性能分析" class="headerlink" title="2.性能分析"></a>2.性能分析</h3><h5 id="MySQL-Query-Optimizer"><a href="#MySQL-Query-Optimizer" class="headerlink" title="MySQL Query Optimizer"></a>MySQL Query Optimizer</h5><p><img src="https://img-blog.csdnimg.cn/20210411160912466.png#pic_center" alt="在这里插入图片描述"></p>
<h5 id="MySQL常见瓶颈"><a href="#MySQL常见瓶颈" class="headerlink" title="MySQL常见瓶颈:"></a>MySQL常见瓶颈:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CPU:CPU在饱和的时候一般发生在数据装入在内存或从磁盘上读取数据时候</span><br><span class="line"></span><br><span class="line">IO:磁盘I/O瓶颈发生在装入数据远大于内存容量时</span><br><span class="line"></span><br><span class="line">服务器硬件的性能瓶颈：top,free,iostat和vmstat来查看系统的性能状态</span><br></pre></td></tr></table></figure>



<h4 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h4><h5 id="是什么（查看执行计划）"><a href="#是什么（查看执行计划）" class="headerlink" title="是什么（查看执行计划）"></a>是什么（查看执行计划）</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用EXPLAIN关键字可以模拟优化器执行SQL语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是结构的性能瓶颈</span><br></pre></td></tr></table></figure>

<h5 id="怎么玩"><a href="#怎么玩" class="headerlink" title="怎么玩"></a>怎么玩</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Explain+SQL语句</span><br></pre></td></tr></table></figure>

<h5 id="执行计划包含的信息"><a href="#执行计划包含的信息" class="headerlink" title="执行计划包含的信息"></a>执行计划包含的信息</h5><p><img src="https://img-blog.csdnimg.cn/20210411160925619.png#pic_center" alt="在这里插入图片描述"></p>
<h5 id="各个字段解释"><a href="#各个字段解释" class="headerlink" title="各个字段解释"></a>各个字段解释</h5><h5 id="id"><a href="#id" class="headerlink" title="id"></a>id</h5><p>select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序<br>三种情况<br>id相同，执行顺序由上至下</p>
<p><img src="https://img-blog.csdnimg.cn/2021041116093949.png#pic_center" alt="在这里插入图片描述"></p>
<p>id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</p>
<p><img src="https://img-blog.csdnimg.cn/20210411160951577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>id相同不同，同时存在</p>
<p><img src="https://img-blog.csdnimg.cn/20210411161001782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h5><p>有哪些：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411161011738.png#pic_center" alt="在这里插入图片描述"></p>
<p>查询的类型，主要用于区别普通查询、联合查询、子查询等的复杂查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.SIMPLE：简单的select查询，查询中不包含子查询或者UNION</span><br><span class="line"></span><br><span class="line">2.PRIMARY：查询中若包含任何复杂的子部分，最外层查询则被标记为</span><br><span class="line"></span><br><span class="line">3.SUBQUERY：在SELECT或者WHERE列表中包含了子查询</span><br><span class="line"></span><br><span class="line">4.DERIVED：在FROM列表中包含的子查询被标记为DERIVED（衍生）MySQL会递归执行这些子查询，把结果放在临时表里。</span><br><span class="line"></span><br><span class="line">5.UNION：若第二个SELECT出现在UNION之后，则被标记为UNION;若UNION包含在FROM子句的子查询中，外层SELECT将被标记为：DERIVED</span><br><span class="line"></span><br><span class="line">6.UNION RESULT：从UNION表获取结果的SELECT</span><br></pre></td></tr></table></figure>



<h5 id="table"><a href="#table" class="headerlink" title="table"></a>table</h5><p>显示这一行的数据是关于哪张表的</p>
<h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><p>显示查询使用了何种类型<br>从最好到最差依次是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，这个也可以忽略不计</span><br><span class="line"></span><br><span class="line">const：表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很			快。如将主键至于where列表中，MySQL就能将该查询转换为一个常量</span><br><span class="line"></span><br><span class="line">eq_ref：唯一性索引，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描</span><br><span class="line"></span><br><span class="line">ref：非唯一索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的		行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体</span><br><span class="line"></span><br><span class="line">range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引一般就是在你的where语句中				出现了between、&lt;、&gt;、in等的查询这种范围扫描索引扫描比全表扫描要好，因为他只需要开始索引的				某一点，而结束语另一点，不用扫描全部索引</span><br><span class="line"></span><br><span class="line">index：Full Index Scan,index与ALL区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据		文件小。（也就是说虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘中读的）</span><br><span class="line"></span><br><span class="line">all：FullTable Scan,将遍历全表以找到匹配的行</span><br></pre></td></tr></table></figure>

<h5 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h5><p>显示可能应用在这张表中的索引,一个或多个。查询涉及的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用</p>
<h5 id="key"><a href="#key" class="headerlink" title="key"></a>key</h5><p>实际使用的索引。如果为null则没有使用索引</p>
<h5 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h5><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好key_len显示的值为索引最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的</p>
<h5 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h5><p>显示索引那一列被使用了，如果可能的话，是一个常数。那些列或常量被用于查找索引列上的值</p>
<h5 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h5><p>根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数</p>
<h5 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h5><p>包含不适合在其他列中显示但十分重要的额外信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.Using filesort：说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。</span><br><span class="line">MySQL中无法利用索引完成排序操作成为“文件排序”</span><br><span class="line"></span><br><span class="line">2.Using temporary：使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于排序order by 和分组查询 group by</span><br><span class="line"></span><br><span class="line">3.USING index：表示相应的select操作中使用了覆盖索引（Coveing Index）,避免访问了表的数据行，效率不错！</span><br><span class="line">如果同时出现using where，表明索引被用来执行索引键值的查找；</span><br><span class="line">如果没有同时出现using where，表面索引用来读取数据而非执行查找动作。</span><br></pre></td></tr></table></figure>

<p>覆盖索引（Covering Index）：</p>
<p><img src="https://img-blog.csdnimg.cn/20210411161024904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4.Using where：表面使用了where过滤</span><br><span class="line"></span><br><span class="line">5.using join buffer：使用了连接缓存</span><br><span class="line"></span><br><span class="line">6.impossible where：where子句的值总是false，不能用来获取任何元组</span><br><span class="line"></span><br><span class="line">7.select tables optimized away：在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者</span><br><span class="line">对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，</span><br><span class="line">查询执行计划生成的阶段即完成优化。</span><br><span class="line"></span><br><span class="line">8.distinct：优化distinct，在找到第一匹配的元组后即停止找同样值的工作</span><br></pre></td></tr></table></figure>



<h3 id="3-索引优化"><a href="#3-索引优化" class="headerlink" title="3.索引优化"></a>3.索引优化</h3><h5 id="索引失效（应该避免）"><a href="#索引失效（应该避免）" class="headerlink" title="索引失效（应该避免）"></a>索引失效（应该避免）</h5><p>1.全值匹配我最爱</p>
<p><img src="https://img-blog.csdnimg.cn/20210411161035533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>2.最佳左前缀法则（针对于联合索引）</p>
<p><img src="https://img-blog.csdnimg.cn/20210411161045407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>3.不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描</p>
<p><img src="https://img-blog.csdnimg.cn/20210411161057270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>4.存储引擎不能使用索引中范围条件右边的列</p>
<p><img src="https://img-blog.csdnimg.cn/20210411161108536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>5.尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select*</p>
<p><img src="https://img-blog.csdnimg.cn/20210411161134357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411161146709.png#pic_center" alt="在这里插入图片描述"></p>
<p>6.mysql在使用不等于（！&#x3D;或者&lt;&gt;）的时候无法使用索引会导致全表扫描</p>
<p><img src="https://img-blog.csdnimg.cn/20210411161156765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>7.is null,is not null 也无法使用索引</p>
<p><img src="https://img-blog.csdnimg.cn/20210411161213888.png#pic_center" alt="在这里插入图片描述"></p>
<p>8.like以通配符开头（’$abc…’）mysql索引失效会变成全表扫描操作</p>
<p><img src="https://img-blog.csdnimg.cn/20210411161227556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>9.字符串不加单引号索引失效</p>
<p><img src="https://img-blog.csdnimg.cn/20210411161239574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>10.少用or,用它连接时会索引失效</p>
<p><img src="https://img-blog.csdnimg.cn/20210411161251181.png#pic_center" alt="在这里插入图片描述"></p>
<p>11.小总结</p>
<p><img src="https://img-blog.csdnimg.cn/2021041116130355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411161315688.png#pic_center" alt="在这里插入图片描述"></p>
<h4 id="一般性建议"><a href="#一般性建议" class="headerlink" title="一般性建议"></a>一般性建议</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于单键索引，尽量选择针对当前query过滤性更好的索引</span><br><span class="line"></span><br><span class="line">在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</span><br><span class="line"></span><br><span class="line">在选择组合索引的时候，尽量选择可以能包含当前query中的where子句中更多字段的索引</span><br><span class="line"></span><br><span class="line">尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的</span><br></pre></td></tr></table></figure>

<h2 id="三、查询截取分析"><a href="#三、查询截取分析" class="headerlink" title="三、查询截取分析"></a>三、查询截取分析</h2><h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><p>永远小表驱动大表，类似嵌套循环Nested Loop</p>
<p><img src="https://img-blog.csdnimg.cn/20210411161330292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411161342413.png#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411161355201.png#pic_center" alt="在这里插入图片描述"></p>
<h5 id="order-by关键字优化"><a href="#order-by关键字优化" class="headerlink" title="order by关键字优化"></a>order by关键字优化</h5><p>ORDER BY子句，尽量使用Index方式排序，避免使用FileSort方式排序</p>
<p>尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀</p>
<p>如果不在索引列上，filesort有两种算法：<br>mysql就要启动双路排序和单路排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">双路排序</span><br><span class="line">1.MySQL4.1之前是使用双路排序，字面意思是两次扫描磁盘，最终得到数据。</span><br><span class="line">读取行指针和orderby列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据传输</span><br><span class="line">2.从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。</span><br><span class="line">取一批数据，要对磁盘进行两次扫描，众所周知，I\O是很耗时的，所以在mysql4.1之后，出现了第二张改进的算法，就是单路排序。</span><br><span class="line"></span><br><span class="line">单路排序</span><br><span class="line">从磁盘读取查询需要的所有列，按照orderby列在buffer对它们进行排序，然后扫描排序后的列表进行输出，</span><br><span class="line">它的效率更快一些，避免了第二次读取数据，并且把随机IO变成顺序IO，但是它会使用更多的空间，</span><br><span class="line">因为它把每一行都保存在内存中了。</span><br><span class="line"></span><br><span class="line">结论及引申出的问题</span><br><span class="line">由于单路是后出来的，总体而言好过双路</span><br><span class="line">但是用单路有问题</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210411161406124.png#pic_center" alt="在这里插入图片描述"></p>
<h5 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h5><p>增大sort_buffer_size参数的设置</p>
<p>增大max_length_for_sort_data参数的设置</p>
<p><img src="https://img-blog.csdnimg.cn/20210411161417639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="小总结"><a href="#小总结" class="headerlink" title="小总结:"></a>小总结:</h5><p><img src="https://img-blog.csdnimg.cn/20210411161429396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="GROUP-BY关键字优化"><a href="#GROUP-BY关键字优化" class="headerlink" title="GROUP BY关键字优化"></a>GROUP BY关键字优化</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">groupby实质是先排序后进行分组，遵照索引建的最佳左前缀</span><br><span class="line"></span><br><span class="line">当无法使用索引列，增大max_length_for_sort_data参数的设置+增大sort_buffer_size参数的设置</span><br><span class="line"></span><br><span class="line">where高于having,能写在where限定的条件就不要去having限定了。</span><br></pre></td></tr></table></figure>



<h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><h5 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h5><p><img src="https://img-blog.csdnimg.cn/20210411161441551.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="日志分析工具mysqldumpslow"><a href="#日志分析工具mysqldumpslow" class="headerlink" title="日志分析工具mysqldumpslow"></a>日志分析工具mysqldumpslow</h5><p>查看mysqldumpslow的帮助信息</p>
<p><img src="https://img-blog.csdnimg.cn/20210411161450524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="批量数据脚本"><a href="#批量数据脚本" class="headerlink" title="批量数据脚本"></a>批量数据脚本</h3><h5 id="往表里插入1000W数据"><a href="#往表里插入1000W数据" class="headerlink" title="往表里插入1000W数据"></a>往表里插入1000W数据</h5><p>1.建表</p>
<p>2.设置参数log_trust_function_createors</p>
<p><img src="https://img-blog.csdnimg.cn/20210411161503700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>3创建函数保证每条数据都不同</p>
<p><img src="https://img-blog.csdnimg.cn/20210411161521242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<pre><code>随机产生字符串

随机产生部门编号
</code></pre>
<p>4.创建存储过程</p>
<p><img src="https://img-blog.csdnimg.cn/20210411161531804.png#pic_center" alt="在这里插入图片描述"></p>
<pre><code>创建往emp表中插入数据的存储过程

创建往dept表中插入数据的存储过程
</code></pre>
<p>5.调用存储过程</p>
<h3 id="Show-profiles"><a href="#Show-profiles" class="headerlink" title="Show profiles"></a>Show profiles</h3><h5 id="是什么："><a href="#是什么：" class="headerlink" title="是什么："></a>是什么：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">是mysql提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优测量</span><br></pre></td></tr></table></figure>

<p>默认情况下，参数处于关闭状态，并保存最近15次的运行结果</p>
<h5 id="分析步骤"><a href="#分析步骤" class="headerlink" title="分析步骤:"></a>分析步骤:</h5><p>1.是否支持，看看当前的SQL版本是否支持</p>
<p><img src="https://img-blog.csdnimg.cn/20210411161553776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>2.开启功能，默认是关闭，使用前需要开启</p>
<p>3.运行SQL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp group by id%10 limit 150000</span><br></pre></td></tr></table></figure>

<p>4.查看结果，show profiles;</p>
<p>5.诊断SQL，show profile cpu,block io for query 上一步前面的问题SQL 数字号码；</p>
<p><img src="https://img-blog.csdnimg.cn/20210411161613579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411161627224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>6.日常开发需要注意的结论</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">converting HEAP to MyISAM 查询结果太大，内存都不够用了往磁盘上搬了。</span><br><span class="line"></span><br><span class="line">Creating tmp table 创建临时表</span><br><span class="line"></span><br><span class="line">Copying to tmp table on disk 把内存中临时表复制到磁盘，危险！！！</span><br><span class="line"></span><br><span class="line">locked</span><br></pre></td></tr></table></figure>







<h3 id="全局查询日志"><a href="#全局查询日志" class="headerlink" title="全局查询日志"></a>全局查询日志</h3><p>配置启用</p>
<p><img src="https://img-blog.csdnimg.cn/20210411161732272.png#pic_center" alt="在这里插入图片描述"></p>
<p>编码启用</p>
<p><img src="https://img-blog.csdnimg.cn/20210411161748686.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="永远不要在生产环境开启这个功能。"><a href="#永远不要在生产环境开启这个功能。" class="headerlink" title="永远不要在生产环境开启这个功能。"></a>永远不要在生产环境开启这个功能。</h5><h2 id="四、MySQL锁机制"><a href="#四、MySQL锁机制" class="headerlink" title="四、MySQL锁机制"></a>四、MySQL锁机制</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h4><h5 id="从数据操作的类型（读、写）分："><a href="#从数据操作的类型（读、写）分：" class="headerlink" title="从数据操作的类型（读、写）分："></a>从数据操作的类型（读、写）分：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响</span><br><span class="line"></span><br><span class="line">写锁（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁。</span><br></pre></td></tr></table></figure>

<h5 id="从对数据操作的颗粒度："><a href="#从对数据操作的颗粒度：" class="headerlink" title="从对数据操作的颗粒度："></a>从对数据操作的颗粒度：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">表锁</span><br><span class="line"></span><br><span class="line">行锁</span><br></pre></td></tr></table></figure>



<h3 id="表锁（偏读）"><a href="#表锁（偏读）" class="headerlink" title="表锁（偏读）"></a>表锁（偏读）</h3><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">偏向MyISAM存储引擎，开销小，加锁快，无死锁，锁定粒度大，发生锁冲突的概率最高，并发最低</span><br></pre></td></tr></table></figure>

<h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><h5 id="建表SQL"><a href="#建表SQL" class="headerlink" title="建表SQL"></a>建表SQL</h5><p><img src="https://img-blog.csdnimg.cn/20210411161800601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="加读锁"><a href="#加读锁" class="headerlink" title="加读锁"></a>加读锁</h5><p><img src="https://img-blog.csdnimg.cn/20210411161820643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411161837283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411161848101.png#pic_center" alt="在这里插入图片描述"></p>
<h5 id="加写锁"><a href="#加写锁" class="headerlink" title="加写锁"></a>加写锁</h5><p><img src="https://img-blog.csdnimg.cn/20210411161859850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411161914256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="案例结论"><a href="#案例结论" class="headerlink" title="案例结论"></a>案例结论</h4><p><img src="https://img-blog.csdnimg.cn/20210411161925835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="表锁分析"><a href="#表锁分析" class="headerlink" title="表锁分析"></a>表锁分析</h4><p><img src="https://img-blog.csdnimg.cn/20210411161938708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>or连接会使行锁升级为表锁</strong></p>
<h3 id="行锁（偏写）"><a href="#行锁（偏写）" class="headerlink" title="行锁（偏写）"></a>行锁（偏写）</h3><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">偏向InnoDB存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</span><br><span class="line"></span><br><span class="line">InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）;二是采用了行级锁</span><br></pre></td></tr></table></figure>



<h4 id="由于行锁支持事务，复习老知识"><a href="#由于行锁支持事务，复习老知识" class="headerlink" title="由于行锁支持事务，复习老知识"></a>由于行锁支持事务，复习老知识</h4><h5 id="事务（Transation）及其ACID属性"><a href="#事务（Transation）及其ACID属性" class="headerlink" title="事务（Transation）及其ACID属性"></a>事务（Transation）及其ACID属性</h5><h5 id="并发事务处理带来的问题"><a href="#并发事务处理带来的问题" class="headerlink" title="并发事务处理带来的问题"></a>并发事务处理带来的问题</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">脏读:（Dirty Reads）：事务A读到了事务B已修改但尚未提交的数据，还在这个数据基础上做了操作，此时，如果B事务回滚，A读取的数据无效，不符合一致性要求。</span><br><span class="line">不可重复读（Non-Repeatable Reads）：事务A读取到事务B已经提交的数据,不符合隔离性</span><br><span class="line">幻读（Phantom Reads）:事务A读取到事务B新增的数据</span><br><span class="line"></span><br><span class="line">脏读和幻读的区别：脏读是事务B修改了数据，幻读是事务B新增了数据.</span><br></pre></td></tr></table></figure>



<h5 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h5><p><img src="https://img-blog.csdnimg.cn/20210411161951836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="案例分析-1"><a href="#案例分析-1" class="headerlink" title="案例分析"></a>案例分析</h4><h5 id="建表SQL-1"><a href="#建表SQL-1" class="headerlink" title="建表SQL"></a>建表SQL</h5><p><img src="https://img-blog.csdnimg.cn/20210411162002797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="行锁定基本演示"><a href="#行锁定基本演示" class="headerlink" title="行锁定基本演示"></a>行锁定基本演示</h5><p><img src="https://img-blog.csdnimg.cn/20210411162014791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="无索引行锁升级为表锁"><a href="#无索引行锁升级为表锁" class="headerlink" title="无索引行锁升级为表锁"></a>无索引行锁升级为表锁</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">varchar  不用 &#x27; &#x27;  导致系统自动转换类型, 行锁变表锁</span><br></pre></td></tr></table></figure>

<h5 id="间隙锁危害"><a href="#间隙锁危害" class="headerlink" title="间隙锁危害"></a>间隙锁危害</h5><p>间隙锁实际上是为了解决幻读的问题</p>
<p>例如A session开启事务但是没有提交,update user set age&#x3D;1 where id&gt;1 and id&lt;5;</p>
<p>这个时候B session进行插入 insert into user value(2,4); 这个时候会阻塞</p>
<p><img src="https://img-blog.csdnimg.cn/2021041116202880.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="面试题：常考如何锁定一行"><a href="#面试题：常考如何锁定一行" class="headerlink" title="面试题：常考如何锁定一行"></a>面试题：常考如何锁定一行</h5><p><img src="https://img-blog.csdnimg.cn/20210411162038496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="案例结论-1"><a href="#案例结论-1" class="headerlink" title="案例结论"></a>案例结论</h4><p><img src="https://img-blog.csdnimg.cn/20210411162052761.png#pic_center" alt="在这里插入图片描述"></p>
<h4 id="行锁分析"><a href="#行锁分析" class="headerlink" title="行锁分析"></a>行锁分析</h4><p><img src="https://img-blog.csdnimg.cn/20210411162105872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁</span><br><span class="line">合理设计索引，尽量缩小锁的范围</span><br><span class="line">尽可能较少检索条件，避免间隙锁</span><br><span class="line">尽量控制事务大小，减少锁定资源量和时间长度</span><br><span class="line">尽可能低级别事务隔离</span><br></pre></td></tr></table></figure>



<p>MVCC详情：<a href="https://www.bilibili.com/video/BV1Lt4y1S7zF?from=search&amp;seid=17514361240759101872">https://www.bilibili.com/video/BV1Lt4y1S7zF?from=search&amp;seid=17514361240759101872</a></p>
<h2 id="五、主从复制"><a href="#五、主从复制" class="headerlink" title="五、主从复制"></a>五、主从复制</h2><h3 id="复制的基本原理"><a href="#复制的基本原理" class="headerlink" title="复制的基本原理"></a>复制的基本原理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slave会从master读取binlog来进行数据同步</span><br></pre></td></tr></table></figure>

<h5 id="三大步骤："><a href="#三大步骤：" class="headerlink" title="三大步骤："></a>三大步骤：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">master将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志时间，binary log events</span><br><span class="line"></span><br><span class="line">slave将master的binary log ebents拷贝到它的中继日志（relay log</span><br><span class="line"></span><br><span class="line">slave重做中继日志中事件，将改变应用到自己的数据库中。MySQL复制是异步的且串行化的</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210411162117641.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="复制的基本原则"><a href="#复制的基本原则" class="headerlink" title="复制的基本原则"></a>复制的基本原则</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">每个slave只有一个master</span><br><span class="line"></span><br><span class="line">每个slave只能有一个唯一的服务器ID</span><br><span class="line"></span><br><span class="line">每个master可以有多个salve</span><br></pre></td></tr></table></figure>



<h3 id="复制最大问题"><a href="#复制最大问题" class="headerlink" title="复制最大问题"></a>复制最大问题</h3><h5 id="延时"><a href="#延时" class="headerlink" title="延时"></a>延时</h5><h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p><a href="https://b23.tv/8EpgnH">https://b23.tv/8EpgnH</a></p>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>快照读 当前读 事务id 事务管理器</p>
<h3 id="数据库事务实现原理"><a href="#数据库事务实现原理" class="headerlink" title="数据库事务实现原理"></a>数据库事务实现原理</h3><h2 id="2-日志文件"><a href="#2-日志文件" class="headerlink" title="2. 日志文件"></a>2. 日志文件</h2><h3 id="2-1-redo-log"><a href="#2-1-redo-log" class="headerlink" title="2.1. redo log"></a>2.1. redo log</h3><p>redo log叫做重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。</p>
<p>当事务提交之后会把所有修改信息都会存到该日志中。假设有个表叫做tb1(id,username) 现在要插入数据（3，ceshi）</p>
<p><img src="https://img-blog.csdnimg.cn/20210411162246816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start transaction; </span><br><span class="line">select balance from bank where name=&quot;zhangsan&quot;; </span><br><span class="line">// 生成 重做日志 balance=600 </span><br><span class="line">update bank set balance = balance - 400; </span><br><span class="line">// 生成 重做日志 amount=400 </span><br><span class="line">update finance set amount = amount + 400; </span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210411162346107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>redo log 有什么作用？</strong></p>
</blockquote>
<p>mysql 为了提升性能不会把每次的修改都实时同步到磁盘，而是会先存到Boffer Pool(缓冲池)里头，把这个当作缓存来用。然后使用后台线程去做<strong>缓冲池和磁盘之间的同步</strong>。</p>
<p>那么问题来了，如果还没来的同步的时候宕机或断电了怎么办？还没来得及执行上面图中红色的操作。这样会导致丢部分已提交事务的修改信息！</p>
<p>所以引入了redo log来记录已成功提交事务的修改信息，并且会把redo log持久化到磁盘，系统重启之后在读取redo log恢复最新数据。</p>
<p><strong>总结：redo log是用来恢复数据的 用于保障，已提交事务的持久化特性。</strong></p>
<h3 id="2-2-undo-log"><a href="#2-2-undo-log" class="headerlink" title="2.2. undo log"></a>2.2. undo log</h3><p>undo log 叫做回滚日志，用于记录数据<strong>被修改前</strong>的信息。他正好跟前面所说的重做日志所记录的相反，重做日志记录数据被修改后的信息。undo log主要记录的是数据的逻辑变化，为了在发生错误时回滚之前的操作，需要将之前的操作都记录下来，然后在发生错误时才可以回滚。</p>
<p>还用上面那两张表</p>
<p><img src="https://img-blog.csdnimg.cn/20210411162417353.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>每次写入数据或者修改数据之前都会把修改前的信息记录到 undo log。</p>
<blockquote>
<p><strong>undo log 有什么作用？</strong></p>
</blockquote>
<p>undo log 记录事务修改之前版本的数据信息，因此假如由于系统错误或者rollback操作而回滚的话可以根据undo log的信息来进行回滚到没被修改前的状态。</p>
<p><strong>总结：undo log是用来回滚数据的用于保障 未提交事务的原子性。</strong></p>
<h3 id="2-3-archive-log-binlog"><a href="#2-3-archive-log-binlog" class="headerlink" title="2.3. archive log(binlog)"></a>2.3. archive log(binlog)</h3><p>archive log（归档日志）是Oracle数据库中的概念，它其实是redo log的衍生物。</p>
<p>在Mysql数据库中，归档日志有另外一个名字 binlog（二进制日志 binary log），在mysql主从模式中，从节点就是通过同步主节点的binlog实现主从同步的。</p>
<p>redo log file是LGWR进程从Oracle实例中的redo log buffer写入的，是循环利用的。就是说一个redo log file写满后，才写下一个。归档日志是当数据库运行在归档模式下时，一个redo log file写满后，由ARCn进程将重做日志的内容备份到归档日志文件下，然后这个redo log file才能被下一次使用。</p>
<p>不管数据库是否是归档模式，重做日志是肯定要写的。而只有数据库在归档模式下，重做日志才会备份，形成归档日志。</p>
<p>redo log是循环利用的，但是归档日志不是，它不断接收从redo log中写入的日志备份。因此到一定时间后，会导致数据库存储不够，影响数据库使用。我们一般都会执行一个定时脚本，在规定时间周期后，删掉保留周期前的归档日志文件。**</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>OLTP</tag>
        <tag>数据库</tag>
        <tag>分库分表</tag>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis缓存机制</title>
    <url>/2022/10/25/Mybatis%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MyBatis是常见的Java数据库访问层框架。在日常工作中，开发人员多数情况下是使用MyBatis的默认缓存配置，但是MyBatis缓存机制有一些不足之处，在使用中容易引起脏数据，形成一些潜在的隐患。个人在业务开发中也处理过一些由于MyBatis缓存引发的开发问题，带着个人的兴趣，希望从应用及源码的角度为读者梳理MyBatis缓存机制。</p>
<p>本次分析中涉及到的代码和数据库表均放在GitHub上，地址： <a href="https://github.com/kailuncen/mybatis-cache-demo">mybatis-cache-demo</a> 。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>本文按照以下顺序展开。</p>
<ul>
<li>一级缓存介绍及相关配置。</li>
<li>一级缓存工作流程及源码分析。</li>
<li>一级缓存总结。</li>
<li>二级缓存介绍及相关配置。</li>
<li>二级缓存源码分析。</li>
<li>二级缓存总结。</li>
<li>全文总结。</li>
</ul>
<h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><h3 id="一级缓存介绍"><a href="#一级缓存介绍" class="headerlink" title="一级缓存介绍"></a>一级缓存介绍</h3><p>在应用运行过程中，我们有可能在一次数据库会话中，执行多次查询条件完全相同的SQL，MyBatis提供了一级缓存的方案优化这部分场景，如果是相同的SQL语句，会优先命中一级缓存，避免直接对数据库进行查询，提高性能。具体执行过程如下图所示。</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/6e38df6a.jpg" alt="img"></p>
<p>每个SqlSession中持有了Executor，每个Executor中有一个LocalCache。当用户发起查询时，MyBatis根据当前执行的语句生成<code>MappedStatement</code>，在Local Cache进行查询，如果缓存命中的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入<code>Local Cache</code>，最后返回结果给用户。具体实现类的类关系图如下图所示。</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/d76ec5fe.jpg" alt="img"></p>
<h3 id="一级缓存配置"><a href="#一级缓存配置" class="headerlink" title="一级缓存配置"></a>一级缓存配置</h3><p>我们来看看如何使用MyBatis一级缓存。开发者只需在MyBatis的配置文件中，添加如下语句，就可以使用一级缓存。共有两个选项，<code>SESSION</code>或者<code>STATEMENT</code>，默认是<code>SESSION</code>级别，即在一个MyBatis会话中执行的所有语句，都会共享这一个缓存。一种是<code>STATEMENT</code>级别，可以理解为缓存只对当前执行的这一个<code>Statement</code>有效。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;localCacheScope&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SESSION&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="一级缓存实验"><a href="#一级缓存实验" class="headerlink" title="一级缓存实验"></a>一级缓存实验</h3><p>接下来通过实验，了解MyBatis一级缓存的效果，每个单元测试后都请恢复被修改的数据。</p>
<p>首先是创建示例表student，创建对应的POJO类和增改的方法，具体可以在entity包和mapper包中查看。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` tinyint(<span class="number">3</span>) unsigned <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">4</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin;</span><br></pre></td></tr></table></figure>

<p>在以下实验中，id为1的学生名称是凯伦。</p>
<h4 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h4><p>开启一级缓存，范围为会话级别，调用三次<code>getStudentById</code>，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getStudentById</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> factory.openSession(<span class="literal">true</span>); <span class="comment">// 自动提交事务</span></span><br><span class="line">        <span class="type">StudentMapper</span> <span class="variable">studentMapper</span> <span class="operator">=</span> sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">        System.out.println(studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">        System.out.println(studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">        System.out.println(studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/9e996384.jpg" alt="img"></p>
<p>我们可以看到，只有第一次真正查询了数据库，后续的查询使用了一级缓存。</p>
<h4 id="实验2"><a href="#实验2" class="headerlink" title="实验2"></a>实验2</h4><p>增加了对数据库的修改操作，验证在一次数据库会话中，如果对数据库发生了修改操作，一级缓存是否会失效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addStudent</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> factory.openSession(<span class="literal">true</span>); <span class="comment">// 自动提交事务</span></span><br><span class="line">        <span class="type">StudentMapper</span> <span class="variable">studentMapper</span> <span class="operator">=</span> sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">        System.out.println(studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;增加了&quot;</span> + studentMapper.addStudent(buildStudent()) + <span class="string">&quot;个学生&quot;</span>);</span><br><span class="line">        System.out.println(studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">        sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/fb6a78e0.jpg" alt="img"></p>
<p>我们可以看到，在修改操作后执行的相同查询，查询了数据库，<strong>一级缓存失效</strong>。</p>
<h4 id="实验3"><a href="#实验3" class="headerlink" title="实验3"></a>实验3</h4><p>开启两个<code>SqlSession</code>，在<code>sqlSession1</code>中查询数据，使一级缓存生效，在<code>sqlSession2</code>中更新数据库，验证一级缓存只在数据库会话内部共享。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLocalCacheScope</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession1</span> <span class="operator">=</span> factory.openSession(<span class="literal">true</span>); </span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession2</span> <span class="operator">=</span> factory.openSession(<span class="literal">true</span>); </span><br><span class="line"></span><br><span class="line">        <span class="type">StudentMapper</span> <span class="variable">studentMapper</span> <span class="operator">=</span> sqlSession1.getMapper(StudentMapper.class);</span><br><span class="line">        <span class="type">StudentMapper</span> <span class="variable">studentMapper2</span> <span class="operator">=</span> sqlSession2.getMapper(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;studentMapper读取数据: &quot;</span> + studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;studentMapper读取数据: &quot;</span> + studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;studentMapper2更新了&quot;</span> + studentMapper2.updateStudentName(<span class="string">&quot;小岑&quot;</span>,<span class="number">1</span>) + <span class="string">&quot;个学生的数据&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;studentMapper读取数据: &quot;</span> + studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;studentMapper2读取数据: &quot;</span> + studentMapper2.getStudentById(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/f480ac76.jpg" alt="img"></p>
<p><code>sqlSession2</code>更新了id为1的学生的姓名，从凯伦改为了小岑，但session1之后的查询中，id为1的学生的名字还是凯伦，出现了脏数据，也证明了之前的设想，一级缓存只在数据库会话内部共享。</p>
<h3 id="一级缓存工作流程-amp-源码分析"><a href="#一级缓存工作流程-amp-源码分析" class="headerlink" title="一级缓存工作流程&amp;源码分析"></a>一级缓存工作流程&amp;源码分析</h3><p>那么，一级缓存的工作流程是怎样的呢？我们从源码层面来学习一下。</p>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>一级缓存执行的时序图，如下图所示。</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/bb851700.png" alt="img"></p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>接下来将对MyBatis查询相关的核心类和一级缓存的源码进行走读。这对后面学习二级缓存也有帮助。</p>
<p><strong>SqlSession</strong>： 对外提供了用户和数据库之间交互需要的所有方法，隐藏了底层的细节。默认实现类是<code>DefaultSqlSession</code>。</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/ba96bc7f.jpg" alt="img"></p>
<p><strong>Executor</strong>： <code>SqlSession</code>向用户提供操作数据库的方法，但和数据库操作有关的职责都会委托给Executor。</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/ef5e0eb3.jpg" alt="img"></p>
<p>如下图所示，Executor有若干个实现类，为Executor赋予了不同的能力，大家可以根据类名，自行学习每个类的基本作用。</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/83326eb3.jpg" alt="img"></p>
<p>在一级缓存的源码分析中，主要学习<code>BaseExecutor</code>的内部实现。</p>
<p><strong>BaseExecutor</strong>： <code>BaseExecutor</code>是一个实现了Executor接口的抽象类，定义若干抽象方法，在执行的时候，把具体的操作委托给子类进行执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">doUpdate</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;BatchResult&gt; <span class="title function_">doFlushStatements</span><span class="params">(<span class="type">boolean</span> isRollback)</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;E&gt; Cursor&lt;E&gt; <span class="title function_">doQueryCursor</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException;</span><br></pre></td></tr></table></figure>

<p>在一级缓存的介绍中提到对<code>Local Cache</code>的查询和写入是在<code>Executor</code>内部完成的。在阅读<code>BaseExecutor</code>的代码后发现<code>Local Cache</code>是<code>BaseExecutor</code>内部的一个成员变量，如下代码所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseExecutor</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line"><span class="keyword">protected</span> ConcurrentLinkedQueue&lt;DeferredLoad&gt; deferredLoads;</span><br><span class="line"><span class="keyword">protected</span> PerpetualCache localCache;</span><br></pre></td></tr></table></figure>

<p><strong>Cache</strong>： MyBatis中的Cache接口，提供了和缓存相关的最基本的操作，如下图所示：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/793031d0.jpg" alt="img"></p>
<p>有若干个实现类，使用装饰器模式互相组装，提供丰富的操控缓存的能力，部分实现类如下图所示：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/cdb21712.jpg" alt="img"></p>
<p><code>BaseExecutor</code>成员变量之一的<code>PerpetualCache</code>，是对Cache接口最基本的实现，其实现非常简单，内部持有HashMap，对一级缓存的操作实则是对HashMap的操作。如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PerpetualCache</span> <span class="keyword">implements</span> <span class="title class_">Cache</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;Object, Object&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Object, Object&gt;();</span><br></pre></td></tr></table></figure>

<p>在阅读相关核心类代码后，从源代码层面对一级缓存工作中涉及到的相关代码，出于篇幅的考虑，对源码做适当删减，读者朋友可以结合本文，后续进行更详细的学习。</p>
<p>为执行和数据库的交互，首先需要初始化<code>SqlSession</code>，通过<code>DefaultSqlSessionFactory</code>开启<code>SqlSession</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> SqlSession <span class="title function_">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="type">boolean</span> autoCommit)</span> &#123;</span><br><span class="line">    ............</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> configuration.newExecutor(tx, execType);     </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultSqlSession</span>(configuration, executor, autoCommit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在初始化<code>SqlSesion</code>时，会使用<code>Configuration</code>类创建一个全新的<code>Executor</code>，作为<code>DefaultSqlSession</code>构造函数的参数，创建Executor代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Executor <span class="title function_">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> &#123;</span><br><span class="line">    executorType = executorType == <span class="literal">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="literal">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> <span class="title class_">BatchExecutor</span>(<span class="built_in">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> <span class="title class_">ReuseExecutor</span>(<span class="built_in">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> <span class="title class_">SimpleExecutor</span>(<span class="built_in">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尤其可以注意这里，如果二级缓存开关开启的话，是使用CahingExecutor装饰BaseExecutor的子类</span></span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> <span class="title class_">CachingExecutor</span>(executor);                      </span><br><span class="line">    &#125;</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SqlSession</code>创建完毕后，根据Statment的不同类型，会进入<code>SqlSession</code>的不同方法中，如果是<code>Select</code>语句的话，最后会执行到<code>SqlSession</code>的<code>selectList</code>，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> &#123;</span><br><span class="line">      <span class="type">MappedStatement</span> <span class="variable">ms</span> <span class="operator">=</span> configuration.getMappedStatement(statement);</span><br><span class="line">      <span class="keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SqlSession</code>把具体的查询职责委托给了Executor。如果只开启了一级缓存的话，首先会进入<code>BaseExecutor</code>的<code>query</code>方法。代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="type">BoundSql</span> <span class="variable">boundSql</span> <span class="operator">=</span> ms.getBoundSql(parameter);</span><br><span class="line">    <span class="type">CacheKey</span> <span class="variable">key</span> <span class="operator">=</span> createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">    <span class="keyword">return</span> query(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，会先根据传入的参数生成CacheKey，进入该方法查看CacheKey是如何生成的，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CacheKey</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CacheKey</span>();</span><br><span class="line">cacheKey.update(ms.getId());</span><br><span class="line">cacheKey.update(rowBounds.getOffset());</span><br><span class="line">cacheKey.update(rowBounds.getLimit());</span><br><span class="line">cacheKey.update(boundSql.getSql());</span><br><span class="line"><span class="comment">//后面是update了sql中带的参数</span></span><br><span class="line">cacheKey.update(value);</span><br></pre></td></tr></table></figure>

<p>在上述的代码中，将<code>MappedStatement</code>的Id、SQL的offset、SQL的limit、SQL本身以及SQL中的参数传入了CacheKey这个类，最终构成CacheKey。以下是这个类的内部结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_MULTIPLYER</span> <span class="operator">=</span> <span class="number">37</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_HASHCODE</span> <span class="operator">=</span> <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> multiplier;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> hashcode;</span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> checksum;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"><span class="keyword">private</span> List&lt;Object&gt; updateList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CacheKey</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.hashcode = DEFAULT_HASHCODE;</span><br><span class="line">    <span class="built_in">this</span>.multiplier = DEFAULT_MULTIPLYER;</span><br><span class="line">    <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.updateList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是成员变量和构造函数，有一个初始的<code>hachcode</code>和乘数，同时维护了一个内部的<code>updatelist</code>。在<code>CacheKey</code>的<code>update</code>方法中，会进行一个<code>hashcode</code>和<code>checksum</code>的计算，同时把传入的参数添加进<code>updatelist</code>中。如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">baseHashCode</span> <span class="operator">=</span> object == <span class="literal">null</span> ? <span class="number">1</span> : ArrayUtil.hashCode(object); </span><br><span class="line">    count++;</span><br><span class="line">    checksum += baseHashCode;</span><br><span class="line">    baseHashCode *= count;</span><br><span class="line">    hashcode = multiplier * hashcode + baseHashCode;</span><br><span class="line">    </span><br><span class="line">    updateList.add(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时重写了<code>CacheKey</code>的<code>equals</code>方法，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    .............</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; updateList.size(); i++) &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">thisObject</span> <span class="operator">=</span> updateList.get(i);</span><br><span class="line">      <span class="type">Object</span> <span class="variable">thatObject</span> <span class="operator">=</span> cacheKey.updateList.get(i);</span><br><span class="line">      <span class="keyword">if</span> (!ArrayUtil.equals(thisObject, thatObject)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除去hashcode、checksum和count的比较外，只要updatelist中的元素一一对应相等，那么就可以认为是CacheKey相等。只要两条SQL的下列五个值相同，即可以认为是相同的SQL。</p>
<blockquote>
<p>Statement Id + Offset + Limmit + Sql + Params</p>
</blockquote>
<p>BaseExecutor的query方法继续往下走，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list = resultHandler == <span class="literal">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (list != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 这个主要是处理存储过程用的。</span></span><br><span class="line">    handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果查不到的话，就从数据库查，在<code>queryFromDatabase</code>中，会对<code>localcache</code>进行写入。</p>
<p>在<code>query</code>方法执行的最后，会判断一级缓存级别是否是<code>STATEMENT</code>级别，如果是的话，就清空缓存，这也就是<code>STATEMENT</code>级别的一级缓存无法共享<code>localCache</code>的原因。代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">        clearLocalCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在源码分析的最后，我们确认一下，如果是<code>insert/delete/update</code>方法，缓存就会刷新的原因。</p>
<p><code>SqlSession</code>的<code>insert</code>方法和<code>delete</code>方法，都会统一走<code>update</code>的流程，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insert</span><span class="params">(String statement, Object parameter)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> update(statement, parameter);</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(String statement)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> update(statement, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>update</code>方法也是委托给了<code>Executor</code>执行。<code>BaseExecutor</code>的执行方法如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing an update&quot;</span>).object(ms.getId());</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clearLocalCache();</span><br><span class="line">    <span class="keyword">return</span> doUpdate(ms, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次执行<code>update</code>前都会清空<code>localCache</code>。</p>
<p>至此，一级缓存的工作流程讲解以及源码分析完毕。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>MyBatis一级缓存的生命周期和SqlSession一致。</li>
<li>MyBatis一级缓存内部设计简单，只是一个没有容量限定的HashMap，在缓存的功能性上有所欠缺。</li>
<li>MyBatis的一级缓存最大范围是SqlSession内部，有多个SqlSession或者分布式的环境下，数据库写操作会引起脏数据，建议设定缓存级别为Statement。</li>
</ol>
<h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><h3 id="二级缓存介绍"><a href="#二级缓存介绍" class="headerlink" title="二级缓存介绍"></a>二级缓存介绍</h3><p>在上文中提到的一级缓存中，其最大的共享范围就是一个SqlSession内部，如果多个SqlSession之间需要共享缓存，则需要使用到二级缓存。开启二级缓存后，会使用CachingExecutor装饰Executor，进入一级缓存的查询流程前，先在CachingExecutor进行二级缓存的查询，具体的工作流程如下所示。</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/28399eba.png" alt="img"></p>
<p>二级缓存开启后，同一个namespace下的所有操作语句，都影响着同一个Cache，即二级缓存被多个SqlSession共享，是一个全局的变量。</p>
<p>当开启缓存后，数据的查询执行的流程就是 二级缓存 -&gt; 一级缓存 -&gt; 数据库。</p>
<h3 id="二级缓存配置"><a href="#二级缓存配置" class="headerlink" title="二级缓存配置"></a>二级缓存配置</h3><p>要正确的使用二级缓存，需完成如下配置的。</p>
<ol>
<li>在MyBatis的配置文件中开启二级缓存。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>在MyBatis的映射XML中配置cache或者 cache-ref 。</li>
</ol>
<p>cache标签用于声明这个namespace使用二级缓存，并且可以自定义配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span>   </span><br></pre></td></tr></table></figure>

<ul>
<li><code>type</code>：cache使用的类型，默认是<code>PerpetualCache</code>，这在一级缓存中提到过。</li>
<li><code>eviction</code>： 定义回收的策略，常见的有FIFO，LRU。</li>
<li><code>flushInterval</code>： 配置一定时间自动刷新缓存，单位是毫秒。</li>
<li><code>size</code>： 最多缓存对象的个数。</li>
<li><code>readOnly</code>： 是否只读，若配置可读写，则需要对应的实体类能够序列化。</li>
<li><code>blocking</code>： 若缓存中找不到对应的key，是否会一直blocking，直到有对应的数据进入缓存。</li>
</ul>
<p><code>cache-ref</code>代表引用别的命名空间的Cache配置，两个命名空间的操作使用的是同一个Cache。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache-ref</span> <span class="attr">namespace</span>=<span class="string">&quot;mapper.StudentMapper&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="二级缓存实验"><a href="#二级缓存实验" class="headerlink" title="二级缓存实验"></a>二级缓存实验</h3><p>接下来我们通过实验，了解MyBatis二级缓存在使用上的一些特点。</p>
<p>在本实验中，id为1的学生名称初始化为点点。</p>
<h4 id="实验1-1"><a href="#实验1-1" class="headerlink" title="实验1"></a>实验1</h4><p>测试二级缓存效果，不提交事务，<code>sqlSession1</code>查询完数据后，<code>sqlSession2</code>相同的查询是否会从缓存中获取数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCacheWithoutCommitOrClose</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession1</span> <span class="operator">=</span> factory.openSession(<span class="literal">true</span>); </span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession2</span> <span class="operator">=</span> factory.openSession(<span class="literal">true</span>); </span><br><span class="line">        </span><br><span class="line">        <span class="type">StudentMapper</span> <span class="variable">studentMapper</span> <span class="operator">=</span> sqlSession1.getMapper(StudentMapper.class);</span><br><span class="line">        <span class="type">StudentMapper</span> <span class="variable">studentMapper2</span> <span class="operator">=</span> sqlSession2.getMapper(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;studentMapper读取数据: &quot;</span> + studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;studentMapper2读取数据: &quot;</span> + studentMapper2.getStudentById(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/71e2bfdc.jpg" alt="img"></p>
<p>我们可以看到，当<code>sqlsession</code>没有调用<code>commit()</code>方法时，二级缓存并没有起到作用。</p>
<h4 id="实验2-1"><a href="#实验2-1" class="headerlink" title="实验2"></a>实验2</h4><p>测试二级缓存效果，当提交事务时，<code>sqlSession1</code>查询完数据后，<code>sqlSession2</code>相同的查询是否会从缓存中获取数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCacheWithCommitOrClose</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession1</span> <span class="operator">=</span> factory.openSession(<span class="literal">true</span>); </span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession2</span> <span class="operator">=</span> factory.openSession(<span class="literal">true</span>); </span><br><span class="line">        </span><br><span class="line">        <span class="type">StudentMapper</span> <span class="variable">studentMapper</span> <span class="operator">=</span> sqlSession1.getMapper(StudentMapper.class);</span><br><span class="line">        <span class="type">StudentMapper</span> <span class="variable">studentMapper2</span> <span class="operator">=</span> sqlSession2.getMapper(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;studentMapper读取数据: &quot;</span> + studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">        sqlSession1.commit();</span><br><span class="line">        System.out.println(<span class="string">&quot;studentMapper2读取数据: &quot;</span> + studentMapper2.getStudentById(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/f366f34e.jpg" alt="img"></p>
<p>从图上可知，<code>sqlsession2</code>的查询，使用了缓存，缓存的命中率是0.5。</p>
<h4 id="实验3-1"><a href="#实验3-1" class="headerlink" title="实验3"></a>实验3</h4><p>测试<code>update</code>操作是否会刷新该<code>namespace</code>下的二级缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCacheWithUpdate</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession1</span> <span class="operator">=</span> factory.openSession(<span class="literal">true</span>); </span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession2</span> <span class="operator">=</span> factory.openSession(<span class="literal">true</span>); </span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession3</span> <span class="operator">=</span> factory.openSession(<span class="literal">true</span>); </span><br><span class="line">        </span><br><span class="line">        <span class="type">StudentMapper</span> <span class="variable">studentMapper</span> <span class="operator">=</span> sqlSession1.getMapper(StudentMapper.class);</span><br><span class="line">        <span class="type">StudentMapper</span> <span class="variable">studentMapper2</span> <span class="operator">=</span> sqlSession2.getMapper(StudentMapper.class);</span><br><span class="line">        <span class="type">StudentMapper</span> <span class="variable">studentMapper3</span> <span class="operator">=</span> sqlSession3.getMapper(StudentMapper.class);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;studentMapper读取数据: &quot;</span> + studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">        sqlSession1.commit();</span><br><span class="line">        System.out.println(<span class="string">&quot;studentMapper2读取数据: &quot;</span> + studentMapper2.getStudentById(<span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        studentMapper3.updateStudentName(<span class="string">&quot;方方&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        sqlSession3.commit();</span><br><span class="line">        System.out.println(<span class="string">&quot;studentMapper2读取数据: &quot;</span> + studentMapper2.getStudentById(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/3ad93c3a.jpg" alt="img"></p>
<p>我们可以看到，在<code>sqlSession3</code>更新数据库，并提交事务后，<code>sqlsession2</code>的<code>StudentMapper namespace</code>下的查询走了数据库，没有走Cache。</p>
<h4 id="实验4"><a href="#实验4" class="headerlink" title="实验4"></a>实验4</h4><p>验证MyBatis的二级缓存不适应用于映射文件中存在多表查询的情况。</p>
<p>通常我们会为每个单表创建单独的映射文件，由于MyBatis的二级缓存是基于<code>namespace</code>的，多表查询语句所在的<code>namspace</code>无法感应到其他<code>namespace</code>中的语句对多表查询中涉及的表进行的修改，引发脏数据问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCacheWithDiffererntNamespace</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession1</span> <span class="operator">=</span> factory.openSession(<span class="literal">true</span>); </span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession2</span> <span class="operator">=</span> factory.openSession(<span class="literal">true</span>); </span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession3</span> <span class="operator">=</span> factory.openSession(<span class="literal">true</span>); </span><br><span class="line">    </span><br><span class="line">        <span class="type">StudentMapper</span> <span class="variable">studentMapper</span> <span class="operator">=</span> sqlSession1.getMapper(StudentMapper.class);</span><br><span class="line">        <span class="type">StudentMapper</span> <span class="variable">studentMapper2</span> <span class="operator">=</span> sqlSession2.getMapper(StudentMapper.class);</span><br><span class="line">        <span class="type">ClassMapper</span> <span class="variable">classMapper</span> <span class="operator">=</span> sqlSession3.getMapper(ClassMapper.class);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;studentMapper读取数据: &quot;</span> + studentMapper.getStudentByIdWithClassInfo(<span class="number">1</span>));</span><br><span class="line">        sqlSession1.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;studentMapper2读取数据: &quot;</span> + studentMapper2.getStudentByIdWithClassInfo(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        classMapper.updateClassName(<span class="string">&quot;特色一班&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        sqlSession3.commit();</span><br><span class="line">        System.out.println(<span class="string">&quot;studentMapper2读取数据: &quot;</span> + studentMapper2.getStudentByIdWithClassInfo(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/5265ed97.jpg" alt="img"></p>
<p>在这个实验中，我们引入了两张新的表，一张class，一张classroom。class中保存了班级的id和班级名，classroom中保存了班级id和学生id。我们在<code>StudentMapper</code>中增加了一个查询方法<code>getStudentByIdWithClassInfo</code>，用于查询学生所在的班级，涉及到多表查询。在<code>ClassMapper</code>中添加了<code>updateClassName</code>，根据班级id更新班级名的操作。</p>
<p>当<code>sqlsession1</code>的<code>studentmapper</code>查询数据后，二级缓存生效。保存在StudentMapper的namespace下的cache中。当<code>sqlSession3</code>的<code>classMapper</code>的<code>updateClassName</code>方法对class表进行更新时，<code>updateClassName</code>不属于<code>StudentMapper</code>的<code>namespace</code>，所以<code>StudentMapper</code>下的cache没有感应到变化，没有刷新缓存。当<code>StudentMapper</code>中同样的查询再次发起时，从缓存中读取了脏数据。</p>
<h4 id="实验5"><a href="#实验5" class="headerlink" title="实验5"></a>实验5</h4><p>为了解决实验4的问题呢，可以使用Cache ref，让<code>ClassMapper</code>引用<code>StudenMapper</code>命名空间，这样两个映射文件对应的SQL操作都使用的是同一块缓存了。</p>
<p>执行结果：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/a2e4c2d8.jpg" alt="img"></p>
<p>不过这样做的后果是，缓存的粒度变粗了，多个<code>Mapper namespace</code>下的所有操作都会对缓存使用造成影响。</p>
<h3 id="二级缓存源码分析"><a href="#二级缓存源码分析" class="headerlink" title="二级缓存源码分析"></a>二级缓存源码分析</h3><p>MyBatis二级缓存的工作流程和前文提到的一级缓存类似，只是在一级缓存处理前，用<code>CachingExecutor</code>装饰了<code>BaseExecutor</code>的子类，在委托具体职责给<code>delegate</code>之前，实现了二级缓存的查询和写入功能，具体类关系图如下图所示。</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/090216b1.jpg" alt="img"></p>
<h4 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h4><p>源码分析从<code>CachingExecutor</code>的<code>query</code>方法展开，源代码走读过程中涉及到的知识点较多，不能一一详细讲解，读者朋友可以自行查询相关资料来学习。</p>
<p><code>CachingExecutor</code>的<code>query</code>方法，首先会从<code>MappedStatement</code>中获得在配置初始化时赋予的Cache。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> ms.getCache();</span><br></pre></td></tr></table></figure>

<p>本质上是装饰器模式的使用，具体的装饰链是：</p>
<blockquote>
<p>SynchronizedCache -&gt; LoggingCache -&gt; SerializedCache -&gt; LruCache -&gt; PerpetualCache。</p>
</blockquote>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/1f5233b2.jpg" alt="img"></p>
<p>以下是具体这些Cache实现类的介绍，他们的组合为Cache赋予了不同的能力。</p>
<ul>
<li><code>SynchronizedCache</code>：同步Cache，实现比较简单，直接使用synchronized修饰方法。</li>
<li><code>LoggingCache</code>：日志功能，装饰类，用于记录缓存的命中率，如果开启了DEBUG模式，则会输出命中率日志。</li>
<li><code>SerializedCache</code>：序列化功能，将值序列化后存到缓存中。该功能用于缓存返回一份实例的Copy，用于保存线程安全。</li>
<li><code>LruCache</code>：采用了Lru算法的Cache实现，移除最近最少使用的Key&#x2F;Value。</li>
<li><code>PerpetualCache</code>： 作为为最基础的缓存类，底层实现比较简单，直接使用了HashMap。</li>
</ul>
<p>然后是判断是否需要刷新缓存，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">flushCacheIfRequired(ms);</span><br></pre></td></tr></table></figure>

<p>在默认的设置中<code>SELECT</code>语句不会刷新缓存，<code>insert/update/delte</code>会刷新缓存。进入该方法。代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">flushCacheIfRequired</span><span class="params">(MappedStatement ms)</span> &#123;</span><br><span class="line">    <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> ms.getCache();</span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="literal">null</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;      </span><br><span class="line">      tcm.clear(cache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyBatis的<code>CachingExecutor</code>持有了<code>TransactionalCacheManager</code>，即上述代码中的tcm。</p>
<p><code>TransactionalCacheManager</code>中持有了一个Map，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;Cache, TransactionalCache&gt; transactionalCaches = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Cache, TransactionalCache&gt;();</span><br></pre></td></tr></table></figure>

<p>这个Map保存了Cache和用<code>TransactionalCache</code>包装后的Cache的映射关系。</p>
<p><code>TransactionalCache</code>实现了Cache接口，<code>CachingExecutor</code>会默认使用他包装初始生成的Cache，作用是如果事务提交，对缓存的操作才会生效，如果事务回滚或者不提交事务，则不对缓存产生影响。</p>
<p>在<code>TransactionalCache</code>的clear，有以下两句。清空了需要在提交时加入缓存的列表，同时设定提交时清空缓存，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">	clearOnCommit = <span class="literal">true</span>;</span><br><span class="line">	entriesToAddOnCommit.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CachingExecutor</code>继续往下走，<code>ensureNoOutParams</code>主要是用来处理存储过程的，暂时不用考虑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">	ensureNoOutParams(ms, parameterObject, boundSql);</span><br></pre></td></tr></table></figure>

<p>之后会尝试从tcm中获取缓存的列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br></pre></td></tr></table></figure>

<p>在<code>getObject</code>方法中，会把获取值的职责一路传递，最终到<code>PerpetualCache</code>。如果没有查到，会把key加入Miss集合，这个主要是为了统计命中率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> delegate.getObject(key);</span><br><span class="line"><span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line">	entriesMissedInCache.add(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CachingExecutor</code>继续往下走，如果查询到数据，则调用<code>tcm.putObject</code>方法，往缓存中放入值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (list == <span class="literal">null</span>) &#123;</span><br><span class="line">	list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">	tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tcm的<code>put</code>方法也不是直接操作缓存，只是在把这次的数据和key放入待提交的Map中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putObject</span><span class="params">(Object key, Object object)</span> &#123;</span><br><span class="line">    entriesToAddOnCommit.put(key, object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从以上的代码分析中，我们可以明白，如果不调用<code>commit</code>方法的话，由于<code>TranscationalCache</code>的作用，并不会对二级缓存造成直接的影响。因此我们看看<code>Sqlsession</code>的<code>commit</code>方法中做了什么。代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">boolean</span> force)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executor.commit(isCommitOrRollbackRequired(force));</span><br></pre></td></tr></table></figure>

<p>因为我们使用了CachingExecutor，首先会进入CachingExecutor实现的commit方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">boolean</span> required)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    delegate.commit(required);</span><br><span class="line">    tcm.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会把具体commit的职责委托给包装的<code>Executor</code>。主要是看下<code>tcm.commit()</code>，tcm最终又会调用到<code>TrancationalCache</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (clearOnCommit) &#123;</span><br><span class="line">      delegate.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    flushPendingEntries();</span><br><span class="line">    reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这里的<code>clearOnCommit</code>就想起刚才<code>TrancationalCache</code>的<code>clear</code>方法设置的标志位，真正的清理Cache是放到这里来进行的。具体清理的职责委托给了包装的Cache类。之后进入<code>flushPendingEntries</code>方法。代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">flushPendingEntries</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : entriesToAddOnCommit.entrySet()) &#123;</span><br><span class="line">      delegate.putObject(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    ................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>flushPending</code>Entries中，将待提交的Map进行循环处理，委托给包装的Cache类，进行<code>putObject</code>的操作。</p>
<p>后续的查询操作会重复执行这套流程。如果是<code>insert|update|delete</code>的话，会统一进入<code>CachingExecutor</code>的<code>update</code>方法，其中调用了这个函数，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">flushCacheIfRequired</span><span class="params">(MappedStatement ms)</span> </span><br></pre></td></tr></table></figure>

<p>在二级缓存执行流程后就会进入一级缓存的执行流程，因此不再赘述。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol>
<li>MyBatis的二级缓存相对于一级缓存来说，实现了<code>SqlSession</code>之间缓存数据的共享，同时粒度更加的细，能够到<code>namespace</code>级别，通过Cache接口实现类不同的组合，对Cache的可控性也更强。</li>
<li>MyBatis在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻。</li>
<li>在分布式环境下，由于默认的MyBatis Cache实现都是基于本地的，分布式环境下必然会出现读取到脏数据，需要使用集中式缓存将MyBatis的Cache接口实现，有一定的开发成本，直接使用Redis、Memcached等分布式缓存可能成本更低，安全性也更高。</li>
</ol>
<h2 id="全文总结"><a href="#全文总结" class="headerlink" title="全文总结"></a>全文总结</h2><p>本文对介绍了MyBatis一二级缓存的基本概念，并从应用及源码的角度对MyBatis的缓存机制进行了分析。最后对MyBatis缓存机制做了一定的总结，个人建议MyBatis缓存特性在生产环境中进行关闭，单纯作为一个ORM框架使用可能更为合适。</p>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title>OIDC认证授权</title>
    <url>/2022/10/24/OIDC%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83/</url>
    <content><![CDATA[<h1 id="五分钟理解什么是-OIDC-（OpenID-Connect）"><a href="#五分钟理解什么是-OIDC-（OpenID-Connect）" class="headerlink" title="五分钟理解什么是 OIDC （OpenID Connect）"></a>五分钟理解什么是 OIDC （OpenID Connect）</h1><p><img src="/2022/10/24/OIDC%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83/1.png" alt="在这里插入图片描述"></p>
<h2 id="什么是-OIDC？"><a href="#什么是-OIDC？" class="headerlink" title="什么是 OIDC？"></a>什么是 OIDC？</h2><p>OIDC 的全称是 OpenID Connect，是一套基于 OAuth 2.0 的<strong>认证 + 授权</strong>协议，用于用户身份认证，将用户数据安全地暴露给第三方。</p>
<h2 id="OIDC-与-OAuth-2-0-有何不同？"><a href="#OIDC-与-OAuth-2-0-有何不同？" class="headerlink" title="OIDC 与 OAuth 2.0 有何不同？"></a>OIDC 与 OAuth 2.0 有何不同？</h2><p>OAuth 2.0 是用于授权的行业标准协议。OAuth 2.0 致力于简化客户端开发人员的工作，同时为 Web 应用程序，桌面应用程序，移动电话和物联网设备提供特定的授权流程。</p>
<p>以上是 OAuth 2.0 的官方定义。我们举一个实际的例子，你在登录京东的时候，会发现在京东的登录框中有使用 QQ 登录、使用 QQ 登录的按钮，这些地方就是 OAuth 2.0 协议的用武之地。京东希望从 QQ 获取你的 QQ 用户数据，从而完成在京东的注册，这就需要数据的主人——你的授权。完成授权之后， QQ 会给京东一个 access_token，京东携带这个凭证，就能以你的名义，以及你授予此网站的权限（例如你授权京东能够访问你的个人信息而不是转账能力），访问你在 QQ 服务器上的数据，从而获取你的信息，在此过程中，你无须告诉京东你的 QQ 账号和密码，你输入账密信息的时候，是在腾讯的服务器完成的认证。</p>
<p>OIDC 与 OAuth 2.0 相比，多了认证的能力。不但能够返回用户的 access_token，让第三方通过 access_token 调用用户授权过的接口（用户授权），还可以返回用户的 id_token，第三方可以将 id_token 用作用户身份标识（用户认证）。</p>
<p>回到刚才的例子，京东获取到 QQ 颁发的 access_token （是一个随机字符串）之后确实能够获取到你的信息，但是如果不借助其他手段，是不具备用户身份认证功能的。而在 OIDC 协议中，获取 access_token 的同时，会返回一个 JWT 格式的 id_token，可直接用作身份标识，供第三方确认用户身份。</p>
<p>JWT Token 是这个样子的：</p>
<pre><code>eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ.dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk
</code></pre>
<p>格式为“点分 base64 编码”，一共三段，第一部分叫作<strong>头部（JOSE Header）</strong>，第二部分叫作<strong>荷载（Payload）</strong>，第三部分叫作<strong>签名（Signature）</strong>。其中的签名根据头部、荷载和一个密钥计算得出，不可伪造。</p>
<p>base64 解码之后是这样子的：</p>
<pre><code>&#123;&quot;typ&quot;:&quot;JWT&quot;, &quot;alg&quot;:&quot;HS256&quot;&#125;.&#123;&quot;iss&quot;:&quot;joe&quot;, &quot;exp&quot;:1300819380, &quot;http://example.com/is_root&quot;:true&#125;.&lt; 签名 &gt;
</code></pre>
<p>更多 JWT 知识请参考 JWT 规范。</p>
<p>总结成一句话：OAuth 2.0 能做的 OIDC 都能做，OAuth 2.0 不具备的认证能力，OIDC 也具备。</p>
<h2 id="OIDC-协议的应用场景"><a href="#OIDC-协议的应用场景" class="headerlink" title="OIDC 协议的应用场景"></a>OIDC 协议的应用场景</h2><p>所有使用 OAuth 2.0 的场景都可以升级为 OIDC 协议，OIDC 协议是 OAuth 2.0 的超集。以下是一些 OIDC 协议的应用场景：</p>
<p>1.社会化登录场景，网站登录框上常见许多按钮「使用 XXX 登录」。<br>物联网设备的身份认证和授权。<br>2.企业内多个应用统一身份，单点登录。<br>3.开放平台对外暴露应用数据，做用户认证与授权。<br>4.Serverless 中的身份层。<br>5.OIDC 协议是 OAuth 2.0 协议的下一代，是身份认证协议升级的不二之选。</p>
<h3 id="OIDC-协议中的四个主体"><a href="#OIDC-协议中的四个主体" class="headerlink" title="OIDC 协议中的四个主体"></a>OIDC 协议中的四个主体</h3><p>在介绍 OIDC 授权模式之前，先要明确四个主体：<strong>第三方应用</strong>、<strong>资源服务器</strong>、<strong>资源所有者</strong>、<strong>认证授权服务器</strong>。我们继续沿用前文京东与 QQ 登录的例子。</p>
<p>P.S. QQ 使用的是变种 OAuth 2.0 协议，并不完全符合 OIDC 规范，在此假设 QQ 使用 OIDC 协议进行对外数据授权。</p>
<p><strong>第三方应用</strong></p>
<p>京东的角色是第三方应用。</p>
<p><strong>资源服务器</strong></p>
<p>QQ 的个人信息存放于资源服务器。</p>
<p><strong>资源所有者</strong></p>
<p>用户是 QQ 账号的所有者。</p>
<p><strong>认证授权服务器</strong></p>
<p>QQ 的授权服务器负责用户的身份认证和授权，管理第三方应用、受保护资源、资源所有者之间的关系。<br><img src="/2022/10/24/OIDC%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83/2.png" alt="在这里插入图片描述"></p>
<h2 id="OIDC-的三种授权模式"><a href="#OIDC-的三种授权模式" class="headerlink" title="OIDC 的三种授权模式"></a>OIDC 的三种授权模式</h2><h3 id="Authorization-Code-Flow"><a href="#Authorization-Code-Flow" class="headerlink" title="Authorization Code Flow"></a>Authorization Code Flow</h3><p>应用最为广泛的是授权码模式，此模式的交互过程如下图：<br><img src="/2022/10/24/OIDC%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83/3.png" alt="在这里插入图片描述"></p>
<p>1.第三方应用访问认证服务器的授权链接。（用户在京东网站登录框点击使用 QQ 登录）<br>2.用户与认证服务器完成身份认证。（浏览器跳转到 QQ 授权页面，用户输入 QQ 号和密码）<br>3.认证服务器向第三方应用返回授权码 code。（QQ 服务器将用户的浏览器重定向，将授权码发送到京东服务器）<br>4.第三方应用携带授权码访问认证服务器的 token 接口。（京东服务器携带授权码与 QQ 服务器交互）<br>5.认证服务器返回 access_token 和 id_token 给第三方应用。（QQ 服务器返回 access_token 和 id_token 给京东服务器）<br>此后，第三方应用可以利用 access_token 到资源服务器获取用户的信息，完成在第三方应用的注册和登录业务，并可以将 id_token 作为用户的身份凭证，存放在前端。第三方应用的前端需要访问受保护的资源（例如用户账单信息、购物车）时需要携带 id_token，后端验证 id_token 合法性，核实用户身份之后，返回相关资源数据。</p>
<h3 id="OIDC-认证时相关-Token-解释"><a href="#OIDC-认证时相关-Token-解释" class="headerlink" title="OIDC 认证时相关 Token 解释"></a>OIDC 认证时相关 Token 解释</h3><p>OIDC 认证时会签发两种 Token，一类叫 id_token，还有一类叫 access_token。</p>
<ol>
<li>id_token 是用户身份的凭证，只起到判定用户身份的作用。</li>
</ol>
<p>id_token 示例：</p>
<pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI1ZTQ5NjBkZmJkOTE1OGZiODQ0OTAzYTkiLCJiaXJ0aGRhdGUiOiIiLCJmYW1pbHlfbmFtZSI6IiIsImdlbmRlciI6IiIsImdpdmVuX25hbWUiOiIiLCJsb2NhbGUiOiIiLCJtaWRkbGVfbmFtZSI6IiIsIm5hbWUiOiIiLCJuaWNrbmFtZSI6IiIsInBpY3R1cmUiOiJodHRwczovL3VzZXJjb250ZW50cy5hdXRoaW5nLmNuL2F1dGhpbmctYXZhdGFyLnBuZyIsInByZWZlcnJlZF91c2VybmFtZSI6IiIsInByb2ZpbGUiOiIiLCJ1cGRhdGVkX2F0IjoiIiwid2Vic2l0ZSI6IiIsInpvbmVpbmZvIjoiIiwiY29tcGFueSI6IiIsImJyb3dzZXIiOiJNb3ppbGxhLzUuMCAoTWFjaW50b3NoOyBJbnRlbCBNYWMgT1MgWCAxMF8xNF82KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvODAuMC4zOTg3Ljg3IFNhZmFyaS81MzcuMzYiLCJkZXZpY2UiOiIiLCJsb2dpbnNfY291bnQiOjEsInJlZ2lzdGVyX21ldGhvZCI6ImRlZmF1bHQ6dXNlcm5hbWUtcGFzc3dvcmQiLCJibG9ja2VkIjpmYWxzZSwibGFzdF9pcCI6IjEyMS4yMS41Ni4xNzEiLCJyZWdpc3Rlcl9pbl91c2VycG9vbCI6IjVjOTU5MDU1NzhmY2U1MDAwMTY2Zjg1MyIsImxhc3RfbG9naW4iOiIyMDIwLTAyLTE2VDE1OjMzOjUyLjQ0NFoiLCJzaWduZWRfdXAiOiIyMDIwLTAyLTE2VDE1OjMzOjUxLjY2NVoiLCJlbWFpbCI6InRlc3QxQDEyMy5jb20iLCJlbWFpbF92ZXJpZmllZCI6ZmFsc2UsInBob25lX251bWJlciI6IiIsInBob25lX251bWJlcl92ZXJpZmllZCI6ZmFsc2UsImF0X2hhc2giOiJWYW9sSnVqWXltQjUxNlNGOGNaQkpBIiwic2lkIjoiZGYzMGFlNDgtOTkzMS00YjZlLWI0YzgtMWI5NjRkOGZjOWIyIiwiYXVkIjoiNWQwMWUzODk5ODVmODFjNmMxZGQzMWRlIiwiZXhwIjoxNTgxODcwOTc4LCJpYXQiOjE1ODE4NjczODEsImlzcyI6Imh0dHBzOi8vb2F1dGguYXV0aGluZy5jbi9vYXV0aC9vaWRjIn0.pH-bWm-Im0wnOcUEA-OG_iKwy9DTZlAXuik50HPsfGY
</code></pre>
<p>解码后：</p>
<pre><code>&#123;  &quot;alg&quot;: &quot;HS256&quot;,  &quot;typ&quot;: &quot;JWT&quot;&#125;.&#123;  &quot;sub&quot;: &quot;5e3a3b2315a0b8398cdaaa08&quot;,  &quot;birthdate&quot;: &quot;&quot;,  &quot;family_name&quot;: &quot;&quot;,  &quot;gender&quot;: &quot;&quot;,  &quot;given_name&quot;: &quot;&quot;,  &quot;locale&quot;: &quot;&quot;,  &quot;middle_name&quot;: &quot;&quot;,  &quot;name&quot;: &quot;&quot;,  &quot;nickname&quot;: &quot;&quot;,  &quot;picture&quot;: &quot;https://usercontents.authing.cn/authing-avatar.png&quot;,  &quot;preferred_username&quot;: &quot;&quot;,  &quot;profile&quot;: &quot;&quot;,  &quot;updated_at&quot;: &quot;&quot;,  &quot;website&quot;: &quot;&quot;,  &quot;zoneinfo&quot;: &quot;&quot;,  &quot;company&quot;: &quot;&quot;,  &quot;browser&quot;: &quot;&quot;,  &quot;device&quot;: &quot;&quot;,  &quot;logins_count&quot;: 8,  &quot;register_method&quot;: &quot;default:username-password&quot;,  &quot;blocked&quot;: false,  &quot;last_ip&quot;: &quot;127.0.0.1&quot;,  &quot;register_in_userpool&quot;: &quot;5e3a3b2315a0b8398cdaaa04&quot;,  &quot;last_login&quot;: &quot;2020-02-16T09:04:09.764Z&quot;,  &quot;signed_up&quot;: &quot;2020-02-05T03:48:51.447Z&quot;,  &quot;email&quot;: &quot;test@test.com&quot;,  &quot;email_verified&quot;: false,  &quot;phone_number&quot;: &quot;&quot;,  &quot;at_hash&quot;: &quot;6k-IWJwh-Dd3_hLOay0s7A&quot;,  &quot;sid&quot;: &quot;d50a8c9d-23db-4156-80ea-1c82d199d0e9&quot;,  &quot;aud&quot;: &quot;5e3a3b2315a0b8398cdaaa0e&quot;,  &quot;exp&quot;: 1581948533,  &quot;iat&quot;: 1581944933,  &quot;iss&quot;: &quot;https://core.littleimp.cn/oauth/oidc&quot;&#125;. 签名
</code></pre>
<p>access_token 是用户授权给第三方应用的一个令牌，第三方应用可以使用这个令牌访问用户在资源服务器上受保护的资源，一般不用于用户凭证和身份标识。<br>access_token 示例：</p>
<pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJXaXdndEdHYzVMeGtZRUFRY012RFkiLCJzdWIiOiI1ZTNhM2IyMzE1YTBiODM5OGNkYWFhMDgiLCJpc3MiOiJodHRwczovL2NvcmUubGl0dGxlaW1wLmNuL29hdXRoL29pZGMiLCJpYXQiOjE1ODE5NDQ5MzMsImV4cCI6MTU4MTk0ODUzMywic2NvcGUiOiJvcGVuaWQgcHJvZmlsZSBlbWFpbCBwaG9uZSIsImF1ZCI6IjVlM2EzYjIzMTVhMGI4Mzk4Y2RhYWEwZSJ9.MnAAGj6HlYvN3FOAo6PA2cxNxZDZbL3yhxTM3uxnt0M
</code></pre>
<p>解码后：</p>
<pre><code>&#123;  &quot;alg&quot;: &quot;HS256&quot;,  &quot;typ&quot;: &quot;JWT&quot;&#125;.&#123;  &quot;jti&quot;: &quot;WiwgtGGc5LxkYEAQcMvDY&quot;,  &quot;sub&quot;: &quot;5e3a3b2315a0b8398cdaaa08&quot;,  &quot;iss&quot;: &quot;https://core.littleimp.cn/oauth/oidc&quot;,  &quot;iat&quot;: 1581944933,  &quot;exp&quot;: 1581948533,  &quot;scope&quot;: &quot;openid profile email phone&quot;,  &quot;aud&quot;: &quot;5e3a3b2315a0b8398cdaaa0e&quot;&#125;. 签名
</code></pre>
<h2 id="bImplicit-Flow"><a href="#bImplicit-Flow" class="headerlink" title="bImplicit Flow"></a>bImplicit Flow</h2><p>在隐式模式中，认证服务器的授权接口不会返回授权码 code，而是在与用户完成认证后返回 id_token 和 access_token，交互模式如下图所示：</p>
<p><img src="/2022/10/24/OIDC%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83/4.png" alt="在这里插入图片描述"></p>
<ol>
<li>第三方应用访问认证服务器的授权链接。（用户在京东网站登录框点击使用 QQ 登录）</li>
<li>用户与认证服务器完成身份认证。（浏览器跳转到 QQ 授权页面，用户输入 QQ 号和密码）</li>
<li>认证服务器向第三方应用返回 id_token 和 access_token。（QQ 服务器将用户的浏览器重定向，将 id_token access_token 发送到京东前端页面）</li>
</ol>
<p>隐式模式比授权码模式简单，经常用于将 id_token、access_token 直接返回到前端，方便前端直接存储 id_token 用于证明用户身份。也需要前端自行将 access_token 发回后端，后端用于获取用户的详细信息，这增加了暴露 access_token 的风险。隐式模式不支持返回 refresh_token，即不能从后端刷新 access_token，登录一旦过期需要用户重新登录。</p>
<h2 id="Hybrid-Flow"><a href="#Hybrid-Flow" class="headerlink" title="Hybrid Flow"></a>Hybrid Flow</h2><p>混合模式是以上两种模式的组合，特点是能够在授权接口一次性获取到 c ode、id_token、access_token，一般 code 会与 id_token、access_token 混合出现，混合模式的交互如下图所示：</p>
<p><img src="/2022/10/24/OIDC%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83/5.png" alt="在这里插入图片描述"></p>
<ol>
<li>第三方应用访问认证服务器的授权链接。（用户在京东网站登录框点击使用 QQ 登录）</li>
<li>用户与认证服务器完成身份认证。（浏览器跳转到 QQ 授权页面，用户输入 QQ 号和密码）</li>
<li>认证服务器向第三方应用返回 code、id_token 和 access_token。（QQ 服务器将用户的浏览器重定向，将 id_token access_token 发送到京东前端页面）</li>
<li>第三方应用携带授权码访问认证服务器的 token 接口。（京东服务器携带授权码与 QQ 服务器交互）</li>
<li>认证服务器返回 access_token 和 id_token 给第三方应用。（QQ 服务器返回 access_token 和 id_token 给京东服务器）<br>混合模式可以灵活满足 code、id_token、access_token 的各种处理方式，可以在享有隐式模式便利的同时，利用 code 获取 refresh_token，从而可以在后端刷新用户 access_token，不必重复让用户登录。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>OIDC 协议是 OAuth 2.0 协议的超集，是可以替代 OAuth 2.0 的下一代身份认证协议，能够解决认证 + 授权两个问题。OIDC 的授权流程与 OAuth 2.0 完全一致，能够保持向下兼容。</p>
<p>授权服务器的意义在于管理第三方应用、受保护资源、资源所有者之间的关系，让互相不信任的应用之间安全地暴露数据——应用之间约定好某种规范，按照这种规范，就能在用户授权的前提下，安全地将数据暴露给第三方，而第三方也无需获知用户的账密信息。</p>
<p>此外，我们介绍了两种 Token 的区别，其中，<strong>id_token</strong> 是用户的身份凭证，<strong>access_token</strong> 是用户的授权凭证。</p>
<p>最后，我们介绍了 OIDC 的三种授权模式，分别是授权码模式、隐式模式、混合模式。授权码模式中只能获取到 code；隐式模式中只能获取到 access_token id_token；混合模式中都能够获取到。</p>
<p>Authing 拥有 OIDC 的无服务器实现，基于 Authing，可不用搭建或管理任何 OIDC 服务器即可完成身份认证，详情请查看文档：<a href="https://docs.authing.cn/authing/quickstart/implement-sso-with-authing%E3%80%82">https://docs.authing.cn/authing/quickstart/implement-sso-with-authing。</a><br><img src="/2022/10/24/OIDC%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83/6.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>认证授权</tag>
      </tags>
  </entry>
  <entry>
    <title>Paxos协议</title>
    <url>/2022/10/24/Paxos%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>Google的粗粒度锁服务Chubby的设计开发者Burrows曾经说过：<strong>所有一致性协议本质上要么是Paxos要么是其变体</strong>。</p>
<p>网上有很多讲解Paxos算法的文章，但是质量层次不齐。今天笔者带大家深入聊一下Paxos</p>
<h2 id="Paxos是什么？"><a href="#Paxos是什么？" class="headerlink" title="Paxos是什么？"></a>Paxos是什么？</h2><p>Paxos算法是基于<strong>消息传递</strong>且具有<strong>高度容错特性</strong>的<strong>一致性算法</strong>，是目前公认的解决<strong>分布式一致性</strong>问题<strong>最有效</strong>的算法之一。</p>
<p>Paxos算法是Lamport宗师提出的一种基于消息传递的分布式一致性算法，使其获得2013年图灵奖。</p>
<p>自Paxos问世以来就持续垄断了分布式一致性算法，Paxos这个名词几乎等同于分布式一致性。</p>
<p>Google的很多大型分布式系统都采用了Paxos算法来解决分布式一致性问题，如<strong>Chubby</strong>、<strong>Megastore</strong>以及Spanner等。开源的<strong>ZooKeeper</strong>，以及MySQL 5.7推出的用来取代传统的主从复制的MySQL Group Replication等纷纷采用Paxos算法解决分布式一致性问题。</p>
<p>但是它也有两个明显的缺点：</p>
<ol>
<li>难以理解</li>
<li>在工程是实现上比较复杂。</li>
</ol>
<h2 id="问题产生的背景"><a href="#问题产生的背景" class="headerlink" title="问题产生的背景"></a>问题产生的背景</h2><p>在常见的分布式系统中，总会发生诸如<strong>机器宕机</strong>或<strong>网络异常</strong>（包括消息的延迟、丢失、重复、乱序，还有网络分区）等情况。Paxos算法需要解决的问题就是如何在一个可能发生上述异常的分布式系统中，快速且正确地在集群内部对<strong>某个数据的值</strong>达成<strong>一致</strong>，并且保证不论发生以上任何异常，都不会破坏整个系统的一致性。</p>
<blockquote>
<p>“</p>
<p>这里<strong>某个数据的值</strong>并不只是狭义上的某个数，它可以是一条日志，也可以是一条命令（command）。根据应用场景不同，<strong>某个数据的值</strong>有不同的含义。</p>
<p>”</p>
</blockquote>
<p><img src="/2022/10/24/Paxos%E5%8D%8F%E8%AE%AE/1.png" alt="图片"></p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>在Paxos算法中，有三种角色：</p>
<ul>
<li>Proposer (提案者)</li>
<li>Acceptor (人大代表)</li>
<li>Learners (广大群众)</li>
</ul>
<p>需要注意的是，在具体的算法实现过程中，并不是一个进程只能担任其中一种角色，它有可能会同时充当多个。比如一个进程<strong>既是Proposer又是Acceptor还是Learner</strong>。</p>
<p>还有一个很重要的概念叫<strong>提案（Proposal）</strong>。最终要达成一致的value就在提案里。</p>
<p>这个提案包括什么呢？是仅仅包括一个信息数值吗？到底是如何咱们继续向下阅读，目前咱们先认为仅仅是一个普普通通的value。</p>
<p><img src="/2022/10/24/Paxos%E5%8D%8F%E8%AE%AE/2.png" alt="图片"></p>
<h3 id="初次认识"><a href="#初次认识" class="headerlink" title="初次认识"></a>初次认识</h3><p>Paxos算法过程和我国的立法过程是极其相似的（法律案的提出、法律案的审议、法律案的表决、法律的公布四个阶段），所谓的提案就是新颁布法律。</p>
<p>Proposer (提案者)可以提出（propose）提案；Accoptor可以接受（accept）提案；如果某个提案被选定（chosen），那么该提案里的value就被选定了。</p>
<p>回到刚刚说的『对某个数据的值达成一致』，指的是Proposer、Acceptor、Learner都认为同一个value被选定（chosen）。那么，Proposer、Acceptor、Learner分别在什么情况下才能认为某个value被选定呢？</p>
<ul>
<li>Proposer：只要Proposer发的提案被Acceptor接受（刚开始先认为只需要一个Acceptor接受即可，在推导过程中会发现需要半数以上的Acceptor同意才行），Proposer就认为该提案里的value被选定了。</li>
<li>Acceptor：只要Acceptor接受了某个提案，Acceptor就认为该提案里的value被选定了。</li>
<li>Learner：作为一个学习者，Acceptor告诉Learner哪个value被选定，Learner就认为那个value被选定。</li>
</ul>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>假设有一组可以<strong>提出（propose）value</strong>的进程集合（提案者团队），一个一致性算法需要保证提出的这么多value中，仅仅<strong>只有一个相同的</strong>value被选定（chosen）。也就是说要么没有value被提出，只要提出了value并且被选定，那么大家最终学习到的value必须是一致的。对于一致性算法，<strong>安全性</strong>（safaty）要求如下：</p>
<ul>
<li>只有被提出的value才能被选定。</li>
<li>只有一个value被选定。</li>
<li>如果某个进程认为某个value被选定了，那么这个value必须是真的被选定的那个。</li>
</ul>
<blockquote>
<p>“</p>
<p>Paxos的目标：保证最终有一个value会被选定，当value被选定后，进程最终也能获取到被选定的value。</p>
<p>”</p>
</blockquote>
<p>俗话说的好，<strong>哪里有需求，哪里就会出现糟糕的问题</strong>。如果假设不同角色之间可以通过发送消息来进行通信，那么：</p>
<ul>
<li>每个角色以各自任意的速度进行通信执行，在这个过程中可能会因为各种原因出错而导致执行停止或重启。当一个value被选定之后，因为故障原因才恢复正常的角色因为失去了某些重要的信息，导致它们无法确定被选定的值。</li>
<li>消息在传递过程中可能出现任意时长的延迟，可能会重复，也可能丢失。但是消息不会被损坏，即消息内容不会被篡改（拜占庭将军问题）。</li>
</ul>
<p>以上都是可能会遇到的问题，要怎么解决？？？</p>
<h2 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h2><h3 id="最简单的方案——只有一个Acceptor"><a href="#最简单的方案——只有一个Acceptor" class="headerlink" title="最简单的方案——只有一个Acceptor"></a>最简单的方案——只有一个Acceptor</h3><p>假设只有一个Acceptor（可以有多个Proposer），只要Acceptor接受它收到的第一个提案，则该提案被选定，该提案里的value就是被选定的value。这样就保证只有一个value会被选定。</p>
<p>但是，如果这个唯一的Acceptor宕机了，那么整个系统就<strong>无法工作</strong>了！</p>
<p>因此，一个Acceptor是不可行的，必须要有<strong>多个Acceptor</strong>！</p>
<p><img src="/2022/10/24/Paxos%E5%8D%8F%E8%AE%AE/3.png" alt="图片"></p>
<h3 id="多个Acceptor"><a href="#多个Acceptor" class="headerlink" title="多个Acceptor"></a>多个Acceptor</h3><p>当有多个Acceptor的时候，如何保证在多个Proposer和多个Acceptor的情况下选定一个value呢？</p>
<p>大家可以自己先进行思考。</p>
<p>首先，我们的最终目标是无论有多少Proposer提出提案，有且仅有一个value被选定。</p>
<p>那么，我们可以先定义一个约束：</p>
<blockquote>
<p>“</p>
<p>P1：一个Acceptor必须接受它收到的第一个提案。</p>
<p>”</p>
</blockquote>
<p>但是，这样又会出现其它的问题：如果每个Proposer所提出的提案value是不同的，并且将提案发送给不同的Acceptor。根据P1约束，每个Acceptor都接受它收到的第一个提案，就会出现不同value被选定的情况，出现了不一致。</p>
<p><img src="/2022/10/24/Paxos%E5%8D%8F%E8%AE%AE/4.png" alt="图片"></p>
<p>刚刚是因为『一个提案只要被一个Acceptor接受，则该提案的value就被选定了』才导致了出现上面不一致的问题。因此，我们需要加一个规定：</p>
<blockquote>
<p>“</p>
<p>规定：一个提案被选定需要被<strong>半数以上</strong>的Acceptor接受</p>
<p>”</p>
</blockquote>
<p>一个提案被半数以上接受，说明『一个Acceptor必须能够接受不止一个提案！』，不然可能导致最终没有value被选定。比如上图的情况。v1、v2、v3都没有被选定，因为它们都只被一个Acceptor的接受，并没有被超过半数以上的Acceptor接受。</p>
<p>最开始将【<strong>提案 &#x3D; value</strong>】已经无法满足现在的需求，因为当一个Proposer发送多个提案到一个Acceptor的时候，需要使用一个编号来区分被提出的顺序。现在【<strong>提案&#x3D;提案编号+value</strong>】。</p>
<p>虽然允许多个提案被选定，但必须保证所有被选定的提案都具有相同的value值。否则又会出现不一致。</p>
<blockquote>
<p>“</p>
<p>P2：如果某个value为v的提案被选定了，那么每个编号更高的被选定提案的value必须也是v。</p>
<p>”</p>
</blockquote>
<p>一个提案只有被Acceptor接受才可能被选定，因此我们可以把P2约束改写成对Acceptor接受的提案的约束P2a。</p>
<blockquote>
<p>“</p>
<p>P2a：如果某个value为v的提案被选定了，那么每个编号更高的被Acceptor接受的提案的value必须也是v。</p>
<p>”</p>
</blockquote>
<p>只要满足了P2a，就能满足P2。</p>
<p>但是，考虑如下的情况：以立法过程为背景，假设总的有5个人大代表（Acceptor）。</p>
<p><strong>人民法院</strong>（Proposer2）提出[M1,V1]的提案，<strong>人大代表2-5号</strong>（半数以上）均接受了该提案，于是对于人大代表2-5号和人民法院来讲，它们都认为V1提案是被选定的。此时，<strong>人大代表1</strong>在办完其它事务之后也参与到其中（之前人大代表1没有收到过任何提案），此时<strong>最高人民检察院</strong>（另一个提案者Proposer1）向人大代表1发送了[M2,V2]的提案（V2≠V1且M2&gt;M1），对于人大代表1来讲，这是它收到的第一个提案。根据P1（一个Acceptor必须接受它收到的第一个提案。）,人大代表1必须接受该提案！同时人大代表1认为V2被选定。这就出现了两个问题：</p>
<ol>
<li>人大代表1认为V2被选定，人大代表2-5和人民法院认为V1被选定。出现了不一致。</li>
<li>V1被选定了，但是编号更高的被人大代表1接受的提案[M2,V2]的value为V2，且V2≠V1。这就跟P2a（如果某个value为v的提案被选定了，那么每个编号更高的被Acceptor接受的提案的value必须也是v）矛盾了。</li>
</ol>
<p><img src="/2022/10/24/Paxos%E5%8D%8F%E8%AE%AE/5.png" alt="图片"></p>
<p>所以，我们要对P2a约束进行加强！</p>
<p>P2a是对Acceptor接受的提案约束，但其实提案是Proposer提出来的，所有我们可以对Proposer提出的提案进行约束。得到P2b：</p>
<blockquote>
<p>“</p>
<p>P2b：如果某个value为v的提案被选定了，那么之后任何Proposer提出的编号更高的提案的value必须也是v。</p>
<p>”</p>
</blockquote>
<p>那么，如何确保在某个value为v的提案被选定后，Proposer提出的编号更高的提案的value都是v呢？</p>
<p>只要满足P2c即可：</p>
<blockquote>
<p>“</p>
<p>P2c：对于任意的N和V，如果提案[N, V]被提出，那么存在一个半数以上的Acceptor组成的集合S，满足以下两个条件中的任意一个：</p>
<ul>
<li>S中每个Acceptor都没有接受过编号小于N的提案。</li>
<li>S中Acceptor接受过的最大编号的提案的value为V。</li>
</ul>
<p>”</p>
</blockquote>
<h3 id="Proposer生成提案"><a href="#Proposer生成提案" class="headerlink" title="Proposer生成提案"></a>Proposer生成提案</h3><p>为了满足P2b，这里有个比较重要的思想：Proposer生成提案之前，应该先去<strong>『学习』</strong>已经被选定或者可能被选定的value，然后以该value作为自己提出的提案的value。如果没有value被选定，Proposer才可以自己决定value的值。这样才能达成一致。这个学习的阶段是通过一个<strong>『Prepare请求』</strong>实现的。</p>
<p>于是我们得到了如下的<strong>提案生成算法</strong>：</p>
<ol>
<li><p>Proposer选择一个<strong>新的提案编号N</strong>，然后向<strong>某个Acceptor集合</strong>（半数以上）发送请求，要求该集合中的每个Acceptor做出如下响应（response）。</p>
<p>(a) 向Proposer承诺保证<strong>不再接受</strong>任何编号<strong>小于N的提案</strong>。</p>
<p>(b) 如果Acceptor已经接受过提案，那么就向Proposer响应<strong>已经接受过</strong>的编号小于N的<strong>最大编号的提案</strong>。</p>
<p>我们将该请求称为<strong>编号为N</strong>的<strong>Prepare请求</strong>。</p>
</li>
<li><p>如果Proposer收到了<strong>半数以上</strong>的Acceptor的<strong>响应</strong>，那么它就可以生成编号为N，Value为V的<strong>提案[N,V]。这里的V是所有的响应中编号最大的提案的Value</strong>。如果所有的响应中<strong>都没有提案</strong>，那 么此时V就可以由Proposer<strong>自己选择</strong>(一般为当前提案)。</p>
<p>生成提案后，Proposer将该<strong>提案</strong>发送给<strong>半数以上</strong>的Acceptor集合，并期望这些Acceptor能接受该提案。我们称该请求为<strong>Accept请求</strong>。（注意：此时接受Accept请求的Acceptor集合<strong>不一定</strong>是之前响应Prepare请求的Acceptor集合）</p>
</li>
</ol>
<h3 id="Acceptor接受提案"><a href="#Acceptor接受提案" class="headerlink" title="Acceptor接受提案"></a>Acceptor接受提案</h3><p>Acceptor<strong>可以忽略任何请求</strong>（包括Prepare请求和Accept请求）而不用担心破坏算法的<strong>安全性</strong>。因此，我们这里要讨论的是什么时候Acceptor可以响应一个请求。</p>
<p>我们对Acceptor接受提案给出如下约束：</p>
<blockquote>
<p>“</p>
<p>P1a：一个Acceptor只要尚<strong>未响应过</strong>任何<strong>编号大于N</strong>的<strong>Prepare请求</strong>，那么他就可以<strong>接受</strong>这个<strong>编号为N的提案</strong>。</p>
<p>”</p>
</blockquote>
<p>如果Acceptor收到一个编号为N的Prepare请求，在此之前它已经响应过编号大于N的Prepare请求。根据P1a，该Acceptor不可能接受编号为N的提案。因此，该Acceptor可以忽略编号为N的Prepare请求。当然，也可以回复一个error，让Proposer尽早知道自己的提案不会被接受。</p>
<p>因此，一个Acceptor<strong>只需记住</strong>：1. 已接受的编号最大的提案 2. 已响应的请求的最大编号。</p>
<h3 id="Paxos算法描述"><a href="#Paxos算法描述" class="headerlink" title="Paxos算法描述"></a>Paxos算法描述</h3><p>经过上面的推导，我们总结下Paxos算法的流程。</p>
<p>Paxos算法分为<strong>两个阶段</strong>。具体如下：</p>
<p>1.<strong>阶段一：</strong></p>
<ol>
<li>Proposer选择一个<strong>提案编号N</strong>，然后向<strong>半数以上</strong>的Acceptor发送编号为N的<strong>Prepare请求</strong>。</li>
<li>如果一个Acceptor收到一个编号为N的Prepare请求，且N<strong>大于</strong>该Acceptor已经<strong>响应过的</strong>所有<strong>Prepare请求</strong>的编号，那么它就会将它已经<strong>接受过的编号最大的提案（如果有的话）</strong> 作为响应反馈给Proposer，同时该Acceptor承诺<strong>不再接受</strong>任何<strong>编号小于N的提案</strong>。</li>
</ol>
<p>2.<strong>阶段二：</strong></p>
<ol>
<li>如果Proposer收到<strong>半数以上</strong>Acceptor对其发出的编号为N的Prepare请求的<strong>响应</strong>，那么它就会发送一个针对[N,V]提案的Accept请求给<strong>半数以上</strong>的Acceptor（和之前的Acceptor不一定相同）。注意：V就是收到的响应中编号最大的提案的value，如果响应中<strong>不包含任何提案</strong>，那么V就由Proposer<strong>自己决定</strong>。</li>
<li>如果Acceptor收到一个针对编号为N的提案的Accept请求，只要该Acceptor<strong>没有</strong>对编号<strong>大于N</strong>的<strong>Prepare请求</strong>做出过<strong>响应</strong>，它就<strong>接受该提案</strong>。</li>
</ol>
<p><img src="/2022/10/24/Paxos%E5%8D%8F%E8%AE%AE/6.png" alt="图片"></p>
<h2 id="Learner学习被选定的value"><a href="#Learner学习被选定的value" class="headerlink" title="Learner学习被选定的value"></a>Learner学习被选定的value</h2><p>Learner学习（获取）被选定的value有如下三种方案：</p>
<h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>Acceptor接受到一个提案，就将该提案发送给所有Learners.</p>
<ul>
<li>优点：Learner能够快速获取被选定的value</li>
<li>缺点：通信次数为M*N（M为提案数，N为Learner数）</li>
</ul>
<h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>Acceptor接受一个提案，就将提案发送给<strong>主Learner</strong>,主Learner再通知其它Learner</p>
<ul>
<li>优点：通信次数减少（M+N-1）（M为提案数，N为Learner数，M个提案发送给主Learner，然后主Learner通知N-1个Learner）</li>
<li>缺点：单点故障问题（主Learner可能出现故障）</li>
</ul>
<h3 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h3><p>Acceptor接受一个提案，就将提案发送给<strong>Learner团</strong>,Learner团再通知其它Learner</p>
<ul>
<li>优点：解决了方案二单点故障问题，可靠性好</li>
<li>缺点：实现复杂，网络通信复杂度高</li>
</ul>
<h2 id="如何保证Paxos算法的活性"><a href="#如何保证Paxos算法的活性" class="headerlink" title="如何保证Paxos算法的活性"></a>如何保证Paxos算法的活性</h2><p>通过选取<strong>主Proposer</strong>，就可以保证Paxos算法的活性。通过选取主Proposer，并规定只有主Proposer才能提出议案。这样一来只要主Proposer和过半的Acceptor能够正常进行网络通信，那么但凡主Proposer提出一个编号更高的提案，该提案终将会被批准，这样通过选择一个主Proposer，整套Paxos算法就能够保持活性。至此，我们得到一个<strong>既能保证安全性，又能保证活性</strong>的<strong>分布式一致性算法</strong>——<strong>Paxos算法</strong>。</p>
<p><img src="/2022/10/24/Paxos%E5%8D%8F%E8%AE%AE/7.png" alt="图片"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到此，我们针对Paxos算法是什么、它的特性以及算法的具体推导过程做了详细的阐述。<strong>Paxos算法</strong>是现在很多一致性算法的变体，非常值得我们学习</p>
]]></content>
      <categories>
        <category>分布式一致性协议</category>
      </categories>
      <tags>
        <tag>分布式一致性协议</tag>
        <tag>Paxos协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis知识点PDF总结</title>
    <url>/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9PDF%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>Redis知识点PDF总结</p>
<div class="pdf-container" data-target="./Redis高手心法-码哥字节原创.pdf" data-height="1000px"></div>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>AOF</tag>
        <tag>RDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-携程最终一致和强一致性缓存实践</title>
    <url>/2022/10/25/Redis-%E6%90%BA%E7%A8%8B%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E5%92%8C%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E7%BC%93%E5%AD%98%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1 id="携程最终一致和强一致性缓存实践"><a href="#携程最终一致和强一致性缓存实践" class="headerlink" title="携程最终一致和强一致性缓存实践"></a>携程最终一致和强一致性缓存实践</h1><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h1><p>​    </p>
<p>携程金融从成立至今，整体架构经历了从0到1再到10的变化，其中有多个场景使用了缓存来提升服务质量。从系统层面看，使用缓存的目的无外乎缓解DB压力（主要是读压力），提升服务响应速度。引入缓存，就不可避免地引入了缓存与业务DB数据的一致性问题，而不同的业务场景，对数据一致性的要求也不同。本文将从以下两个场景介绍我们的一些缓存实践方案：</p>
<ul>
<li>最终一致性分布式缓存场景</li>
<li>强一致性分布式缓存场景</li>
</ul>
<p>注：我们DB用的是MySQL，缓存介质用的是携程高可用Redis服务，存储介质的选型及存储服务的高可用不是本文重点，后文也不再做特别说明。</p>
<h1 id><a href="#" class="headerlink" title></a></h1><h1 id="二、最终一致性分布式缓存场景"><a href="#二、最终一致性分布式缓存场景" class="headerlink" title="二、最终一致性分布式缓存场景"></a><strong>二、最终一致性分布式缓存场景</strong></h1><h3 id="2-1-场景描述"><a href="#2-1-场景描述" class="headerlink" title="2.1 场景描述"></a><strong>2.1 场景描述</strong></h3><p>​    </p>
<p>经过几年演进，携程金融形成了自顶向下的多层次系统架构，如业务层、平台层、基础服务层等，其中用户信息、产品信息、订单信息等基础数据由基础平台等底层系统产生，服务于所有的金融系统，对这部分基础数据我们引入了统一的缓存服务（系统名utag），缓存数据有三大特点：全量、准实时、永久有效，在数据实时性要求不高的场景下，业务系统可直接调用统一的缓存查询接口。</p>
<p>我们的典型使用场景有：风控流程、APP入口信息提示等，而对数据一致性要求高的场景依然需要走实时的业务接口查询。引入缓存前后系统架构对比如下：</p>
<p><img src="/2022/10/25/Redis-%E6%90%BA%E7%A8%8B%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E5%92%8C%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E7%BC%93%E5%AD%98%E5%AE%9E%E8%B7%B5/1.png" alt="图片"></p>
<p>统一缓存服务的构建给部门的整体系统架构带来了一些优势：</p>
<p>对业务系统：</p>
<ul>
<li>响应速度提升：相比直接调用底层高流量的基础服务，调用缓存服务接口的系统响应时间大大减少（缓存查询接口P98为10毫秒）。</li>
<li>统一接口，降低接入成本：一部分业务场景下可以直接调用统一缓存服务查询接口，而不用再对接底层的多个子系统，极大地降低了各个业务线的接入成本。</li>
<li>统一缓存，省去各个服务单独维护缓存的成本。</li>
</ul>
<p>对基础服务：</p>
<ul>
<li>服务压力降低：基础平台的系统本身就属于高流量系统，可减少一大部分的查询流量，降低服务压力。</li>
</ul>
<p>整体而言，缓存服务处于中间层，数据的写入方和数据查询方解耦，数据甚至可以在底层系统不感知的情况下写入（见下文），而数据使用方的查询也可在底层服务不可用或“堵塞”时候仍然保持可用（前提是缓存服务是可用的，而缓存服务的处理逻辑简单、统一且有多种手段保证，其可用性比单个子系统都高），整体上服务的稳定性得到了提升。</p>
<p>在构建此统一缓存服务时候，有三个关键目标：</p>
<ul>
<li>数据准确性：DB中单条数据的更新一定要准确同步到缓存服务。</li>
<li>数据完整性：将对应DB表的全量数据进行缓存且永久有效，从而可以替代对应的DB查询。</li>
<li>系统可用性：我们多个产品线的多个核心服务都已经接入，utag的高可用性显的尤为关键。</li>
</ul>
<p>接下来先说明统一缓存服务的整体方案，再逐一介绍此三个关键特性的设计实现方案。</p>
<h3 id="2-2-整体方案"><a href="#2-2-整体方案" class="headerlink" title="2.2 整体方案"></a><strong>2.2 整体方案</strong></h3><h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><h6 id="我们的系统在多地都有部署，故缓存服务也做了相应的异地多机房部署，一来可以让不同地区的服务调用本地区服务，无需跨越网络专线，二来也可以作为一种灾备方案，增加可用性。"><a href="#我们的系统在多地都有部署，故缓存服务也做了相应的异地多机房部署，一来可以让不同地区的服务调用本地区服务，无需跨越网络专线，二来也可以作为一种灾备方案，增加可用性。" class="headerlink" title="我们的系统在多地都有部署，故缓存服务也做了相应的异地多机房部署，一来可以让不同地区的服务调用本地区服务，无需跨越网络专线，二来也可以作为一种灾备方案，增加可用性。"></a>我们的系统在多地都有部署，故缓存服务也做了相应的异地多机房部署，一来可以让不同地区的服务调用本地区服务，无需跨越网络专线，二来也可以作为一种灾备方案，增加可用性。</h6><p>对于缓存的写入，由于缓存服务是独立部署的，因此需要感知业务DB数据变更然后触发缓存的更新，本着“可以多次更新，但不能漏更新”的原则，我们设计了多种数据更新触发源：定时任务扫描，业务系统MQ、binlog变更MQ，相互之间作为互补来保证数据不会漏更新。</p>
<p>此外为了缓存更新流程的统一和与触发源的解耦，我们使用MQ来驱动多地多机房的缓存更新，在不同的触发源触发后，会查询最新的DB数据，然后发出一个缓存更新的MQ消息，不同地区机房的缓存系统同时监听该主题并各自进行缓存的更新。对于MQ我们使用携程开源消息中间件QMQ 和 Kafka，在公司内部QMQ和Kafka也做了异地机房的互通。</p>
<p>对于缓存的读取，utag系统提供dubbo协议的缓存查询接口，业务系统可调用本地区的接口，省去了网络专线的耗时（50ms延迟）。在utag内部查询redis数据，并反序列化为对应的业务model，再通过接口返回给业务方。</p>
<p>为了描述方便，以下异地多机房部署统一使用AB两地部署的概念进行说明。</p>
<p>整体框架如下图所示：</p>
<p><img src="/2022/10/25/Redis-%E6%90%BA%E7%A8%8B%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E5%92%8C%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E7%BC%93%E5%AD%98%E5%AE%9E%E8%B7%B5/2.png" alt="图片"></p>
<p>接下来介绍一下几个关键点的设计 。</p>
<h3 id="-2"><a href="#-2" class="headerlink" title></a></h3><h3 id="2-3-数据准确性设计"><a href="#2-3-数据准确性设计" class="headerlink" title="2.3 数据准确性设计"></a><strong>2.3 数据准确性设计</strong></h3><p>不同的触发源，对缓存更新过程是一样的，整个更新步骤可抽象为4步：</p>
<ul>
<li>step1：触发更新，查询DB中的新数据，并发送统一的MQ</li>
<li>step2：接收MQ，查询缓存中的老数据</li>
<li>step3：新老数据对比，判断是否需要更新</li>
<li>step4：若需要，则更新缓存</li>
</ul>
<p>​    </p>
<p>由于我们业务的大部分核心系统和所有的DB都在A地机房，所以触发源（如binlog的消费、业务MQ的接收、扫表任务的执行）都在A侧，触发更新后，第一步查询DB数据也只能在A侧查询（避免跨网络专线的数据库连接，影响性能）。查询到新数据后，发送更新缓存的MQ，两地机房的utag服务进行消费，之后进行统一的缓存更新流程。总体的缓存更新方案如下图所示：</p>
<p><img src="/2022/10/25/Redis-%E6%90%BA%E7%A8%8B%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E5%92%8C%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E7%BC%93%E5%AD%98%E5%AE%9E%E8%B7%B5/3.png" alt="图片"></p>
<p>由于有多个触发源，不同的触发源之间可能会对同一条数据的缓存更新请求出现并发，此外可能出现同一条数据在极短时间内（如1秒内）更新多次，无法区分数据更新顺序，因此需要做两方面的操作来确保数据更新的准确性。</p>
<p>（1）并发控制</p>
<p>若一条DB数据出现了多次更新，且刚好被不同的触发源触发，更新缓存时候若未加控制，可能出现数据更新错乱，如下图所示：</p>
<p><img src="/2022/10/25/Redis-%E6%90%BA%E7%A8%8B%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E5%92%8C%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E7%BC%93%E5%AD%98%E5%AE%9E%E8%B7%B5/4.png" alt="图片"></p>
<p>故需要将第2、3、4步加锁，使得缓存刷新操作全部串行化。由于utag本身就依赖了redis，此处我们的分布式锁就基于redis实现。</p>
<p>（2）基于updateTime的更新顺序控制</p>
<p>即使加了锁，也需要进一步判断当前db数据与缓存数据的新老，因为到达缓存更新流程的顺序并不代表数据的真正更新顺序。我们通过对比新老数据的更新时间来实现数据更新顺序的控制。若新数据的更新时间大于老数据的更新时间，则认为当前数据可以直接写入缓存。</p>
<p>我们系统从建立之初就有自己的MySQL规范，每张表都必须有update_time字段，且设置为ON UPDATE CURRENT_TIMESTAMP，但是并没有约束时间字段的精度，大部分都是秒级别的，因此在同一秒内的多次更新操作就无法识别出数据的新老。</p>
<p>针对同一秒数据的更新策略我们采用的方案是：先进行数据对比，若当前数据与缓存数据不相等，则直接更新，并且发送一条延迟消息，延迟1秒后再次触发更新流程。</p>
<p>举个例子：假设同一秒内同一条数据出现了两次更新，value&#x3D;1和value&#x3D;2，期望最终缓存中的数据是value&#x3D;2。若这两次更新后的数据被先后触发，分两种情况：</p>
<ul>
<li>case1：若value&#x3D;1先更新，value&#x3D;2后更新，（两者都可更新到缓存中，因为虽然是同一秒，但是值不相等）则缓存中最终数据为value&#x3D;2。</li>
<li>case2：若value&#x3D;2先更新，value&#x3D;1后更新，则第一轮更新后缓存数据为value&#x3D;1，不是期望数据，之后对比发现是同一秒数据后会通过消息触发二次更新，重新查询DB数据为value&#x3D;2，可以更新到缓存中。如下图所示：</li>
</ul>
<p><img src="/2022/10/25/Redis-%E6%90%BA%E7%A8%8B%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E5%92%8C%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E7%BC%93%E5%AD%98%E5%AE%9E%E8%B7%B5/5.png" alt="图片"></p>
<p>通过以上方案我们可以确保缓存数据的准确性。有几个点需要额外说明： </p>
<ul>
<li>为什么要用延迟消息？</li>
</ul>
<p>其实不用延迟消息也是可以的，毕竟DB数据的更新时间是不变的，但是考虑到出现同一秒更新的可能是高频更新场景，若直接发消息，然后立即消费并触发二次更新，可能依然查到同一秒内更新的其他数据，为减少此种情况下的多次循环更新，延迟几秒再刷新可作为一种优化策略。</p>
<ul>
<li>不支持db的删除操作</li>
</ul>
<p>因为删除操作和update操作无法进行数据对比，无法确定操作的先后顺序，进而可能导致更新错乱。而在数据异常宝贵的时代，一般的业务系统中也没有物理删除的逻辑。</p>
<ul>
<li>若当前db没有设置更新时间该如何处理？</li>
</ul>
<p>可以将查DB、查缓存、数据对比、更新缓存这四个步骤全部放到锁的范围内，这样就不需要处理同一秒的顺序问题。因为在这个串行化操作中每次都从DB中查询到了最新的数据，可以直接更新，而时间的判断、值的判断可以作为优化操作，减少缓存的更新次数，也可以减少锁定的时间。</p>
<p>而我们为何不采用该方案？因为查询DB的操作我们只能在一侧机房处理，无法让AB两地系统的更新流程统一，也就降低了二者互备的可能性。</p>
<ul>
<li><p>其他方案</p>
</li>
<li><p>DB数据模型上增加版本字段，可严格控制数据的更新时序。</p>
</li>
<li><p>将update_time 字段精度设置为精确到毫秒或微秒，提升数据对比的准确度，但是相比增加版本字段的方案，依然存在同一时间有多次更新的可能。</p>
</li>
<li><p>这些额外的方案，都需要业务数据模型做对应的支持。</p>
</li>
</ul>
<h3 id="2-4-数据完整性设计"><a href="#2-4-数据完整性设计" class="headerlink" title="2.4 数据完整性设计"></a><strong>2.4 数据完整性设计</strong></h3><p>上述数据准确性是从单条数据更新角度的设计，而我们构建缓存服务的目的是替代对应DB表的查询，因此需要缓存对应DB表的全量数据，而数据的完整性从以下三个方面得到保证：</p>
<p>（1）“把鸡蛋放到多个篮子里”，使用多种触发源（定时任务，业务MQ，binglog MQ）来最大限度降低单条数据更新缺失的可能性。</p>
<p>单一触发源有可能出现问题，比如消息类的触发依赖业务系统、中间件canel、中间件QMQ和Kafka，扫表任务依赖分布式调度平台、MySQL等。中间任何一环都可能出现问题，而这些中间服务同时出概率的可能相对来说就极小了，相互之间可以作为互补。</p>
<p>（2）全量数据刷新任务：全表扫描定时任务，每周执行一次来进行兜底，确保缓存数据的全量准确同步。</p>
<p>（3）数据校验任务：监控Redis和DB数据是否同步并进行补偿。  </p>
<h3 id="-3"><a href="#-3" class="headerlink" title></a></h3><h3 id="2-5-系统可用性设计"><a href="#2-5-系统可用性设计" class="headerlink" title="2.5 系统可用性设计"></a><strong>2.5 系统可用性设计</strong></h3><p>统一缓存服务被多个业务线的核心系统所依赖，所以缓存服务的高可用是至关重要的。而对高可用的建设，除了集群部署、容量规划、熔断降级等常用手段外，针对我们自己的场景也做了一些方案。主要有以下三点：</p>
<p>（1）异地机房互备</p>
<p>如上所述，我们的服务在AB两地部署，两机房的缓存通过两地互通的MQ同时写入。在这套机制下，本地区的业务系统可以直接读取本地区的缓存，如果出现了本地区utag应用异常或redis服务异常，则可以快速降级到调用另外机房的服务接口。具体方案如下图所示：</p>
<p><img src="/2022/10/25/Redis-%E6%90%BA%E7%A8%8B%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E5%92%8C%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E7%BC%93%E5%AD%98%E5%AE%9E%E8%B7%B5/6.png" alt="图片"></p>
<p>本地业务系统通过dubbo调用本地的utag服务，在utag的本地处理流程中，查询本地缓存前后分别可根据一定的条件进行服务降级，即查询另一机房。</p>
<ul>
<li><p>查询本地缓存前降级：若本地redis集群出现故障，可以在配置平台人工快速切换到查询另一侧的服务。</p>
</li>
<li><p>查询本地缓存后降级：本地处理结束，若出现特定错误码（”OPERATE_REDIS_ERROR”）则可降级到查询另一侧服务。该功能也需要手工配置开关来启用。</p>
</li>
</ul>
<p>为了避免循环调用，在降级调用前，需要判断当前请求是否来自本地，而此功能通过Dubbo的RpcContext透传特定标识来实现。除此之外，还建立了两机房的应用心跳，来辅助切换。</p>
<p><img src="/2022/10/25/Redis-%E6%90%BA%E7%A8%8B%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E5%92%8C%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E7%BC%93%E5%AD%98%E5%AE%9E%E8%B7%B5/7.png" alt="图片"></p>
<p>（2）QMQ和Kafka互备</p>
<p>缓存更新流程通过MQ来驱动，虽然公司的MQ中间件服务由专人维护，但是万一出现问题长时间不能恢复，对我们来说将是致命的。所以我们决定同时采用Kafka和QMQ两种中间件来作为互备方案。默认情况下对于全表扫描任务和binlog消费这类大批量消息场景使用Kafka来驱动，而其他场景通过QMQ来驱动。所有的场景都可以通过开关来控制走Kafka或者QMQ。目前该功能可通过配置管理平台来实现快速切换。</p>
<p>（3）快速恢复</p>
<p>在极端情况下，可能出现Redis数据丢失的情况，如主机房（A机房）突然断网，redis集群切换过程出现数据丢失或同步错乱，此时很可能无法通过自动触发来补齐数据，因此设计了全表快速扫描的补偿机制，通过多任务并行调度，可在30分钟内将全量数据完成刷新。此功能需要人工判断并触发。</p>
<h3 id="-4"><a href="#-4" class="headerlink" title></a></h3><h3 id="2-6-总结"><a href="#2-6-总结" class="headerlink" title="2.6 总结"></a><strong>2.6 总结</strong></h3><p>​    </p>
<p>以上介绍了我们最终一致性分布式缓存服务的设计思路和要点，其中的关键点为数据准确性、数据完整性、系统可用性的设计。除此之外，还有一些优化点如降级方案的自动触发、异地机房缓存之间、缓存与DB之间做旁路数据diff，可进一步确保缓存服务整体的健壮性，在后续的版本中进行迭代。</p>
<h1 id="-5"><a href="#-5" class="headerlink" title></a></h1><h1 id="三、强一致性分布式缓存场景"><a href="#三、强一致性分布式缓存场景" class="headerlink" title="三、强一致性分布式缓存场景"></a><strong>三、强一致性分布式缓存场景</strong></h1><h3 id="-6"><a href="#-6" class="headerlink" title></a></h3><h3 id="3-1-场景描述"><a href="#3-1-场景描述" class="headerlink" title="3.1 场景描述"></a><strong>3.1 场景描述</strong></h3><p>​    </p>
<p>强一致性分布式缓存目前主要应用在我们携程金融的消金贷前服务中。随着我们用户量和业务量的增涨，贷前服务的查询量激增，给数据库带来了很大的压力，解决此问题有几种可选方案：</p>
<p>（1）分库分表：成本和复杂度相对较高，我们场景下只是数据查询流量较大。</p>
<p>（2）读写分离：出于数据库性能考虑，我们的MySQL大部分采用异步复制的方式，而由于我们的场景对数据实时性要求较高，因此无法直接利用读写分离的优势来分担主库压力。</p>
<p>​    </p>
<p>综合来看，增加缓存是更加合适的方案，我们决定设计一套高可用的满足强一致性要求的分布式缓存。接下来介绍我们的具体设计实现方案。</p>
<h3 id="3-2-整体方案"><a href="#3-2-整体方案" class="headerlink" title="3.2 整体方案"></a><strong>3.2 整体方案</strong></h3><p>缓存的处理我们采用了较为常见的处理思路：在更新操作中，先更新数据库，再删除缓存，查询操作中，触发缓存更新。</p>
<p><img src="/2022/10/25/Redis-%E6%90%BA%E7%A8%8B%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E5%92%8C%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E7%BC%93%E5%AD%98%E5%AE%9E%E8%B7%B5/8.png" alt="图片"></p>
<p>在此过程中，若不加控制，则会存在数据不一致性问题，主要是由于缓存操作和DB更新之间的并发导致的。具体分析如下：</p>
<p>（1）缓存读取和DB更新并发</p>
<p>如下图所示，查询时候若缓存已经存在，则会直接返回缓存数据。若查询缓存的操作，发生在“更新DB数据”和“删除缓存”之间，则本次查询到数据为缓存中的老数据，导致不一致。当然下次查询可能就会查询到最新的数据。这种并发在我们服务中是存在的，比如某个产品开通后，会在更新DB（产品开通状态）后立即发送MQ（事务型消息）告知业务，业务侧处理流程中会立即发起查询操作。此场景中数据库的更新和数据的查询间隔极短，很容易出现此种并发问题。</p>
<p><img src="/2022/10/25/Redis-%E6%90%BA%E7%A8%8B%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E5%92%8C%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E7%BC%93%E5%AD%98%E5%AE%9E%E8%B7%B5/9.png" alt="图片"></p>
<p>（2）缓存更新与DB更新并发</p>
<p>如下图所示，查询的时候，若缓存不存在，则更新缓存，流程是先查询DB再更新Redis。若更新缓存时候，出现以下时序：查询DB老数据（T0时刻，DB中value&#x3D;1）→ 更新DB（T1时刻，更新DB为value&#x3D;2）→ 删除Redis（T2）→ 更新Redis（T3），则会导致本次查询返回数据及缓存中的数据与DB数据不一致，即接口返回和更新后的缓存都为脏数据。若T2和T3互换，即更新DB后，先更新Redis，再删除Redis ，由于缓存被删除在下次更新可能会被正确更新，但本次返回数据依然与DB更新后的数据不一致。 </p>
<p><img src="/2022/10/25/Redis-%E6%90%BA%E7%A8%8B%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E5%92%8C%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E7%BC%93%E5%AD%98%E5%AE%9E%E8%B7%B5/10.png" alt="图片"></p>
<p>基于以上分析，为了避免并发带来的缓存不一致问题，需要将”更新DB”+”删除缓存”、”查询DB”+”更新缓存”两个流程都进行加锁。此处需要加的是分布式锁，我们使用的是redis分布式锁实现。加锁后的读写整体流程如下：</p>
<p><img src="/2022/10/25/Redis-%E6%90%BA%E7%A8%8B%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E5%92%8C%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E7%BC%93%E5%AD%98%E5%AE%9E%E8%B7%B5/11.png" alt="图片"></p>
<p>如上图所示，有两处加锁，更新DB时加锁，锁范围为”更新DB”+”删除cache”（图中lock1），更新缓存时加锁，锁范围为”查询DB” + “更新cache”（图中lock2），两处对应的锁key是相同的。基于此方案，对于上面所说的两种并发场景，做针对性分析如下：</p>
<p>（1）缓存查询和DB更新的并发控制</p>
<p>查询操作流程中，先判断lock是否存在，若存在，则表示当前DB或缓存正在更新，不能直接查询缓存，在查询DB后返回数据。之所以这么做，还是由场景决定的，如前文所述，我们场景下的基本处理思路是，缓存仅作为“DB降压”的辅助手段，在不确定缓存数据是否最新的情况下，宁可多查询几次DB，也不要查询到缓存中的不一致数据。此外，更新操作相对于查询操作是很少的，在我们贷前服务中，读写比例约为8:1。</p>
<p>此处另外的一个可行方案是可在检测到有锁后可进行短暂的等待和重试，好处是可进一步增加缓存的命中率，但是多一次锁等待，可能会影响到查询接口的性能。可根据自身场景进行抉择。</p>
<p>此外，为了进行降级，在锁判断前也增加了降级开关判断，若降级开关开启，也会直接查询DB。而降级主要是由于redis故障引起的，下文详述。若检测是否有锁时发生了异常同样也会直接查询DB。</p>
<p>（2）缓存更新和DB更新的并发控制</p>
<p>查询操作流程中，若缓存不存在，则进行缓存的更新，在更新时候先尝试进行加锁，若当前有锁说明当前有DB或缓存正在更新，则进行等待和重试，从而可避免查询到DB中的老数据更新到缓存中。</p>
<p>其中lock2的流程（load cache），我们是同步进行的。另外一个可行的方案是，异步发起缓存的加载，可减少锁等待时间，但是若出现瞬时的高并发查询，可能缓存无法及时加载产生从而频繁产生瞬时压力。可根据自身场景进行抉择。</p>
<p>以上为我们的整体设计思路，接下来从实现的角度分别描述一下基于本地消息表的缓存删除策略，缓存的降级和恢复这两个方面的具体方案。</p>
<h3 id="-7"><a href="#-7" class="headerlink" title></a></h3><h3 id="3-3-缓存删除策略"><a href="#3-3-缓存删除策略" class="headerlink" title="3.3 缓存删除策略"></a><strong>3.3 缓存删除策略</strong></h3><p>在更新操作中，在锁的范围内，先更新DB，再删除缓存。</p>
<p>其中锁的选型，我们采用与缓存同介质的redis分布式锁，这样做的好处是若因为redis服务不可用导致的锁处理失败，对于缓存本身也就不可用，可以自动走降级方案。</p>
<p>此外，更新流程还要考虑两点：锁的范围和删除缓存失败后如何补偿。</p>
<p>（1）锁粒度</p>
<p>更新操作中加锁粒度有以下三种方案：</p>
<p>方案一：事务提交后加锁，只锁定删除缓存操作。对原事务无任何额外影响，但是在事务提交后到删除缓存之间存在与查询的并发可能性。</p>
<p>方案二：在事务提交前加锁，删除缓存后解锁。在满足一致性要求的前提下，锁的粒度可以做到最小，但是增加了DB事务的范围，若redis出现超时则可能导致事务时间拉长，进而影响DB操作性能。</p>
<p>方案三：在事务开始前加锁，删除缓存后解锁。锁的范围较大，但是能满足我们一致性要求，对单个DB事务也基本无影响。且对同一个用户来说，贷前数据的更新并不频繁，锁范围稍大一些是我们可以接受的。</p>
<p><img src="/2022/10/25/Redis-%E6%90%BA%E7%A8%8B%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E5%92%8C%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E7%BC%93%E5%AD%98%E5%AE%9E%E8%B7%B5/12.png" alt="图片"></p>
<p>立足自身场景，权衡一致性要求和服务性能要求，我们剔除了方案二，默认情况下使用方案三，但是若在事务开始前加锁失败，为了不影响原业务流程（缓存只是辅助方案，redis故障不影响原应用功能）会自动降级到方案一，即在事务提交后删除缓存前再加锁。而这种降级，若出现并发的查询操作，依然可能出现上述不一致的问题，但是是可以容忍的，原因如下：</p>
<p>通常情况下加锁失败是由于操作redis异常或者锁竞争引起的。</p>
<ul>
<li>若出现redis异常，同时出现了并发的查询，而并发的两个操作时间间隔是极短的，因此查询时候，锁检测操作通常也是异常的，此时查询会自动降级为查询DB。</li>
<li>若极短时间内的redis集群抖动，事务执行前redis不可用，事务执行后redis恢复，而此时在加锁操作还没有完成前恰巧又进行了并发的查询操作，检测锁成功且锁不存在，才可能会出现查询出老数据的情况。这种是极其严苛的并发条件。</li>
<li>而加锁过程会进行重试（可动态调整配置），多次重试后可解决大部分的锁竞争情况。</li>
</ul>
<p>综上，在上述锁降级的方案下，数据不一致出现的情况虽然无法完全避免，但是产生条件极其苛刻，而应对这种极其极端的情况，在系统层面做更加强的方案带来的复杂度提升与收益是不成正比的，一般情况下做好日志记录、监控、报警，通过人工介入来弥补即可。从该方案上线后至今两年多的时间内，没有出现过该情况。</p>
<p>（2）删除缓存失败的补偿</p>
<p>​    </p>
<p>另外要考虑的问题是，如果更新DB成功但删除缓存失败要后如何处理，而此种情况往往因应用服务器故障、网络故障、redis故障等原因导致。</p>
<p>若应用服务器突然故障，则服务整体不可用，跟缓存就没多大关系了。若是由于网络、redis故障等原因导致的删除缓存失败，此时查询缓存也不可用，查询走DB，但需要可靠地记录下哪些数据做了变更，待redis可用后需要进行恢复，需要将中间变更的记录对应的缓存全部删除。</p>
<p>​    </p>
<p>此处的一个关键点在于数据变更的可靠性记录，受到QMQ事务消息实现方案的启发，我们的方案是构建一张简易的记录表（代表发生变更的DB数据），每次DB变更后，将该变更记录表的插入和业务DB操作放在一个事务中处理。事务提交后，对应的变更记录持久化，之后进行删除缓存，若缓存删除成功，则将对应的记录表数据也删除掉。若缓存删除失败，则可根据记录表的数据进行补偿删除，而在redis的恢复流程中，需要校验记录表中是否存在数据，若存在则表示有变更后的数据对应的缓存未清除，不可进行缓存读取的恢复。</p>
<p>​    </p>
<p>此外删除操作还要进行异步重试，来避免偶尔超时引起的缓存删除失败。此方案整体流程如下：</p>
<p><img src="/2022/10/25/Redis-%E6%90%BA%E7%A8%8B%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E5%92%8C%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E7%BC%93%E5%AD%98%E5%AE%9E%E8%B7%B5/13.png" alt="图片"></p>
<p>​    </p>
<p>其中cache_key_queue表即为我们的变更记录表，放在业务的同DB内。其表结构非常简单，只有插入和删除操作，对业务DB的额外影响可以忽略。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `cache_key_queue` (</span><br><span class="line">    `id` <span class="type">bigint</span>(<span class="number">20</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">    `cache_key` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;待删除的缓存key&#x27;</span>,</span><br><span class="line">    `create_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">0</span> CHARSET <span class="operator">=</span> utf8 COMMENT <span class="string">&#x27;缓存删除队列表&#x27;</span></span><br></pre></td></tr></table></figure>

<p>基于以上分析，为了锁范围尽可能小，且为了尽可能降低极端的redis抖动情况下产生的影响，我们期望可以在事务提交后立即触发缓存的删除操作。为了能够对redis不可用期间发生变更的数据进行清除，我们需要可靠地记录数据变更记录。幸运的是，基于Spring的事务同步机制 TransactionSynchronization，可以很容易实现该方案。简单来说，该机制提供了Spring环境中事务执行前后的AOP功能，可以在spring事务的执行前后添加自己的操作，如下所示（代码和注释经过了简化）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionSynchronization</span> <span class="keyword">extends</span> <span class="title class_">Flushable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事务同步器挂起处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">suspend</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事务同步器恢复处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">resume</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事务提交前处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">beforeCommit</span><span class="params">(<span class="type">boolean</span> readOnly)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事务完成(提交或回滚)前处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">beforeCompletion</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事务提交后处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">afterCommit</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事务完成(提交或回滚)后处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(<span class="type">int</span> status)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于此机制，我们可以很方便且相对优雅地实现我们的设计思路，即在 beforeCommit方法中，插入cache_key_queue记录；在 afterCommit方法中同步删除缓存，若删除缓存成功则同步删除cache_key_queue表记录；在afterCompletion方法中进行锁的释放处理。若同步删除缓存失败，则cache_key_queue表记录也会保留下来，之后触发异步删除，并启动定时任务不断扫描cache_key_queue表进行缓存删除的补偿。需要注意的是可能存在嵌套事务，一个完整事务中，可能存在多次数据更新，可借助ThreadLocal进行多条更新记录的汇总。</p>
<h3 id="3-4-缓存的熔断和恢复"><a href="#3-4-缓存的熔断和恢复" class="headerlink" title="3.4 缓存的熔断和恢复"></a><strong>3.4 缓存的熔断和恢复</strong></h3><p>​    </p>
<p>除了上述锁处理流程中讨论的redis抖动问题外，还需要考虑缓存服务redis集群不可用（网络问题、redis集群问题等）。按照我们的基本原则，引入的缓存服务仅做辅助，并不能强依赖。如果缓存不可用，主业务依然要保持可用，这就是我们接下来要讨论的缓存的熔断和恢复。</p>
<p>（1）缓存熔断</p>
<p>熔断的目的是在redis不可用时避免每次调用（查询或更新）都进行额外的缓存操作，这些缓存操作会进行多次尝试，比如加锁操作我们设置的自动重试3次，每次间隔50ms，总耗时会增加150ms。若redis不可用则每次调用的耗时都会有额外增加，这对主业务功能可能会产生影响，降低底层服务的质量和性能。因此我们需要识别出 redis不可用的情况，并进行熔断。</p>
<p>​    </p>
<p>我们的熔断判断逻辑为：每个redis操作都try-catch异常，并做计数统计（不区分读写操作），若在M秒内出现N次异常则开启熔断。我们的场景下设置为10秒内出现50次异常就熔断，可根据自身场景设置，需要注意的是如果redis请求次数比较少，则需要在配置上保证在M秒内至少出现N次请求。</p>
<p>此外熔断开关的配置是放在应用服务器的内存中，即单机熔断，而非集群熔断，这样做的原因是，redis服务不可用有可能是单机与redis服务的连通性问题导致，而在其他机器上依然可以访问缓存。</p>
<p>（2）缓存恢复</p>
<p>熔断之后的恢复策略相对复杂一些，需要区分缓存的读操作恢复和写操作恢复。具体如下流程如下：</p>
<p><img src="/2022/10/25/Redis-%E6%90%BA%E7%A8%8B%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E5%92%8C%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E7%BC%93%E5%AD%98%E5%AE%9E%E8%B7%B5/14.png" alt="图片"></p>
<p>step1：校验redis是否可用</p>
<p>​    </p>
<p>判断逻辑为，连续发起特定的set操作N次，每次间隔一定时间，若都成功，则认为redis恢复。</p>
<p>此处需要注意的是，我们的redis集群是Cluster模式，不同的key会散落在不同的redis主节点上，因此最保险的做法是判断当前集群中所有的主节点都恢复才认为操作恢复，而简单的做法是每次探测恢复的set操作都设置不同的key以求能尽可能散列到不同的节点去。可按照自身场景进行方案抉择。</p>
<p>step2：恢复缓存写操作</p>
<p>若redis恢复，缓存的写操作就可以恢复了。即可在更新操作中进行加锁、更新DB、删除缓存。但是此时读操作还不能立即恢复，因为redis不可用期间发生了DB变更但是缓存并没有变更，依然为老数据，因此需要将这部分老数据剔除后才能恢复读操作。</p>
<p>step3：校验挤压的cache_key_queue记录</p>
<p>轮训查看cache_key_queue表中是否有记录存在，若存在记录则认为当前有不一致的缓存数据，需要等待定时任务将暂存的key表记录对应的缓存全部删除（同时也会删除cache_key_queue表记录）。</p>
<p> step4：恢复缓存读操作</p>
<p>若当前不存在cache_key_queue记录则可恢复读操作。</p>
<p>以上阐述了redis缓存的自动熔断和恢复方案。需要明确的是，能够进行熔断是有前提条件的，即应用完全去掉缓存，DB还是可以抗住一段时间压力的，否则一旦出现缓存服务故障，流量全部走到应用，超过了应用和DB的承受能力，将服务压垮，后果更加严重。所以不能强依赖熔断机制，不能强依赖缓存，而这就需要接口限流等其他手段来从整体上保证服务的高可用。此外可进行定期压测，来锚定服务性能上限，进而不断优化对各种策略和资源的配置。</p>
<h3 id="-8"><a href="#-8" class="headerlink" title></a></h3><h3 id="3-5-总结"><a href="#3-5-总结" class="headerlink" title="3.5 总结"></a><strong>3.5 总结</strong></h3><p>以上描述了我们强一致性缓存方案的设计思路及一些实现细节。基于该方案，我们核心数据库的QPS降低了80%，缓存的命中率达到92%。而该方案的关键是通过加锁来控制读写，从表面上看会牺牲一些性能，但是实际上高缓存命中率同样弥补了此缺陷，缓存的建立使得我们服务查询接口AVG响应时间降低了10%左右。</p>
<p><img src="/2022/10/25/Redis-%E6%90%BA%E7%A8%8B%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E5%92%8C%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E7%BC%93%E5%AD%98%E5%AE%9E%E8%B7%B5/15.png" alt="图片"></p>
<h1 id="四、结语"><a href="#四、结语" class="headerlink" title="四、结语"></a><strong>四、结语</strong></h1><p>以上分别描述了我们的最终一致性和强一致性缓存设计和实现思路。两套缓存方案侧重点各有不同：</p>
<ul>
<li>最终一致性场景的基本思路是：读缓存优先，数据可以容忍暂时不一致，因此重点在及时补偿。</li>
<li>强一致性场景的基本思路是：读DB优先，缓存仅作为“DB降压”的辅助手段，在不确定缓存数据是否最新的情况下，宁可多查询几次DB，也不要查询到缓存中的不一致数据。</li>
</ul>
<p>此外，我们的最终一致性缓存方案是独立的缓存服务，而该强一致缓存方案，是需要嵌入到应用系统中去使用的。方案的选择需要立足于自身场景，希望我们的分享能够给大家带来一些启发。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存一致性</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot自动装配</title>
    <url>/2022/10/25/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</url>
    <content><![CDATA[<p>先看看SpringBoot的主配置类：</p>
<p><img src="/2022/10/25/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/30.png" alt="img"></p>
<p>里面有一个main方法运行了一个run()方法，在run方法中必须要传入一个被@SpringBootApplication注解的类。</p>
<h4 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h4><p>SpringBoot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就会运行这个类的main方法来启动SpringBoot项目。</p>
<p>那@SpringBootApplication注解到底是什么呢，点进去看看：</p>
<p><img src="/2022/10/25/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/31.png" alt="img"></p>
<p>发现@@SpringBootApplication是一个组合注解。</p>
<h4 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h4><p>先看看@SpringBootConfiguration注解：</p>
<p><img src="/2022/10/25/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/32.png" alt="img"></p>
<p>这个注解很简单，表名该类是一个Spring的配置类。</p>
<p>再进去看看@Configuration：</p>
<p><img src="/2022/10/25/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/33.png" alt="img"></p>
<p>说明Spring的配置类也是Spring的一个组件。</p>
<h4 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h4><p>这个注解是开启自动配置的功能。</p>
<p><img src="/2022/10/25/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/34.png" alt="img"></p>
<p>先看看@AutoConfigurationPackage注解：</p>
<p><img src="/2022/10/25/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/35.png" alt="img"></p>
<p>这个注解是自动配置包，主要是使用的@Import来给Spring容器中导入一个组件 ，这里导入的是Registrar.class。</p>
<p>来看下这个Registrar：</p>
<p><img src="/2022/10/25/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/36.png" alt="img"></p>
<p>就是通过这个方法获取扫描的包路径，可以debug看看：</p>
<p>在这行代码上打了一个断点：</p>
<p><img src="/2022/10/25/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/37.png" alt="img"></p>
<p>启动项目：</p>
<p>进入断点处：</p>
<p><img src="/2022/10/25/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/38.png" alt="img"></p>
<p>看看能否获取扫描的包路径：</p>
<p><img src="/2022/10/25/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/39.png" alt="img"></p>
<p>已经获取到了包路径：</p>
<p><img src="/2022/10/25/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/40.png" alt="img"></p>
<p>那那个metadata是什么呢：</p>
<p>可以看到是标注在@SpringBootApplication注解上的DemosbApplication，也就是我们的主配置类：</p>
<p><img src="/2022/10/25/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/41.png" alt="img"></p>
<p>说白了就是将主配置类（即@SpringBootApplication标注的类）的所在包及子包里面所有组件扫描加载到Spring容器。所以包名一定要注意。</p>
<p>现在包扫描路径获取到了，那具体加载哪些组件呢，看看下面这个注解。</p>
<h3 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import({AutoConfigurationImportSelector.class})"></a>@Import({AutoConfigurationImportSelector.class})</h3><p><img src="/2022/10/25/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/42.png" alt="img"></p>
<p>@Import注解就是给Spring容器中导入一些组件，这里传入了一个组件的选择器:AutoConfigurationImportSelector。</p>
<p>里面有一个selectImports方法，将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中。</p>
<p><img src="/2022/10/25/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/43.png" alt="img"></p>
<p>debug运行看看：</p>
<p>会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件:</p>
<p><img src="/2022/10/25/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/45.png" alt="img"></p>
<p><img src="/2022/10/25/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/44.png" alt="img"></p>
<p>有了自动配置类，免去了我们手动编写配置注入功能组件等的工作。</p>
<p>那他是如何获取到这些配置类的呢，看看上面这个方法：</p>
<p><img src="/2022/10/25/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/46.png" alt="img"></p>
<p><img src="/2022/10/25/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/47.png" alt="img"></p>
<p><img src="https://img-blog.csdn.net/20180630150230910?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RvbmdndWFiYWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>会从META-INF&#x2F;spring.factories中获取资源，然后通过Properties加载资源：</p>
<p><img src="/2022/10/25/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/48.png" alt="img">Spring Boot在启动的时候从类路径下的META-INF&#x2F;spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作。以前我们需要自己配置的东西，自动配置类都帮我们完成了。</p>
<p><img src="/2022/10/25/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/49.png" alt="img"></p>
<p>J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-2.0.3.RELEASE.jar：</p>
<p><img src="/2022/10/25/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/50.png" alt="img"></p>
<p><img src="/2022/10/25/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/51.png" alt="img"></p>
<p>比如看看WebMvcAutoConfiguration：</p>
<p>都已经帮我们配置好了，我们不用再单独配置了：</p>
<p><img src="/2022/10/25/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/52.png" alt="img"></p>
<h1 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h1><p>首先Spring Boot项目中都会如下启动类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        SpringApplication.run(Application.class, args);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>从上面代码可以看出，注解<code>@SpringBootApplication</code>和<code>SpringApplication.run()</code>方法是最为重要的部分。这里主要来看看<code>@SpringBootApplication</code>注解部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    excludeFilters = &#123;@Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;TypeExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">), @Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">)&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然定义使用了多个Annotation进行了原信息标注，但实际上重要的只有三个Annotation：</p>
<p>@Configuration（@SpringBootConfiguration点开查看发现里面还是应用了@Configuration）<br>@EnableAutoConfiguration<br>@ComponentScan<br>如果在启动类使用这个三个注解，整个SpringBoot应用依然可以与之前的启动类功能一样。但每次写这3个比较啰嗦，所以写一个@SpringBootApplication方便点。</p>
<p>这三个注解中@Configuration和@ComponentScan对我们来说并不陌生，今天我们的主角是<code>@EnableAutoConfiguration</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="operator">=</span> <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中最关键的要属<code>@Import(AutoConfigurationImportSelector.class)</code>，借助<code>AutoConfigurationImportSelector</code>，<code>@EnableAutoConfiguration</code>可以帮助SpringBoot应用将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器。</p>
<p>借助于Spring框架原有的一个工具类：<code>SpringFactoriesLoader</code>的支持，<code>@EnableAutoConfiguration</code>可以智能的自动配置功效才得以大功告成！</p>
<p>在<code>AutoConfigurationImportSelector</code>类中可以看到通过<code> SpringFactoriesLoader.loadFactoryNames()</code><br>把 spring-boot-autoconfigure.jar&#x2F;META-INF&#x2F;spring.factories中每一个xxxAutoConfiguration文件都加载到容器中，spring.factories文件里每一个xxxAutoConfiguration文件一般都会有下面的条件注解:</p>
<p>@ConditionalOnClass ： classpath中存在该类时起效<br>@ConditionalOnMissingClass ： classpath中不存在该类时起效<br>@ConditionalOnBean ： DI容器中存在该类型Bean时起效<br>@ConditionalOnMissingBean ： DI容器中不存在该类型Bean时起效<br>@ConditionalOnSingleCandidate ： DI容器中该类型Bean只有一个或@Primary的只有一个时起效<br>@ConditionalOnExpression ： SpEL表达式结果为true时<br>@ConditionalOnProperty ： 参数设置或者值一致时起效<br>@ConditionalOnResource ： 指定的文件存在时起效<br>@ConditionalOnJndi ： 指定的JNDI存在时起效<br>@ConditionalOnJava ： 指定的Java版本存在时起效<br>@ConditionalOnWebApplication ： Web应用环境下起效<br>@ConditionalOnNotWebApplication ： 非Web应用环境下起效</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">...</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<p><strong>SpringFactoriesLoader</strong><br>SpringFactoriesLoader属于Spring框架私有的一种扩展方案(类似于Java的SPI方案java.util.ServiceLoader)，其主要功能就是从指定的配置文件<code>META-INF/spring-factories</code>加载配置，spring-factories是一个典型的java properties文件，只不过Key和Value都是Java类型的完整类名，比如：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">example.MyService</span>=<span class="string">example.MyServiceImpl1,example.MyServiceImpl2</span></span><br></pre></td></tr></table></figure>

<p>对于<code>@EnableAutoConfiguration</code>来说，SpringFactoriesLoader的用途稍微不同一些，其本意是为了提供SPI扩展的场景，而在<code>@EnableAutoConfiguration</code>场景中，它更多提供了一种配置查找的功能支持，即根据@EnableAutoConfiguration的完整类名<code>org.springframework.boot.autoconfig.EnableAutoConfiguration</code>作为查找的Key，获得对应的一组<code>@Configuration</code>类。</p>
<p>SpringFactoriesLoader是一个抽象类，类中定义的静态属性定义了其加载资源的路径<code>public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;</code>，此外还有三个静态方法：</p>
<p>loadFactories：加载指定的factoryClass并进行实例化。<br>loadFactoryNames：加载指定的factoryClass的名称集合。<br>instantiateFactory：对指定的factoryClass进行实例化。<br>在loadFactories方法中调用了loadFactoryNames以及instantiateFactory方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">loadFactories</span><span class="params">(Class&lt;T&gt; factoryClass, ClassLoader classLoader)</span> &#123;</span><br><span class="line">   Assert.notNull(factoryClass, <span class="string">&quot;&#x27;factoryClass&#x27; must not be null&quot;</span>);</span><br><span class="line">   <span class="type">ClassLoader</span> <span class="variable">classLoaderToUse</span> <span class="operator">=</span> classLoader;</span><br><span class="line">   <span class="keyword">if</span> (classLoaderToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">      classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();</span><br><span class="line">   &#125;</span><br><span class="line">   List&lt;String&gt; factoryNames = loadFactoryNames(factoryClass, classLoaderToUse);</span><br><span class="line">   <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">&quot;Loaded [&quot;</span> + factoryClass.getName() + <span class="string">&quot;] names: &quot;</span> + factoryNames);</span><br><span class="line">   &#125;</span><br><span class="line">   List&lt;T&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;T&gt;(factoryNames.size());</span><br><span class="line">   <span class="keyword">for</span> (String factoryName : factoryNames) &#123;</span><br><span class="line">      result.add(instantiateFactory(factoryName, factoryClass, classLoaderToUse));</span><br><span class="line">   &#125;</span><br><span class="line">   AnnotationAwareOrderComparator.sort(result);</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>loadFactories方法首先获取类加载器，然后调用<code>loadFactoryNames</code>方法获取所有的指定资源的名称集合、接着调用instantiateFactory方法实例化这些资源类并将其添加到result集合中。最后调用<code>AnnotationAwareOrderComparator.sort</code>方法进行集合的排序。</p>
<p><strong>一个例子</strong></p>
<p>上面介绍了很多原理的知识，下面结合一个例子来加深理解，例子展示的是当项目启动时如果某个类存在就自动配置这个Bean，并且这个属性可以在application.properties中配置</p>
<p>新建一个Maven项目,pom.xml文件如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.chm.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>spring-boot-starter-hello<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- FIXME change it to the project&#x27;s website --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.example.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>项目目录结构如下：</p>
<p><img src="/2022/10/25/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/27.png" alt="这里写图片描述"></p>
<p>Hello.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>HelloProperties.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;hello&quot;)</span> <span class="comment">//获取属性值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MSG</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> MSG ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HelloAutoConfiguration.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//为带有@ConfigurationProperties注解的Bean提供有效的支持。</span></span><br><span class="line"><span class="comment">// 这个注解可以提供一种方便的方式来将带有@ConfigurationProperties注解的类注入为Spring容器的Bean。</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(HelloProperties.class)</span><span class="comment">//开启属性注入,通过@autowired注入</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(Hello.class)</span><span class="comment">//判断这个类是否在classpath中存在，如果存在，才会实例化一个Bean</span></span><br><span class="line"><span class="comment">// The Hello bean will be created if the hello.enable property exists and has a value other than false</span></span><br><span class="line"><span class="comment">// or the property doesn&#x27;t exist at all.</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix=&quot;hello&quot;, value=&quot;enabled&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloProperties helloProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(Hello.class)</span><span class="comment">//容器中如果没有Hello这个类,那么自动配置这个Hello</span></span><br><span class="line">    <span class="keyword">public</span> Hello <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hello</span>();</span><br><span class="line">        hello.setMsg(helloProperties.getMsg());</span><br><span class="line">        <span class="keyword">return</span> hello;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>spring.factories</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">com.chm.test.HelloAutoConfiguration</span></span><br></pre></td></tr></table></figure>

<p>最后使用<code>mvn package</code>将上面项目打包，使用<code>mvn install:install-file</code>命令将打包文件上传到本地Maven仓库进行测试。下面再新建一个Maven项目用于测试。</p>
<p>pom.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.chm.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>test-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>test-starter<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- FIXME change it to the project&#x27;s website --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.example.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">boot.version</span>&gt;</span>2.0.4.RELEASE<span class="tag">&lt;/<span class="name">boot.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.chm.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>App.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Hello hello;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hello.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(App.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>application.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#可以不配置</span></span><br><span class="line"><span class="attr">hello.enabled</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">hello.msg</span>=<span class="string">charmingfst</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#以debug模式运行</span></span><br><span class="line"><span class="attr">debug</span>=<span class="string">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以debug模式运行，可以看到我们的配置：</p>
<p><img src="/2022/10/25/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/28.png" alt="这里写图片描述"></p>
<p>启动项目，打开浏览器，运行结果如下：</p>
<p><img src="/2022/10/25/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/29.png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>框架源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis知识点总结</title>
    <url>/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="1-在分布式数据库中CAP原理CAP-BASE"><a href="#1-在分布式数据库中CAP原理CAP-BASE" class="headerlink" title="1.在分布式数据库中CAP原理CAP+BASE"></a>1.在分布式数据库中CAP原理CAP+BASE</h1><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:Consistency（强一致性）</span><br><span class="line"></span><br><span class="line">A:Availability（可用性）</span><br><span class="line"></span><br><span class="line">P:Partition tolerance（分区容错性）</span><br><span class="line"></span><br><span class="line">注意：分布式架构的时候必须做出取舍。</span><br><span class="line">一致性和可用性之间取一个平衡。多余大多数web应用，其实并不需要强一致性。因此牺牲C换取P，这是目前分布式数据库产品的方向</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="经典CAP图"><a href="#经典CAP图" class="headerlink" title="经典CAP图"></a>经典CAP图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，</span><br><span class="line">最多只能同时较好的满足两个。</span><br><span class="line">因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三大类：</span><br><span class="line">CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。</span><br><span class="line">CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。</span><br><span class="line">AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/1.png" alt="在这里插入图片描述"></p>
<h3 id="Base"><a href="#Base" class="headerlink" title="Base"></a>Base</h3><p>BASE就是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。</p>
<p>BASE其实是下面三个术语的缩写：<br>    基本可用（Basically Available）<br>    软状态（Soft state）<br>    最终一致（Eventually consistent）</p>
<p>它的思想是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观。为什么这么说呢，缘由就在于大型系统往往由于地域分布和极高性能的要求，不可能采用分布式事务来完成这些指标，要想获得这些指标，我们必须采用另外一种方式来完成，这里BASE就是解决这个问题的办法</p>
<h3 id="分布式-集群简介"><a href="#分布式-集群简介" class="headerlink" title="分布式+集群简介"></a>分布式+集群简介</h3><p>分布式系统</p>
<p>分布式系统（distributed system）<br> 由多台计算机和通信的软件组件通过计算机网络连接（本地网络或广域网）组成。分布式系统是建立在网络之上的软件系统。正是因为软件的特性，所以分布式系统具有高度的内聚性和透明性。因此，网络和分布式系统之间的区别更多的在于高层软件（特别是操作系统），而不是硬件。分布式系统可以应用在在不同的平台上如：Pc、工作站、局域网和广域网上等。</p>
<p>简单来讲：<br>1分布式：不同的多台服务器上面部署不同的服务模块（工程），他们之间通过Rpc&#x2F;Rmi之间通信和调用，对外提供服务和组内协作。</p>
<p>2集群：不同的多台服务器上面部署相同的服务模块，通过分布式调度软件进行统一的调度，对外提供服务和访问。</p>
<h1 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h1><table>
<thead>
<tr>
<th>数据类型</th>
<th>可以存储的值</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>STRING</td>
<td>字符串、整数或者浮点数</td>
<td>对整个字符串或者字符串的其中一部分执行操作对整数和浮点数执行自增或者自减操作</td>
</tr>
<tr>
<td>LIST</td>
<td>列表</td>
<td>从两端压入或者弹出元素对单个或者多个元素进行修剪，只保留一个范围内的元素</td>
</tr>
<tr>
<td>SET</td>
<td>无序集合</td>
<td>添加、获取、移除单个元素，检查一个元素是否存在于集合中，计算交集、并集、差集，从集合里面随机获取元素</td>
</tr>
<tr>
<td>HASH</td>
<td>包含键值对的无序散列表</td>
<td>添加、获取、移除单个键值对，获取所有键值对，检查某个键是否存在</td>
</tr>
<tr>
<td>ZSET</td>
<td>有序集合</td>
<td>添加、获取、删除元素，根据分值范围或者成员来获取元素，计算一个键的排名</td>
</tr>
</tbody></table>
<h3 id="Redis字符串-String"><a href="#Redis字符串-String" class="headerlink" title="Redis字符串(String)"></a>Redis字符串(String)</h3><h4 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h4><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/2.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411163156202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">set/get/del/append/strlen</span><br><span class="line"></span><br><span class="line">Incr/decr/incrby/decrby,一定要是数字才能进行加减</span><br><span class="line"></span><br><span class="line">getrange/setrange</span><br></pre></td></tr></table></figure>

<p>getrange:获取指定区间范围内的值，类似between……and的关系<br>从零到负一表示全部</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/3.png" alt="在这里插入图片描述"></p>
<p>setrange设置指定区间范围内的值，格式是setrange key值 具体值</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/4.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setex(set with expire)键秒值/setnx(set if not exist)</span><br></pre></td></tr></table></figure>

<p>setex:设置带过期时间的key，动态设置。<br>setex 键 秒值 真实值</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/5.png" alt="在这里插入图片描述"></p>
<p>setnx:只有在 key 不存在时设置 key 的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mset/mget/msetnx</span><br></pre></td></tr></table></figure>

<p>mset:同时设置一个或多个 key-value 对。</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/6.png" alt="在这里插入图片描述"></p>
<p>mget:获取所有(一个或多个)给定 key 的值。</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/7.png" alt="在这里插入图片描述"></p>
<p>msetnx:同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/8.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getset(先get再set)</span><br></pre></td></tr></table></figure>

<p>getset:将给定 key 的值设为 value ，并返回 key 的旧值(old value)。<br>简单一句话，先get然后立即set</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/9.png" alt="在这里插入图片描述"></p>
<h3 id="Redis列表-List"><a href="#Redis列表-List" class="headerlink" title="Redis列表(List)"></a>Redis列表(List)</h3><h4 id="常用-1"><a href="#常用-1" class="headerlink" title="常用"></a>常用</h4><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/10.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210411163635194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjQ0NDk1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lpush/rpush/lrange</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lpop/rpop</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/11.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lindex，按照索引下标获得元素(从上到下)</span><br></pre></td></tr></table></figure>

<p>通过索引获取列表中的元素 lindex key index</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/12.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">llen</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lrem key 删N个value</span><br></pre></td></tr></table></figure>

<ul>
<li>从left往right删除2个值等于v1的元素，返回的值为实际删除的数量</li>
<li>LREM list3 0 值，表示删除全部给定的值。零个就是全部值</li>
</ul>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/13.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ltrim key 开始index 结束index，截取指定范围的值后再赋值给key</span><br></pre></td></tr></table></figure>

<p>ltrim：截取指定索引区间的元素，格式是ltrim list的key 起始索引 结束索引</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/14.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpoplpush 源列表 目的列表</span><br></pre></td></tr></table></figure>

<p>移除列表的最后一个元素，并将该元素添加到另一个列表并返回</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/15.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lset key index value</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/16.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">linsert key  before/after 值1 值2</span><br></pre></td></tr></table></figure>

<p>在list某个已有值的前后再添加具体值</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/17.png" alt="在这里插入图片描述"></p>
<h3 id="Redis集合-Set"><a href="#Redis集合-Set" class="headerlink" title="Redis集合(Set)"></a>Redis集合(Set)</h3><h4 id="常用-2"><a href="#常用-2" class="headerlink" title="常用"></a>常用</h4><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/18.png" alt="在这里插入图片描述"></p>
<h4 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sadd/smembers/sismember</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/19.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scard，获取集合里面的元素个数</span><br></pre></td></tr></table></figure>

<p>获取集合里面的元素个数</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/20.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">srem key value 删除集合中元素</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/21.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">srandmember key 某个整数(随机出几个数)</span><br></pre></td></tr></table></figure>

<ul>
<li>从set集合里面随机取出2个</li>
<li>如果超过最大数量就全部取出，</li>
<li>如果写的值是负数，比如-3 ，表示需要取出3个，但是可能会有重复值。</li>
</ul>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/22.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spop key 随机出栈</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/23.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">smove key1 key2 在key1里某个值      作用是将key1里的某个值赋给key2</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/24.png" alt="在这里插入图片描述"></p>
<h4 id="数学集合类"><a href="#数学集合类" class="headerlink" title="数学集合类"></a>数学集合类</h4><h5 id="差集：sdiff"><a href="#差集：sdiff" class="headerlink" title="差集：sdiff"></a>差集：sdiff</h5><p>在第一个set里面而不在后面任何一个set里面的项</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/25.png" alt="在这里插入图片描述"></p>
<h5 id="交集：sinter"><a href="#交集：sinter" class="headerlink" title="交集：sinter"></a>交集：sinter</h5><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/26.png" alt="在这里插入图片描述"></p>
<h5 id="并集：sunion"><a href="#并集：sunion" class="headerlink" title="并集：sunion"></a>并集：sunion</h5><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/27.png" alt="在这里插入图片描述"></p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/28.png" alt="在这里插入图片描述"></p>
<h3 id="Redis哈希-Hash"><a href="#Redis哈希-Hash" class="headerlink" title="Redis哈希(Hash)"></a>Redis哈希(Hash)</h3><h4 id="常用-3"><a href="#常用-3" class="headerlink" title="常用"></a>常用</h4><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/29.png" alt="在这里插入图片描述"></p>
<h4 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hset/hget/hmset/hmget/hgetall/hdel</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/30.png" alt="在这里插入图片描述"></p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/31.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hlen</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexists key 在key里面的某个值的key</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hkeys/hvals</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/32.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hincrby/hincrbyfloat</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/33.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hsetnx</span><br></pre></td></tr></table></figure>

<p>不存在赋值，存在了无效</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/34.png" alt="在这里插入图片描述"></p>
<h3 id="Redis有序集合Zset-sorted-set"><a href="#Redis有序集合Zset-sorted-set" class="headerlink" title="Redis有序集合Zset(sorted set)"></a>Redis有序集合Zset(sorted set)</h3><h4 id="常用-4"><a href="#常用-4" class="headerlink" title="常用"></a>常用</h4><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/35.png" alt="在这里插入图片描述"></p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/36.png" alt="在这里插入图片描述"></p>
<h4 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zadd/zrange</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zrangebyscore key 开始score 结束score</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/37.png" alt="在这里插入图片描述"></p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/38.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zrem key 某score下对应的value值，作用是删除元素</span><br></pre></td></tr></table></figure>


<p>删除元素，格式是zrem zset的key 项的值，项的值可以是多个zrem key score某个对应值，可以是多个值</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/39.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zcard/zcount key score区间/zrank key values值，作用是获得下标值/zscore key 对应值,获得分数</span><br></pre></td></tr></table></figure>

<h5 id="zcard-：获取集合中元素个数"><a href="#zcard-：获取集合中元素个数" class="headerlink" title="zcard ：获取集合中元素个数"></a>zcard ：获取集合中元素个数</h5><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/40.png" alt="在这里插入图片描述"></p>
<h5 id="zcount-：获取分数区间内元素个数，zcount-key-开始分数区间-结束分数区间"><a href="#zcount-：获取分数区间内元素个数，zcount-key-开始分数区间-结束分数区间" class="headerlink" title="zcount ：获取分数区间内元素个数，zcount key 开始分数区间 结束分数区间"></a>zcount ：获取分数区间内元素个数，zcount key 开始分数区间 结束分数区间</h5><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/41.png" alt="在这里插入图片描述"></p>
<h5 id="zrank：-获取value在zset中的下标位置"><a href="#zrank：-获取value在zset中的下标位置" class="headerlink" title="zrank： 获取value在zset中的下标位置"></a>zrank： 获取value在zset中的下标位置</h5><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/42.png" alt="在这里插入图片描述"></p>
<h5 id="zscore：按照值获得对应的分数"><a href="#zscore：按照值获得对应的分数" class="headerlink" title="zscore：按照值获得对应的分数"></a>zscore：按照值获得对应的分数</h5><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/43.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zrevrank key values值，作用是逆序获得下标值</span><br></pre></td></tr></table></figure>

<p>正序、逆序获得下标索引值</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/44.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zrevrange</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/45.png" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zrevrangebyscore  key 结束score 开始score</span><br></pre></td></tr></table></figure>

<p>zrevrangebyscore zset1 90 60 withscores    分数是反着来的</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/46.png" alt="在这里插入图片描述"></p>
<h2 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h2><h3 id="1、Geospatial-地理位置"><a href="#1、Geospatial-地理位置" class="headerlink" title="1、Geospatial 地理位置"></a>1、Geospatial 地理位置</h3><p><strong>geoadd</strong> key 经度 纬度 城市（地点名称） </p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/47.png" alt="在这里插入图片描述"></p>
<p> 也可以一次加多个</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/48.png" alt="在这里插入图片描述"></p>
<p><strong>zrange</strong> 获得指定key中所有坐标信息</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/49.png" alt="在这里插入图片描述"></p>
<p><strong>zrem</strong> 删除指定key下指定目标的数据</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/50.png" alt="在这里插入图片描述"></p>
<p> <strong>geopos</strong> 获得指定key中指定地点的坐标</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/51.png" alt="在这里插入图片描述"></p>
<p> <strong>geodist</strong> key 第一个点 第二个点 单位 返回指定key中指定地点的距离 （单位可选 m（米）, km（千米）, ft(英尺), mi（英里））</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/52.png" alt="在这里插入图片描述"></p>
<p> <strong>GEORADIUS</strong> key 目标经度 目标纬度 查询范围 查询单位 显示范围内位置的坐标 目标坐标与范围内坐标的距离 取几条 距离排序  斜体字标识非必填参数</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/53.png" alt="在这里插入图片描述"></p>
<p><strong>GEORADIUSBYMEMBER</strong> 查询指定key中指定一个目标范围内的数据</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/54.png" alt="在这里插入图片描述"></p>
<p><strong>应用场景：</strong></p>
<p>　　附近的人，附近的美食</p>
<h3 id="2、Hyperloglog"><a href="#2、Hyperloglog" class="headerlink" title="2、Hyperloglog"></a>2、Hyperloglog</h3><p><strong>什么是基数？</strong></p>
<p>A {1,3,5,7,8,7} </p>
<p>B{1,3,5,7,8} </p>
<p>基数（不重复的元素） &#x3D; 5，可以接受误差！</p>
<p><strong>简介</strong></p>
<p>Redis 2.8.9 版本就更新了 Hyperloglog 数据结构！</p>
<p> Redis Hyperloglog 基数统计的算法！</p>
<p>优点：占用的内存是固定，2^64 不同的元素的技术，只需要废 12KB内存！如果要从内存角度来比较的 话 Hyperloglog 首选！ 网页的 UV （一个人访问一个网站多次，但是还是算作一个人！）</p>
<p> 传统的方式， set 保存用户的id，然后就可以统计 set 中的元素数量作为标准判断 ! </p>
<p>这个方式如果保存大量的用户id，就会比较麻烦！我们的目的是为了计数，而不是保存用户id； </p>
<p>0.81% 错误率！ 统计UV任务，可以忽略不计的！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PFadd mykey a b c d e f g h i j # 创建第一组元素 mykey</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT mykey # 统计 mykey 元素的基数数量</span><br><span class="line">(integer) 10</span><br><span class="line">127.0.0.1:6379&gt; PFadd mykey2 i j z x c v b n m # 创建第二组元素 mykey2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT mykey2</span><br><span class="line">(integer) 9</span><br><span class="line">127.0.0.1:6379&gt; PFMERGE mykey3 mykey mykey2 # 合并两组 mykey mykey2 =&gt; mykey3 并集</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT mykey3 # 看并集的数量！</span><br><span class="line">(integer) 15</span><br></pre></td></tr></table></figure>

<p>如果允许容错，那么一定可以使用 Hyperloglog ！</p>
<p>如果不允许容错，就使用 set 或者自己的数据类型即可！</p>
<h3 id="3、Bitmap"><a href="#3、Bitmap" class="headerlink" title="3、Bitmap"></a>3、Bitmap</h3><p>统计用户信息，活跃，不活跃！ 登录 、 未登录！ 打卡，365打卡！ 两个状态的，都可以使用</p>
<p>Bitmap 位图，数据结构！ 都是操作二进制位来进行记录，就只有0 和 1 两个状态！</p>
<p>365 天 &#x3D; 365 bit 1字节 &#x3D; 8bit 46 个字节左右！</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/55.png" alt="在这里插入图片描述"></p>
<p>使用bitmap 来记录 周一到周日的打卡！</p>
<p>周一：1 周二：0 周三：0 周四：1 ……</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/56.png" alt="在这里插入图片描述"></p>
<p>查看某一天是否有打卡！</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getbit sign 3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 6</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<p>统计操作，统计 打卡的天数！</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitcount sign <span class="comment"># 统计这周的打卡记录，就可以看到是否有全勤！</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>



<h1 id="3-谈下你对-Redis-的了解？"><a href="#3-谈下你对-Redis-的了解？" class="headerlink" title="3.谈下你对 Redis 的了解？"></a>3.谈下你对 Redis 的了解？</h1><p>Redis（全称：Remote Dictionary Server 远程字典服务）是一个开源的使用 ANSIC 语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API。</p>
<h1 id="4-Redis-一般都有哪些使用场景？"><a href="#4-Redis-一般都有哪些使用场景？" class="headerlink" title="4.Redis 一般都有哪些使用场景？"></a>4.Redis 一般都有哪些使用场景？</h1><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/57.png" alt="在这里插入图片描述"></p>
<h5 id="Redis-适合的场景"><a href="#Redis-适合的场景" class="headerlink" title="Redis 适合的场景"></a>Redis 适合的场景</h5><p>1.缓存：减轻 MySQL 的查询压力，提升系统性能；</p>
<p>2.排行榜：利用 Redis 的 SortSet（有序集合）实现；<br>3.计算器&#x2F;限速器：利用 Redis 中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等。这类操作如果用 MySQL，频繁的读写会带来相当大的压力；限速器比较典型的使用场景是限制某个用户访问某个 API 的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力；<br>4.好友关系：利用集合的一些命令，比如求交集、并集、差集等。可以方便解决一些共同好友、共同爱好之类的功能；</p>
<p>5.消息队列：除了 Redis 自身的发布&#x2F;订阅模式，我们也可以利用 List 来实现一个队列机制，比如：到货通知、邮件发送之类的需求，不需	要高可靠，但是会带来非常大的 DB 压力，完全可以用 List 来完成异步解耦；</p>
<p>6.Session 共享：Session 是保存在服务器的文件中，如果是集群服务，同一个用户过来	可能落在不同机器上，这就会导致用户频繁登陆；采用 Redis 保存 Session 后，无论用户落在那台机器上都能够获取到对应的 Session 信息。</p>
<h5 id="Redis-不适合的场景"><a href="#Redis-不适合的场景" class="headerlink" title="Redis 不适合的场景"></a>Redis 不适合的场景</h5><p>数据量太大、数据访问频率非常低的业务都不适合使用 Redis，数据太大会增加成本，访问频率太低，保存在内存中纯属浪费资源。</p>
<h1 id="5-Redis-为什么是单线程的？"><a href="#5-Redis-为什么是单线程的？" class="headerlink" title="5.Redis 为什么是单线程的？"></a>5.Redis 为什么是单线程的？</h1><p>官方 FAQ 表示，因为 Redis 是基于内存的操作，CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章地采用单线程的方案了，毕竟采用多线程会有很多麻烦。</p>
<h1 id="6-Redis-为什么这么快？"><a href="#6-Redis-为什么这么快？" class="headerlink" title="6.Redis 为什么这么快？"></a>6.Redis 为什么这么快？</h1><p>1.完全基于内存，绝大部分请求是纯粹的内存操作，非常快速；</p>
<p>2.数据结构简单，对数据操作也简单；</p>
<p>3.采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；<br>4.使用多路 I&#x2F;O 复用模型，非阻塞 IO。</p>
<h1 id="7-什么是缓存穿透？怎么解决？"><a href="#7-什么是缓存穿透？怎么解决？" class="headerlink" title="7.什么是缓存穿透？怎么解决？"></a>7.什么是缓存穿透？怎么解决？</h1><p>缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。</p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>1.缓存空对象：如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p>
<p>缓存空对象带来的问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.空值做了缓存，意味着缓存中存了更多的键，需要更多的内存空间，比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。</span><br><span class="line">2.缓存和存储的数据会有一段时间窗口的不一致，可能会对业务有一定影响。例如:过期时间设置为 5分钟，如果此时存储添加了这个数据，那此段时间就会出现缓存和存储数据的不一致，此时可以利用消息系统或者其他方式清除掉缓存层中的空对象。</span><br></pre></td></tr></table></figure>

<p>2.布隆过滤器：将db中所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。</p>
<h1 id="8-什么是缓存雪崩？该如何解决？"><a href="#8-什么是缓存雪崩？该如何解决？" class="headerlink" title="8.什么是缓存雪崩？该如何解决？"></a>8.什么是缓存雪崩？该如何解决？</h1><pre><code>如果缓存集中在一段时间内失效，发生大量的缓存穿透，所有的查询都落在数据库上，造成了缓存雪崩。
</code></pre>
<h4 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h4><p>1.加锁排队：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量.比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待；</p>
<p>2.数据预热：可以通过缓存 reload 机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存不同的 key，设置不同的过期时间，让缓存失效的时间点尽量		均匀；</p>
<p>3.做二级缓存，或者双缓存策略：Cache1 为原始缓存，Cache2 为拷贝缓存，Cache1 失效时，可以访问 Cache2，Cache1 缓存失效时间设置为短期，Cache2 设置为长期。</p>
<p>4.在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。</p>
<h1 id="9-什么是缓存击穿？该如何解决？"><a href="#9-什么是缓存击穿？该如何解决？" class="headerlink" title="9.什么是缓存击穿？该如何解决？"></a>9.什么是缓存击穿？该如何解决？</h1><p>对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。</p>
<p>缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p>
<p><strong>解决方案</strong><br><strong>1.使用互斥锁(mutex key)</strong><br>业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。</p>
<p>SETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果。在redis2.6.1之前版本未实现setnx的过期时间，所以这里给出两种版本代码参考：</p>
<p>&#x2F;&#x2F;2.6.1前单机版本锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">get</span><span class="params">(String key)</span> &#123;  </span><br><span class="line">   <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> redis.get(key);  </span><br><span class="line">   <span class="keyword">if</span> (value  == <span class="literal">null</span>) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (redis.setnx(key_mutex, <span class="string">&quot;1&quot;</span>)) &#123;  </span><br><span class="line">        <span class="comment">// 3 min timeout to avoid mutex holder crash  </span></span><br><span class="line">        redis.expire(key_mutex, <span class="number">3</span> * <span class="number">60</span>)  </span><br><span class="line">        value = db.get(key);  </span><br><span class="line">        redis.set(key, value);  </span><br><span class="line">        redis.delete(key_mutex);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">//其他线程休息50毫秒后重试  </span></span><br><span class="line">        Thread.sleep(<span class="number">50</span>);  </span><br><span class="line">        get(key);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最新版本代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(key)</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> redis.get(key);</span><br><span class="line">      <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123; <span class="comment">//代表缓存值过期</span></span><br><span class="line">          <span class="comment">//设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</span></span><br><span class="line">		  <span class="keyword">if</span> (redis.setnx(key_mutex, <span class="number">1</span>, <span class="number">3</span> * <span class="number">60</span>) == <span class="number">1</span>) &#123;  <span class="comment">//代表设置成功</span></span><br><span class="line">               value = db.get(key);</span><br><span class="line">                      redis.set(key, value, expire_secs);</span><br><span class="line">                      redis.del(key_mutex);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;  <span class="comment">//这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可</span></span><br><span class="line">                      sleep(<span class="number">50</span>);</span><br><span class="line">                      get(key);  <span class="comment">//重试</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> value;      </span><br><span class="line">          &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="9-怎么保证缓存和数据库数据的一致性？"><a href="#9-怎么保证缓存和数据库数据的一致性？" class="headerlink" title="9.怎么保证缓存和数据库数据的一致性？"></a>9.怎么保证缓存和数据库数据的一致性？</h1><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/58.png" alt="在这里插入图片描述"></p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/59.png" alt="在这里插入图片描述"></p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/60.png" alt="在这里插入图片描述"></p>
<h1 id="10-Redis-持久化有几种方式？"><a href="#10-Redis-持久化有几种方式？" class="headerlink" title="10.Redis 持久化有几种方式？"></a>10.Redis 持久化有几种方式？</h1><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。Redis 提供了两种持久化方式：RDB（默认） 和 AOF。</p>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>RDB 是 Redis DataBase 的缩写。按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件。即 Snapshot 快照存储，对应产生的数据文件为 dump.rdb，通过配置文件中的 save 参数来定义快照的周期。核心函数：rdbSave（生成 RDB 文件）和 rdbLoad（从文件加载内存）两个函数<img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/61.png" alt="在这里插入图片描述"></p>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>AOF 是 Append-only file 的缩写。Redis会将每一个收到的写命令都通过 Write 函数追加到文件最后，类似于 MySQL 的 binlog。当 Redis 重启是会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。每当执行服务器（定时）任务或者函数时，flushAppendOnlyFile 函数都会被调用， 这个函数执行以下两个工作：</p>
<p>WRITE：根据条件，将 aof_buf 中的缓存写入到 AOF 文件；</p>
<p>SAVE：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中。</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/62.png" alt="在这里插入图片描述"></p>
<h4 id="RDB-和-AOF-的区别："><a href="#RDB-和-AOF-的区别：" class="headerlink" title="RDB 和 AOF 的区别："></a>RDB 和 AOF 的区别：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.AOF 文件比 RDB 更新频率高，优先使用 AOF 还原数据；</span><br><span class="line"></span><br><span class="line">2.AOF比 RDB 更安全也更大；</span><br><span class="line"></span><br><span class="line">3.RDB 性能比 AOF 好；</span><br><span class="line"></span><br><span class="line">4.如果两个都配了优先加载 AOF。</span><br></pre></td></tr></table></figure>

<h1 id="12-Redis-淘汰策略有哪些？"><a href="#12-Redis-淘汰策略有哪些？" class="headerlink" title="12.Redis 淘汰策略有哪些？"></a>12.Redis 淘汰策略有哪些？</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰；</span><br><span class="line"></span><br><span class="line">2.volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。</span><br><span class="line"></span><br><span class="line">3.allkeys-lru：从数据集中挑选最近最少使用的数据淘汰。</span><br><span class="line"></span><br><span class="line">4.allkeys-random：从数据集中任意选择数据淘汰。</span><br><span class="line"></span><br><span class="line">5.volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰。</span><br><span class="line"></span><br><span class="line">6.no-enviction（驱逐）：禁止驱逐数据。</span><br></pre></td></tr></table></figure>

<h1 id="13-Redis的原子性如何保证"><a href="#13-Redis的原子性如何保证" class="headerlink" title="13.Redis的原子性如何保证"></a>13.Redis的原子性如何保证</h1><p>对于Redis而言，命令的原子性指的是：一个操作不可再分，操作要么执行要么不执行，Redis之所以是原子的，是因为Redis是单线程的。</p>
<p>Redis所有单个命令的执行都是原子的，Redis是实现事务的原理：</p>
<p>1.批量操作在发送EXEC（执行）命令前被放入队列缓存；</p>
<p>2.收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令都不会被执行；</p>
<p>3.在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>
<h1 id="14-Redis-有哪些架构模式讲讲各自的特点"><a href="#14-Redis-有哪些架构模式讲讲各自的特点" class="headerlink" title="14.Redis 有哪些架构模式讲讲各自的特点"></a>14.Redis 有哪些架构模式讲讲各自的特点</h1><h3 id="单机版"><a href="#单机版" class="headerlink" title="单机版"></a>单机版</h3><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/63.png" alt="在这里插入图片描述"></p>
<p>特点：简单</p>
<p>问题：</p>
<p>1、内存容量有限 2、处理能力有限 3、无法高可用。</p>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/64.png" alt="在这里插入图片描述"></p>
<p>Redis 的复制（replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器（master），而通过复制创建出来的服务器复制品则为从服务器（slave）。 只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，主服务器就会一直将发生在自己身上的数据更新同步 给从服务器，从而一直保证主从服务器的数据相同。</p>
<p>特点：</p>
<p>1、master&#x2F;slave 角色</p>
<p>2、master&#x2F;slave 数据相同</p>
<p>3、降低 master 读压力在转交从库</p>
<p>问题：</p>
<p>无法保证高可用</p>
<p>没有解决 master 写的压力</p>
<h3 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h3><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/65.png" alt="在这里插入图片描述"></p>
<p>Redis sentinel 是一个分布式系统中监控 redis 主从服务器，并在主服务器下线时自动进行故障转移。其中三个特性：</p>
<p>监控（Monitoring）：  Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</p>
<p>提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</p>
<p>自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作。</p>
<p>特点：</p>
<p>1、保证高可用</p>
<p>2、监控各个节点</p>
<p>3、自动故障迁移</p>
<p>缺点：主从模式，切换需要时间丢数据</p>
<p>没有解决 master 写的压力</p>
<h3 id="集群（proxy-型）"><a href="#集群（proxy-型）" class="headerlink" title="集群（proxy 型）"></a>集群（proxy 型）</h3><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/66.png" alt="在这里插入图片描述"></p>
<p>Twemproxy 是一个 Twitter 开源的一个 redis 和 memcache 快速&#x2F;轻量级代理服务器； Twemproxy 是一个快速的单线程代理程序，支持 Memcached ASCII 协议和 redis 协议。</p>
<p>特点：1、多种 hash 算法：MD5、CRC16、CRC32、CRC32a、hsieh、murmur、Jenkins </p>
<p>2、支持失败节点自动删除</p>
<p>3、后端 Sharding 分片逻辑对业务透明，业务方的读写方式和操作单个 Redis 一致</p>
<p>缺点：增加了新的 proxy，需要维护其高可用。</p>
<p>failover 逻辑需要自己实现，其本身不能支持故障的自动转移可扩展性差，进行扩缩容都需要手动干预</p>
<h3 id="集群（直连型）"><a href="#集群（直连型）" class="headerlink" title="集群（直连型）"></a>集群（直连型）</h3><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/67.png" alt="在这里插入图片描述"></p>
<p>从redis 3.0之后版本支持redis-cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。</p>
<p>特点：</p>
<p>1、无中心架构（不存在哪个节点影响性能瓶颈），少了 proxy 层。</p>
<p>2、数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。</p>
<p>3、可扩展性，可线性扩展到 1000 个节点，节点可动态添加或删除。</p>
<p>4、高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本</p>
<p>5、实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave到 Master 的角色提升。</p>
<p>缺点：</p>
<p>1、资源隔离性较差，容易出现相互影响的情况。</p>
<p>2、数据通过异步复制,不保证数据的强一致性</p>
<h1 id="15-使用过Redis做异步队列么，你是怎么用的？有什么缺点？"><a href="#15-使用过Redis做异步队列么，你是怎么用的？有什么缺点？" class="headerlink" title="15.使用过Redis做异步队列么，你是怎么用的？有什么缺点？"></a>15.使用过Redis做异步队列么，你是怎么用的？有什么缺点？</h1><p>一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试也可以使用blpop指令。</p>
<p>缺点：</p>
<p>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。</p>
<h1 id="16-能不能生产一次消费多次呢？"><a href="#16-能不能生产一次消费多次呢？" class="headerlink" title="16.能不能生产一次消费多次呢？"></a>16.能不能生产一次消费多次呢？</h1><p>使用pub&#x2F;sub主题订阅者模式，可以实现1:N的消息队列。</p>
<p>进程间的一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/68.png" alt="在这里插入图片描述"></p>
<h1 id="17-Redis相比memcached有哪些优势？"><a href="#17-Redis相比memcached有哪些优势？" class="headerlink" title="17.Redis相比memcached有哪些优势？"></a>17.Redis相比memcached有哪些优势？</h1><p>(1) memcached所有的值均是简单的字符串，redis作为其替代者， 支持更为丰富的数据类型<br>(2) redis的速度比memcached快很多<br>(3) redis可以持久化其数据</p>
<h1 id="18-Redis的过期策略"><a href="#18-Redis的过期策略" class="headerlink" title="18.Redis的过期策略"></a>18.Redis的过期策略</h1><p>我们都知道，Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。</p>
<p>过期策略通常有以下三种</p>
<p>· 定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</p>
<p>· 惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</p>
<p>· 定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。<br>(expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)</p>
<p>Redis中同时使用了惰性过期和定期过期两种过期策略。</p>
<h1 id="19-Redis底层数据结构"><a href="#19-Redis底层数据结构" class="headerlink" title="19.Redis底层数据结构"></a>19.Redis底层数据结构</h1><h3 id="1-简单动态字符串"><a href="#1-简单动态字符串" class="headerlink" title="1.简单动态字符串"></a>1.简单动态字符串</h3><p>　　第一篇文章我们就说过 Redis 是用 C 语言写的，但是对于Redis的字符串，却不是 C 语言中的字符串（即以空字符’\0’结尾的字符数组），它是自己构建了一种名为 简单动态字符串（simple dynamic string,SDS）的抽象类型，并将 SDS 作为 Redis的默认字符串表示。</p>
<p>在<code>Redis 3.2</code>之前使用的是第一个版本，其数据结构如下所示：</p>
<p>SDS 定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//记录buf数组中已使用字节的数量</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//等于 SDS 保存字符串的长度</span></span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//记录 buf 数组中未使用字节的数量</span></span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//字节数组，用于保存字符串</span></span><br><span class="line"></span><br><span class="line">   <span class="type">char</span> buf[];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　用SDS保存字符串 “Redis”具体图示如下：</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/69.png" alt="在这里插入图片描述"></p>
<p>　　</p>
<p> 　我们看上面对于 SDS 数据类型的定义：</p>
<p>　　1、len 保存了SDS保存字符串的长度</p>
<p>　　2、buf[] 数组用来保存字符串的每个元素</p>
<p>　　3、free j记录了 buf 数组中未使用的字节数量</p>
<p>　　上面的定义相对于 C 语言对于字符串的定义，多出了 len 属性以及 free 属性。为什么不使用C语言字符串实现，而是使用 SDS呢？这样实现有什么好处？</p>
<h5 id="①、常数复杂度获取字符串长度"><a href="#①、常数复杂度获取字符串长度" class="headerlink" title="①、常数复杂度获取字符串长度"></a>①、常数复杂度获取字符串长度</h5><p>　　由于 len 属性的存在，我们获取 SDS 字符串的长度只需要读取 len 属性，时间复杂度为 O(1)。而对于 C 语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。通过 strlen key 命令可以获取 key 的字符串长度。</p>
<h5 id="②、杜绝缓冲区溢出"><a href="#②、杜绝缓冲区溢出" class="headerlink" title="②、杜绝缓冲区溢出"></a>②、杜绝缓冲区溢出</h5><p>　　我们知道在 C 语言中使用 strcat 函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。而对于 SDS 数据类型，在进行字符修改的时候，会首先根据记录的 len 属性检查内存空间是否满足需求，如果不满足，会进行相应的空间扩展，然后在进行修改操作，所以不会出现缓冲区溢出。</p>
<h5 id="③、减少修改字符串的内存重新分配次数"><a href="#③、减少修改字符串的内存重新分配次数" class="headerlink" title="③、减少修改字符串的内存重新分配次数"></a>③、减少修改字符串的内存重新分配次数</h5><p>　　C语言由于不记录字符串的长度，所以如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。</p>
<p>　　而对于SDS，由于len属性和free属性的存在，对于修改字符串SDS实现了空间预分配和惰性空间释放两种策略：</p>
<p>　　1、空间预分配：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。</p>
<p>　　2、惰性空间释放：对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 free 属性将这些字节的数量记录下来，等待后续使用。（当然SDS也提供了相应的API，当我们有需要时，也可以手动释放这些未使用的空间。）</p>
<h5 id="④、二进制安全"><a href="#④、二进制安全" class="headerlink" title="④、二进制安全"></a>④、二进制安全</h5><p>　　因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；而所有 SDS 的API 都是以处理二进制的方式来处理 buf 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len 属性表示的长度来判断字符串是否结束。</p>
<h5 id="⑤、兼容部分-C-字符串函数"><a href="#⑤、兼容部分-C-字符串函数" class="headerlink" title="⑤、兼容部分 C 字符串函数"></a>⑤、兼容部分 C 字符串函数</h5><p>　　虽然 SDS 是二进制安全的，但是一样遵从每个字符串都是以空字符串结尾的惯例，这样可以重用 C 语言库&lt;string.h&gt; 中的一部分函数。</p>
<h5 id="⑥、总结"><a href="#⑥、总结" class="headerlink" title="⑥、总结"></a>⑥、总结</h5><p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/70.png" alt="在这里插入图片描述"></p>
<p>一般来说，SDS 除了保存数据库中的字符串值以外，SDS 还可以作为缓冲区（buffer）：包括 AOF 模块中的AOF缓冲区以及客户端状态中的输入缓冲区。后面在介绍Redis的持久化时会进行介绍。</p>
<p>但是在<code>Redis 3.2 版本</code>中，对数据结构做出了修改，针对不同的长度范围定义了不同的结构，如下，这是目前的结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *sds;      </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span>     <span class="comment">// 对应的字符串长度小于 1&lt;&lt;5</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span>     <span class="comment">// 对应的字符串长度小于 1&lt;&lt;8</span></span><br><span class="line">    <span class="type">uint8_t</span> len; <span class="comment">/* used */</span>                       <span class="comment">//目前字符创的长度</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc;                                <span class="comment">//已经分配的总长度</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags;                          <span class="comment">//flag用3bit来标明类型，类型后续解释，其余5bit目前没有使用</span></span><br><span class="line">    <span class="type">char</span> buf[];                                   <span class="comment">//柔性数组，以&#x27;\0&#x27;结尾</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span>    <span class="comment">// 对应的字符串长度小于 1&lt;&lt;16</span></span><br><span class="line">    <span class="type">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span>    <span class="comment">// 对应的字符串长度小于 1&lt;&lt;32</span></span><br><span class="line">    <span class="type">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span>    <span class="comment">// 对应的字符串长度小于 1&lt;&lt;64</span></span><br><span class="line">    <span class="type">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>新版带来的好处就是针对长度不同的字符串做了优化，选取不同的数据类型uint8_t或者uint16_t或者uint32_t等来表示长度、一共申请字节的大小等。上面结构体中的__attribute__ ((<strong>packed</strong>)) 设置是告诉编译器取消字节对齐，则结构体的大小就是按照结构体成员实际大小相加得到的。</p>
<h3 id="2-链表"><a href="#2-链表" class="headerlink" title="2.链表"></a>2.链表</h3><p>　　链表是一种常用的数据结构，C 语言内部是没有内置这种数据结构的实现，所以Redis自己构建了链表的实现。</p>
<p>链表定义：</p>
<p>　　通过多个 listNode 结构就可以组成链表，这是一个双端链表，Redis还提供了操作链表的数据结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">//后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">//节点的值</span></span><br><span class="line">    <span class="type">void</span> *value; </span><br><span class="line">&#125;listNode</span><br></pre></td></tr></table></figure>

<p>　　</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//表头节点</span></span><br><span class="line">   listNode *head;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//表尾节点</span></span><br><span class="line">   listNode *tail;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//链表所包含的节点数量</span></span><br><span class="line">   <span class="type">unsigned</span>  <span class="type">long</span> len;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//节点值复制函数</span></span><br><span class="line">   <span class="type">void</span> (<span class="built_in">free</span>) (<span class="type">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//节点值释放函数</span></span><br><span class="line">   <span class="type">void</span> (<span class="built_in">free</span>) (<span class="type">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//节点值对比函数</span></span><br><span class="line">   <span class="type">int</span> (*match) (<span class="type">void</span> *ptr,<span class="type">void</span> *key);</span><br><span class="line"></span><br><span class="line">&#125;<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/71.png" alt="在这里插入图片描述"></p>
<p>　　Redis链表特性：</p>
<p>　　①、双端：链表具有前置节点和后置节点的引用，获取这两个节点时间复杂度都为O(1)。</p>
<p>　　②、无环：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL,对链表的访问都是以 NULL 结束。　　</p>
<p>　　③、带链表长度计数器：通过 len 属性获取链表长度的时间复杂度为 O(1)。</p>
<p>　　④、多态：链表节点使用 void* 指针来保存节点值，可以保存各种不同类型的值。</p>
<h3 id="3-字典"><a href="#3-字典" class="headerlink" title="3.字典"></a>3.字典</h3><p>　　字典又称为符号表或者关联数组、或映射（map），是一种用于保存键值对的抽象数据结构。字典中的每一个键 key 都是唯一的，通过 key 可以对值来进行查找或修改。C 语言中没有内置这种数据结构的实现，所以字典依然是 Redis自己构建的。</p>
<p>　　哈希表结构定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//哈希表数组</span></span><br><span class="line"></span><br><span class="line">   dictEntry **table;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//哈希表大小</span></span><br><span class="line"></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//哈希表大小掩码，用于计算索引值</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//总是等于 size-1</span></span><br><span class="line"></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//该哈希表已有节点的数量</span></span><br><span class="line"></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;dictht</span><br></pre></td></tr></table></figure>

<p>　　哈希表是由数组 table 组成，table 中每个元素都是指向 dict.h&#x2F;dictEntry 结构，dictEntry 结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//键</span></span><br><span class="line">   <span class="type">void</span> *key;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//值</span></span><br><span class="line">   <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line"></span><br><span class="line">     <span class="type">void</span> *val;</span><br><span class="line"></span><br><span class="line">     uint64_tu64;</span><br><span class="line"></span><br><span class="line">     int64_ts64;</span><br><span class="line"></span><br><span class="line">   &#125;v;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//指向下一个哈希表节点，形成链表</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;dictEntry</span><br></pre></td></tr></table></figure>

<p>　　key 用来保存键，val 属性用来保存值，值可以是一个指针，也可以是uint64_t整数，也可以是int64_t整数。</p>
<p>　　注意这里还有一个指向下一个哈希表节点的指针，我们知道哈希表最大的问题是存在哈希冲突，如何解决哈希冲突，有开放地址法和链地址法。这里采用的便是链地址法，通过next这个指针可以将多个哈希值相同的键值对连接在一起，用来解决哈希冲突。</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/72.png" alt="在这里插入图片描述"></p>
<p>　　①、哈希算法：Redis计算哈希值和索引值方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#<span class="number">1</span>、使用字典设置的哈希函数，计算键 key 的哈希值</span><br><span class="line"></span><br><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、使用哈希表的sizemask属性和第一步得到的哈希值，计算索引值</span><br><span class="line"></span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>

<p>　②、解决哈希冲突：这个问题上面我们介绍了，方法是链地址法。通过字典里面的 *next 指针指向下一个具有相同索引值的哈希表节点。</p>
<p>　③、扩容和收缩：当哈希表保存的键值对太多或者太少时，就要通过 rerehash(重新散列）来对哈希表进行相应的扩展或者收缩。具体步骤：</p>
<p>　　　　　　1、如果执行扩展操作，会基于原哈希表创建一个大小等于 ht[0].used*2n 的哈希表（也就是每次扩展都是根据原哈希表已使用的空间扩大一倍创建另一个哈希表）。相反如果执行的是收缩操作，每次收缩是根据已使用空间缩小一倍创建一个新的哈希表。</p>
<p>　　　　　　2、重新利用上面的哈希算法，计算索引值，然后将键值对放到新的哈希表位置上。</p>
<p>　　　　　　3、所有键值对都迁徙完毕后，释放原哈希表的内存空间。</p>
<p>　④、触发扩容的条件：</p>
<p>　　　　　　1、服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于1。</p>
<p>　　　　　　2、服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于5。</p>
<p>　　　　ps：负载因子 &#x3D; 哈希表已保存节点数量 &#x2F; 哈希表大小。</p>
<p>⑤、渐近式 rehash</p>
<p>　　　　什么叫渐进式 rehash？也就是说扩容和收缩操作不是一次性、集中式完成的，而是分多次、渐进式完成的。如果保存在Redis中的键值对只有几个几十个，那么 rehash 操作可以瞬间完成，但是如果键值对有几百万，几千万甚至几亿，那么要一次性的进行 rehash，势必会造成Redis一段时间内不能进行别的操作。所以Redis采用渐进式 rehash,这样在进行渐进式rehash期间，字典的删除查找更新等操作可能会在两个哈希表上进行，第一个哈希表没有找到，就会去第二个哈希表上进行查找。但是进行 增加操作，一定是在新的哈希表上进行的。</p>
<h3 id="4-跳跃表"><a href="#4-跳跃表" class="headerlink" title="4.跳跃表"></a>4.跳跃表</h3><p>　　跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其它节点的指针，从而达到快速访问节点的目的。具有如下性质：</p>
<p>　　1、由很多层结构组成；</p>
<p>　　2、每一层都是一个有序的链表，排列顺序为由高层到底层，都至少包含两个链表节点，分别是前面的head节点和后面的nil节点；</p>
<p>　　3、最底层的链表包含了所有的元素；</p>
<p>　　4、如果一个元素出现在某一层的链表中，那么在该层之下的链表也全都会出现（上一层的元素是当前层的元素的子集）；</p>
<p>　　5、链表中的每个节点都包含两个指针，一个指向同一层的下一个链表节点，另一个指向下一层的同一个链表节点；</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/73.png" alt="在这里插入图片描述"></p>
<p>　　Redis中跳跃表节点定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//层</span></span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span>&#123;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//前进指针</span></span><br><span class="line"></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//跨度</span></span><br><span class="line"></span><br><span class="line">      <span class="type">unsigned</span> ***\*<span class="type">int</span>\**** span;</span><br><span class="line"></span><br><span class="line">   &#125;level[];</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">   <span class="comment">//后退指针</span></span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//分值</span></span><br><span class="line"></span><br><span class="line">   <span class="type">double</span> score;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//成员对象</span></span><br><span class="line"></span><br><span class="line">   robj *obj;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125; zskiplistNode</span><br></pre></td></tr></table></figure>

<p>　　多个跳跃表节点构成一个跳跃表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span>&#123;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//表头节点和表尾节点</span></span><br><span class="line">   structz skiplistNode *header, *tail;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//表中节点的数量</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//表中层数最大的节点的层数</span></span><br><span class="line">   <span class="type">int</span> level;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;zskiplist;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/74.png" alt="在这里插入图片描述"></p>
<p>　　①、搜索：从最高层的链表节点开始，如果比当前节点要大和比当前层的下一个节点要小，那么则往下找，也就是和当前层的下一层的节点的下一个节点进行比较，以此类推，一直找到最底层的最后一个节点，如果找到则返回，反之则返回空。</p>
<p>　　②、插入：首先确定插入的层数，有一种方法是假设抛一枚硬币，如果是正面就累加，直到遇见反面为止，最后记录正面的次数作为插入的层数。当确定插入的层数k后，则需要将新元素插入到从底层到k层。</p>
<p>③、删除：在各个层中找到包含指定值的节点，然后将节点从链表中删除即可，如果删除以后只剩下头尾两个节点，则删除这一层。</p>
<h3 id="5-整数集合"><a href="#5-整数集合" class="headerlink" title="5.整数集合"></a>5.整数集合</h3><p>　　整数集合（intset）是Redis用于保存整数值的集合抽象数据类型，它可以保存类型为int16_t、int32_t 或者int64_t 的整数值，并且保证集合中不会出现重复元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//编码方式</span></span><br><span class="line"></span><br><span class="line">   <span class="type">uint32_t</span> encoding;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//集合包含的元素数量</span></span><br><span class="line"></span><br><span class="line">   <span class="type">uint32_t</span> length;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//保存元素的数组</span></span><br><span class="line"></span><br><span class="line">   <span class="type">int8_t</span> contents[];</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;intset;</span><br></pre></td></tr></table></figure>

<p>　　定义如下：</p>
<p>　　整数集合的每个元素都是 contents 数组的一个数据项，它们按照从小到大的顺序排列，并且不包含任何重复项。</p>
<p>　　length 属性记录了 contents 数组的大小。</p>
<p>　　需要注意的是虽然 contents 数组声明为 int8_t 类型，但是实际上contents 数组并不保存任何 int8_t 类型的值，其真正类型有 encoding 来决定。</p>
<p>　①、升级</p>
<p>　　当我们新增的元素类型比原集合元素类型的长度要大时，需要对整数集合进行升级，才能将新元素放入整数集合中。具体步骤：</p>
<p>　　1、根据新元素类型，扩展整数集合底层数组的大小，并为新元素分配空间。</p>
<p>　　2、将底层数组现有的所有元素都转成与新元素相同类型的元素，并将转换后的元素放到正确的位置，放置过程中，维持整个元素顺序都是有序的。</p>
<p>　　3、将新元素添加到整数集合中（保证有序）。</p>
<p>　　升级能极大地节省内存。</p>
<p>②、降级</p>
<p>　　整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。</p>
<h3 id="6-压缩列表"><a href="#6-压缩列表" class="headerlink" title="6.压缩列表"></a>6.压缩列表</h3><p>压缩列表（ziplist）是Redis为了节省内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构，一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。</p>
<p>压缩列表的原理：压缩列表并不是对数据利用某种算法进行压缩，而是将数据按照一定规则编码在一块连续的内存区域，目的是节省内存。</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/75.png" alt="在这里插入图片描述"></p>
<p>　　压缩列表的每个节点构成如下：</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/76.png" alt="在这里插入图片描述"></p>
<p>　　①、previous_entry_ength：记录压缩列表前一个字节的长度。previous_entry_ength的长度可能是1个字节或者是5个字节，如果上一个节点的长度小于254，则该节点只需要一个字节就可以表示前一个节点的长度了，如果前一个节点的长度大于等于254，则previous length的第一个字节为254，后面用四个字节表示当前节点前一个节点的长度。利用此原理即当前节点位置减去上一个节点的长度即得到上一个节点的起始位置，压缩列表可以从尾部向头部遍历。这么做很有效地减少了内存的浪费。</p>
<p>　　②、encoding：节点的encoding保存的是节点的content的内容类型以及长度，encoding类型一共有两种，一种字节数组一种是整数，encoding区域长度为1字节、2字节或者5字节长。</p>
<p>　　③、content：content区域用于保存节点的内容，节点内容类型和长度由encoding决定。</p>
<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h3><p>　　大多数情况下，Redis使用简单字符串SDS作为字符串的表示，相对于C语言字符串，SDS具有常数复杂度获取字符串长度，杜绝了缓存区的溢出，减少了修改字符串长度时所需的内存重分配次数，以及二进制安全能存储各种类型的文件，并且还兼容部分C函数。</p>
<p>　　通过为链表设置不同类型的特定函数，Redis链表可以保存各种不同类型的值，除了用作列表键，还在发布与订阅、慢查询、监视器等方面发挥作用（后面会介绍）。</p>
<p>　　Redis的字典底层使用哈希表实现，每个字典通常有两个哈希表，一个平时使用，另一个用于rehash时使用，使用链地址法解决哈希冲突。</p>
<p>　　跳跃表通常是有序集合的底层实现之一，表中的节点按照分值大小进行排序。</p>
<p>　　整数集合是集合键的底层实现之一，底层由数组构成，升级特性能尽可能的节省内存。</p>
<p>　　压缩列表是Redis为节省内存而开发的顺序型数据结构，通常作为列表键和哈希键的底层实现之一。</p>
<h1 id="20-一致性hash"><a href="#20-一致性hash" class="headerlink" title="20.一致性hash"></a>20.一致性hash</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>互联网公司中，绝大部分都没有马爸爸系列的公司那样财大气粗，他们即没有强劲的服务器、也没有钱去购买昂贵的海量数据库。那他们是怎么应对大数据量高并发的业务场景的呢？<br> 这个和当前的开源技术、海量数据架构都有着不可分割的关系。比如通过mysql、nginx等开源软件，通过架构和低成本的服务器搭建千万级别的用户访问系统。<br> 怎么样搭建一个好的系统架构，这个话题我们能聊上个七天七夜。这里我主要结合Redis集群来讲一下一致性Hash的相关问题。</p>
<h3 id="Redis集群的使用"><a href="#Redis集群的使用" class="headerlink" title="Redis集群的使用"></a>Redis集群的使用</h3><p>我们在使用Redis的过程中，为了保证Redis的高可用，我们一般会对Redis做主从复制，组成<code>Master-Master</code>或者<code>Master-Slave</code>的形式，进行数据的读写分离，如下图1-1所示：</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/77.png" alt="在这里插入图片描述"></p>
<p>图1-1：Master-Slave模式</p>
<p>当缓存数据量超过一定的数量时，我们就要对Redis集群做分库分表的操作。</p>
<p>来个栗子，我们有一个电商平台，需要使用Redis存储商品的图片资源，存储的格式为键值对，key值为图片名称，Value为该图片所在的文件服务器的路径，我们需要根据文件名，查找到文件所在的文件服务器上的路径，我们的图片数量大概在3000w左右，按照我们的规则进行分库，规则就是随机分配的，我们以每台服务器存500w的数量，部署12台缓存服务器，并且进行主从复制，架构图如下图1-2所示：</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/78.png" alt="在这里插入图片描述"></p>
<p>图1-2：Redis分库分表</p>
<p>由于我们定义的规则是随机的，所以我们的数据有可能存储在任何一组Redis中，比如我们需要查询”product.png”的图片，由于规则的随机性，我们需要遍历所有Redis服务器，才能查询得到。这样的结果显然不是我们所需要的。所以我们会想到按某一个字段值进行Hash值、取模。所以我们就看看使用Hash的方式是怎么进行的。</p>
<h3 id="使用Hash的Redis集群"><a href="#使用Hash的Redis集群" class="headerlink" title="使用Hash的Redis集群"></a>使用Hash的Redis集群</h3><p>如果我们使用Hash的方式，每一张图片在进行分库的时候都可以定位到特定的服务器，示意图如图1-3所示：</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/79.png" alt="在这里插入图片描述"></p>
<p>图1-3：使用Hash方式的命中缓存</p>
<p>从上图中，我们需要查询的是图<code>product.png</code>，由于我们有6台主服务器，所以计算的公式为：<code>hash(product.png) % 6 = 5</code>, 我们就可以定位到是5号主从，这们就省去了遍历所有服务器的时间，从而大大提升了性能。</p>
<h3 id="使用Hash时遇到的问题"><a href="#使用Hash时遇到的问题" class="headerlink" title="使用Hash时遇到的问题"></a>使用Hash时遇到的问题</h3><p>在上述hash取模的过程中，我们虽然不需要对所有Redis服务器进行遍历而提升了性能。但是，使用Hash算法缓存时会出现一些问题，<code>Redis服务器变动时，所有缓存的位置都会发生改变</code>。<br> 比如，现在我们的Redis缓存服务器增加到了8台，我们计算的公式从<code>hash(product.png) % 6 = 5</code>变成了<code>hash(product.png) % 8 = ?</code> 结果肯定不是原来的5了。<br> 再者，6台的服务器集群中，当某个主从群出现故障时，无法进行缓存，那我们需要把故障机器移除，所以取模数又会从6变成了5。我们计算的公式也会变化。</p>
<p>由于上面hash算法是使用取模来进行缓存的，为了规避上述情况，Hash一致性算法就诞生了~~</p>
<h3 id="一致性Hash算法原理"><a href="#一致性Hash算法原理" class="headerlink" title="一致性Hash算法原理"></a>一致性Hash算法原理</h3><p>一致性Hash算法也是使用取模的方法，不过，上述的取模方法是对服务器的数量进行取模，而一致性的Hash算法是对<code>2的32方</code>取模。即，一致性Hash算法将整个Hash空间组织成一个虚拟的圆环，Hash函数的值空间为<code>0 ~ 2^32 - 1(一个32位无符号整型)</code>，整个哈希环如下：</p>
<p>图1-4：Hash圆环</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/80.png" alt="在这里插入图片描述"></p>
<p> 整个圆环以<code>顺时针方向组织</code>，圆环正上方的点代表0，0点右侧的第一个点代表1，以此类推。<br> 第二步，我们将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台服务器就确定在了哈希环的一个位置上，比如我们有三台机器，使用IP地址哈希后在环空间的位置如图1-4所示：</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/81.png" alt="在这里插入图片描述"></p>
<p>图1-4：服务器在哈希环上的位置</p>
<p>现在，我们使用以下算法定位数据访问到相应的服务器：</p>
<blockquote>
<p>将数据Key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针查找，遇到的服务器就是其应该定位到的服务器。</p>
</blockquote>
<p>例如，现在有ObjectA，ObjectB，ObjectC三个数据对象，经过哈希计算后，在环空间上的位置如下：</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/82.png" alt="在这里插入图片描述"></p>
<p>图1-5：数据对象在环上的位置</p>
<p>根据一致性算法，Object -&gt; NodeA，ObjectB -&gt; NodeB, ObjectC -&gt; NodeC</p>
<h3 id="一致性Hash算法的容错性和可扩展性"><a href="#一致性Hash算法的容错性和可扩展性" class="headerlink" title="一致性Hash算法的容错性和可扩展性"></a>一致性Hash算法的容错性和可扩展性</h3><p>现在，假设我们的Node C宕机了，我们从图中可以看到，A、B不会受到影响，只有Object C对象被重新定位到Node A。所以我们发现，在一致性Hash算法中，如果一台服务器不可用，受影响的数据仅仅是此服务器到其环空间前一台服务器之间的数据（这里为Node C到Node B之间的数据），其他不会受到影响。如图1-6所示：</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/83.png" alt="在这里插入图片描述"></p>
<p>图1-6：C节点宕机情况，数据移到节点A上</p>
<p>另外一种情况，现在我们系统增加了一台服务器Node X，如图1-7所示：</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/84.png" alt="图1-7：增加新的服"><br>务器节点X</p>
<p>此时对象ObjectA、ObjectB没有受到影响，只有Object C重新定位到了新的节点X上。<br> 如上所述：</p>
<blockquote>
<p>一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，有很好的容错性和可扩展性。</p>
</blockquote>
<h3 id="数据倾斜问题"><a href="#数据倾斜问题" class="headerlink" title="数据倾斜问题"></a>数据倾斜问题</h3><p>在一致性Hash算法服务节点太少的情况下，容易因为节点分布不均匀面造成<code>数据倾斜（被缓存的对象大部分缓存在某一台服务器上）问题</code>，如图1-8特例：</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/85.png" alt="在这里插入图片描述"></p>
<p>图1-8：数据倾斜</p>
<p> 这时我们发现有大量数据集中在节点A上，而节点B只有少量数据。为了解决数据倾斜问题，一致性Hash算法引入了<code>虚拟节点机制</code>，即对每一个服务器节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。<br> 具体操作可以为服务器IP或主机名后加入编号来实现，实现如图1-9所示：</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/86.png" alt="在这里插入图片描述"></p>
<p>图1-9：增加虚拟节点情况</p>
<p>数据定位算法不变，只需要增加一步：虚拟节点到实际点的映射。<br> 所以加入虚拟节点之后，即使在服务节点很少的情况下，也能做到数据的均匀分布。</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><h6 id="算法接口类"><a href="#算法接口类" class="headerlink" title="算法接口类"></a>算法接口类</h6><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IHashService</span> &#123;</span><br><span class="line">    <span class="function">Long <span class="title">hash</span>(<span class="params">String key</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="算法接口实现类"><a href="#算法接口实现类" class="headerlink" title="算法接口实现类"></a>算法接口实现类</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashService</span> <span class="keyword">implements</span> <span class="title class_">IHashService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * MurMurHash算法,性能高,碰撞率低</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Long</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">hash</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.wrap(key.getBytes());</span><br><span class="line">        <span class="type">int</span> <span class="variable">seed</span> <span class="operator">=</span> <span class="number">0x1234ABCD</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteOrder</span> <span class="variable">byteOrder</span> <span class="operator">=</span> buf.order();</span><br><span class="line">        buf.order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0xc6a4a7935bd1e995L</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">h</span> <span class="operator">=</span> seed ^ (buf.remaining() * m);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> k;</span><br><span class="line">        <span class="keyword">while</span> (buf.remaining() &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">            k = buf.getLong();</span><br><span class="line"></span><br><span class="line">            k *= m;</span><br><span class="line">            k ^= k &gt;&gt;&gt; r;</span><br><span class="line">            k *= m;</span><br><span class="line"></span><br><span class="line">            h ^= k;</span><br><span class="line">            h *= m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (buf.remaining() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">finish</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">8</span>).order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">            finish.put(buf).rewind();</span><br><span class="line">            h ^= finish.getLong();</span><br><span class="line">            h *= m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        h ^= h &gt;&gt;&gt; r;</span><br><span class="line">        h *= m;</span><br><span class="line">        h ^= h &gt;&gt;&gt; r;</span><br><span class="line"></span><br><span class="line">        buf.order(byteOrder);</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="模拟机器节点"><a href="#模拟机器节点" class="headerlink" title="模拟机器节点"></a>模拟机器节点</h6><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">String</span> ip;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">String</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">Node</span>(<span class="title class_">String</span> ip, <span class="title class_">String</span> name) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">ip</span> = ip;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">getIp</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">setIp</span>(<span class="params"><span class="built_in">String</span> ip</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">ip</span> = ip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">setName</span>(<span class="params"><span class="built_in">String</span> name</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用IP当做hash的Key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> <span class="variable">String</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="一致性Hash操作"><a href="#一致性Hash操作" class="headerlink" title="一致性Hash操作"></a>一致性Hash操作</h6><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsistentHash</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// Hash函数接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IHashService iHashService;</span><br><span class="line">    <span class="comment">// 每个机器节点关联的虚拟节点数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> int          numberOfReplicas;</span><br><span class="line">    <span class="comment">// 环形虚拟节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SortedMap&lt;<span class="built_in">Long</span>, T&gt; circle = new TreeMap&lt;<span class="built_in">Long</span>, T&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ConsistentHash(IHashService iHashService, int numberOfReplicas, Collection&lt;T&gt; nodes) &#123;</span><br><span class="line">        <span class="keyword">this</span>.iHashService = iHashService;</span><br><span class="line">        <span class="keyword">this</span>.numberOfReplicas = numberOfReplicas;</span><br><span class="line">        <span class="keyword">for</span> (T node : nodes) &#123;</span><br><span class="line">            add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加真实机器节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node T</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> void add(T node) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.numberOfReplicas; i++) &#123;</span><br><span class="line">            circle.put(<span class="keyword">this</span>.iHashService.hash(node.toString() + i), node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除真实机器节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node T</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> void remove(T node) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.numberOfReplicas; i++) &#123;</span><br><span class="line">            circle.remove(<span class="keyword">this</span>.iHashService.hash(node.toString() + i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">get</span>(String key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (circle.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        long hash = iHashService.hash(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 沿环的顺时针找到一个虚拟节点</span></span><br><span class="line">        <span class="keyword">if</span> (!circle.containsKey(hash)) &#123;</span><br><span class="line">            SortedMap&lt;<span class="built_in">Long</span>, T&gt; tailMap = circle.tailMap(hash);</span><br><span class="line">            hash = tailMap.isEmpty() ? circle.firstKey() : tailMap.firstKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> circle.<span class="keyword">get</span>(hash);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h6><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TestHashCircle</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 机器节点IP前缀</span></span><br><span class="line">    private <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">String</span> IP_PREFIX = <span class="string">&quot;192.168.0.&quot;</span>;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">        <span class="comment">// 每台真实机器节点上保存的记录条数</span></span><br><span class="line">        <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;<span class="built_in">String</span>, Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 真实机器节点, 模拟10台</span></span><br><span class="line">        <span class="built_in">List</span>&lt;Node&lt;<span class="built_in">String</span>&gt;&gt; nodes = <span class="keyword">new</span> ArrayList&lt;Node&lt;<span class="built_in">String</span>&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            map.put(IP_PREFIX + i, <span class="number">0</span>); <span class="comment">// 初始化记录</span></span><br><span class="line">            Node&lt;<span class="built_in">String</span>&gt; node = <span class="keyword">new</span> Node&lt;<span class="built_in">String</span>&gt;(IP_PREFIX + i, <span class="string">&quot;node&quot;</span> + i);</span><br><span class="line">            nodes.add(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        IHashService iHashService = <span class="keyword">new</span> HashService();</span><br><span class="line">        <span class="comment">// 每台真实机器引入100个虚拟节点</span></span><br><span class="line">        ConsistentHash&lt;Node&lt;<span class="built_in">String</span>&gt;&gt; consistentHash = <span class="keyword">new</span> ConsistentHash&lt;Node&lt;<span class="built_in">String</span>&gt;&gt;(iHashService, <span class="number">500</span>, nodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将5000条记录尽可能均匀的存储到10台机器节点上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 产生随机一个字符串当做一条记录，可以是其它更复杂的业务对象,比如随机字符串相当于对象的业务唯一标识</span></span><br><span class="line">            <span class="built_in">String</span> data = UUID.randomUUID().toString() + i;</span><br><span class="line">            <span class="comment">// 通过记录找到真实机器节点</span></span><br><span class="line">            Node&lt;<span class="built_in">String</span>&gt; node = consistentHash.<span class="keyword">get</span>(data);</span><br><span class="line">            <span class="comment">// 再这里可以能过其它工具将记录存储真实机器节点上，比如MemoryCache等</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="comment">// 每台真实机器节点上保存的记录条数加1</span></span><br><span class="line">            map.put(node.getIp(), map.<span class="keyword">get</span>(node.getIp()) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印每台真实机器节点保存的记录条数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(IP_PREFIX + i + <span class="string">&quot;节点记录条数：&quot;</span> + map.<span class="keyword">get</span>(IP_PREFIX + i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="/2022/10/24/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/87.png" alt="在这里插入图片描述"></p>
<p>一致性hash测试结果</p>
<p>每台机器映射的虚拟节点越多，则分布的越均匀~~~</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>CAP原理</tag>
        <tag>缓存一致性协议</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud-注册中心原理和选型</title>
    <url>/2022/10/25/SpringCloud-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E5%92%8C%E9%80%89%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="注册中心原理和选型：Zookeeper、Eureka、Nacos、Consul和Etcd"><a href="#注册中心原理和选型：Zookeeper、Eureka、Nacos、Consul和Etcd" class="headerlink" title="注册中心原理和选型：Zookeeper、Eureka、Nacos、Consul和Etcd"></a>注册中心原理和选型：Zookeeper、Eureka、Nacos、Consul和Etcd</h1><p><img src="/2022/10/25/SpringCloud-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E5%92%8C%E9%80%89%E5%9E%8B/1.png" alt="图片"></p>
<blockquote>
<p>讲解5种常用的注册中心，对比其流程和原理，无论是面试还是技术选型，都非常有帮助。</p>
</blockquote>
<p>经过近2周的学习，原来注册中心除了ETCD和Zookeeper，常用的还有Eureka、Nacos、Consul，下面我们就对这些常用的注册中心，初探它们的异同，便于后续技术选型。</p>
<p>全文接近 <strong>8千字</strong>，有点长，<strong>建议先收藏，再慢慢看</strong>，下面是文章目录：</p>
<p><img src="/2022/10/25/SpringCloud-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E5%92%8C%E9%80%89%E5%9E%8B/2.png" alt="图片"></p>
<h1 id="注册中心基本概念"><a href="#注册中心基本概念" class="headerlink" title="注册中心基本概念"></a>注册中心基本概念</h1><h2 id="什么是注册中心？"><a href="#什么是注册中心？" class="headerlink" title="什么是注册中心？"></a>什么是注册中心？</h2><p>注册中心主要有三种角色：</p>
<ul>
<li><strong>服务提供者（RPC Server）</strong>：在启动时，向 Registry 注册自身服务，并向 Registry 定期发送心跳汇报存活状态。</li>
<li><strong>服务消费者（RPC Client）</strong>：在启动时，向 Registry 订阅服务，把 Registry 返回的服务节点列表缓存在本地内存中，并与 RPC Sever 建立连接。</li>
<li><strong>服务注册中心（Registry）</strong>：用于保存 RPC Server 的注册信息，当 RPC Server 节点发生变更时，Registry 会同步变更，RPC Client 感知后会刷新本地 内存中缓存的服务节点列表。</li>
</ul>
<p>最后，RPC Client 从本地缓存的服务节点列表中，基于负载均衡算法选择一台 RPC Sever 发起调用。</p>
<p><img src="/2022/10/25/SpringCloud-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E5%92%8C%E9%80%89%E5%9E%8B/3.png" alt="图片"></p>
<h2 id="注册中心需要实现功能"><a href="#注册中心需要实现功能" class="headerlink" title="注册中心需要实现功能"></a>注册中心需要实现功能</h2><p>根据注册中心原理的描述，注册中心必须实现以下功能，偷个懒，直接贴幅图：</p>
<p><img src="/2022/10/25/SpringCloud-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E5%92%8C%E9%80%89%E5%9E%8B/4.png" alt="图片"></p>
<h1 id="注册中心基础扫盲"><a href="#注册中心基础扫盲" class="headerlink" title="注册中心基础扫盲"></a>注册中心基础扫盲</h1><blockquote>
<p>这块知识如果大家已经知道，可以直接跳过，主要是为了扫盲。</p>
</blockquote>
<h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><p>CAP理论是分布式架构中重要理论：</p>
<ul>
<li>一致性(Consistency)：所有节点在同一时间具有相同的数据；</li>
<li>可用性(Availability) ：保证每个请求不管成功或者失败都有响应；</li>
<li>分隔容忍(Partition tolerance) ：系统中任意信息的丢失或失败不会影响系统的继续运作。</li>
</ul>
<p>关于 P 的理解，我觉得是在整个系统中某个部分，挂掉了，或者宕机了，并不影响整个系统的运作或者说使用，而可用性是，某个系统的某个节点挂了，但是并不影响系统的接受或者发出请求。</p>
<p>CAP 不可能都取，只能取其中2个的原因如下：</p>
<ul>
<li>如果C是第一需求的话，那么会影响A的性能，因为要数据同步，不然请求结果会有差异，但是数据同步会消耗时间，期间可用性就会降低。</li>
<li>如果A是第一需求，那么只要有一个服务在，就能正常接受请求，但是对于返回结果变不能保证，原因是，在分布式部署的时候，数据一致的过程不可能想切线路那么快。</li>
<li>再如果，同时满足一致性和可用性，那么分区容错就很难保证了，也就是单点，也是分布式的基本核心。</li>
</ul>
<h2 id="分布式系统协议"><a href="#分布式系统协议" class="headerlink" title="分布式系统协议"></a>分布式系统协议</h2><p>一致性协议算法主要有Paxos、Raft、ZAB。</p>
<p>Paxos算法是Leslie Lamport在1990年提出的一种基于消息传递的一致性算法，非常难以理解，基于Paxos协议的数据同步与传统主备方式最大的区别在于：Paxos只需超过半数的副本在线且相互通信正常，就可以保证服务的持续可用，且数据不丢失。</p>
<p>Raft是斯坦福大学的Diego Ongaro、John Ousterhout两个人以易理解为目标设计的一致性算法，已经有了十几种语言的Raft算法实现框架，较为出名的有etcd，Google的Kubernetes也是用了etcd作为他的服务发现框架。</p>
<p>Raft是Paxos的简化版，与Paxos相比，Raft强调的是易理解、易实现，Raft和Paxos一样只要保证超过半数的节点正常就能够提供服务。这篇文章 <a href="https://mp.weixin.qq.com/s?__biz=Mzg3OTU5NzQ1Mw==&mid=2247484080&idx=1&sn=24ccb6e7de6d7a274c75296799b57c32&chksm=cf034052f874c944a601a6eb50d524753d7adaf59c0f2326a47a3104302c2544a6901104668f&token=333114218&lang=zh_CN&scene=21#wechat_redirect">《ETCD教程-2.Raft协议》</a> 详细讲解了Raft原理，非常有意思，感兴趣的同学可以看看。</p>
<p>ZooKeeper Atomic Broadcast (ZAB, ZooKeeper原子消息广播协议)是ZooKeeper实现分布式数据一致性的核心算法，ZAB借鉴Paxos算法，但又不像Paxos算法那样，是一种通用的分布式一致性算法，它是一种特别为ZooKeeper专门设计的支持崩溃恢复的原子广播协议。</p>
<h1 id="常用注册中心"><a href="#常用注册中心" class="headerlink" title="常用注册中心"></a>常用注册中心</h1><p>这里主要介绍5种常用的注册中心，分别为<strong>Zookeeper、Eureka、Nacos、Consul和ETCD</strong>。</p>
<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><p>这个说起来有点意思的是官方并没有说他是一个注册中心，但是国内Dubbo场景下很多都是使用Zookeeper来完成了注册中心的功能。</p>
<p>当然这有很多历史原因，这里我们就不追溯了。ZooKeeper是非常经典的服务注册中心中间件，在国内环境下，由于受到Dubbo框架的影响，大部分情况下认为Zookeeper是RPC服务框架下注册中心最好选择，随着Dubbo框架的不断开发优化，和各种注册中心组件的诞生，即使是RPC框架，现在的注册中心也逐步放弃了ZooKeeper。在常用的开发集群环境中，ZooKeeper依然起到十分重要的作用，Java体系中，大部分的集群环境都是依赖ZooKeeper管理服务的各个节点。</p>
<p><img src="/2022/10/25/SpringCloud-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E5%92%8C%E9%80%89%E5%9E%8B/5.png" alt="图片"></p>
<h3 id="Zookeeper如何实现注册中心"><a href="#Zookeeper如何实现注册中心" class="headerlink" title="Zookeeper如何实现注册中心"></a>Zookeeper如何实现注册中心</h3><blockquote>
<p>具体可参考这篇文章 <a href="https://mp.weixin.qq.com/s?__biz=Mzg3OTU5NzQ1Mw==&mid=2247486840&idx=1&sn=254bb499f1d79a6cc42023f8d143822f&chksm=cf034f9af874c68cc40e4a7da28ad5302173d876fa0b52808644b9d7f4eec10a13712364ef54&scene=21#wechat_redirect">《Zookeeper用作注册中心的原理》</a>，下面的内容都出自该文章。</p>
</blockquote>
<p>Zookeeper可以充当一个服务注册表（Service Registry），让多个服务提供者形成一个集群，让服务消费者通过服务注册表获取具体的服务访问地址（Ip+端口）去访问具体的服务提供者。如下图所示：</p>
<p><img src="/2022/10/25/SpringCloud-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E5%92%8C%E9%80%89%E5%9E%8B/6.png" alt="图片"></p>
<p>每当一个服务提供者部署后都要将自己的服务注册到zookeeper的某一路径上: &#x2F;{service}&#x2F;{version}&#x2F;{ip:port} 。</p>
<p>比如我们的HelloWorldService部署到两台机器，那么Zookeeper上就会创建两条目录：</p>
<ul>
<li>&#x2F;HelloWorldService&#x2F;1.0.0&#x2F;100.19.20.01:16888</li>
<li>&#x2F;HelloWorldService&#x2F;1.0.0&#x2F;100.19.20.02:16888</li>
</ul>
<p>这么描述有点不好理解，下图更直观：</p>
<p><img src="/2022/10/25/SpringCloud-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E5%92%8C%E9%80%89%E5%9E%8B/7.png" alt="图片"></p>
<p>在zookeeper中，进行服务注册，实际上就是在zookeeper中创建了一个znode节点，该节点存储了该服务的IP、端口、调用方式(协议、序列化方式)等。该节点承担着最重要的职责，它由服务提供者(发布服务时)创建，以供服务消费者获取节点中的信息，从而定位到服务提供者真正网络拓扑位置以及得知如何调用。</p>
<p><strong>RPC服务注册&#x2F;发现过程简述如下：</strong></p>
<ol>
<li>服务提供者启动时，会将其服务名称，ip地址注册到配置中心。</li>
<li>服务消费者在第一次调用服务时，会通过注册中心找到相应的服务的IP地址列表，并缓存到本地，以供后续使用。当消费者调用服务时，不会再去请求注册中心，而是直接通过负载均衡算法从IP列表中取一个服务提供者的服务器调用服务。</li>
<li>当服务提供者的某台服务器宕机或下线时，相应的ip会从服务提供者IP列表中移除。同时，注册中心会将新的服务IP地址列表发送给服务消费者机器，缓存在消费者本机。</li>
<li>当某个服务的所有服务器都下线了，那么这个服务也就下线了。</li>
<li>同样，当服务提供者的某台服务器上线时，注册中心会将新的服务IP地址列表发送给服务消费者机器，缓存在消费者本机。</li>
<li>服务提供方可以根据服务消费者的数量来作为服务下线的依据。</li>
</ol>
<p>zookeeper提供了“心跳检测”功能：<strong>它会定时向各个服务提供者发送一个请求（实际上建立的是一个 socket 长连接），如果长期没有响应，服务中心就认为该服务提供者已经“挂了”，并将其剔除。</strong></p>
<p>比如100.100.0.237这台机器如果宕机了，那么zookeeper上的路径就会只剩&#x2F;HelloWorldService&#x2F;1.0.0&#x2F;100.100.0.238:16888。</p>
<p>Zookeeper的Watch机制其实就是一种<strong>推拉结合的模式</strong>：</p>
<ul>
<li>服务消费者会去监听相应路径（&#x2F;HelloWorldService&#x2F;1.0.0），一旦路径上的数据有任务变化（增加或减少），<strong>Zookeeper只会发送一个事件类型和节点信息给关注的客户端，而不会包括具体的变更内容</strong>，所以事件本身是轻量级的，这就是推的部分。</li>
<li><strong>收到变更通知的客户端需要自己去拉变更的数据</strong>，这就是拉的部分。</li>
</ul>
<h3 id="Zookeeper不适合作为注册中心"><a href="#Zookeeper不适合作为注册中心" class="headerlink" title="Zookeeper不适合作为注册中心"></a>Zookeeper不适合作为注册中心</h3><p>作为一个分布式协同服务，ZooKeeper非常好，但是对于Service发现服务来说就不合适了，因为对于Service发现服务来说就算是返回了包含不实的信息的结果也比什么都不返回要好。<strong>所以当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。</strong></p>
<p>但是zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30 ~ 120s, 且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。</p>
<p>所以说，<strong>作为注册中心，可用性的要求要高于一致性！</strong></p>
<p>在 CAP 模型中，<strong>Zookeeper整体遵循一致性（CP）原则</strong>，即在任何时候对 Zookeeper 的访问请求能得到一致的数据结果，但是当机器下线或者宕机时，<strong>不能保证服务可用性。</strong></p>
<p>那为什么Zookeeper不使用最终一致性（AP）模型呢？因为这个依赖<strong>Zookeeper的核心算法是ZAB，所有设计都是为了强一致性</strong>。这个对于分布式协调系统，完全没没有毛病，但是<strong>你如果将Zookeeper为分布式协调服务所做的一致性保障，用在注册中心，或者说服务发现场景，这个其实就不合适。</strong></p>
<h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><h3 id="Eureka-架构图"><a href="#Eureka-架构图" class="headerlink" title="Eureka 架构图"></a>Eureka 架构图</h3><p><img src="/2022/10/25/SpringCloud-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E5%92%8C%E9%80%89%E5%9E%8B/8.png" alt="图片"></p>
<p>什么，上面这幅图看起来很复杂？那我给你贴个简化版：</p>
<p><img src="/2022/10/25/SpringCloud-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E5%92%8C%E9%80%89%E5%9E%8B/9.png" alt="图片"></p>
<h3 id="Eureka-特点"><a href="#Eureka-特点" class="headerlink" title="Eureka 特点"></a>Eureka 特点</h3><ul>
<li><strong>可用性（AP原则）</strong>：Eureka 在设计时就紧遵AP原则，Eureka的集群中，只要有一台Eureka还在，就能保证注册服务可用，只不过查到的信息可能不是最新的（不保证强一致性）。</li>
<li><strong>去中心化架构</strong>：Eureka Server 可以运行多个实例来构建集群，不同于 ZooKeeper 的选举 leader 的过程，Eureka Server 采用的是Peer to Peer 对等通信。这是一种去中心化的架构，无 master&#x2F;slave 之分，每一个 Peer 都是对等的。节点通过彼此互相注册来提高可用性，每个节点需要添加一个或多个有效的 serviceUrl 指向其他节点。每个节点都可被视为其他节点的副本。</li>
<li><strong>请求自动切换</strong>：在集群环境中如果某台 Eureka Server 宕机，Eureka Client 的请求会自动切换到新的 Eureka Server 节点上，当宕机的服务器重新恢复后，Eureka 会再次将其纳入到服务器集群管理之中。</li>
<li><strong>节点间操作复制</strong>：当节点开始接受客户端请求时，所有的操作都会在节点间进行复制操作，将请求复制到该 Eureka Server 当前所知的其它所有节点中。</li>
<li><strong>自动注册&amp;心跳</strong>：当一个新的 Eureka Server 节点启动后，会首先尝试从邻近节点获取所有注册列表信息，并完成初始化。Eureka Server 通过 getEurekaServiceUrls() 方法获取所有的节点，并且会通过心跳契约的方式定期更新。</li>
<li><strong>自动下线</strong>：默认情况下，如果 Eureka Server 在一定时间内没有接收到某个服务实例的心跳（默认周期为30秒），Eureka Server 将会注销该实例（默认为90秒， eureka.instance.lease-expiration-duration-in-seconds 进行自定义配置）。</li>
<li><strong>保护模式</strong>：当 Eureka Server 节点在短时间内丢失过多的心跳时，那么这个节点就会进入自我保护模式。</li>
</ul>
<p>除了上述特点，Eureka还有一种自我保护机制，如果在15分钟内超过 <strong>85%</strong> 的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况：</p>
<ul>
<li>Eureka不再从注册表中移除因为长时间没有收到心跳而过期的服务；</li>
<li>Eureka仍然能够接受新服务注册和查询请求，但是不会被同步到其它节点上（即保证当前节点依然可用）</li>
<li>当网络稳定时，当前实例新注册的信息会被同步到其它节点中。</li>
</ul>
<h3 id="Eureka工作流程"><a href="#Eureka工作流程" class="headerlink" title="Eureka工作流程"></a>Eureka工作流程</h3><p>了解完 Eureka 核心概念，自我保护机制，以及集群内的工作原理后，我们来整体梳理一下 Eureka 的工作流程：</p>
<ol>
<li>Eureka Server 启动成功，等待服务端注册。在启动过程中如果配置了集群，集群之间定时通过 Replicate 同步注册表，每个 Eureka Server 都存在独立完整的服务注册表信息。</li>
<li>Eureka Client 启动时根据配置的 Eureka Server 地址去注册中心注册服务。</li>
<li>Eureka Client 会每 30s 向 Eureka Server 发送一次心跳请求，证明客户端服务正常。</li>
<li>当 Eureka Server 90s 内没有收到 Eureka Client 的心跳，注册中心则认为该节点失效，会注销该实例。</li>
<li>单位时间内 Eureka Server 统计到有大量的 Eureka Client 没有上送心跳，则认为可能为网络异常，进入自我保护机制，不再剔除没有上送心跳的客户端。</li>
<li>当 Eureka Client 心跳请求恢复正常之后，Eureka Server 自动退出自我保护模式。</li>
<li>Eureka Client 定时全量或者增量从注册中心获取服务注册表，并且将获取到的信息缓存到本地。</li>
<li>服务调用时，Eureka Client 会先从本地缓存找寻调取的服务。如果获取不到，先从注册中心刷新注册表，再同步到本地缓存。</li>
<li>Eureka Client 获取到目标服务器信息，发起服务调用。</li>
<li>Eureka Client 程序关闭时向 Eureka Server 发送取消请求，Eureka Server 将实例从注册表中删除。</li>
</ol>
<blockquote>
<p>通过分析 Eureka 工作原理，我可以明显地感觉到 Eureka 的设计之巧妙，完美地解决了注册中心的稳定性和高可用性。</p>
<p>Eureka 为了保障注册中心的高可用性，容忍了数据的非强一致性，服务节点间的数据可能不一致， Client-Server 间的数据可能不一致。<strong>比较适合跨越多机房、对注册中心服务可用性要求较高的使用场景。</strong></p>
</blockquote>
<h2 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h2><blockquote>
<p>以下内容摘抄自Nacos官网：<a href="https://nacos.io/zh-cn/docs/what-is-nacos.html">https://nacos.io/zh-cn/docs/what-is-nacos.html</a></p>
</blockquote>
<p><img src="/2022/10/25/SpringCloud-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E5%92%8C%E9%80%89%E5%9E%8B/10.png" alt="图片"></p>
<p>Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。</p>
<p>Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。</p>
<p><img src="/2022/10/25/SpringCloud-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E5%92%8C%E9%80%89%E5%9E%8B/11.png" alt="图片"></p>
<h3 id="Nacos-主要特点"><a href="#Nacos-主要特点" class="headerlink" title="Nacos 主要特点"></a>Nacos 主要特点</h3><p><strong>服务发现和服务健康监测</strong>：</p>
<ul>
<li>Nacos 支持基于 DNS 和基于 RPC 的服务发现。服务提供者使用原生SDK、OpenAPI、或一个独立的Agent TODO注册 Service 后，服务消费者可以使用DNS TODO 或HTTP&amp;API查找和发现服务。</li>
<li>Nacos 提供对服务的实时的健康检查，阻止向不健康的主机或服务实例发送请求。Nacos 支持传输层 (PING 或 TCP)和应用层 (如 HTTP、MySQL、用户自定义）的健康检查。对于复杂的云环境和网络拓扑环境中（如 VPC、边缘网络等）服务的健康检查，Nacos 提供了 agent 上报模式和服务端主动检测2种健康检查模式。Nacos 还提供了统一的健康检查仪表盘，帮助您根据健康状态管理服务的可用性及流量。</li>
</ul>
<p><strong>动态配置服务</strong>：</p>
<ul>
<li>动态配置服务可以让您以中心化、外部化和动态化的方式管理所有环境的应用配置和服务配置。</li>
<li>动态配置消除了配置变更时重新部署应用和服务的需要，让配置管理变得更加高效和敏捷。</li>
<li>配置中心化管理让实现无状态服务变得更简单，让服务按需弹性扩展变得更容易。</li>
<li>Nacos 提供了一个简洁易用的UI (控制台样例 Demo) 帮助您管理所有的服务和应用的配置。Nacos 还提供包括配置版本跟踪、金丝雀发布、一键回滚配置以及客户端配置更新状态跟踪在内的一系列开箱即用的配置管理特性，帮助您更安全地在生产环境中管理配置变更和降低配置变更带来的风险。</li>
</ul>
<p><strong>动态 DNS 服务</strong>：</p>
<ul>
<li>动态 DNS 服务支持权重路由，让您更容易地实现中间层负载均衡、更灵活的路由策略、流量控制以及数据中心内网的简单DNS解析服务。动态DNS服务还能让您更容易地实现以 DNS 协议为基础的服务发现，以帮助您消除耦合到厂商私有服务发现 API 上的风险。</li>
<li>Nacos 提供了一些简单的 DNS APIs TODO 帮助您管理服务的关联域名和可用的 IP:PORT 列表。</li>
</ul>
<blockquote>
<p>小节一下：</p>
<ul>
<li>Nacos是阿里开源的，支持基于 DNS 和基于 RPC 的服务发现。</li>
<li><strong>Nacos的注册中心支持CP也支持AP</strong>，对他来说只是一个命令的切换，随你玩，还支持各种注册中心迁移到Nacos，反正一句话，只要你想要的他就有。</li>
<li><strong>Nacos除了服务的注册发现之外，还支持动态配置服务</strong>，一句话概括就是<strong>Nacos &#x3D; Spring Cloud注册中心 + Spring Cloud配置中心</strong>。</li>
</ul>
</blockquote>
<h2 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h2><p>Consul 是 HashiCorp 公司推出的开源工具，用于实现分布式系统的服务发现与配置。与其它分布式服务注册与发现的方案，Consul 的方案更“一站式”，内置了服务注册与发现框 架、分布一致性协议实现、健康检查、Key&#x2F;Value 存储、多数据中心方案，不再需要依赖其它工具（比如 ZooKeeper 等）。</p>
<p>Consul 使用起来也较为简单，使用 Go 语言编写，因此具有天然可移植性(支持Linux、windows和Mac OS X)；安装包仅包含一个可执行文件，方便部署，与 Docker 等轻量级容器可无缝配合。</p>
<h3 id="Consul-的调用过程"><a href="#Consul-的调用过程" class="headerlink" title="Consul 的调用过程"></a>Consul 的调用过程</h3><ol>
<li>当 Producer 启动的时候，会向 Consul 发送一个 post 请求，告诉 Consul 自己的 IP 和 Port；</li>
<li>Consul 接收到 Producer 的注册后，每隔 10s（默认）会向 Producer 发送一个健康检查的请求，检验 Producer 是否健康；</li>
<li>当 Consumer 发送 GET 方式请求 &#x2F;api&#x2F;address 到 Producer 时，会先从 Consul 中拿到一个存储服务 IP 和 Port 的临时表，从表中拿到 Producer 的 IP 和 Port 后再发送 GET 方式请求 &#x2F;api&#x2F;address；</li>
<li>该临时表每隔 10s 会更新，只包含有通过了健康检查的 Producer。</li>
</ol>
<p><img src="/2022/10/25/SpringCloud-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E5%92%8C%E9%80%89%E5%9E%8B/12.png" alt="图片"></p>
<h3 id="Consul-主要特征"><a href="#Consul-主要特征" class="headerlink" title="Consul 主要特征"></a>Consul 主要特征</h3><ul>
<li>CP模型，使用 Raft 算法来保证强一致性，不保证可用性；</li>
<li>支持服务注册与发现、健康检查、KV Store功能。</li>
<li>支持多数据中心，可以避免单数据中心的单点故障，而其部署则需要考虑网络延迟, 分片等情况等。</li>
<li>支持安全服务通信，Consul可以为服务生成和分发TLS证书，以建立相互的TLS连接。</li>
<li>支持 http 和 dns 协议接口；</li>
<li>官方提供 web 管理界面。</li>
</ul>
<h3 id="多数据中心"><a href="#多数据中心" class="headerlink" title="多数据中心"></a>多数据中心</h3><blockquote>
<p>这里纯属了解，学习一下 Consul 的多数据中心是如何实现的。</p>
</blockquote>
<p>Consul支持开箱即用的多数据中心，这意味着用户不需要担心需要建立额外的抽象层让业务扩展到多个区域。</p>
<p><img src="/2022/10/25/SpringCloud-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E5%92%8C%E9%80%89%E5%9E%8B/13.png" alt="图片"></p>
<p>在上图中有两个DataCenter，他们通过Internet互联，同时请注意为了提高通信效率，只有Server节点才加入跨数据中心的通信。</p>
<p>在单个数据中心中，Consul分为Client和Server两种节点（所有的节点也被称为Agent），Server节点保存数据，Client负责健康检查及转发数据请求到Server；Server节点有一个Leader和多个Follower，Leader节点会将数据同步到Follower，Server的数量推荐是3个或者5个，在Leader挂掉的时候会启动选举机制产生一个新的Leader。</p>
<p>集群内的Consul节点通过gossip协议（流言协议）维护成员关系，也就是说某个节点了解集群内现在还有哪些节点，这些节点是Client还是Server。单个数据中心的流言协议同时使用TCP和UDP通信，并且都使用8301端口。跨数据中心的流言协议也同时使用TCP和UDP通信，端口使用8302。</p>
<p>集群内数据的读写请求既可以直接发到Server，也可以通过Client使用RPC转发到Server，请求最终会到达Leader节点，在允许数据延时的情况下，读请求也可以在普通的Server节点完成，集群内数据的读写和复制都是通过TCP的8300端口完成。</p>
<h2 id="ETCD"><a href="#ETCD" class="headerlink" title="ETCD"></a>ETCD</h2><p>etcd是一个Go言编写的分布式、高可用的一致性键值存储系统，用于提供可靠的分布式键值存储、配置共享和服务发现等功能。</p>
<h3 id="ETCD-特点"><a href="#ETCD-特点" class="headerlink" title="ETCD 特点"></a>ETCD 特点</h3><ul>
<li>易使用：基于HTTP+JSON的API让你用curl就可以轻松使用；</li>
<li>易部署：使用Go语言编写，跨平台，部署和维护简单；</li>
<li>强一致：使用Raft算法充分保证了分布式系统数据的强一致性；</li>
<li>高可用：具有容错能力，假设集群有n个节点，当有(n-1)&#x2F;2节点发送故障，依然能提供服务；</li>
<li>持久化：数据更新后，会通过WAL格式数据持久化到磁盘，支持Snapshot快照；</li>
<li>快速：每个实例每秒支持一千次写操作，极限写性能可达10K QPS；</li>
<li>安全：可选SSL客户认证机制；</li>
<li>ETCD 3.0：除了上述功能，还支持gRPC通信、watch机制。</li>
</ul>
<h3 id="ETCD-框架"><a href="#ETCD-框架" class="headerlink" title="ETCD 框架"></a>ETCD 框架</h3><p>etcd主要分为四个部分：</p>
<ul>
<li>HTTP Server：用于处理用户发送的API请求以及其它etcd节点的同步与心跳信息请求。</li>
<li>Store：用于处理etcd支持的各类功能的事务，包括数据索引、节点状态变更、监控与反馈、事件处理与执行等等，是etcd对用户提供的大多数API功能的具体实现。</li>
<li>Raft：Raft强一致性算法的具体实现，是etcd的核心。</li>
<li>WAL：Write Ahead Log（预写式日志），是etcd的数据存储方式。除了在内存中存有所有数据的状态以及节点的索引以外，etcd就通过WAL进行持久化存储。WAL中，所有的数据提交前都会事先记录日志。Snapshot是为了防止数据过多而进行的状态快照；Entry表示存储的具体日志内容。</li>
</ul>
<p><img src="/2022/10/25/SpringCloud-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E5%92%8C%E9%80%89%E5%9E%8B/14.png" alt="图片"></p>
<p>通常，一个用户的请求发送过来，会经由HTTP Server转发给Store进行具体的事务处理，如果涉及到节点的修改，则交给Raft模块进行状态的变更、日志的记录，然后再同步给别的etcd节点以确认数据提交，最后进行数据的提交，再次同步。</p>
<p>更多关于ETCD相关知识，可以查看该文章 <a href="https://mp.weixin.qq.com/s?__biz=Mzg3OTU5NzQ1Mw==&mid=2247485759&idx=1&sn=41957e94a2c69426befafd373fbddcc5&chksm=cf034bddf874c2cb52a7aafea5cd194e70308c7d4ad74183db8a36d3747122be1c7a31b84ee3&token=179167416&lang=zh_CN&scene=21#wechat_redirect">《肝了一个月的ETCD，从Raft原理到实践》</a></p>
<h1 id="注册中心对比-amp-选型"><a href="#注册中心对比-amp-选型" class="headerlink" title="注册中心对比&amp;选型"></a>注册中心对比&amp;选型</h1><h2 id="注册中心对比"><a href="#注册中心对比" class="headerlink" title="注册中心对比"></a>注册中心对比</h2><p><img src="/2022/10/25/SpringCloud-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E5%92%8C%E9%80%89%E5%9E%8B/15.png" alt="图片"><img src="https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLH1sibhR8TTTyfnDtlcUfyyVI3Y47K5IuFaUuagpibVt9kMdZkiaeibd9I1k0DqibbAV55gjC6s3ndk9ibA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<ul>
<li><p><strong>服务健康检查</strong>：Euraka 使用时需要显式配置健康检查支持；Zookeeper、Etcd 则在失去了和服务进程的连接情况下任务不健康，而 Consul 相对更为详细点，比如内存是否已使用了90%，文件系统的空间是不是快不足了。</p>
</li>
<li><p><strong>多数据中心</strong>：Consul 和 Nacos 都支持，其他的产品则需要额外的开发工作来实现。</p>
</li>
<li><p><strong>KV 存储服务</strong>：除了 Eureka，其他几款都能够对外支持 k-v 的存储服务，所以后面会讲到这几款产品追求高一致性的重要原因。而提供存储服务，也能够较好的转化为动态配置服务哦。</p>
</li>
<li><p><strong>CAP 理论的取舍</strong>：</p>
</li>
<li><ul>
<li>Eureka 是典型的 AP，Nacos可以配置为 AP，作为分布式场景下的服务发现的产品较为合适，服务发现场景的可用性优先级较高，一致性并不是特别致命。</li>
<li>而Zookeeper、Etcd、Consul则是 CP 类型牺牲可用性，在服务发现场景并没太大优势；</li>
</ul>
</li>
<li><p><strong>Watch的支持</strong>：Zookeeper 支持服务器端推送变化，其它都通过长轮询的方式来实现变化的感知。</p>
</li>
<li><p><strong>自身集群的监控</strong>：除了Zookeeper和Nacos，其它几款都默认支持 metrics，运维者可以搜集并报警这些度量信息达到监控目的。</p>
</li>
<li><p><strong>Spring Cloud的集成</strong>：目前都有相对应的 boot starter，提供了集成能力。</p>
</li>
</ul>
<h2 id="注册中心选型"><a href="#注册中心选型" class="headerlink" title="注册中心选型"></a>注册中心选型</h2><p>关于注册中心的对比和选型，其实上面已经讲的非常清楚了，我给出一些个人理解：</p>
<ul>
<li><strong>关于CP还是AP的选择</strong>：选择 AP，因为可用性高于一致性，所以更倾向 Eureka 和 Nacos；关于Eureka、Nacos如何选择，哪个让我做的事少，我就选择哪个，显然 Nacos 帮我们做了更多的事。</li>
<li><strong>技术体系</strong>：Etcd 和 Consul 都是Go开发的，Eureka、Nacos、Zookeeper 和 Zookeeper 都是Java开发的，可能项目属于不同的技术栈，会偏向选择对应的技术体系。</li>
<li><strong>高可用</strong>：这几款开源产品都已经考虑如何搭建高可用集群，有些差别而已；</li>
<li><strong>产品的活跃度</strong>：这几款开源产品整体上都比较活跃。</li>
</ul>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpinrgCloud</tag>
        <tag>注册中心</tag>
        <tag>Eureka</tag>
        <tag>Nacos</tag>
        <tag>Etcd</tag>
      </tags>
  </entry>
  <entry>
    <title>SystemDesign-弹幕系统设计</title>
    <url>/2022/10/25/SystemDesign-%E5%BC%B9%E5%B9%95%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>直播业务现在特别火爆，也给人们的互动方式带来了很多新的改变，比如刷礼物、弹幕、排行榜等等。面对巨大的流量规模，直播技术的发展也备受关注。作为一个技术爱好者，相信你也会对直播的技术比较感兴趣，于是我去翻了几篇文章，了解了直播的技术方案，发现涉及到的技术细节太多，有部分已经是知识盲区，如<a href="https://so.csdn.net/so/search?q=%E9%9F%B3%E9%A2%91&spm=1001.2101.3001.7020">音频</a>、视频的编码传输等。</p>
<p>　　直播中弹幕是一个非常亮眼和重要的功能，相比于秒杀架构，直播弹幕系统也有很多有趣的知识可以挖掘，一起来 YY 下如何设计一个直播弹幕系统，不对的地方还请有经验的大佬指出。</p>
<p>　　直播弹幕是一个读写 QPS 要求都很高，假设一个直播间有 100w 用户同时在线观看，假设弹幕的提交频率为有 10000条&#x2F;秒，那么需要每秒同时推送给在线用户的次数为 100w * 10000。由此可见，读请求的吞吐量需要远大于写请求，这点类似于 IM 实时聊天。</p>
<p>　　架构设计考虑以下几个场景：</p>
<p>　　支持直播弹幕回放用户进入直播间可以推送最新几秒的弹幕数据长连模式和短连模式可以做降级切换</p>
<p>　　为了不影响读写的性能，采用读写分离架构。</p>
<p>　　写服务：若不考虑历史弹幕可回放，可以直接使用 Redis 作为唯一存储。若考虑支持弹幕的回放，数据还是需要持久化，可以考虑使用 MySQL 或者 TiDB，暂且认为写入不是较大的瓶颈。如果有更高性能的写需求，HBase、OpenTSDB 等都可以解决问题。读服务：Redis 主要用于读缓存，缓存直播间最新的弹幕数据，采用直播间 ID 作为 Key。系统读服务最大 QPS&#x3D;Redis 集群QPS。</p>
<p>　　Redis 存储结构选择：SortedSet。</p>
<p>　　提交弹幕：ZADD，score 设置为时间戳。进一步优化可以只存储时间的 delta 值，减少数据存储量。弹幕查询：ZRANGEBYSCORE 定时轮询弹幕数据。</p>
<p>　　有什么问题？</p>
<p>　　系统性能与 Redis 集群容量强相关，性能提升需要扩容 Redis，成本高。Redis 重复请求较多，相同直播间会存在很多重复的轮询请求。</p>
<p><img src="/2022/10/25/SystemDesign-%E5%BC%B9%E5%B9%95%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/1.png" alt="img"></p>
<p>　　如果能让最新的实时弹幕数据都能命中本地缓存，那性能是最高的，同时大幅度降低了 Redis 的读取压力。所以弹幕读服务可以每秒轮询 Redis 数据，构建本地缓存。</p>
<p>　　热点问题：</p>
<p>　　假设同时在线的直播间有 10000 个，读服务<a href="https://www.jianfei8.net/">机器</a>有 50 台，那么每秒轮询 Redis 的 QPS&#x3D;10000 * 50&#x3D;50w，读取请求线性膨胀。本地内存的使用量也随直播间的数量增长而膨胀，每个直播间的缓存的数据量降低，导致本地缓存的命中率降低，容易导致 GC 频繁。</p>
<p><img src="/2022/10/25/SystemDesign-%E5%BC%B9%E5%B9%95%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/2.png" alt="img"></p>
<p>　　如何降低本地缓存的使用量？</p>
<p>　　因为火爆的直播间会占据整个平台大部分的流量，可以只针对火爆的直播间开启本地缓存。通过路由控制同一个直播间的请求分发到固定的几台机器，例如一致性 Hash 算法。通过减少读服务机器上的直播间数量，达到降低本地缓存使用量的目的。</p>
<p><img src="/2022/10/25/SystemDesign-%E5%BC%B9%E5%B9%95%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/3.png" alt="img"></p>
<p>　　上述方法可以有效地解决问题，但是不能解决流量不均衡的问题。不同直播间分配的机器资源不是拍脑袋定的，需要有理论依据， 可以根据直播间的一些数据指标进行动态分配机器资源。</p>
<p>　　增加对直播间数据指标的统计，如单机 QPS、集群 QPS、单机直播间在线数等。关于自适应的负载均衡又是一个可以深挖的话题，在这里我们讨论几个常用的方案，有可能结合起来使用效果更好。分桶：不同 QPS 的范围段划分为不同的桶，根据桶范围的不同分配的机器数量也是不同的。最大最小公平分配：根据直播间的 QPS 划分资源需求的权重比例，根据总机器的数量和权重比例来分配机器数量。启发式算法：遗传算法、蚁群算法等。</p>
<p>　　单元化可以说是解决性能容量以及容灾的杀手锏。实现单元化需要完成有很多重要的工作，如数据同步 DRC、流量调度等，在此不作展开。</p>
<p>　　</p>
<p><img src="/2022/10/25/SystemDesign-%E5%BC%B9%E5%B9%95%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/4.png" alt="img"></p>
<p>　　推荐一篇携程的 DRC 实践： 携程异地多活-MySQL实时双向（多向）复制实践</p>
<p>　　为了保障客户端消息的推送性能和实时性，长连接基本是必备的，最新的消息可以直接采用长连接实时推送。</p>
<p>　　Push Server 从 Redis 中获取用户和直播间的订阅关系以及长连接信息。连接代理只负责与客户端保持长连接。海量的消息推送需要批量压缩。</p>
<p><img src="/2022/10/25/SystemDesign-%E5%BC%B9%E5%B9%95%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/5.png" alt="img"></p>
<p>　　增加一组专门用于回放的 Redis 集群，同时增加回放的本地缓存，其余设计与上述方案保持一致。</p>
<p>　　抱着学习的心态，思考了直播弹幕系统的架构应该如何设计，本文主要讨论了以下几个点：</p>
<p>　　读写分离的架构设计通过缓存优化读性能通过路由规则解决直播间流量不均衡的热点问题长连接的方案设计以及客户端的消息推送</p>
<p>　　暂时就 YY 这么多吧，做好一个系统还有需要细节需要考虑：高可用、监控、限流降级、延迟优化等。有什么错误和好的实践经验欢迎留言。</p>
]]></content>
      <categories>
        <category>SystemDesign</category>
      </categories>
      <tags>
        <tag>SystemDesign</tag>
        <tag>系统设计</tag>
        <tag>弹幕系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring循环依赖</title>
    <url>/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<p>众所周知spring在默认单例的情况下是支持循环引用的</p>
<p>为了节省图片大小我把那些可以动得gif图片做成了只循环一次，如果看到图片不动了请右键选择在新标签打开，那么图片就会动，手机用户则更简单，直接手指点击图片便能看到动图，每张gif我都标识了，如果没有标识则为静态图片；</p>
<p><code>Appconfig.java</code>类的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configurable</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.shadow&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Appconfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>X.java</code>类的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shadow.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	Y y;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">X</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;X create&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>Y.java</code>类的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shadow.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Y</span> &#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	X x;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Y</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Y create&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这两个类非常简单，就是相互引用了对方，也就是我们常常的说的循环依赖，spring是允许这样的循环依赖(前提是单例的情况下的,非构造方法注入的情况下)</p>
<p><strong>运行这段代码的结果下图</strong></p>
<blockquote>
<p>注意这是张gif，如果你看着不动请参考我上面说的方法</p>
</blockquote>
<p><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/1.png" alt="在这里插入图片描述"></p>
<p>上面代码从容器中能正常获取到<code>Xbean</code>，说明循环依赖成功。但是spring的循环依赖其实是可以关闭的，spring提供了api来关闭循环依赖的功能。当然你也可以修改<code>spring</code>源码来关闭这个功能，这里笔者为了提高逼格，就修改一下spring的源码来关闭这个功能，老话说:要想高明就得装逼。<br>下图是我修改spring源码运行的结果<br>我在<code>AnnotationConfigApplicationContext</code>的构造方法中加了一行<code>setAllowCircularReferences(false)</code>;结果代码异常，循环依赖失败<br><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/2.png" alt="在这里插入图片描述"></p>
<p>那么为什么<code>setAllowCircularReferences(false);</code>会关闭循环依赖呢？首要明白spring的循环依赖是怎么做到的呢？spring源码当中是如何处理循环依赖的？ 分析一下所谓的循环依赖其实无非就是属性注入，或者就是大家常常说的自动注入， 故而搞明白循环依赖就需要去研究spring自动注入的源码；spring的属性注入属于spring bean的生命周期一部分；怎么理解spring bean的生命周期呢？注意笔者这里并不打算对bean的生命周期大书特书，只是需要读者理解生命周期的概念，细节以后在计较；<br>要理解bean的生命周期首先记住两个概念<br>请读者一定记住两个概念——spring bean（以下简称bean）和对象；<br>1、<strong>spring bean</strong>——受spring容器管理的对象，可能经过了完整的spring bean生命周期（为什么是可能？难道还有bean是没有经过bean生命周期的？答案是有的，具体我们后面文章分析），最终存在spring容器当中；一个bean一定是个对象<br>2、<strong>对象</strong>——任何符合java语法规则实例化出来的对象，但是一个对象并不一定是spring bean；</p>
<p>所谓的bean的生命周期就是磁盘上的类通过spring扫描，然后实例化，跟着初始化，继而放到容器当中的过程；<br>我画了一张简单图来阐述一下spring bean的生命周期大概有哪些步骤<br><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/3.png" alt="在这里插入图片描述"></p>
<p>上图就是spring容器初始化bean的大概过程(至于详细的过程，后面文章再来介绍)；<br>文字总结一下：<br>1：实例化一个ApplicationContext的对象；<br>2：调用bean工厂后置处理器完成扫描；<br>3：循环解析扫描出来的类信息；<br>4：实例化一个BeanDefinition对象来存储解析出来的信息；<br>5：把实例化好的beanDefinition对象put到<code>beanDefinitionMap</code>当中缓存起来，以便后面实例化bean；<br>6：再次调用bean工厂后置处理器；<br>7：当然spring还会干很多事情，比如国际化，比如注册BeanPostProcessor等等，如果我们只关心如何实例化一个bean的话那么这一步就是spring调用<code>finishBeanFactoryInitialization</code>方法来实例化单例的bean，实例化之前spring要做验证，需要遍历所有扫描出来的类，依次判断这个bean是否Lazy，是否prototype，是否abstract等等；<br>8：如果验证完成spring在实例化一个bean之前需要推断构造方法，因为spring实例化对象是通过构造方法反射，故而需要知道用哪个构造方法；<br>9：推断完构造方法之后spring调用构造方法反射实例化一个对象；注意我这里说的是对象、对象、对象；这个时候对象已经实例化出来了，但是并不是一个完整的bean，最简单的体现是这个时候实例化出来的对象属性是没有注入，所以不是一个完整的bean；<br>10：spring处理合并后的beanDefinition(合并？是spring当中非常重要的一块内容，后面的文章我会分析)；<br>11：判断是否支持循环依赖，如果支持则提前把一个工厂存入singletonFactories——map；<br>12：判断是否需要完成属性注入<br>13：如果需要完成属性注入，则开始注入属性<br>14：判断bean的类型回调Aware接口<br>15：调用生命周期回调方法<br>16：如果需要代理则完成代理<br>17：put到单例池——bean完成——存在spring容器当中</p>
<p>用一个例子来证明上面的步骤，结合一些运行时期的动态图片</p>
<p>为了节省图片大小我把那些可以动得gif图片做成了只循环一次，如果看到图片不动了请右键选择在新标签打开，那么图片就会动，手机用户则更简单，直接手指点击图片便能看到动图，每张gif我都标识了，如果没有标识则为静态图片；</p>
<p><code>Z.java</code>的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shadow.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Z</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	X x;<span class="comment">//注入X</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Z</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Z create&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生命周期初始化回调方法</span></span><br><span class="line">	<span class="meta">@PostConstruct</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">zinit</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;call z lifecycle init callback&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ApplicationContextAware 回调方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext ac)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;call aware callback&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>来看看Z的生命周期，注意下图当中的字幕，会和上面的17个步骤一一对应<br><strong>下图是第一步到第六步，请自行对应</strong><br>接下来我们通过各种图片分析一下springbean的生命周期，读者只需要看图搞明白流程，至于图中涉及的源码，分析完流程之后再来解释；</p>
<blockquote>
<p><strong>图① 注意这是张gif，如果你看着不动请参考我上面说的方法</strong></p>
</blockquote>
<p><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/4.png" alt="在这里插入图片描述"></p>
<p>在研究其他步骤之前，首先了解spring大概在什么时候实例化bean的</p>
<blockquote>
<p><strong>图② 注意这是张gif，如果你看着不动请参考我上面说的方法</strong></p>
</blockquote>
<p><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/5.png" alt="在这里插入图片描述"></p>
<p>上图可以知道spring在<code>AbstractApplicationContext#finishBeanFactoryInitialization</code>方法中完成了bean的实例化。这点需要记住</p>
<p><strong>然后通过图片来说明一下第7步</strong></p>
<blockquote>
<p><strong>图③ 注意这是张gif，如果你看着不动请参考我上面说的方法</strong></p>
</blockquote>
<p><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/6.png" alt="在这里插入图片描述"></p>
<p>接下来spring需要推断构造方法，然后通过推断出来的构造方法反射实例化对象，也就是上面说的<strong>第</strong>8<strong>步和第</strong>9<strong>步</strong></p>
<blockquote>
<p>当然有可能推断不出来构造方法；关于这块知识博主后面更新文章</p>
</blockquote>
<blockquote>
<p><strong>图④ 注意这是张gif，如果你看着不动请参考我上面说的方法</strong></p>
</blockquote>
<p><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/7.png" alt="在这里插入图片描述"></p>
<p>上图说明spring是通过<code>createBeanInstance(beanName, mbd, args);</code>完成了推断构造方法和实例化的事情那么接下来便要执行<strong>第10步处理合并后的beanDefinition对象</strong>，这一块内容特别多，读者可以先不必要理解，后面文章会解释；</p>
<blockquote>
<p><strong>图⑤ 注意这是张gif，如果你看着不动请参考我上面说的方法</strong></p>
</blockquote>
<p><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/8.png" alt="在这里插入图片描述"></p>
<p>仔细看上图，其实这个时候虽然Z被实例化出来了，但是并没有完成属性的注入；其中的X属性为null，而且里面的Aware接口的方法也没有调用，再就是<code>@PostConstruct</code>方法也没有调用，再一次说明他不是一个完整的bean，这里我们只能说z是个对象；<br>继而<code>applyMergedBeanDefinitionPostProcessors</code>方法就是用来处理合并后的beanDefinition对象；</p>
<p>跟着第11步，判断是否支持循环依赖，如果支持则提前暴露一个工厂对象，注意是工厂对象</p>
<blockquote>
<p><strong>图⑥ 注意这是张gif，如果你看着不动请参考我上面说的方法</strong></p>
</blockquote>
<p><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/9.png" alt="在这里插入图片描述"></p>
<p><strong>第12步</strong>，spring会判断是否需要完成属性注入（spring默认是需要的，但是程序员可以扩展spring，根据情况是否需要完成属性注入）；如果需要则spring完成<strong>13步</strong>——属性注入，也就是所谓的自动注入；</p>
<blockquote>
<p><strong>图⑦ 注意这是张gif，如果你看着不动请参考我上面说的方法</strong></p>
</blockquote>
<p><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/10.png" alt="在这里插入图片描述"></p>
<p>第<strong>14、15、16</strong>步</p>
<blockquote>
<p><strong>图⑧ 注意这是张gif，如果你看着不动请参考我上面说的方法</strong></p>
</blockquote>
<p><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/11.png" alt="在这里插入图片描述"></p>
<p>默认情况 至此一个bean完成初始化，被put到单例池，也是对上文说的17个步骤的一个证明；这说明一个bean在spring容器当中被创建出来是有一个过程的，这个过程就是所谓的bean的生命周期，我们的循环依赖也是在这个生命周内完成的。下面我们具体来分析这些步骤</p>
<blockquote>
<p>由于bean的生命周期特别复杂本文只对涉及到循环依赖的步骤做分析，其他生命周期的步骤我会在后续博客中分析，可以继续关注博主</p>
</blockquote>
<p>回顾上面的图② 和 图③ 我们知道spring的bean是在<code>AbstractApplicationContext#finishBeanFactoryInitialization()</code>方法完成的初始化，即循环依赖也在这个方法里面完成的。该方法里面调用了一个非常重要的方法 <code>doGetBean</code>的方法</p>
<p>照例用图片来说明一下吧</p>
<blockquote>
<p><strong>图⑨ 注意这是张gif，如果你看着不动请参考我上面说的方法</strong></p>
</blockquote>
<p><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/12.png" alt="在这里插入图片描述"></p>
<p><code>doGetBean</code>方法内容有点多，这个方法非常重要，不仅仅针对循环依赖，甚至整个spring bean生命周期中这个方法也有着举足轻重的地位，读者可以认真看看笔者的分析。需要说明的是我为了更好的说清楚这个方法，我把代码放到文章里面进行分析；但是删除了一些无用的代码；比如日志的记录这些无关紧要的代码。下面重点说这个<code>doGetBean</code>方法</p>
<p>首先笔者把精简后的代码贴出来方便大家阅读</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, </span></span><br><span class="line"><span class="params">					<span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span><br><span class="line"><span class="params">      				<span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, </span></span><br><span class="line"><span class="params">      				<span class="type">boolean</span> typeCheckOnly)</span></span><br><span class="line">      				<span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">//读者可以简单的认为就是对beanName做一个校验特殊字符串的功能</span></span><br><span class="line">    <span class="comment">//我会在下次更新博客的时候重点讨论这个方法</span></span><br><span class="line">    <span class="comment">//transformedBeanName(name)这里的name就是bean的名字</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//定义了一个对象，用来存将来返回出来的bean</span></span><br><span class="line">   Object bean;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//deGetBean-1</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">   </span><br><span class="line">	<span class="comment">//deGetBean-2</span></span><br><span class="line">	<span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line">      bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="literal">null</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   		deGetBean-<span class="number">3</span></span><br><span class="line">   		<span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">         	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      	<span class="comment">//doGetBean-4</span></span><br><span class="line">      	<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">            sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                  destroySingleton(beanName);</span><br><span class="line">                  <span class="keyword">throw</span> ex;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：上面的代码是我对doGetBean方法进行了删减的代码，只保留了和本文讨论的循环依赖有关的代码，完整版可以参考spring的源码<code>org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean</code></p>
<p>接着笔者对上述代码逐行来解释</p>
<blockquote>
<p>1、deGetBean-1</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/13.png" alt="在这里插入图片描述"></p>
<p>首先这行代码上有一句spring作者写的注释</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Eagerly check singleton cache <span class="keyword">for</span> manually registered singletons.</span><br></pre></td></tr></table></figure>

<p>大概的意思就是检查一下单例池当中有没有手动注册的单例对象，说白了spring在创建一个bean之前先检查一下<code>beanName</code>是否被手动注册过到单例池当中；别小看这句spring作者写的javadoc背后的意义，其实这里有两重意思；要搞清楚这两重意思首先知道当代码执行到这里的时候其实是spring在初始化的时候执行过来的；既然spring在初始化的时候他肯定知道这个类X.java肯定没有在容器当中，为什么还需要去验证一下呢？好比说你第一次去天上人间，你几乎都能确定这是你一次去你不可能跑到那里问一下前台你有没有办会员吧？但是spring确这样做了，他问了，他问问自己有没有办会员；为什么呢？回到你自己，如果你去问自己有没有办会员无非就是怕别人拿着你的身份证去办了一个会员，或者各种原因阴差阳错别人吧身份证名字写错了，导致你成了天上人间的会员；其实spring也是这个意思，因为一个bean被put到单例池的渠道有很多；除了spring容器初始化—扫描类—-实例化—–put到容器这条线之外还有很多方法可以把一个对象put到单例池；我这里只列举一种，其他的有机会再讨论，看下图 注意注释；<br><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/14.png" alt="在这里插入图片描述"></p>
<p>这就相当于在你第一次抱着紧张心态去天上人间的时候，发现你朋友以前拿着你的身份证去那里办了一个会员卡一样；</p>
<p>所以上面提到的这句注释的两重意思①第一重意思判断spring当前正准备初始化的bean有没有提前被put到容器；<br>那么第二重意思是什么呢？既然这里用来做spring初始化的工作，为什么这个方法名叫做doGetBean呢？讲道理应该叫做createBean啊才合理啊；有读者可能会说这个方法命名可能作者乱写的，请注意spring之所以经久不衰命名规范绝对是一个重要原因，作者是不会这么乱给方法命名的。诚然有的读者会说讨论这个的意义不大，其实博主觉得讨论这个非常重要；之所这里叫做doGetBean的原因就是因为这个方法就是用来获取bean的，他主要的工作不仅仅服务于spring bean的初始化；这个方法的作用不仅仅是为了spring 在初始化bean的过程中去判断一下这个bean是否被注册了这么简单；笔者认为这个方法最主要的作用是为了从容器中得到一个bean，也就是说当我们在spring代码中调用getBean(“a”)其背后的意义就是调用这个doGetBean，同样用一段代码来证明</p>
<blockquote>
<p><strong>图⑩ 注意这是张gif，如果你看着不动请参考我上面说的方法</strong></p>
</blockquote>
<p><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/15.png" alt="在这里插入图片描述"></p>
<p>可以看到当我调用ac.getBean(“x”)的时候，底层其实就调用doGetBean获取这X对象的；spring之所以这么设计就是因为判断bean是否初始化好和get一个bean都需要从单例池当中获取，所以创建bean和getBean都需要调用这个doGetBean方法；也就是第②重意思，这个方法其实就是程序员getBean的底层实现；</p>
<p>换成天上人间，你第一次跑去前台，人家前台直接说：先生请出示会员卡；你可能会奇怪——我是来全套的，你应该问我要什么服务，不是问会员卡；但是人家前台的职责有两，办会员和问你要什么服务；所以才会说出这句话；doGetBean也是这个意思，于是解释了这个方法名的意义了；</p>
<p>总结一下 <code>Object sharedInstance = getSingleton(beanName);</code>目前看来主要是用于在spring初始化bean的时候判断bean是否在容器当中；以及供程序员直接get某个bean。</p>
<p>注意笔者这里用了 目前这个词；因为getSingleton(beanName);这个方法代码比较多；他里面的逻辑是实现循环依赖最主要的代码，文章下面我会回过头再来讲这个方法的全部意义；</p>
<p>请注意我们当前代码的场景，当前代码是spring容器在初始化的时候，初始化X这个bean的场景；运行到了<code>Object sharedInstance = getSingleton(beanName);</code><br>根据上面的分析，这个时候我的X Bean肯定没有被创建，所以这里返回<code>sharedInstance = =null</code>；</p>
<blockquote>
<p>跟着解析 <code>//deGetBean-2</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//deGetBean-2</span></span><br><span class="line"><span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line">  bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="literal">null</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于 <code>sharedInstance = =null</code> 故而不会进入这个if分支，那么什么时候不等于null呢？两种情况1、在spring初始化完成后程序员调用getBean(“x”)的时候得到的sharedInstance 就不等于null；2、循环依赖的时候第二次获取对象的时候这里也不等于空；比如X 依赖 Y；Y依赖X；spring做初始化第一次执行到这里的时候X 肯定等于null，然后接着往下执行，当执行到属性注入Y的时候，Y也会执行到这里，那么Y也是null，因为Y也没初始化，Y也会接着往下执行，当Y执行到属性注入的时候获取容器中获取X，也就是第二次执行获取X；这个时候X则不为空；至于具体原因，读者接着往下看；</p>
<p>至于这个if分支里面的代码干了什么事情，本文不讨论，放到后面写factoryBean的时候讨论，现在你可以理解if分支里面就把sharedInstance 原原本本的返回出来就行；即这个if分支没有意义；</p>
<p>上文说了本次不进入if分支，所以这行代码解析完毕；</p>
<blockquote>
<p>接下解析 doGetBean -3</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">   		deGetBean-<span class="number">3</span></span><br><span class="line">   		<span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">         	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">如果把<span class="keyword">throw</span>删了可能更加清晰吧，下面是删除后的代码</span><br><span class="line"><span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不进if分支，则进入这个else分支，把throw删了 就一句代码；判断当前初始化的bean—-X 是不是正在创建原型bean集合当中当中？<br>spring源码当中关于这行代码有两行javadoc</p>
<p><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/16.png" alt="在这里插入图片描述"></p>
<p>比较简单我就不翻译了，一般情况下这里返回false，也就是不会进入if分支抛异常；为什么呢说一般情况下呢？首先这里是判断当前的类是不是正在创建的原型集合当中，即里面只会存原型；一般情况下我们的类不是原型，而是单例的，大家都知道spring默认是单例；所以返回false，再就是即使这个bean是原型也很少会在这里就存在<strong>正在创建的原型集合</strong>当中。因为不管单例还是原型，bean在创建的过程中会add到这个集合当中，但是创建完成之后就会从这个集合remove掉（关于这个文章后面有证明），原型情况第一次创建的时候会add到这个集合，但是不是在这里，而是在后面的创建过程中add，所以这里肯定不会存在，即使后面过程中add到这个集合了，但是创建完成之后也会remove掉，故而下一次实例化同一个原型bean（原型可以实例化无数次）的时候当代码执行到这里也不可能存在集合当中了；除非循环依赖会在bean还没有在这个集合remove之前再次判断一次，才有可能会存在，故而我前面说了一般情况下这里都返回false；那么单例情况我们已经说了一定返回false，原型情况只有循环依赖才会成立，但是只要是正常人就不会对原型对象做循环依赖的；即使你用原型做了循环依赖这里也出抛异常（因为if成立，进入分支 throw exception）。再一次说明原型不支持循环依赖（当然你非得用原型做循环依赖，其实有办法，以后文章说明，本文忽略）；画了一幅图说明上面的文字，因为这个集合非常重要，但是读者如果这里不理解也没关系，文章下面我还会结合代码分析一次；</p>
<p><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/17.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>重点来了：说明叫做正在创建的原型集合呢？ 还有一个与之对应的叫做正在创建的单例集合<br>唯一的区别就是集合里面存的是单例和原型<br>故而我们统称正在创建的集合，关于正在创建的集合是什么我下面会解释<br>但是需要记住的，这个集合是我的一家之言，说白了这是笔者自己翻译的，叫做正在创建的集合，没有官方支持，至少我也没在书上看到过这个名词</p>
</blockquote>
<blockquote>
<p>下面解析doGetBean-4</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">      	<span class="comment">//doGetBean-4</span></span><br><span class="line">      	<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">            sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                  destroySingleton(beanName);</span><br><span class="line">                  <span class="keyword">throw</span> ex;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">   同样把抛异常的代码删了，如下</span><br><span class="line">   	<span class="comment">//doGetBean-4</span></span><br><span class="line">      	<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">            sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">                  <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码有点多；<code>if (mbd.isSingleton())</code> 比较简单，判断当前bean是否单例；本文环境下是成立的；继而</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">                  <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里又调用了一次getSingleton，如果有印象上面也调用了一次getSingleton，这是方法重载，两个getSingleton方法并不是同一个方法，读者自己看参数就行，为了区别我这这里叫做第二次调用getSingleton；上文的叫做第一次调用getSingleton；</p>
<p>由于这里使用lamda表达式，有些读者看起来不是很理解；笔者改一下吧</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectFactory&lt;?&gt;  singletonFactory = <span class="keyword">new</span> <span class="title class_">ObjectFactory</span>()&#123;</span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">//其实这是个抽象类，不能实例化</span></span><br><span class="line">		<span class="comment">//createBean是子类实现的，这里就不关心了</span></span><br><span class="line">		<span class="comment">//你就理解这不是一个抽象类吧</span></span><br><span class="line">		<span class="type">AbstractBeanFactory</span> <span class="variable">abf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AbstractBeanFactory</span>();</span><br><span class="line">		<span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> abf.createBean(beanName, mbd, args);</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//传入 beanName 和singletonFactory 对象</span></span><br><span class="line">sharedInstance = getSingleton(beanName,singletonFactory);</span><br><span class="line"></span><br><span class="line">这样看是不是明白多了呢？</span><br></pre></td></tr></table></figure>

<p>当然第二次getSingleton就会把我们bean创建出来，换言之整个bean如何被初始化的都是在这个方法里面；至此本文当中笔者例举出来的doGetBean方法的核心代码看起来解析完成了；</p>
<p>注意我说的是本文当中例举的doGetBean代码，前面我已经说了我删了很多和循环依赖无关的代码，实际spring源码当中这个方法的代码很多，以后文章介绍吧；</p>
<p>接下来就要研究第二次getSingleton方法的内容了，因为我说了整个bean初始化过程都在里面体现了；</p>
<p>我先把spring源码贴出来，读者可以忽略这里，因为下面会精简代码；之所以贴出源码就是想告诉读者，为了研究循环依赖，本文中的很代码我是做了删减的；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring源码：-----读者可以忽略</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">		Assert.notNull(beanName, <span class="string">&quot;Bean name must not be null&quot;</span>);</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">			<span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">			<span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationNotAllowedException</span>(beanName,</span><br><span class="line">							<span class="string">&quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot;</span> +</span><br><span class="line">							<span class="string">&quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(<span class="string">&quot;Creating shared instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				beforeSingletonCreation(beanName);</span><br><span class="line">				<span class="type">boolean</span> <span class="variable">newSingleton</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">				<span class="type">boolean</span> <span class="variable">recordSuppressedExceptions</span> <span class="operator">=</span> (<span class="built_in">this</span>.suppressedExceptions == <span class="literal">null</span>);</span><br><span class="line">				<span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">					<span class="built_in">this</span>.suppressedExceptions = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					singletonObject = singletonFactory.getObject();</span><br><span class="line">					newSingleton = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">					<span class="comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span></span><br><span class="line">					<span class="comment">// if yes, proceed with it since the exception indicates that state.</span></span><br><span class="line">					singletonObject = <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">					<span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">						<span class="keyword">throw</span> ex;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">					<span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">						<span class="keyword">for</span> (Exception suppressedException : <span class="built_in">this</span>.suppressedExceptions) &#123;</span><br><span class="line">							ex.addRelatedCause(suppressedException);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">throw</span> ex;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">finally</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">						<span class="built_in">this</span>.suppressedExceptions = <span class="literal">null</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					afterSingletonCreation(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">					addSingleton(beanName, singletonObject);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> singletonObject;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面是我删减后只和循环依赖有关的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; </span></span><br><span class="line"><span class="params">singletonFactory)</span> &#123;</span><br><span class="line">	<span class="comment">//getSingleton2 -1</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">			<span class="comment">//getSingleton2 -2</span></span><br><span class="line">			<span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="comment">//getSingleton2 -3</span></span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(beanName,</span><br><span class="line">							<span class="string">&quot;excepition&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//getSingleton2 -4</span></span><br><span class="line">				beforeSingletonCreation(beanName);</span><br><span class="line">				<span class="comment">//getSingleton2 -5</span></span><br><span class="line">				singletonObject = singletonFactory.getObject();	</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> singletonObject;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&#x2F;&#x2F;getSingleton2 -1 开始解析</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br></pre></td></tr></table></figure>

<p>第二次getSingleton上来便调用了this.singletonObjects.get(beanName)，直接从单例池当中获取这个对象，由于这里是创建故而一定返回null；singletonObjects是一个map集合，即所谓的单例池；用大白话说spring所有的单例bean实例化好都存放在这个map当中，这也是很多读者以前认为的spring容器，但是笔者想说这种理解是错误的，因为spring容器的概念比较抽象，而单例池只是spring容器的一个组件而已；但是你如果一定要找一个平衡的说法，只能说这个map——singletonObjects仅仅是狭义上的容器；比如你的原型bean便不在这个map当中，所以是狭义的spring容器；下图为这个map在spring源码当中的定义<br><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/18.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>&#x2F;&#x2F;getSingleton2 -2 开始解析</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">上面解释了，在spring 初始化bean的时候这里肯定为空，故而成立</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&#x2F;&#x2F;getSingleton2 -3 开始解析</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(beanName,</span><br><span class="line">				<span class="string">&quot;excepition&quot;</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>这行代码其实比较简单，判断当前实例化的bean是否正在销毁的集合里面；spring不管销毁还是创建一个bean的过程都比较繁琐，都会先把他们放到一个集合当中标识正在创建或者销毁；所以如果你理解了前面那个正在创建集合那么这个正在销毁集合也就理解了；但是不理解也没关系，下面会分析这些集合；</p>
<p>如果一个bean正在创建，但是有正在销毁那么则会出异常；为什么会有这种情况？其实也很简单，多线程可能会吧；</p>
<blockquote>
<p>&#x2F;&#x2F;getSingleton2 -4 假设解析</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">beforeSingletonCreation(beanName);</span><br></pre></td></tr></table></figure>

<p>这段代码就比较重要了，关于上面说那个正在创建和正在销毁的集合；这段代码就能解释，所以如果上面你没看明白那个集合的意义，笔者这里用spring源码来说明一下；先看看当代码执行到这里的时候语境</p>
<p><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/19.png" alt="在这里插入图片描述"></p>
<p>当spring觉得可以着手来创建bean的时候首先便是调用<code>beforeSingletonCreation(beanName);</code>判断当前正在实例化的bean是否存在正在创建的集合当中，说白了就是判断当前是否正在被创建；因为spring不管创建原型bean还是单例bean，当他需要正式创建bean的时候他会记录一下这个bean正在创建(add到一个set集合当中)；故而当他正式创建之前他要去看看这个bean有没有正在被创建（是否存在集合当中）; 为什么spring要去判断是否存在这个集合呢？原因很多除了你们能想到了（你们能想到的基本不会出现，比如并发啊，重复创建什么的，因为他已经做了严格并发处理），其实这个集合主要是为了循环依赖服务的，怎么服务的呢？慢慢看吧，首先我们来看下这行 代码的具体内容<br><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/20.png" alt="在这里插入图片描述"></p>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeSingletonCreation</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">this</span>.inCreationCheckExclusions.contains(beanName) &amp;&amp; !<span class="built_in">this</span>.singletonsCurrentlyInCreation.add(beanName)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>1、<code>this.inCreationCheckExclusions.contains(beanName)</code>这里是判断当前需要创建的bean是否在Exclusions集合，被排除的bean，程序员可以提供一些bean不被spring初始化（哪怕被扫描到了，也不初始化），那么这些提供的bean便会存在这个集合当中；一般情况下我们不会提供，而且与循环依赖无关；故而所以这里不做深入分析，后面文章如果写到做分析；</p>
<p><code>this.singletonsCurrentlyInCreation.add(beanName)</code>，如果当前bean不在排除的集合当中那么则这个bean添加到singletonsCurrentlyInCreation（当然这里只是把bean名字添加到集合，为了方便我们直接认为把bean添加到集合吧，因为他能根据名字能找打对应的bean）；</p>
<p>关于<code>singletonsCurrentlyInCreation</code>的定义参考下图<br><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/21.png" alt="在这里插入图片描述"></p>
<p>其实就是一个set集合，当运行完<code>this.singletonsCurrentlyInCreation.add(beanName)</code> 之后结果大概如下图这样</p>
<p><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/22.png" alt="在这里插入图片描述"></p>
<p>我们可以通过debug来调试证明一下上面这幅图</p>
<blockquote>
<p>注意这是张gif，如果你看着不动请参考我上面说的方法</p>
</blockquote>
<p><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/23.png" alt="在这里插入图片描述"></p>
<p>结果分析：当代码运行完<code>this.singletonsCurrentlyInCreation.add(beanName)</code>之后可以看到singletonsCurrentlyInCreation集合当中只存在一个x，并且后天并没有执行x的构造方法，说明spring仅仅是把x添加到正在创建的集合当中，但是并没有完成bean的创建(因为连构造方法都没调用)；</p>
<p>请一定注意这个集合的数据情况（目前只有一个x）;因为这和循环依赖有天大的关系；add完x之后代码接着往下执行；</p>
<blockquote>
<p>&#x2F;&#x2F;getSingleton2 -5 开始分析</p>
</blockquote>
<p><code>singletonObject = singletonFactory.getObject();</code><br>可能有读者已经忘记了singletonFactory这个对象怎么来的了；笔者再把代码贴一遍吧</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectFactory&lt;?&gt;  singletonFactory = <span class="keyword">new</span> <span class="title class_">ObjectFactory</span>()&#123;</span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">//其实这是个抽象类，不能实例化</span></span><br><span class="line">		<span class="comment">//createBean是子类实现的，这里就不关心了</span></span><br><span class="line">		<span class="comment">//你就理解这不是一个抽象类吧</span></span><br><span class="line">		<span class="type">AbstractBeanFactory</span> <span class="variable">abf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AbstractBeanFactory</span>();</span><br><span class="line">		<span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> abf.createBean(beanName, mbd, args);</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//传入 beanName 和singletonFactory 对象</span></span><br><span class="line">sharedInstance = getSingleton(beanName,singletonFactory);</span><br></pre></td></tr></table></figure>

<p><code>singletonFactory.getObject();</code>调用的就是上面代码中getObject方法，换言之调用的是<code>abf.createBean(beanName, mbd, args)；</code>把创建好的bean返回出来；至此第二次<code>getSingleton</code>方法结束，bean通过<code>singletonFactory.getObject();</code>调用createBean建完成；接下来分析createBean的源码，继续探讨循环依赖的原理；</p>
<p><code>AbstractAutowireCapableBeanFactory#createBean()</code>方法中调用了<code>doCreateBean</code>方法创建bean；下图是dubug流程</p>
<blockquote>
<p>注意这是张gif，如果你看着不动请参考我上面说的方法</p>
</blockquote>
<p><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/24.png" alt="在这里插入图片描述"></p>
<p>结果分析：因为执行完doCreateBean之后X和Y的构造方法都已经完成了调用，说明这个方法里面对X做了实例化，也就是把bean创建好了，而且完成了循环依赖(因为Y的构造方法也打印说明X在完成属性注入的时候注入了Y，所以Y也实例化了，Y bean也创建好了)；接下来重点分析这个doCreateBean方法内容。</p>
<p>我先给出这个方法的源码全貌；重点我用红色标记了，并且会在进行代码解析；黄色线下面的读者可以不用管，和本文内容没多大关系；</p>
<p>读者可以好好看看下图：方便你阅读下面的代码解析<br><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/25.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>&#x2F;&#x2F;doCreateBean -1</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br></pre></td></tr></table></figure>

<p>createBeanInstance 顾名思义就是创建一个实例，注意这里仅仅是创建一个实例对象，还不能称为bean；因为我文章一开头就解释了什么是bean，什么是对象；好吧再啰嗦一下吧，文章比较长，不方便翻阅；</p>
<p>1、<strong>spring bean</strong>——受spring容器管理的对象，可能经过了完整的spring bean生命周期（为什么是可能？难道还有bean是没有经过bean生命周期的？答案是有的，具体我们后面文章分析），最终存在spring容器当中；一个bean一定是个对象<br>2、<strong>对象</strong>——任何符合java语法规则实例化出来的对象，但是一个对象并不一定是spring bean；</p>
<p>同样用dubug来说明一下：</p>
<blockquote>
<p>注意这是张gif，如果你看着不动请参考我上面说的方法</p>
</blockquote>
<p><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/26.png" alt="在这里插入图片描述"></p>
<p>运行完createBeanInstance之后控制打印了X构造方法的内容，说明X对象已经被创建了，但是这个时候的x不是bean，因为bean的生命周期才刚刚开始；这就好比你跑到天上人间，问了各种你想问的问题之后交了1000块钱，但是这个时候你仅仅是个消费者，还不是渣男，因为一条龙的服务是从交钱开始，接下来的各种服务完成你才是一个名副其实的渣男，不知道这么解释有没有偏差；为了把前面知识串起来，照例画一下当前代码的语境吧<br><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/27.png" alt="在这里插入图片描述"></p>
<p>这个createBeanInstance方法是如何把对象创建出来的呢？对应文章开头说的bean的生命周期一共17步，其中的第8步（推断构造方法）和第9步（利用构造方法反射来实例化对象）；具体如何推断构造方法我会在后面的博客分析；这里截个图看看代码就行，不做分析；</p>
<p>推断构造方法的代码运行结果分析——注意这张图比较长，读者可以多看几遍；因为推断构造方法笔者以为是属于spring源码中特别重要和特别难的一块知识；后面会有单独博客来分析，所以读者可以先多看看这张图；</p>
<blockquote>
<p>注意这是张gif，如果你看着不动请参考我上面说的方法</p>
</blockquote>
<p><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/28.png" alt="在这里插入图片描述"></p>
<p>至此x对象已经实例化出来，代码往下执行到合并beanDefinition，看图吧</p>
<p><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/29.png" alt="在这里插入图片描述"></p>
<p>但是其实合并beanDefinition和本文讨论的循环依赖无关，故而先跳过；</p>
<blockquote>
<p>&#x2F;&#x2F;doCreateBean-2 开始解析</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">		isSingletonCurrentlyInCreation(beanName));</span><br></pre></td></tr></table></figure>

<p>这段代码其实比较简单，就是给<code>earlySingletonExposure</code>这个布尔类型的变量赋值；这个变量的意义是——是否支持（开启了）循环依赖；如果返回true则spring会做一些特殊的操作来完成循环依赖；如果返回false，则不会有特殊操作；</p>
<p>回到天上人间那个问题，好比你去一条龙的时候；人家会分析你是否是雏，如果你是雏则随便给你安排一个技师；当然如果你是笔者这样的资深玩家，可能会安排新亘结衣也说不定；</p>
<p>那么这个布尔变量的赋值逻辑是怎样的呢？上面代码可知三个条件做&amp;&amp;运算，同时成立才会返回true；<br>1、mbd.isSingleton()；判断当前实例化的bean是否为单例；再一次说明原型是不支持循环依赖的；因为如果是原型这里就会返回false，由于是&amp;&amp;运算，整个结果都为false；相当于人家判断你是雏；那么新亘结衣什么的就别想了；在本文环境里X是默认单例的，故而整个条件是true。<br>2、<code>this.allowCircularReferences</code>；整个全局变量spring 默认为true；当然spring提供了api供程序员修改，这个在本文开头笔者解释过(笔者是通过修改spring源码来改变这个值为false)，在没有修改的情况下这里也返回true<br>3、<code>isSingletonCurrentlyInCreation(beanName)；</code>判断当前正在创建的bean是否在正在创建bean的集合当中；还记得前文笔者已经解释过<code>singletonsCurrentlyInCreation</code>这个集合现在里面存在且只有一个x；故而也会返回true；</p>
<p>其实这三种情况需要关心的只有第二种；因为第一种是否单例一般都是成立的，因为如果是原型的循环依赖前面代码已经报错了；压根不会执行到这里；第三种情况也一般是成立，因为这个集合是spring操作的，没有提供api给程序员去操作；而正常流程下代码执行到这里，当前正在创建的bean是一定在那个集合里面的；换句话说这三个条件1和3基本恒成立；唯有第二种情况可能会不成立，因为程序员可以通过api来修改第二个条件的结果；</p>
<p>总结：spring的循环依赖，不支持原型，不支持构造方法注入的bean；默认情况下单例bean是支持循环依赖的，但是也支持关闭，关闭的原理就是设置<code>allowCircularReferences=false；</code>spring提供了api来设置这个值；</p>
<p>至此我们知道<code>boolean earlySingletonExposure=true，</code>那么代码接着往下执行；判断这个变量；<br><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/30.png" alt="在这里插入图片描述"></p>
<p><code>if</code>成立，进入分支；</p>
<blockquote>
<p>&#x2F;&#x2F;doCreateBean-3 开始分析</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">这段代码又用了lamda表达式；笔者为了初学者看懂，还是改成传统代码</span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">new</span> <span class="title class_">ObjectFactory</span>&lt;?&gt;()&#123;</span><br><span class="line">	<span class="keyword">public</span> T <span class="title function_">getObject</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">//至于这个getEarlyBeanReference方法的代码，后面再来说</span></span><br><span class="line">		<span class="comment">// 现在可以理解为就是返回 bean</span></span><br><span class="line">		getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">		<span class="comment">//getEarlyBeanReference 的代码稍微复杂一点，可以简单理解为下面这样</span></span><br><span class="line">		getEarlyBeanReference(beanName, mbd, bean)&#123;</span><br><span class="line">			<span class="keyword">return</span> bean;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">也就是singletonFactory.getObject();其实就是返回当前正在实例化的bean</span><br><span class="line">改完之后的代码可以理解成这样：</span><br><span class="line"></span><br><span class="line">addSingletonFactory(beanName,singletonFactory);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>addSingletonFactory(beanName,singletonFactory);</code>顾名思义添加一个单例工厂；其实这里要非常注意，因为大部分资料里面在说到spring循环依赖的时候都说是提前暴露一个半成品bean；笔者觉得这个不严格；甚至算错误了，所谓的提前暴露就是这里的add，但是我们看到源码并不是add一个bean的，而是add一个工厂对象——singletonFactory；两种说法有什么区别呢？区别可大了，简直天壤之别；我们慢慢分析；这里bean和工厂有什么区别呢？在当前的语境下面bean就是x对象经历完spring生命周期之后；所谓的半成品bean，可能还没有经历完整的生命周期；而工厂对象呢？如果你去ObjectFactory的源码或者直接顾名思义他是一个能够产生对象的工厂，或者叫能够产生bean的工厂；换句话说bean是一个产品，而工厂是产生这些产品的公司；如果还不能理解换成天上人间可能好理解——冰火和全套的区别，冰火是全套里面的一个项目，除了冰火还有其他项目；</p>
<p>那么spring在这里add的是singletonFactory这个工厂对象（这个工厂可以产生半成品对象），而不是一个半成品对象；相当于这里add的是全套，而不是冰火；将来拿出来的时候是得到工厂，继而通过工厂得到半成品bean；将来拿出来的是全套，你可以在全套里面肆意选择一个项目；不知道我又没有解释清楚这个问题；</p>
<p>当然说了这么多可能你还是没明白为什么需要在这里add这个工厂对象呢？还有add到哪里去呢？</p>
<p>我们首先分析bean工厂对象到底add到哪里去了，查看源码</p>
<p><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/31.png" alt="在这里插入图片描述"></p>
<p>读者可以好好看看上图，笔者在spring源码当中把注释写上了（注释的信息很重要，认真看看），整个方法其实就是对三个map操作，至于这三个map的意义，参考下图</p>
<p><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/32.png" alt="在这里插入图片描述"></p>
<p>通过代码可以得知singletonFactory主要被add到二级缓存中；至于为什么要add到这个map？主要了循环依赖，提前暴露这个工厂；当然如果你不理解为什么要提前暴露，没关系往下看，看完文章一定会知道的；</p>
<p>保持好习惯照例画个图，让读者知道现在的情况吧</p>
<p><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/33.png" alt="在这里插入图片描述"></p>
<p>当然这里还是用一幅图来秒杀一下这个三个map的各种情况吧</p>
<p><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/34.png" alt="在这里插入图片描述"></p>
<p><strong>一级缓存</strong>：可能存在很多bean，比如spring各种内置bean，比如你项目里面其他的已经创建好的bean，但是在X的创建过程中，一级缓存中绝对是没有xbean的，也没用y；因为spring创建bean默认的顺序是根据字母顺序的；</p>
<p><strong>二级缓存</strong>：里面现在仅仅存在一个工厂对象，对应的key为x的beanName，并且这个bean工厂对象的getObect方法能返回现在的这个时候的x（半成品的xbean）<br>put完成之后，代码接着往下执行；</p>
<p><strong>三级缓存</strong>：姑且认为里面什么都没有吧</p>
<blockquote>
<p>&#x2F;&#x2F;doCreateBean-4 开始解析</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br></pre></td></tr></table></figure>

<p>populateBean这个方法可谓大名鼎鼎，主要就是完成属性注入，也就是大家常常说的自动注入；假设本文环境中的代码运行完这行代码那么则会注入y，而y又引用了x，所以注入进来的y对象，也完成了x的注入；什么意思呢？首先看一下没有执行populateBean之前的情况</p>
<p><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/35.png" alt="在这里插入图片描述"></p>
<p>没有执行populateBean之前只实例化了X，Y并没实例化，那么Y也不能注入了；接下来看看执行完这行代码之后的情况</p>
<p><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/36.png" alt="在这里插入图片描述"></p>
<p>populateBean里面的代码以后我更新文章来说明，本文先来猜测一下这个方法里面究竟干了什么事；<br>x 填充 y （简称 xpy）首先肯定需要获取y，调用getBean(y)，getBean的本质上文已经分析过货进入到第一次调用getSingleton，读者可以回顾一下上文我对doGetBean方法名字的解释里说了这个方法是创建bean和获取共用的；</p>
<p>第一次getSingleton会从单例池获取一下y，如果y没有存在单例池则开始创建y；</p>
<p>创建y的流程和创建x一模一样，都会走bean的生命周期；比如把y添加到正在创建的bean的集合当中，推断构造方法，实例化y，提前暴露工厂对象（二级缓存里面现在有两个工厂了，分别是x和y）等等。。。。重复x的步骤；</p>
<p>直到y的生命周期走到填充x的时候ypx,第一次调用getSingletion获取x？这里问个问题，能否获取到x呢？</p>
<p>在回答这个问题之前我们先把该画的图贴出来，首先那个正在被创建bean的集合已经不在是只有一个x了；（读者可以对比一下上文的图）<br><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/37.png" alt="在这里插入图片描述"></p>
<p>然后我们再把xpy到ypx的流程图贴出来，请读者仔细看看</p>
<p><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/38.png" alt="在这里插入图片描述"></p>
<p>是否能够获取到x呢？首先我们想如果获取失败则又要创建x—&gt;实例化x—填充属性—-获取y——–。。。。。。。就无限循环了；所以结果是完成了循环依赖，那么这里肯定能够获取到x；那么获取到x后流程是怎样呢？</p>
<p><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/39.png" alt="在这里插入图片描述"></p>
<p>那么为什么能够获取到x呢？讲道理联系上文第一次调用getSingleton是无法获取到x的？因为我们上面说过第一次调用getSingleton是从单例池当中获取一个bean，但是x显然没有完成生命周期（x只走到了填充y，还有很多生命周期没走完），所以应该是获取不到的？为了搞清楚这个原因得去查看第一次getSingleton的源码；如果读者有留意的话笔者前面只是凭只管告诉你第一次getSingleton是从单例池当中获取一个bean，并没有去证明，也就是没有去分析第一次getSingleton的源码；而且我在总结第一次getSingleton的时候用了目前这个词；证据如下（图是本文前面的内容，为了翻阅方便我直接贴这里了）</p>
<p><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/40.png" alt="在这里插入图片描述"></p>
<p>显然这是笔者前面故意挖的坑，所以各位读者在阅读别人的文章或者书籍的时候一定要小心验证；包括笔者的文章如果有错误一定记得告诉我；</p>
<p>下面来开始对第一次getSIngleton源码做深入分析；首先把源码以及我写的注释贴出来，分为图片和源代码，建议大家看图片，可读性好</p>
<p><img src="/2022/10/25/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/41.png" alt="在这里插入图片描述"></p>
<p>源码：如果你仔细看了上面的图片可以跳过这里的源码展示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">		<span class="comment">//从单例池当（一级缓存）中直接拿，也就是文章里面&#x27;目前&#x27;的解释</span></span><br><span class="line">		<span class="comment">//这也是为什么getBean(&quot;xx&quot;)能获取一个初始化好bean的根本代码</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">		<span class="comment">//如果这个时候是x注入y，创建y，y注入x，获取x的时候那么x不在容器</span></span><br><span class="line">		<span class="comment">//第一个singletonObject == null成立</span></span><br><span class="line">		<span class="comment">//第二个条件判断是否存在正在创建bean的集合当中，前面我们分析过，成立</span></span><br><span class="line">		<span class="comment">//进入if分支</span></span><br><span class="line">		<span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">				<span class="comment">//先从三级缓存那x？为什么先从三级缓存拿？下文解释</span></span><br><span class="line">				singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">				<span class="comment">//讲道理是拿不到的，因为这三个map现在只有二级缓存中存了一个工厂对象</span></span><br><span class="line">				<span class="comment">//回顾一下文章上面的流程讲工厂对象那里，把他存到了二级缓存</span></span><br><span class="line">				<span class="comment">//所以三级缓存拿到的singletonObject==null  第一个条件成立</span></span><br><span class="line">				<span class="comment">//第二个条件allowEarlyReference=true，这个前文有解释</span></span><br><span class="line">				<span class="comment">//就是spring循环依赖的开关，默认为true 进入if分支</span></span><br><span class="line">				<span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">					<span class="comment">//从二级缓存中获取一个 singletonFactory，回顾前文，能获取到</span></span><br><span class="line">					<span class="comment">//由于这里的beanName=x，故而获取出来的工厂对象，能产生一个x半成品bean</span></span><br><span class="line">					ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">					<span class="comment">//由于获取到了，进入if分支</span></span><br><span class="line">					<span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">						<span class="comment">//调用工厂对象的getObject()方法，产生一个x的半成品bean</span></span><br><span class="line">						<span class="comment">//怎么产生的？下文解释，比较复杂</span></span><br><span class="line">						singletonObject = singletonFactory.getObject();</span><br><span class="line">						<span class="comment">//拿到了半成品的xbean之后，把他放到三级缓存；为什么？下文解释</span></span><br><span class="line">						<span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">						<span class="comment">//然后从二级缓存清除掉x的工厂对象；？为什么，下文解释</span></span><br><span class="line">						<span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>针对上面的源码我做一个简单的总结：首先spring从单例池当中获取x，前面说过获取不到，然后判断是否在正在创建bean的集合当中，前面分析过这个集合现在存在x，和y；所以if成立进入分支；进入分支spring直接从三级缓存中获取x，根据前面的分析三级缓存当中现在什么都没有，故而返回nll；进入下一个if分支，从二级缓存中获取一个ObjectFactory工厂对象；根据前面分析，二级缓存中存在x，故而可以获取到；跟着调用singletonFactory.getObject();拿到一个半成品的x bean对象；然后把这个x对象放到三级缓存，同时把二级缓存中x清除（此时二级缓存中只存在一个y了，而三级缓存中多了一个x）；</p>
<p>问题1、为什么首先是从三级缓存中取呢？主要是为了性能，因为三级缓存中存的是一个x对象，如果能取到则不去二级找了；哪有人会问二级有什么用呢？为什么一开始要存工厂呢？为什么一开始不直接存三级缓存？这里稍微有点复杂，如果直接存到三级缓存，只能存一个对象，假设以前存这个对象的时候这对象的状态为xa，但是我们这里y要注入的x为xc状态，那么则无法满足；但是如果存一个工厂，工厂根据情况产生任意xa或者xb或者xc等等情况；比如说aop的情况下x注入y，y也注入x；而y中注入的x需要加代理（aop），但是加代理的逻辑在注入属性之后，也就是x的生命周期周到注入属性的时候x还不是一个代理对象，那么这个时候把x存起来，然后注入y，获取、创建y，y注入x，获取x；拿出来的x是一个没有代理的对象；但是如果存的是个工厂就不一样；首先把一个能产生x的工厂存起来，然后注入y，注入y的时候获取、创建y，y注入x，获取x，先从三级缓存获取，为null，然后从二级缓存拿到一个工厂，调用工厂的getObject()；spring在getObject方法中判断这个时候x被aop配置了故而需要返回一个代理的x出来注入给y。当然有的读者会问你不是前面说过getObject会返回一个当前状态的xbean嘛？我说这个的前提是不去计较getObject的具体源码，因为这块东西比较复杂，需要去了解spring的后置处理器功能，这里先不讨论，总之getObject会根据情况返回一个x，但是这个x是什么状态，spring会自己根据情况返回；</p>
<p>问题2、为什么要从二级缓存remove？因为如果存在比较复杂的循环依赖可以提高性能；比如x，y，z相互循环依赖，那么第一次y注入x的时候从二级缓存通过工厂返回了一个x，放到了三级缓存，而第二次z注入x的时候便不需要再通过工厂去获得x对象了。因为if分支里面首先是访问三级缓存；至于remove则是为了gc吧；</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>框架源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat-一个Tomcat最多支持多少用户的并发</title>
    <url>/2022/10/25/Tomcat-%E4%B8%80%E4%B8%AATomcat%E6%9C%80%E5%A4%9A%E6%94%AF%E6%8C%81%E5%A4%9A%E5%B0%91%E7%94%A8%E6%88%B7%E7%9A%84%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h1 id="一个Tomcat最多支持多少用户的并发？"><a href="#一个Tomcat最多支持多少用户的并发？" class="headerlink" title="一个Tomcat最多支持多少用户的并发？"></a>一个Tomcat最多支持多少用户的并发？</h1><p>tomcat 默认配置的最大请求数是 150，也就是说同时支持 150 个并发，当然了，也可以将其改大。</p>
<p>当某个应用拥有 250 个以上并发的时候，应考虑应用服务器的集群。</p>
<p>具体能承载多少并发，需要看硬件的配置，CPU 越多性能越高，分配给 JVM 的内存越多性能也就越高，但也会加重 GC 的负担。</p>
<p>操作系统对于进程中的线程数有一定的限制：</p>
<p>Windows 每个进程中的线程数不允许超过 2000</p>
<p>Linux 每个进程中的线程数不允许超过 1000</p>
<p>另外，在 Java 中每开启一个线程需要耗用 1MB 的 JVM 内存空间用于作为线程栈之用。</p>
<p>Tomcat的最大并发数是可以配置的，实际运用中，最大并发数与硬件性能和CPU数量都有很大关系的。更好的硬件，更多的处理器都会使Tomcat支持更多的并发。</p>
<p>Tomcat 默认的 HTTP 实现是采用阻塞式的 Socket 通信，每个请求都需要创建一个线程处理。这种模式下的并发量受到线程数的限制，但对于 Tomcat 来说几乎没有 BUG 存在了。</p>
<p>Tomcat 还可以配置 NIO 方式的 Socket 通信，在性能上高于阻塞式的，每个请求也不需要创建一个线程进行处理，并发能力比前者高。但没有阻塞式的成熟。</p>
<p>这个并发能力还与应用的逻辑密切相关，如果逻辑很复杂需要大量的计算，那并发能力势必会下降。如果每个请求都含有很多的数据库操作，那么对于数据库的性能也是非常高的。</p>
<p>对于单台数据库服务器来说，允许客户端的连接数量是有限制的。</p>
<p>并发能力问题涉及整个系统架构和业务逻辑。</p>
<p>系统环境不同，Tomcat版本不同、JDK版本不同、以及修改的设定参数不同。并发量的差异还是蛮大的。</p>
<p> Tomcat接收请求的方式</p>
<p>   <strong>Tomcat支持三种接收请求的处理方式：BIO、NIO、APR 。</strong>  </p>
<pre><code>  1&gt;、Bio方式，阻塞式I/O操作即使用的是传统Java I/O操作，Tomcat7以下版本默认情况下是以bio模式运行的，由于每个请求都要创建一个线程来处理，线程开销较大，不能处理高并发的场景，在三种模式中性能也最低

  配置如下(tomcat安装目录下的/conf/server.xml)：
</code></pre>
<p>​     <img src="/2022/10/25/Tomcat-%E4%B8%80%E4%B8%AATomcat%E6%9C%80%E5%A4%9A%E6%94%AF%E6%8C%81%E5%A4%9A%E5%B0%91%E7%94%A8%E6%88%B7%E7%9A%84%E5%B9%B6%E5%8F%91/76.png" alt="一个Tomcat最多支持多少用户的并发？_默认值"></p>
<pre><code>  tomcat启动如下，看到http-bio-8080便是bio模式：
</code></pre>
<p>​      <img src="/2022/10/25/Tomcat-%E4%B8%80%E4%B8%AATomcat%E6%9C%80%E5%A4%9A%E6%94%AF%E6%8C%81%E5%A4%9A%E5%B0%91%E7%94%A8%E6%88%B7%E7%9A%84%E5%B9%B6%E5%8F%91/77.png" alt="一个Tomcat最多支持多少用户的并发？_默认值_02"></p>
<pre><code>  2&gt;、Nio方式，是Java SE 1.4及后续版本提供的一种新的I/O操作方式(即java.nio包及其子包)，是一个基于缓冲区、并能提供非阻塞I/O操作的Java API，它拥有比传统I/O操作(bio)更好的并发运行性能。tomcat 8版本及以上默认nio模式

 配置如下：
</code></pre>
<p>​    <img src="/2022/10/25/Tomcat-%E4%B8%80%E4%B8%AATomcat%E6%9C%80%E5%A4%9A%E6%94%AF%E6%8C%81%E5%A4%9A%E5%B0%91%E7%94%A8%E6%88%B7%E7%9A%84%E5%B9%B6%E5%8F%91/78.png" alt="一个Tomcat最多支持多少用户的并发？_默认值_03"></p>
<pre><code>  tomcat启动如下，看到http-nio-8080便是nio模式：
</code></pre>
<p>​     <img src="/2022/10/25/Tomcat-%E4%B8%80%E4%B8%AATomcat%E6%9C%80%E5%A4%9A%E6%94%AF%E6%8C%81%E5%A4%9A%E5%B0%91%E7%94%A8%E6%88%B7%E7%9A%84%E5%B9%B6%E5%8F%91/79.png" alt="一个Tomcat最多支持多少用户的并发？_默认值_04"></p>
<pre><code>  3&gt;、apr模式：简单理解，就是从操作系统级别解决异步IO问题，大幅度的提高服务器的处理和响应性能， 也是Tomcat运行高并发应用的首选模式。 
</code></pre>
<p>启用这种模式稍微麻烦一些，需要安装一些依赖库。具体的怎么安装在此就不讲解,想了解的可以百度</p>
<p>Tomcat配置</p>
<p> Tomcat&#x2F;conf&#x2F;server.xml修改配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">        <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span></span></span><br><span class="line"><span class="tag">    </span></span><br><span class="line"><span class="tag">        <span class="attr">URIEncoding</span>=<span class="string">&quot;UTF-8&quot;</span></span></span><br><span class="line"><span class="tag">    </span></span><br><span class="line"><span class="tag">        <span class="attr">minSpareThreads</span>=<span class="string">&quot;100&quot;</span></span></span><br><span class="line"><span class="tag">    </span></span><br><span class="line"><span class="tag">        <span class="attr">maxSpareThreads</span>=<span class="string">&quot;500&quot;</span></span></span><br><span class="line"><span class="tag">    </span></span><br><span class="line"><span class="tag">        <span class="attr">maxThreads</span>=<span class="string">&quot;1000&quot;</span></span></span><br><span class="line"><span class="tag">    </span></span><br><span class="line"><span class="tag">        <span class="attr">acceptCount</span>=<span class="string">&quot;700&quot;</span></span></span><br><span class="line"><span class="tag">    </span></span><br><span class="line"><span class="tag">        <span class="attr">connectionTimeout</span>=<span class="string">&quot;30000&quot;</span></span></span><br><span class="line"><span class="tag">    </span></span><br><span class="line"><span class="tag">        <span class="attr">enableLookups</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>参数说明</p>
<p><code>maxIdleTime</code>： 最大空闲时间，超过这个空闲时间，且线程数大于minSpareThreads的，都会被回收，默认值1分钟（60000ms）；</p>
<p><code>minSpareThreads</code>：最小空闲线程数，任何情况都会存活的线程数，即便超过了最大空闲时间，也不会被回收，默认值4；</p>
<p><code>maxSpareThreads</code>：最大空闲线程数，在最大空闲时间（maxIdleTime）内活跃过，此时空闲，当空闲时间大于maxIdleTime则被回收，小则继续存活，等待被调度，默认值50；</p>
<p><code>maxThreads</code>：最大线程数，大并发请求时，tomcat能创建来处理请求的最大线程数，超过则放入请求队列中进行排队，默认值为200；</p>
<p><code>acceptCount</code>：当最大线程数（maxThreads）被使用完时，可以放入请求队列排队个数，超过这个数返回connection refused（请求被拒绝），一般设置和maxThreads一样，不过这个具体需要根据自己的应用实际访问峰值和平均值来权衡，默认值为100；</p>
<p><code>connectionTimeout</code>：网络连接超时，假设设置为0表示永不超时，这样设置隐患巨大，通常可设置为30000ms，默认60000ms。</p>
<p><a href="https://blog.csdn.net/wanglei_storage/article/details/50225779">https://blog.csdn.net/wanglei_storage/article/details/50225779</a></p>
]]></content>
      <categories>
        <category>tomcat</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat-从输入URL到浏览器显示界面的流程</title>
    <url>/2022/10/25/Tomcat-%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E7%95%8C%E9%9D%A2%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="从输入URL到浏览器显示页面的流程"><a href="#从输入URL到浏览器显示页面的流程" class="headerlink" title="从输入URL到浏览器显示页面的流程"></a>从输入URL到浏览器显示页面的流程</h1><p>当在浏览器中输入域名，敲下回车后，不一会儿浏览器就会显示我们想要的界面。本文将简单介绍这其中经历了什么过程。</p>
<p>注意：以下分析基于<strong>HTTP</strong>请求，并且Web容器使用<strong>Tomcat</strong>，后端框架使用<strong>SSM</strong></p>
<h2 id="一、URL解析"><a href="#一、URL解析" class="headerlink" title="一、URL解析"></a>一、URL解析</h2><h3 id="1、地址解析"><a href="#1、地址解析" class="headerlink" title="1、地址解析"></a><strong>1、地址解析</strong></h3><p>浏览器会根据你的输入来判断该输入是一条合法的URL，还是需要被搜索的关键词。并且根据你输入的内容进行自动完成、字符编码等操作。</p>
<h3 id="2、其他操作"><a href="#2、其他操作" class="headerlink" title="2、其他操作"></a>2、其他操作</h3><p>目前大部分浏览器都会<strong>强制客户端使用HTTPS协议</strong>以保证信息传输的安全性。同时还会进行一些额外的操作，比如安全检查、访问限制等。</p>
<h3 id="3、缓存检查"><a href="#3、缓存检查" class="headerlink" title="3、缓存检查"></a>3、缓存检查</h3><p>有时候博客在gitee上进行了更新，但是通过谷歌浏览器查看博客时，仍是更新前的博客，这是因为浏览器中缓存了之前的博客界面。</p>
<p>浏览器会先检测是否缓存了目标URL的页面，如果有且缓存未过期，则直接展示缓存页面，无需再向服务器进行请求。</p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201208150315.png"><img src="/2022/10/25/Tomcat-%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E7%95%8C%E9%9D%A2%E7%9A%84%E6%B5%81%E7%A8%8B/80.png" alt="img"></a></p>
<h2 id="二、DNS解析"><a href="#二、DNS解析" class="headerlink" title="二、DNS解析"></a>二、DNS解析</h2><p><strong>DNS解析是寻找所需要的资源的IP地址的过程</strong>。因为互联网中每一台连网的机器都有<strong>唯一IP作为标识</strong>，但是它是一串数字，记忆太过困难。所以就需要将网址和IP地址进行转换，也就是DNS解析。其具体步骤如下。</p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201209141644.png"><img src="/2022/10/25/Tomcat-%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E7%95%8C%E9%9D%A2%E7%9A%84%E6%B5%81%E7%A8%8B/81.png" alt="img"></a></p>
<h3 id="1、查询缓存"><a href="#1、查询缓存" class="headerlink" title="1、查询缓存"></a>1、查询缓存</h3><p>我们的浏览器、操作系统、路由器都会缓存一些URL对应的IP地址，统称为<strong>DNS高速缓存</strong>。这是为了加快DNS解析速度，使得不必每次都到根域名服务器中去查询。</p>
<h3 id="2、递归解析"><a href="#2、递归解析" class="headerlink" title="2、递归解析"></a>2、递归解析</h3><p>输入<code>www.baidu.com</code>网址后，首先在高速缓存中查找，没找到去根域名服务器查找，没有再去<code>com</code>顶级域名服务器查找，依次类推，直到找到IP地址，然后把它记录在本地告诉缓存中，供下次使用。</p>
<p>大致过程就是<code>.</code>-&gt; <code>.com</code> -&gt;<code>baidu.com.</code> -&gt; <code>www.baidu.com.</code></p>
<p>其中<code>.</code>代表根域名服务器。</p>
<h3 id="3、DNS负载均衡"><a href="#3、DNS负载均衡" class="headerlink" title="3、DNS负载均衡"></a>3、DNS负载均衡</h3><p>访问<code>baidu.com</code>的时候，每次响应的可能并非是同一个服务器（IP地址不同），一般大公司都有成百上千台服务器来支撑访问，DNS可以返回一个<strong>合适的机器的IP</strong>给用户，例如可以<strong>根据每台机器的负载量，该机器离用户地理位置的距离</strong>等等，这种过程就是DNS负载均衡。</p>
<h2 id="三、建立TCP连接"><a href="#三、建立TCP连接" class="headerlink" title="三、建立TCP连接"></a>三、建立TCP连接</h2><p>TCP&#x2F;IP 分为四层，在发送数据时，<strong>每层都要对数据进行封装</strong></p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201209141851.png"><img src="/2022/10/25/Tomcat-%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E7%95%8C%E9%9D%A2%E7%9A%84%E6%B5%81%E7%A8%8B/20201209141851.png" alt="img"></a></p>
<p>TCP提供一种<strong>面向连接的，可靠的字节流</strong>服务，是一种可靠传输。接下来将会讲解TCP的<strong>首部、三次握手与四次挥手</strong>。</p>
<h3 id="1、TCP的首部"><a href="#1、TCP的首部" class="headerlink" title="1、TCP的首部"></a>1、TCP的首部</h3><p>TCP首部的格式如下</p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201208164319.png"><img src="/2022/10/25/Tomcat-%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E7%95%8C%E9%9D%A2%E7%9A%84%E6%B5%81%E7%A8%8B/20201208164319.png" alt="img"></a></p>
<ul>
<li><p><strong>源端口</strong>：源端口和IP地址的作用是标识<strong>报文的发送地址和返回地址</strong></p>
</li>
<li><p><strong>目的端口</strong>：端口指明<strong>接收方</strong>计算机上的应用程序接口</p>
<ul>
<li>TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP<strong>唯一确定</strong>一条TCP连接</li>
</ul>
</li>
<li><p><strong>序号</strong>：是TCP可靠传输的<strong>关键部分</strong></p>
<ul>
<li><p>序号是该报文段发送的数据组的</p>
<p>第一个字节的序号</p>
<p>。在TCP传送的流中，每</p>
<p>一个字节都有一个序号</p>
<ul>
<li>比如一个报文段的序号为300，报文段数据部分共有100字节，则<strong>下一个报文段</strong>的序号为400。所以序号确保了TCP传输的有序性</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>确认号：ack，用于指明下一个期待收到的字节序号</strong>，表明该序号之前的所有数据已经正确无误的收到</p>
<ul>
<li><strong>确认号只有当ACK标志为1时才有效</strong>。比如建立连接时，SYN报文的ACK标志位为0</li>
</ul>
</li>
<li><p><strong>首部长度&#x2F;数据偏移</strong>：占4位，它指出<strong>TCP报文的数据距离TCP报文段的起始处有多远</strong></p>
</li>
<li><p><strong>保留</strong>：占6位，保留今后使用，但<strong>目前应都位0</strong></p>
</li>
<li><p><strong>控制位：URG ACK PSH RST SYN FIN</strong>，共6个，每一个标志位表示一个控制功能</p>
<ul>
<li>URG：紧急。当URG&#x3D;1时，表明紧急指针字段有效。告诉系统<strong>此报文段中有紧急数据</strong></li>
<li>ACK：确认。<strong>当ACK&#x3D;1时，确认号字段才有效</strong>。TCP规定，在连接建立后所有报文的传输都必须把ACK置1</li>
<li>PSH：推送。当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH&#x3D;1</li>
<li>RST：复位。当RST&#x3D;1，表明TCP连接中出现严重差错，<strong>必须释放连接，然后再重新建立连接</strong></li>
<li>SYN：同步，在连接建立时用来同步序号。当SYN&#x3D;1，ACK&#x3D;0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN&#x3D;1，ACK&#x3D;1</li>
<li>FIN：终止，用来释放连接。当FIN&#x3D;1，表明此报文的发送方的数据已经发送完毕，并且要求释放</li>
</ul>
</li>
<li><p><strong>窗口</strong>：<strong>滑动窗口</strong>大小，用来告知发送端<strong>接受端的缓存大小</strong>，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小时一个16bits字段，因而窗口大小最大为65535</p>
</li>
<li><p><strong>校验和</strong>：奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证</p>
</li>
<li><p><strong>紧急指针</strong>：只有当 <strong>URG 标志置 1 时紧急指针才有效</strong>。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式</p>
</li>
<li><p><strong>选项和填充</strong>：最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍</p>
</li>
<li><p><strong>数据部分</strong>： TCP 报文段中的数据部分是可选的。<strong>在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部</strong>。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。</p>
</li>
</ul>
<h3 id="2、三次握手"><a href="#2、三次握手" class="headerlink" title="2、三次握手"></a>2、三次握手</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210127161838.png"><img src="/2022/10/25/Tomcat-%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E7%95%8C%E9%9D%A2%E7%9A%84%E6%B5%81%E7%A8%8B/20210127161838.png" alt="img"></a></p>
<p><strong>握手过程中传送的包里不包含数据</strong>，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p>
<p><strong>为什么是三次握手？两次不行吗？四次不行吗？</strong></p>
<h4 id="为什么不是两次握手"><a href="#为什么不是两次握手" class="headerlink" title="为什么不是两次握手"></a>为什么不是两次握手</h4><p>这是为了<strong>避免服务器建立无用连接</strong>（客户端服务器建立连接后，却不传输数据）</p>
<p>如果只进行两次握手，如果客户端向服务器第一次发送的建立连接的请求因为某原因，<strong>兜兜转转绕了一大圈才到达服务器</strong>。这期间客户端因为未收到服务器的响应，就会再次发送连接请求，这时服务器收到了，向客户端发送连接请求后，连接便建立了。然后数据传输完毕后，释放连接。<strong>这时刚刚兜兜转转一大圈的建立连接的请求到了服务器</strong>，服务器收到后再次向客户端发送请求，发送后又建立了连接，但是建立连接后客户端没有再理会服务器，客户端与服务器之间没有传输数据，此时服务器的资源就会被浪费</p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201208172930.png"><img src="/2022/10/25/Tomcat-%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E7%95%8C%E9%9D%A2%E7%9A%84%E6%B5%81%E7%A8%8B/20201208172930.png" alt="img"></a></p>
<h4 id="为什么不是四次握手"><a href="#为什么不是四次握手" class="headerlink" title="为什么不是四次握手"></a>为什么不是四次握手</h4><p><strong>因为通信不可能100%可靠</strong>（红军蓝军约定）， 而上面的三次握手已经做好了通信的准备工作， <strong>再增加握手， 并不能显著提高可靠性</strong>，所以只需要三次握手就足够了</p>
<p>这里简单介绍一下<strong>红军蓝军约定</strong></p>
<blockquote>
<p>红军和蓝军都想消灭一波敌人，但是单凭他们一个军队的力量都不足以消灭这波敌人，因此他们想到了一起合作，于是红军向蓝军发了一封电报，内容是约定好早上8点一起向敌军进攻，由于他们不确定蓝军是否一定能收到电报, 所以只有收到蓝军的回复之后才会进行进攻，而蓝军也是同样的想法，因为他们不确定红军一定能收到自己的回复而在约定好的时间发动进攻，所以他们只有收到红军的回复后才发动进攻….</p>
<p>问怎样才能保证这次战役一定胜利呢？答案是不可能的，因为<strong>双方都对于自己发出的消息对方是否一定接收得到存在质疑</strong>，所以，这样的通信将一直进行下去，结果将是使胜利的几率一直接近100%，但是却永远达不到100%。</p>
</blockquote>
<h3 id="3、四次挥手"><a href="#3、四次挥手" class="headerlink" title="3、四次挥手"></a>3、四次挥手</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201209144349.png"><img src="/2022/10/25/Tomcat-%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E7%95%8C%E9%9D%A2%E7%9A%84%E6%B5%81%E7%A8%8B/20201209144349.png" alt="img"></a></p>
<ul>
<li>第一次挥手<ul>
<li>客户端发送一个<strong>FIN&#x3D;1</strong>，用来关闭客户端到服务器的数据传送，此后客户端不会再向服务器发送数据(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，客户端依然会重发这些数据)，但是，此时客户端还可以接受数据。 FIN&#x3D;1，其序列号为seq&#x3D;u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，<strong>客户端进入FIN-WAIT-1</strong>（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号</li>
</ul>
</li>
<li>第二次挥手<ul>
<li>服务器收到FIN包后，发送一个ACK给对方并且带上自己的序列号seq，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。此时，<strong>服务端就进入了CLOSE-WAIT</strong>（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，<strong>但是服务器若发送数据，客户端依然要接受</strong>。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间</li>
<li>此时，<strong>客户端就进入FIN-WAIT-2</strong>（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）</li>
</ul>
</li>
<li>第三次挥手<ul>
<li>服务器发送一个FIN&#x3D;1，用来关闭服务器到客户端的数据传送，也就是通知客户端，可以真正地释放连接了。由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq&#x3D;w，此时，<strong>服务器就进入了LAST-ACK</strong>（最后确认）状态，等待客户端的确认</li>
</ul>
</li>
<li>第四次挥手<ul>
<li>客户端收到FIN后，发送一个ACK&#x3D;1给服务器，确认序号为收到序号+1，此时，<strong>客户端就进入了TIME-WAIT</strong>（时间等待）状态。注意此时TCP连接还没有释放，<strong>必须经过2MSL（最长报文段寿命）的时间后</strong>，当客户端撤销相应的TCB后，才进入CLOSED状态</li>
<li><strong>服务器只要收到了客户端发出的确认，立即进入CLOSED状态</strong>。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些</li>
</ul>
</li>
</ul>
<h4 id="为什么客户端最后还要等待2MSL"><a href="#为什么客户端最后还要等待2MSL" class="headerlink" title="为什么客户端最后还要等待2MSL"></a>为什么客户端最后还要等待2MSL</h4><p><strong>确保第四次挥手服务器能够收到，同时使失效的连接请求从网络中消失</strong></p>
<p><strong>MSL</strong>是Maximum Segment Lifetime英文的缩写，中文可以译为<strong>报文最大生存时间</strong>，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p>
<ul>
<li><strong>保证客户端发送的最后一个ACK报文能够到达服务器</strong>，因为这个ACK报文可能丢失。站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，<strong>于是服务器又会重新发送一次</strong>，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会<strong>重启2MSL计时器</strong></li>
<li>防止类似与三次握手中提到了的<strong>已经失效的连接请求报文段</strong>出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以<strong>使本连接持续的时间内所产生的所有报文段都从网络中消失</strong>（最长生存MSL）。<strong>这样新的连接中不会出现旧连接的请求报文</strong></li>
</ul>
<h4 id="为什么建立连接是三次握手，关闭连接确是四次挥手"><a href="#为什么建立连接是三次握手，关闭连接确是四次挥手" class="headerlink" title="为什么建立连接是三次握手，关闭连接确是四次挥手"></a>为什么建立连接是三次握手，关闭连接确是四次挥手</h4><ul>
<li>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，<strong>把ACK和SYN放在一个报文里发送给客户端</strong></li>
<li>关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，<strong>己方ACK和FIN一般都会分开发送，从而导致多了一次</strong></li>
</ul>
<h2 id="四、发送HTTPS请求"><a href="#四、发送HTTPS请求" class="headerlink" title="四、发送HTTPS请求"></a>四、发送HTTPS请求</h2><h3 id="1、HTTP简介"><a href="#1、HTTP简介" class="headerlink" title="1、HTTP简介"></a>1、HTTP简介</h3><p>参考<a href="https://mp.weixin.qq.com/s/AK1Pb9rx0q5Hf8dq6HNOhw"><strong>你每天都在使用的HTTP协议，到底是什么鬼？</strong></a></p>
<h3 id="2、HTTPS简介"><a href="#2、HTTPS简介" class="headerlink" title="2、HTTPS简介"></a>2、HTTPS简介</h3><p>在HTTP的基础上再加一层TLS（传输层安全性协议）或者SSL（安全套接层），就构成了HTTPS协议。</p>
<p>HTTPS详细介绍可以参考<a href="https://zhuanlan.zhihu.com/p/158593966"><strong>一文带你了解HTTPS</strong></a></p>
<h4 id="HTTPS如何保证可靠性"><a href="#HTTPS如何保证可靠性" class="headerlink" title="HTTPS如何保证可靠性"></a>HTTPS如何保证可靠性</h4><ul>
<li>对称加密以及非对称加密<ul>
<li>通过非对称加密生成密钥，后面通过这个密钥进行对称加密进行传输</li>
</ul>
</li>
<li>数字签名<ul>
<li>保证非对称加密时发送的公钥是被认证过的，是安全可靠的</li>
</ul>
</li>
<li>单向Hash算法</li>
</ul>
<p><strong>大致过程如下</strong></p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201209163352.png"><img src="/2022/10/25/Tomcat-%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E7%95%8C%E9%9D%A2%E7%9A%84%E6%B5%81%E7%A8%8B/20201209163352.png" alt="img"></a></p>
<h3 id="3、HTTPS传输过程"><a href="#3、HTTPS传输过程" class="headerlink" title="3、HTTPS传输过程"></a>3、HTTPS传输过程</h3><ul>
<li><strong>建立TCP连接</strong>（HTTP）</li>
<li><strong>将HTTP请求转换为HTTPS请求，转到HTTPS网站</strong><ul>
<li>因为一般人输入网址时，都是输入如<code>www.baidu.com</code>，而不会输入<code>https://www.baidu.com</code>。这时默认使用的是HTTP协议，<strong>浏览器会帮我们自动转换为HTTPS协议</strong></li>
</ul>
</li>
<li><strong>建立新的TCP连接</strong>(HTTPS)<ul>
<li>因为HTTP与HTTPS的端口不同。HTTP使用80端口，HTTPS使用443端口</li>
</ul>
</li>
<li><strong>完成一系列的协商工作</strong><ul>
<li>完成加密套件的协商和证书的身份确认，这次交互客户端和服务端会协商出相同的密钥交换算法、对称加密算法、内容一致性校验算法、证书签名算法等等。浏览器获取到证书之后，也要验证证书的有效性，是否过期是否撤销</li>
</ul>
</li>
<li><strong>浏览器获取CA域名</strong><ul>
<li>如果没有CA域名的缓存，还需要进行<strong>DNS解析</strong></li>
</ul>
</li>
<li><strong>再次建立新的TCP连接</strong>（CA域名）</li>
<li><strong>发送OCSP请求</strong><ul>
<li>OCSP全称是Online Certificate Status Protocol，在线证书状态协议，顾名思义用来获取证书状态的请求，这里的状态包括有效、过期、未知。并且可以宽限一段客户端访问证书的时间</li>
</ul>
</li>
<li><strong>进行密钥协商</strong></li>
</ul>
<p>经过以上过程后，便可以进行数据的对称加密传输了。</p>
<h2 id="五、查询MAC地址"><a href="#五、查询MAC地址" class="headerlink" title="五、查询MAC地址"></a>五、查询MAC地址</h2><p>这一步主要负责为打包好的<code>数据+TCP首部+IP首部</code>寻找传输路线，<strong>找到IP对应的物理机</strong>，这里会用到ARP协议。</p>
<h3 id="1、ARP协议"><a href="#1、ARP协议" class="headerlink" title="1、ARP协议"></a>1、ARP协议</h3><p>ARP（Address Resolution Protocol）即地址解析协议， 用于<strong>实现从 IP 地址到 MAC 地址的映射</strong>，即询问目标IP对应的MAC地址。</p>
<h3 id="2、ARP如何交互"><a href="#2、ARP如何交互" class="headerlink" title="2、ARP如何交互"></a>2、ARP如何交互</h3><p>ARP协议通过<strong>一问一答</strong>实现交互，但是问和答都有讲究，<strong>问是通过广播形式实现，答是通过单播形式。</strong></p>
<hr>
<p><strong>以上都是计算机网络的部分，接下来将介绍服务器如何接收与处理请求</strong></p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201209203752.png"><img src="/2022/10/25/Tomcat-%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E7%95%8C%E9%9D%A2%E7%9A%84%E6%B5%81%E7%A8%8B/20201209203752.png" alt="img"></a></p>
<h2 id="六、请求在Tomcat中的处理流程"><a href="#六、请求在Tomcat中的处理流程" class="headerlink" title="六、请求在Tomcat中的处理流程"></a>六、请求在Tomcat中的处理流程</h2><p>Web 容器以<strong>进程</strong>的方式在计算机上运行，<strong>它主要负责接收请求，并将其投送至特定的应用</strong>，但Web容器并不属于计算机网络的组成部分。接下来将以Tomcat为例介绍Web容器的核心组件。</p>
<h3 id="1、Tomcat的核心组件"><a href="#1、Tomcat的核心组件" class="headerlink" title="1、Tomcat的核心组件"></a>1、Tomcat的核心组件</h3><p>Tomcat的核心组件主要有：<strong>Server、Service、Connector、Engine、Host和Context</strong>。</p>
<p><strong>一个Server可以包含多个Service，一个Service可以包含多个Connector，但只能包含一个Engine，一个Engine可以包含多个Host，一个Host可以包含多个Context</strong>。</p>
<p><strong>它们之间的关系如下图所示</strong></p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201209200950.png"><img src="/2022/10/25/Tomcat-%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E7%95%8C%E9%9D%A2%E7%9A%84%E6%B5%81%E7%A8%8B/20201209200950.png" alt="img"></a></p>
<p><strong>配置文件的结构如下</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Server&gt;                              </span><br><span class="line">    &lt;Service&gt;</span><br><span class="line">        &lt;Engine&gt;</span><br><span class="line">            &lt;Host&gt;</span><br><span class="line">                &lt;Context /&gt;</span><br><span class="line">            &lt;/Host&gt;</span><br><span class="line">            &lt;Host&gt;</span><br><span class="line">                &lt;Context /&gt;</span><br><span class="line">            &lt;/Host&gt;</span><br><span class="line">        &lt;/Engine&gt;  </span><br><span class="line">        &lt;Connector /&gt;</span><br><span class="line">        &lt;Connector /&gt;</span><br><span class="line">    &lt;/Service&gt;</span><br><span class="line">&lt;/Server&gt;Copy</span><br></pre></td></tr></table></figure>

<h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><p>Server 是整个配置文件的<strong>唯一根元素</strong>，代表整个 Tomcat 容器。Server 内部可以包含多个 Service，其主要职责就是管理多个 Service，对外提供给客户端访问，同时维护所有 Service 的生命周期，包括初始化服务、结束服务、定位客户端要访问的 Service 等等。</p>
<h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p>Service 的主要职责就是将 Engine 与 Connector 装配在一起对外提供服务。一个 Service 可以包含多个 Connector，但只能包含一个 Engine，<strong>其中 Connector 负责从客户端接收请求，Engine 负责处理 Connector 接收进来的请求。</strong></p>
<h4 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h4><p><strong>Connector是主要负责接收请求的组件</strong>。</p>
<p><strong>Tomcat有以下两种工作模式</strong></p>
<ul>
<li>作为Web服务器，直接接收客户端的请求</li>
<li>作为Java Web服务器，接收前置Web服务器的请求</li>
</ul>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201209213925.png"><img src="/2022/10/25/Tomcat-%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E7%95%8C%E9%9D%A2%E7%9A%84%E6%B5%81%E7%A8%8B/20201209213925.png" alt="img"></a></p>
<p>每个 Service 可以有一个或多个 Connector，不同工作模式下，Tomcat 需要为各种类型的请求分别定义相应的 Connector，这样才能正确接收客户端对应协议的请求。定义 Connector 可以使用多种属性，某些属性只适用于某种特定的 Connector 类型。</p>
<p>一般说来，常见的 Connector 有 4 种类型</p>
<ul>
<li><strong>HTTP</strong></li>
<li><strong>HTTPS</strong></li>
<li><strong>AJP</strong></li>
<li><strong>Proxy</strong></li>
</ul>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201210125922.png"><img src="/2022/10/25/Tomcat-%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E7%95%8C%E9%9D%A2%E7%9A%84%E6%B5%81%E7%A8%8B/20201210125922.png" alt="img"></a></p>
<p>Connector作为通信接口，<strong>它为其所属特定的 Service 接收外部客户端请求，以及回送应答至外部客户端</strong>。具体职责包括创建 Request、Response 对象用于跟外部客户端交换数据，并<strong>将 Request 交给配套的 Engine 来处理</strong>。</p>
<h4 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h4><p>Engine 是 Service 组件中<strong>负责请求处理的组件</strong>，其内部可以包含多个 Host。Engine 从一个或多个 Connector 中接收请求并处理，并将处理结果封装成应答交给 Connector，最终回传给外部客户端。</p>
<h4 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h4><p><strong>Host 代表一个虚拟主机，它对应计算机网络上的一个实体</strong>。即某个在 DNS 服务器上注册过的域名或者 IP 地址，例如：<code>www.baidu.com</code>或 201.187.10.21。Host 内部可以包含多个 Context，<strong>每个 Context 表示一个 Web 应用</strong>。Host 负责安装、展开、启动和结束每个 Web 应用。</p>
<p>客户端在填写目标地址时会通过主机名来标识它希望访问的服务器，Tomcat 将从 HTTP 请求头的 Host 字段提取主机名，然后再匹配对应的虚拟主机。如果没有找到匹配的，HTTP 请求将被发送至默认主机 defaultHost。</p>
<h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>Context 代表在特定虚拟主机上运行的一个 Web 应用，<strong>负责处理某个特定 Web 应用的所有请求</strong>。</p>
<h3 id="2、Tomcat处理HTTP请求"><a href="#2、Tomcat处理HTTP请求" class="headerlink" title="2、Tomcat处理HTTP请求"></a>2、Tomcat处理HTTP请求</h3><p>当以 HTTP 请求到达Tomcat服务器（Server）以后，Tomcat会进行以下几个步骤，将请求交给对应的Web应用进行处理</p>
<ul>
<li>根据协议类型和端口号选定 Service 和 Engine<ul>
<li>Connector 主要负责接收请求。当 Connector 接收到特定协议和特定端口的请求后，<strong>其所属的 Service 和 Service 下的 Engine 也就确定了</strong></li>
</ul>
</li>
<li>根据域名或 IP 地址选定 Host<ul>
<li>Engine一旦确定了，就会根据 IP 来选择对应的虚拟主机Host来处理请求。如果匹配失败了，则会使用默认虚拟主机来处理请求</li>
</ul>
</li>
<li>根据 URI 选定 Context<ul>
<li>URI 中的 context-path 指定了 HTTPS 请求将要访问的 Web 应用</li>
<li>当请求抵达时，Tomcat 将根据 Context 的属性 path 取值与 URI 中的 context-path 的匹配程度来选择 Web 应用处理相应请求</li>
</ul>
</li>
</ul>
<h2 id="七、请求在Web应用中的处理流程"><a href="#七、请求在Web应用中的处理流程" class="headerlink" title="七、请求在Web应用中的处理流程"></a>七、请求在Web应用中的处理流程</h2><p>请求被 Web 容器中的 Connector 捕获，选取对应的 Server 中的 Engine ，Engine 再根据IP选择对应的虚拟主机，虚拟主机根据URI将请求交给对应的Web应用进行处理。接下来将介绍请求在Web请求中的处理过程。</p>
<p>介绍处理过程前，先对Web应用的基本组件进行简单介绍。</p>
<h3 id="1、Web应用核心组件"><a href="#1、Web应用核心组件" class="headerlink" title="1、Web应用核心组件"></a>1、Web应用核心组件</h3><h4 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h4><p>监听器 Listener 主要用于监听 Application、Session、Request 等对象的变化，每当这些对象发生变化就会回调用对应的监听方法。</p>
<h4 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h4><p>过滤器 Filter 负责对请求做<strong>预处理</strong>，接着将请求交给 Servlet 进行处理并生成响应，最后 Filter 再对响应进行后处理。</p>
<p>从请求的处理过程来看，Filter 主要参与以下几个环节</p>
<ul>
<li>在 HttpServletRequest <strong>到达 Servlet 之前，拦截客户的 HttpServletRequest</strong></li>
<li>根据需要检查 HttpServletRequest，也可以修改 HttpServletRequest 报文头和数据</li>
<li>在 Servlet 生成的 HttpServletResponse <strong>抵达客户端之前，拦截 HttpServletResponse</strong></li>
<li>根据需要检查 HttpServletResponse，也可以修改 HttpServletResponse 报文头和数据</li>
</ul>
<p><strong>简单来说就是在真正处理请求以及返回响应之前，通过过滤器对内容再进行一些修改</strong></p>
<h4 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h4><p><strong>Servlet 负责处理客户端访问动态资源的 HTTP 请求</strong>，接口 javax.servlet.Servlet 定义了所有 Servlet 必须要实现的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Servlet &#123;</span><br><span class="line">    // 由 Servlet 容器调用，完成 Servlet 初始化，启动对外服务</span><br><span class="line">    void init(ServletConfig var1) throws ServletException;</span><br><span class="line"></span><br><span class="line">    // 获取 Servlet 初始化和启动时参数的配置信息对象 ServletConfig</span><br><span class="line">    ServletConfig getServletConfig();</span><br><span class="line"></span><br><span class="line">    // 由 Servlet 容器调用，让 Servlet 处理某个 HTTP 请求</span><br><span class="line">    void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;</span><br><span class="line"></span><br><span class="line">    // 获取 Servlet 的说明信息，包括：作者、版本和版权等等</span><br><span class="line">    String getServletInfo();</span><br><span class="line"></span><br><span class="line">    // 由 Servlet 容器调用，用于关闭停止 Servlet 提供的服务</span><br><span class="line">    void destroy();</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p>从 HTTP 请求的处理过程来看，Servlet 主要参与以下几个环节</p>
<ul>
<li>接收请求<ul>
<li>客户端请求会被封装成 HttpServletRequest 对象，包含报文头参数和报文体等信息</li>
</ul>
</li>
<li>处理请求<ul>
<li>通常调用 Servlet 的方法 service、doPost 或 doGet 等方法处理请求，并<strong>进一步调用业务层相应逻辑对其进行处理等</strong></li>
</ul>
</li>
<li>反回响应<ul>
<li>处理完请求后，可以转发（forward）、重定向（redirect）到某个视图页面或者直接返回结果数据</li>
</ul>
</li>
</ul>
<h3 id="2、Web应用处理HTTP请求流程"><a href="#2、Web应用处理HTTP请求流程" class="headerlink" title="2、Web应用处理HTTP请求流程"></a>2、Web应用处理HTTP请求流程</h3><p>Web 应用处理 HTTP 请求的流程主要是<strong>穿越 Listener 和多个 Filters，最终抵达 Servlet 的过程</strong>，Servlet再进行下一步的处理。</p>
<p><strong>具体流程如下图</strong></p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201209213603.png"><img src="/2022/10/25/Tomcat-%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E7%95%8C%E9%9D%A2%E7%9A%84%E6%B5%81%E7%A8%8B/20201209213603.png" alt="img"></a></p>
<h2 id="八、请求在Spring-Web应用中的处理流程"><a href="#八、请求在Spring-Web应用中的处理流程" class="headerlink" title="八、请求在Spring Web应用中的处理流程"></a>八、请求在Spring Web应用中的处理流程</h2><p>因为使用 SSM 框架，所以 Spring MVC 中的 DispatcherServlet 充当了 Web 应用中的 Serlvet，负责将任务分配给对应的Controller，并将最终视图返回给 Web 容器。</p>
<h3 id="1、Spring-MVC的核心组件"><a href="#1、Spring-MVC的核心组件" class="headerlink" title="1、Spring MVC的核心组件"></a>1、Spring MVC的核心组件</h3><h4 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h4><p>DispatcherServlet 是整个流程<strong>控制的中心</strong>，由它来<strong>接收请求并调用其它组件处理用户的请求</strong>，同时还负责响应结果。DispatcherServlet的存在降低了组件之间的耦合性。</p>
<h4 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h4><p>HandlerMapping 负责<strong>根据用户请求映射获得对应的 Handler和 HandlerInterceptor</strong>。处理方法为从 URL 获得 URI，在通过 URI 从 HandlerMapping 中找到对应的 Handler 和 HandlerInterceptor，即处理器和拦截器。</p>
<h4 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h4><p>HandlerAdapter 负责按照特定规则去执行 Handler。</p>
<p>如果 Handler 有对应的 HandlerAdapater，<strong>HandlerAdapater 则会在调用 Handler 之前执行 HandlerInterceptor 的 preHandler() 方法对 Handler 进行拦截</strong>。</p>
<h4 id="HandlerInterceptor"><a href="#HandlerInterceptor" class="headerlink" title="HandlerInterceptor"></a>HandlerInterceptor</h4><p>HandlerInterceptor 主要负责在执行 Handler 前对其进行拦截。HandlerInterceptor 中的 preHandler() 方法将会提取 HTTP 请求中的数据填充到处理器 Handler 的中。</p>
<h4 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h4><p>Handler <strong>即Controller ，是处理业务代码的核心器件</strong>。这部分由程序员自行编写，一般的SSM框架中，其下层还有Service和Dao。</p>
<h3 id="2、Spring-MVC处理请求流程"><a href="#2、Spring-MVC处理请求流程" class="headerlink" title="2、Spring MVC处理请求流程"></a>2、Spring MVC处理请求流程</h3><p>当 Web 容器中的 Host 会选择对应的 Web应用来处理请求，这里将请求交给了 Spring MVC 中的 DispatcherServlet 来进一步处理请求。</p>
<ul>
<li>DispatcherServlet 通过解析 HTTP 请求的 URL 获得 URI，再根据该 URI <strong>从 HandlerMapping 当中获得该请求对应的 Handler 和 HandlerInterceptor</strong></li>
<li>DispatcherServlet 根据获得的 Handler 选择合适的 HandlerAdapter。如果成功获得 HandlerAdapter，<strong>HandlerAdapater 则会在调用 Handler 之前执行 HandlerInterceptor 的 preHandler() 方法对 Handler 进行拦截</strong></li>
<li>Handler 即 Controller 会进行请求的处理，并向下调用 Service 和 Dao 来处理请求</li>
<li>Hander 处理完成请求后会返回模型数据，模型数据由 DispatcherServlet 封装后返回给Web 容器</li>
</ul>
<p><strong>处理的流程图如下</strong></p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201210105723.png"><img src="/2022/10/25/Tomcat-%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E7%95%8C%E9%9D%A2%E7%9A%84%E6%B5%81%E7%A8%8B/20201210105723.png" alt="img"></a></p>
<h2 id="九、返回过程"><a href="#九、返回过程" class="headerlink" title="九、返回过程"></a>九、返回过程</h2><p>Web 应用处理完请求并将结果返回给 Web 容器后，容器会将响应结果返回给客户端，这是上面流程的逆过程。浏览器收到响应结果后，会对结果进行解析和渲染。这样我们就能看到浏览器给我们显示的网页了。</p>
<h2 id="十、整体流程图"><a href="#十、整体流程图" class="headerlink" title="十、整体流程图"></a>十、整体流程图</h2><p>下面给出了输入URL到浏览器显示界面的流程图</p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201210113745.png"><img src="/2022/10/25/Tomcat-%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E7%95%8C%E9%9D%A2%E7%9A%84%E6%B5%81%E7%A8%8B/20201210113745.png" alt="img"></a></p>
<p><strong>以上便是从输入URL到浏览器显示页面的整个流程</strong></p>
]]></content>
      <categories>
        <category>tomcat</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>beanDefinition1</title>
    <url>/2022/10/25/beanDefinition1/</url>
    <content><![CDATA[<p>如果想系统的学习spring源码那么第一个需要搞明白的知识便是spring当中的BeanDefinition——<strong>spring bean的建模对象；</strong></p>
<blockquote>
<p>笔者特别强调，beanDefintion的比较枯燥和晦涩难懂，但是非常非常重要，我打算写三篇来把beanDefintion知识讲完；如果你想精读spring源码，请你一定细读三篇beanDefintion的知识，他是spring framework当中的基石；</p>
</blockquote>
<p>那么什么是spring bean的建模对象呢？一言概之就是把一个bean实例化出来的模型对象？有人会问把一个bean实例化出来有Class就行了啊，Class也就是我们通常说的类对象，就是一个普通对象的建模对象，那么为什么spring不能用Class来建立bean呢?很简单，因为Class无法完成bean的抽象，比如bean的作用域，bean的注入模型，bean是否是懒加载等等信息，Class是无法抽象出来的，故而需要一个BeanDefinition类来抽象这些信息，以便于spring能够完美的实例化一个bean（关于什么是bean什么是对象，请参考我写的第一篇循环引用笔者有解释）</p>
<blockquote>
<p>上述文字可以简单理解spring当中的BeanDefinition就是java当中的Class<br>Class可以用来描述一个类的属性和方法等等其他信息<br>BeanDefintion可以描述springbean当中的scope、lazy，以及属性和方法等等其他信息</p>
</blockquote>
<p>用一副图来说明java实例化一个对象的基本流程</p>
<p><img src="/2022/10/25/beanDefinition1/16.png" alt="在这里插入图片描述"></p>
<p>对上图的文字说明：假设磁盘上有N个.java文件，首先我们把这些java文件编译成class文件，继而java虚拟机启动会把这些class文件load到内存，当遇到new关键字的时候会根据类的模板信息实例化这个对象也就是在堆上面分配内存</p>
<p>但是spring的bean实例化过程和一个普通java对象的实例化过程还是有区别的，同样用一幅图来说明一下</p>
<p><img src="/2022/10/25/beanDefinition1/17.png" alt="在这里插入图片描述"></p>
<p>下面我会对这幅图做大篇幅的说明，在springbean实例化简图当中我一共标记了⑤步；逐一来说明吧</p>
<p>前提：假设在你的项目或者磁盘上有X和Y两个类，X是被加了spring注解的，Y没有加spring的注解；也就是正常情况下当spring容器启动之后通过getBean(X)能正常返回X的bean，但是如果getBean(Y)则会出异常，因为Y不能被spring容器扫描到不能被正常实例化；</p>
<p>①当spring容器启动的时候会去调用ConfigurationClassPostProcessor这个bean工厂的后置处理器完成扫描，关于什么是bean工厂的后置处理器下文再来详细解释；spring完成扫描的具体源码放到后续的文章中再来说。阅读本文读者只需知道扫描具体干了什么事情即可；其实所谓的spring扫描就是把类的信息读取到，但是读取到类的信息存放到哪里呢？比如类的类型(class),比如类的名字，类的构造方法。可能有读者会有疑问这些信息不需要存啊，直接存在class对象里面不就可以？比如当spring扫描到X的时候Class clazzx &#x3D; X.class；那么这个classx里面就已经具备的前面说的那些信息了，确实如此，但是spring实例化一个bean不仅仅只需要这些信息，还有我上文说到的scope，lazy，dependsOn等等信息需要存储，所以spring设计了一个BeanDefintion的类用来存储这些信息。故而当spring读取到类的信息之后。</p>
<p>②会实例化一个BeanDefinition的对象，继而调用这个对象的各种set方法存储信息；每扫描到一个符合规则的类，spring都会实例化一个BeanDefinition对象，然后把根据类的类名生成一个bean的名字（比如一个类IndexService，spring会根据类名IndexService生成一个bean的名字<code>indexService</code>,spring内部有一套默认的名字生成规则，但是程序员可以提供自己的名字生成器覆盖spring内置的，这个后面更新）。</p>
<p>③继而spring会把这个beanDefinition对象和生成的beanName放到一个map当中，key&#x3D;beanName，value&#x3D;beanDefinition对象；至此上图的第①②③步完成。</p>
<blockquote>
<p>这里需要说明的是spring启动的时候会做很多工作，不仅仅是完成扫描，在扫描之前spring还干了其他大量事情；比如实例化beanFacctory、比如实例化类扫描器等等，这里不讨论，在以后的文章再来讨论</p>
</blockquote>
<p>用一段代码和结果来证明上面的理论</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Appconfig.java</span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.luban.beanDefinition&quot;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Appconfig</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">X.java</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">X</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;X Constructor&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Y.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Y</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">		ac.register(Appconfig.class);</span><br><span class="line">		ac.refresh();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码里面有X和Y两个类（下面有笔者运行这些代码的结果截图），X被注解了，Y没注解，并且在X当中有个构造方法一旦X被实例化便会打印”X Constructor”；而且在main方法的最开始打印了”start”按照上面笔者的理论spring首先会扫描X继而把X解析称为一个beanDefinition对象放到map；笔者在spring的源码org.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors方法上打了一个断点（invokeBeanFactoryPostProcessors方法里面就完成了上述所说的扫描解析功能），当应用程序启动的时候首先会打印start，继而启动spring容器，然后调用invokeBeanFactoryPostProcessors方法，在没有执行该方法之前查看beanDefintionMap当中并没有key为”x”的元素，说明X并没有被扫描，然后继续执行，当执行完invokeBeanFactoryPostProcessors方法时候再次查看beanDefintionMap可以看到map当中多了一个key为”x”的元素，其对应的value就是一个beanDefintion的对象，最后查看后台发现还没有打印”X Constructor”这说明这个时候X并没有被实例化，这个例子说明spring是先把类扫描出来解析称为一个beanDefintion对象，然后put到beanDefintionMap后面才会去实例化X，至于这个beanDefintionMap后面的文章我会详细讲解，本文读者只需知道他是一个专门来存放beanDefinition的集合即可<br><img src="/2022/10/25/beanDefinition1/18.gif" alt="在这里插入图片描述"></p>
<p>④当spring把类所对应的beanDefintion对象存到map之后，spring会调用程序员提供的bean工厂后置处理器。什么叫bean工厂后置处理器？在spring的代码级别是用一个接口来表示BeanFactoryPostProcessor，只要实现这个接口便是一个bean工厂后置处理器了，BeanFactoryPostProcessor的详细源码解析后面文章再来分析，这里先说一下他的基本作用。BeanFactoryPostProcessor接口在spring内部也有实现，比如第①步当中完成扫描功能的类ConfigurationClassPostProcessor便是一个spring自己实现的bean工厂后置处理器，这个类笔者认为是阅读spring源码当中最重要的类，没有之一；他完成的功能太多了，以后我们一一分析，先看一下这个类的类结构图。<br><img src="/2022/10/25/beanDefinition1/19.png" alt="在这里插入图片描述"></p>
<p>ConfigurationClassPostProcessor实现了很多接口，和本文有关的只需关注两个接口BeanDefinitionRegistryPostProcessor和BeanFactoryPostProcessor；但是由于BeanDefinitionRegistryPostProcessor是继承了BeanFactoryPostProcessor所以读者也可以理解这是一个接口，但是笔者更加建议你理解成两个接口比较合适，因为spring完成上述①②③步的功能就是调用BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry方法完成的，到了第④步的时候spring是执行BeanFactoryPostProcessor的postProcessBeanFactory方法；这里可能说的有点绕，大概意思spring完成①②③的功能是调用ConfigurationClassPostProcessor的BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry方法，到了第④步spring首先会调用ConfigurationClassPostProcessor的BeanFactoryPostProcessor的postProcessBeanFactory的方法，然后在调用程序员提供的BeanFactoryPostProcessor的postProcessBeanFactory方法，所以上图当中第④步我画的是红色虚线，因为第④步可能没有（如果程序员没有提供自己的BeanFactoryPostProcessor；当然这里一定得说明，即使程序员没有提供自己扩展的BeanFactoryPostProcessor，spring也会执行内置的BeanFactoryPostProcessor也就是ConfigurationClassPostProcessor，所以上图画的并不标准，少了一步；即spring执行内置的BeanFactoryPostProcessor；</p>
<p>重点：我们用自己的话总结一下BeanFactoryPostProcessor的执行时机（不管内置的还是程序员提供）————Ⅰ：如果是直接实现BeanFactoryPostProcessor的类是在spring完成扫描类之后（所谓的扫描包括把类变成beanDefinition然后put到map之中），在实例化bean（第⑤步）之前执行；Ⅱ如果是实现BeanDefinitionRegistryPostProcessor接口的类；诚然这种也叫bean工厂后置处理器他的执行时机是在执行直接实现BeanFactoryPostProcessor的类之前，和扫描（上面①②③步）是同期执行；假设你的程序扩展一个功能，需要在这个时期做某个功能则可以实现这个接口；但是笔者至今没有遇到这样的需求，如果以后遇到或者看到再来补上；（说明一下当笔者发表这篇博客有一个读者联系笔者说他看到了一个主流框架就是扩展了BeanDefinitionRegistryPostProcessor类，瞬间笔者如久旱遇甘霖，光棍遇寡妇；遂立马请教；那位读者说mybatis的最新代码里面便是扩展这个类来实现的，笔者记得以前mybatis是扩展没有用到这个接口，后来笔者看了一下最新的mybatis源码确实如那位读者所言，在下一篇笔者分析主流框架如何扩展spring的时候更新）</p>
<p><img src="/2022/10/25/beanDefinition1/20.png" alt="在这里插入图片描述"></p>
<p>这里再次啰嗦一下，这一段比较枯燥和晦涩，但是非常重要，如果想做到精读spring源码这一段尤为重要，建议读者多看多理解；</p>
<p>那么第④步当中提到的执行程序员提供的BeanFactoryPostProcessor到底有什么意义呢？程序员提供BeanFactoryPostProcessor的场景在哪里？有哪些主流框架这么干过呢？<br>首先回答第一个问题，意义在哪里？可以看一下这个接口的方法签名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span><br><span class="line"><span class="keyword">throws</span> BeansException;</span><br></pre></td></tr></table></figure>

<p>其实讨论这个方法的意义就是讨论<strong>BeanFactoryPostProcessor</strong>的作用或者说意义，参考这个方法的一句javadoc</p>
<blockquote>
<p>Modify the application context’s internal bean factory after its standard initialization<br>在应用程序上下文的标准初始化之后修改它的内部bean工厂</p>
</blockquote>
<p>再结合这个方法的执行时机和这段javadoc我们可以理解bean工厂的后置处理器（这里只讨论直接实现BeanFactoryPostProcessor的后置处理器，不包括实现<code>BeanDefinitionRegistryPostProcessor</code>的后置处理器）其实是spring提供的一个扩展点（spring提供很多扩展点，学习spring源码的一个非常重要的原因就是要学会这些扩展点，以便对spring做二次开发或者写出优雅的插件），可以让程序员干预bean工厂的初始化过程（重点会考）；这句话最重要的几个字是初始化过程，注意不是实例化过程 ；初始化和实例化有很大的区别的，特别是在读spring源码的时候一定要注意这两个名词；翻开spring源码你会发现整个容器初始化过程就是spring各种后置处理器调用过程；而各种后置处理器当中大体分为两种；一种关于实例化的后置处理器一种是关于初始化的后置处理器，这里不是笔者臆想出来的，如果读者熟悉spring的后置处理器体系就可以从spring的后置处理器命名看出来spring对初始化和实例化是有非常大的区分的。</p>
<p>说白了就是——beanFactory怎么new出来的（实例化）BeanFactoryPostProcessor是干预不了的，但是beanFactory new出来之后各种属性的填充或者修改（初始化）是可以通过BeanFactoryPostProcessor来干预；可以看到BeanFactoryPostProcessor里唯一的方法postProcessBeanFactory中唯一的参数就是一个标准的beanFactory对象——ConfigurableListableBeanFactory；既然spring在调用postProcessBeanFactory方法的时候把已经实例化好的beanFactory对象传过来了，那么自然而然我们可以对这个beanFactory肆意妄为了；</p>
<p>虽然肆意妄为听起来很酷，实则很多人会很迷茫；就相当于现在送给了你一辆奥迪A6（笔者的dream car！重点会考）告诉你可以对这辆车肆意妄为，可你如果只是会按按喇叭，那就对不起赠送者的一番美意了；其实你根本不知道可以在午夜开车这辆车去长沙的解放西路转一圈，继而会收货很多意外的“爱情”；笔者举这个例子就是想说当你拿到beanFactory对象的时候不能只会sout，那不叫肆意妄为；我们可以干很多事情，但是你必须要了解beanFactory的特性或者beanFactory的各种api，但是beanFactory这个对象太复杂了，这里不适合展开讨论，与本文相关的只要知道上述我们讲到的那个beanDefintionMap（存储beanDefintion的集合）就定义在beanFactory当中；而且他也提供额api供程序员来操作这个map，比如可以修改这个map当中的beanDefinition对象，也可以添加一个beanDefinition对象到这个map当中；看一段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBeanFactoryPostPorcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">		<span class="comment">//转换为子类，因为父类没有添加beanDefintion对象的api</span></span><br><span class="line">		<span class="type">DefaultListableBeanFactory</span> <span class="variable">defaultbf</span> <span class="operator">=</span></span><br><span class="line">				(DefaultListableBeanFactory) beanFactory;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//new一个Y的beanDefinition对象，方便测试动态添加</span></span><br><span class="line">		GenericBeanDefinition y= <span class="keyword">new</span> <span class="title class_">GenericBeanDefinition</span>();</span><br><span class="line">		y.setBeanClass(Y.class);</span><br><span class="line">		<span class="comment">//添加一个beanDefinition对象，原本这个Y没有被spring扫描到</span></span><br><span class="line">		defaultbf.registerBeanDefinition(<span class="string">&quot;y&quot;</span>, y);</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//得到一个已经被扫描出来的beanDefintion对象x</span></span><br><span class="line">		<span class="comment">//因为X本来就被扫描出来了，所以是直接从map中获取</span></span><br><span class="line">		<span class="type">BeanDefinition</span> <span class="variable">x</span> <span class="operator">=</span> defaultbf.getBeanDefinition(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">		<span class="comment">//修改这个X的beanDefintion对象的class为Z</span></span><br><span class="line">		<span class="comment">//原本这个x代表的class为X.class；现在为Z.class</span></span><br><span class="line">		x.setBeanClassName(<span class="string">&quot;com.luban.beanDefinition.Z&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>项目里面有三个类X，Y，Z其中只有X加了@Component注解；也就是当代码执行到上面那个方法的时候只扫描到了X；beanFactory里的beanDefinitionMap当中也只有X所对应的beanDefinition对象；笔者首先new了一个Y所对应的beanDefinition对象然后调用registerBeanDefinition(“y”, y)；把y对应的beanDefinition对象put到beanDefinitionMap，这是演示动态添加一个自己实例化的beanDefinition对象；继而又调用getBeanDefinition(“x”)得到一个已经存在的beanDefinition对象，然后调用x.setBeanClassName(“Z”);把x所对应的beanDefinition对象所对应的class改成了Z，这是演示动态修改一个已经扫描完成的beanDefinition对象；</p>
<p>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span></span><br><span class="line">		 <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">		ac.register(Appconfig.class);</span><br><span class="line">		ac.refresh();</span><br><span class="line">		<span class="comment">//正常打印</span></span><br><span class="line">		System.out.println(ac.getBean(Y.class));</span><br><span class="line">		<span class="comment">//正常打印</span></span><br><span class="line">		System.out.println(ac.getBean(Z.class));</span><br><span class="line">		<span class="comment">//异常打印</span></span><br><span class="line">		<span class="comment">//虽然X加了注解，但是被偷梁换柱了，故而异常</span></span><br><span class="line">		System.out.println(ac.getBean(X.class));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>附图：</p>
<p><img src="/2022/10/25/beanDefinition1/21.gif" alt="在这里插入图片描述"></p>
<p>总结一下上面那副图，spring实例化一个bean其实和你提供的那个类并没有直接关系，而是和一个beanDefintion对象所对应的那个类有直接关系（正常情况下一个beanDefinition对象会对应一个类，但是也有不正常的情况）；打个庸俗的比方好比读者你喜欢一个女生小A；而小A喜欢笔者，但是你不能说你也喜欢笔者；而且笔者还是钢铁直男无论如何也不被可能掰弯的；</p>
<p>看完这个结果你还敢轻视spring当中的建模对象beanDefintion的作用了吗？但是BeanDefinition这个接口有太多的实现类，是一个比较复杂的体现，下一篇我慢慢把spring体现当的各种beanDefinition对象逐一介绍清楚；</p>
<blockquote>
<p>那么第④步当中提到的执行程序员提供的BeanFactoryPostProcessor到底有什么意义呢？程序员提供BeanFactoryPostProcessor的场景在哪里？有哪些主流框架这么干过呢？<br>第一个问题我们大概回答了一下，程序员一般提供BeanFactoryPostProcessor是为了对beanFactory做修改或者叫做干预他的初始化；能修改什么？或者能干预什么？这个问题比较庞大，至少你现在知道可以修改beanFactory当中的beanDefinitionMap<br>至于剩下两个问题，我以后更新吧</p>
</blockquote>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>框架源码</tag>
      </tags>
  </entry>
  <entry>
    <title>beanDefinition2</title>
    <url>/2022/10/25/beanDefinition2/</url>
    <content><![CDATA[<p>在上一篇文章里面我们讨论了一个beanDefintion对象的重要性，为了讨论spring当中的beanDefinition对象我们不得不牵扯出spring当中的bean工厂后置处理器也就是BeanFactoryPostProcessor这个类；继而讨论了BeanFactoryPostProcessor的大概执行时机（BeanFactoryPostProcessor的执行时机很重要而且spring内部做的稍微有点复杂，本文重点来讨论spring内部怎么保证这些执行时机得以严禁的执行，还有如何来扩展spring的bean工厂后置处理器）；首先通过一张图简单的理解一下spring容器启动的时候执行调用BeanFactoryPostProcessor后置处理器的大概的方法执行顺序</p>
<p><img src="/2022/10/25/beanDefinition2/22.png" alt="在这里插入图片描述"></p>
<p>上图大概分为④步（这里只是讨论spring如何调用BeanFactoryPostProcessor，在调用之前到底执行了那些方法，上图并不是spring容器启动的所有步骤）<br>①启动main方法，在main方法里面调用<br>②AnnotationConfigApplicationContext的无参构造方法，然后②-1在无参构造方法里面首先实例化AnnotatedBeanDefinitionReader对象，实例化这个对象有两个非常重要的意义。 <strong>1、这个对象实例化出来有什么用（问题一） ； 2、实例化这个对象的过程中做了哪些事情（问题二）</strong></p>
<blockquote>
<p>所有的<code>问题X</code>，文章后面再解释，这里先把步骤搞清楚</p>
</blockquote>
<p>继而②-2spring又实例化了一个ClassPathBeanDefinitionScanner对象，这个对象顾名思义就是能够用来完成spring的扫描功能，但是这里提一句——spring内部完成扫描功能并不是用的这个对象，而是在扫描的时候又new了一个新的ClassPathBeanDefinitionScanner对象；换言之这里spring new的对象我们假设他为a，但是spring在真正完成扫描的时候又new了一个b，但是是同一个类都是ClassPathBeanDefinitionScanner，但是为什么需要两个？ 3、直接用a不就可以了吗？如果spring内部完成扫描时候没用a，那么a被new出来在哪里使用了？（问题三）到此为止第②步完成；<br>③调用register(Appconfig.class);首先会把Appconfig类解析成为一个beanDefintion对象（如何把一个类解析称为beanDefinition对象的？这里其实涉及到②-1AnnotatedBeanDefinitionReader对象的意义，如果你明白了②-1这里也就明白了），然后给解析出来的beanDefinition对象设置一些默认属性，继而put到beanDefintionMap当中；为什么需要put到beanDefintionMap呢？在上一篇我们已经解释过这个map就是单纯用来存储beanDefinition的，spring后面会遍历这个map根据map当中的beanDefinition来实例化bean，如果Appconfig类的beanDefintion存在在map当中那么他必然会被spring容器实例化称为一个bean？为什么Appconfig会需要实例化呢？因为Appconfig当中有很多加了@Bean的方法，这些方法需要被调用，故而需要实例化，但是Appconfig类的实例化很复杂比一般类实例化过程复杂很多，涉及到代理涉及到cglib等等，这个我们后面文章解释；这里还需要解释一个问题，为什么Appconfig类是通过register(Appconfig.class);手动put到map当中呢？为什么不是扫描出来的呢？（一般类都是通过扫描出来的），其实也很简单，因为他无法扫描自己，一般类是spring通过解析Appconfig上的@ComponentScan注解然后被扫描到，所以无法扫描自己；接下来便是第<br>④步，④-1到④-4以后分析，④-5便是我们上篇文章说的执行spring当中的bean工厂后置处理器，也是本文重点讨论的；下图是对上述文字的一个说明——spring容器启动的执行顺序</p>
<p><img src="/2022/10/25/beanDefinition2/23.gif" alt="在这里插入图片描述"></p>
<p>接下来解释上面文字里的所有问题<br><strong>问题一</strong>——AnnotatedBeanDefinitionReader这个对象实例化出来有什么用？<br>先看一下这个类的javadoc，看看作者怎么来解释这个类的</p>
<p><img src="/2022/10/25/beanDefinition2/24.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>Convenient adapter for programmatic registration of annotated bean<br>classes. * This is an alternative to {@link<br>ClassPathBeanDefinitionScanner}, applying * the same resolution of<br>annotations but for explicitly registered classes only</p>
</blockquote>
<p>按照笔者蹩脚的英文水平我的理解是：这个类作用分为以下两个<br>1、可用于编程式动态注册一个带注解的bean，什么意思呢?比如我们有一个类A存在com.shadow包下面，并且是一个加注解的类。比如加了@Component，正常情况下这个类A一般是被spring扫描出来的，但是有不正常情况，比如spring并没有扫描到com.shadow包，那么类A就无法被容器实例化。有人可能会问为什么没有扫描到com.shadow包？扫描情况下不会扫描到？其实很简单，假设你的这个类是动态生成，在容器实例化的时候不存在那么肯定不存在，再或者这个包下面有N多类但是只有一个类加了注解，那么其实你不需要去扫描，只需要添加这一个加了注解的类即可，再或者一个类是你和第三方系统交互后得到的。那么这个时候我们可以把这个类通过AnnotatedBeanDefinitionReader的register(Class clazz)方法把一个带注解的类注册给spring（这里的注册其实就是上一篇文章中说的把一个类解析成BeanDefintion对象，然后把这个对象put到beanDefinitionMap当中），写个例子来测试一下他的这个注册bean的功能</p>
<p><img src="/2022/10/25/beanDefinition2/25.gif" alt="在这里插入图片描述"></p>
<p>2、可以代替ClassPathBeanDefinitionScanner这个类，具备相同的注解解析功能， ClassPathBeanDefinitionScanner是spring完成扫描的核心类，这个我后面会分析；简而言之，spring完成扫描主要是依靠ClassPathBeanDefinitionScanner这个类的对象，但是AnnotatedBeanDefinitionReader可以替代他完成相同的注解解析，意思就是通过ClassPathBeanDefinitionScanner扫描出来的类A和通过AnnotatedBeanDefinitionReader显示注册的类A在spring内部会一套相同的解析规则；这点上面那个例子已经证明了。</p>
<p>那么AnnotatedBeanDefinitionReader除了动态显示注册一些spring扫描不到的类之外还有什么功能？在初始化spring容器的过程中他主要干了什么事情呢？或者这么说：假设程序中没有需要动态显示注册的类他就没用了吗？再或者AnnotatedBeanDefinitionReader这个类的对象除了注册一些自己的类还有什么应用场景呢？——注册我们的配置类，对于不理解是什么配置的读者可以理解所谓的配置类就是那个加了@Configuration和@ComponentScan的那个类，也就是Appconfig.java；<br>那么问题来了，为什么配置类需要手动注册呢？很简单因为配置类无法扫描出来，所以需要我们手动注册。为什么无法扫描呢？比如spring完成扫描是需要解析Appconfig.java当中的@ComponentScan注解的值（一般是一个包名），得到这个值之后去扫描这个值所代表的包下面的所有bean；简单的说就是spring如果想要完成扫描必须先提供Appconfig.java，所以Appconfig.java要在一开始就手动注册给spring，spring得到Appconfig.class之后把他解析成BeanDefintion对象，继而去获取@ComponentScan的值然后才开始扫描其他bean；</p>
<p>总结：AnnotatedBeanDefinitionReader的作用1、主要是可以动态、显示的注册一个bean；2、而且具备解析一个类的功能；和扫描解析一个类的功能相同；AnnotatedBeanDefinitionReader的应用场景1、可以显示、动态注册一个程序员提供的bean；2、在初始化spring容器的过程中他完成了对配置类的注册和解析功能；</p>
<p>针对AnnotatedBeanDefinitionReader应用场景的第2点，我在啰嗦几句，一般程序员在初始化spring容器的时候代码有很多种写法，但都是换汤不换药的，我这里举2个栗子。<br>第一种写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span></span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line"><span class="comment">//动态注册一个配置类</span></span><br><span class="line">ac.register(Appconfig.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用refresh方法</span></span><br><span class="line"><span class="comment">//这里很多资料都叫做刷新spring容器</span></span><br><span class="line"><span class="comment">//但是我觉得不合适，这是硬核翻译，比较生硬</span></span><br><span class="line"><span class="comment">//笔者觉得理解为初始化spring容器更加精准</span></span><br><span class="line"><span class="comment">//至于为什么以后慢慢更新再说</span></span><br><span class="line">ac.refresh();</span><br></pre></td></tr></table></figure>

<p>第二种写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(Appconfig.class);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这两种写法都初始化spring容器，代码上的区别无非就是第一种写法是调用<code>AnnotationConfigApplicationContext()</code>；的无参构造方法，第二种写法是调用了<code>AnnotationConfigApplicationContext（Class&lt;?&gt;... annotatedClasses）</code>有参构造方法；但是你如果翻阅源码第二种写法的内部也是首先调用无参构造方法的，继而内部继续调用register(Appconfig.class)方法，最后调用refresh();方法，和第一种写法的区别是register和refresh是程序员调用的；笔者更推荐第一种写法，因为第一种写法可以在初始化spring容器之前得到<code>AnnotationConfigApplicationContext</code>的对象也就是代码里面的ac对象；用一张图来说明一下这两种写法的异同</p>
<p><img src="/2022/10/25/beanDefinition2/26.gif" alt="在这里插入图片描述"></p>
<p>其实第一种方法和第二种方法都可以得到ac对象，那么为什么第一种写法笔者推荐呢？首先第二种方法是在spring容器完成初始化之后的到的ac对象，容器已经初始化了，这个时候得到这个对象能干了事情少了很多；第一种方法在初始化之前得到的，那么能干的事情可多了。①比如我们可以在容器初始化之前动态注册一个自己的bean，就是上文提到的 AnnotatedBeanDefinitionReader的应用场景，②再比如可以利用ac对象来关闭或者开启spring的循环依赖，在笔者的第一篇博客里面也有提到，③还比如程序员可以在容器初始化之前注册自己实例化的BeanDefinition对象。如果你像笔者一样精通spring源码你会发觉提前得到这个ac对象可以做的事情太多了，笔者这里说的三个比如都必须在spring容器初始化之前做才有意义，简而言之就是需要在spring调用refresh方法之间做才有意义；如果你不理解我打个比较污的比方；<br>假设有机会约到某乔姓网红，无比兴奋之后现在来分析起因和最终结果；起因是她愿意出来和你约会，结果是约会完成最终她还是要回家的。但是过程可以很精彩呀！对比spring的源码起因是你首先成功实例化了一个ac对象(ac成功实例化&#x3D;&#x3D;你成功约会&#x3D;&#x3D;new出来的ac对象&#x3D;&#x3D;约出来的乔姑娘)，结果是调用ac.refresh()完成初始化spring容器，相当于乔姑娘回家&#x3D;&#x3D;完成约会；</p>
<p>那么你想一下第一种方式是你成功实例化一个ac对象，在完成初始化之前可以肆意妄为，除了对ac这个对象为所欲为（调用ac的api）之外还可以写任何你自己想写的代码；相当于你成功约到乔姑娘，然后你可以拿到她的身份证。但是第二种方式相当于你约到了乔姑娘，但是约会的过程你没办法参与都是姑娘自己安排，她可能和你看完电影之后就告诉你身份证丢了然后各回各家；所以笔者推荐使用第一种方式实例化spring容器。。。。至于原因我已经说的够清楚了。</p>
<p>到此为止已经解释完了问题一——AnnotatedBeanDefinitionReader这个对象实例化出来有什么用？</p>
<p>那么问题二和问题三 下篇文章讨论，为了说清楚spring当中BeanDefintion笔者已经写了两篇博客（根本没有进入BeanDefintion的主题），之前说过会用三篇文章来分析，看来需要食言了，想了一下至少需要五篇才能说清楚</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>框架源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat-架构解析</title>
    <url>/2022/10/25/Tomcat-%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Tomcat-架构原理解析到架构设计借鉴"><a href="#Tomcat-架构原理解析到架构设计借鉴" class="headerlink" title="Tomcat 架构原理解析到架构设计借鉴"></a>Tomcat 架构原理解析到架构设计借鉴</h1><blockquote>
<p>Tomcat 发展这么多年，已经比较成熟稳定。在如今『追新求快』的时代，Tomcat 作为 Java Web 开发必备的工具似乎变成了『熟悉的陌生人』，难道说如今就没有必要深入学习它了么？学习它我们又有什么收获呢？</p>
</blockquote>
<p><strong>静下心来，细细品味经典的开源作品</strong> 。提升我们的「内功」，具体来说就是学习大牛们如何设计、架构一个中间件系统，并且让这些经验为我所用。</p>
<p>美好的事物往往是整洁而优雅的。但这并不等于简单，而是要将复杂的系统分解成一个个小模块，并且各个模块的职责划分也要清晰合理。</p>
<p>与此相反的是凌乱无序，比如你看到城中村一堆互相纠缠在一起的电线，可能会感到不适。维护的代码一个类几千行、一个方法好几百行。方法之间相互耦合糅杂在一起，你可能会说 what the f*k！</p>
<p><img src="/2022/10/25/Tomcat-%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/1.png" alt="图片"></p>
<h2 id="学习目的"><a href="#学习目的" class="headerlink" title="学习目的"></a>学习目的</h2><h3 id="掌握-Tomcat-架构设计与原理提高内功"><a href="#掌握-Tomcat-架构设计与原理提高内功" class="headerlink" title="掌握 Tomcat 架构设计与原理提高内功"></a>掌握 Tomcat 架构设计与原理提高内功</h3><p><strong>宏观上看</strong></p>
<p>Tomcat 作为一个 「<code>Http</code> 服务器 + <code>Servlet</code> 容器」，对我们屏蔽了应用层协议和网络通信细节，给我们的是标准的 <code>Request</code> 和 <code>Response</code> 对象；对于具体的业务逻辑则作为变化点，交给我们来实现。我们使用了<code>SpringMVC</code> 之类的框架，可是却从来不需要考虑 <code>TCP</code> 连接、 <code>Http</code> 协议的数据处理与响应。就是因为 Tomcat 已经为我们做好了这些，我们只需要关注每个请求的具体业务逻辑。</p>
<p><strong>微观上看</strong></p>
<p><code>Tomcat</code> 内部也隔离了变化点与不变点，使用了组件化设计，目的就是为了实现「俄罗斯套娃式」的高度定制化（组合模式），而每个组件的生命周期管理又有一些共性的东西，则被提取出来成为接口和抽象类，让具体子类实现变化点，也就是模板方法设计模式。</p>
<p>当今流行的微服务也是这个思路，按照功能将单体应用拆成「微服务」，拆分过程要将共性提取出来，而这些共性就会成为核心的基础服务或者通用库。「中台」思想亦是如此。</p>
<p>设计模式往往就是封装变化的一把利器，合理的运用设计模式能让我们的代码与系统设计变得优雅且整洁。</p>
<p>这就是学习优秀开源软件能获得的「内功」，从不会过时，其中的设计思想与哲学才是根本之道。从中借鉴设计经验，合理运用设计模式封装变与不变，更能从它们的源码中汲取经验，提升自己的系统设计能力。</p>
<h3 id="宏观理解一个请求如何与-Spring-联系起来"><a href="#宏观理解一个请求如何与-Spring-联系起来" class="headerlink" title="宏观理解一个请求如何与 Spring 联系起来"></a>宏观理解一个请求如何与 Spring 联系起来</h3><p>在工作过程中，我们对 Java 语法已经很熟悉了，甚至「背」过一些设计模式，用过很多 Web 框架，但是很少有机会将他们用到实际项目中，让自己独立设计一个系统似乎也是根据需求一个个 Service 实现而已。脑子里似乎没有一张 Java Web 开发全景图，比如我并不知道浏览器的请求是怎么跟 Spring 中的代码联系起来的。</p>
<p>为了突破这个瓶颈，为何不站在巨人的肩膀上学习优秀的开源系统，看大牛们是如何思考这些问题。</p>
<p>学习 Tomcat 的原理，我发现 <code>Servlet</code> 技术是 Web 开发的原点，几乎所有的 Java Web 框架（比如 Spring）都是基于 <code>Servlet</code> 的封装，Spring 应用本身就是一个 <code>Servlet</code>（<code>DispatchSevlet</code>），而 Tomcat 和 Jetty 这样的 Web 容器，负责加载和运行 <code>Servlet</code>。如图所示：</p>
<p><img src="/2022/10/25/Tomcat-%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/2.png" alt="图片"></p>
<h3 id="提升自己的系统设计能力"><a href="#提升自己的系统设计能力" class="headerlink" title="提升自己的系统设计能力"></a>提升自己的系统设计能力</h3><p>学习 Tomcat ，我还发现用到不少 Java 高级技术，比如 Java 多线程并发编程、Socket 网络编程以及反射等。之前也只是了解这些技术，为了面试也背过一些题。但是总感觉「知道」与会用之间存在一道沟壑，通过对 Tomcat 源码学习，我学会了什么场景去使用这些技术。</p>
<p>还有就是系统设计能力，比如面向接口编程、组件化组合模式、骨架抽象类、一键式启停、对象池技术以及各种设计模式，比如模板方法、观察者模式、责任链模式等，之后我也开始模仿它们并把这些设计思想运用到实际的工作中。</p>
<h2 id="整体架构设计"><a href="#整体架构设计" class="headerlink" title="整体架构设计"></a>整体架构设计</h2><p>今天咱们就来一步一步分析 Tomcat 的设计思路，一方面我们可以学到 Tomcat 的总体架构，学会从宏观上怎么去设计一个复杂系统，怎么设计顶层模块，以及模块之间的关系；另一方面也为我们深入学习 Tomcat 的工作原理打下基础。</p>
<p>Tomcat 启动流程：<code>startup.sh -&gt; catalina.sh start -&gt;java -jar org.apache.catalina.startup.Bootstrap.main()</code></p>
<p>Tomcat 实现的 2 个核心功能：</p>
<ul>
<li>处理 <code>Socket</code> 连接，负责网络字节流与 <code>Request</code> 和 <code>Response</code> 对象的转化。</li>
<li>加载并管理 <code>Servlet</code> ，以及处理具体的 <code>Request</code> 请求。</li>
</ul>
<p><strong>所以 Tomcat 设计了两个核心组件连接器（Connector）和容器（Container）。连接器负责对外交流，容器负责内部 处理</strong></p>
<p><code>Tomcat</code>为了实现支持多种 <code>I/O</code> 模型和应用层协议，一个容器可能对接多个连接器，就好比一个房间有多个门。</p>
<p><img src="/2022/10/25/Tomcat-%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/3.png" alt="图片">Tomcat整体架构</p>
<ul>
<li>Server 对应的就是一个 Tomcat 实例。</li>
<li>Service 默认只有一个，也就是一个 Tomcat 实例默认一个 Service。</li>
<li>Connector：一个 Service 可能多个 连接器，接受不同连接协议。</li>
<li>Container: 多个连接器对应一个容器，顶层容器其实就是 Engine。</li>
</ul>
<p><strong>每个组件都有对应的生命周期，需要启动，同时还要启动自己内部的子组件，比如一个 Tomcat 实例包含一个 Service，一个 Service 包含多个连接器和一个容器。而一个容器包含多个 Host， Host 内部可能有多个 Contex t 容器，而一个 Context 也会包含多个 Servlet，所以 Tomcat 利用组合模式管理组件每个组件，对待过个也想对待单个组一样对待</strong>。整体上每个组件设计就像是「俄罗斯套娃」一样。</p>
<h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>在开始讲连接器前，我先铺垫一下 <code>Tomcat</code>支持的多种 <code>I/O</code> 模型和应用层协议。</p>
<p><code>Tomcat</code>支持的 <code>I/O</code> 模型有：</p>
<ul>
<li><code>NIO</code>：非阻塞 <code>I/O</code>，采用 <code>Java NIO</code> 类库实现。</li>
<li><code>NIO2</code>：异步<code>I/O</code>，采用 <code>JDK 7</code> 最新的 <code>NIO2</code> 类库实现。</li>
<li><code>APR</code>：采用 <code>Apache</code>可移植运行库实现，是 <code>C/C++</code> 编写的本地库。</li>
</ul>
<p>Tomcat 支持的应用层协议有：</p>
<ul>
<li><code>HTTP/1.1</code>：这是大部分 Web 应用采用的访问协议。</li>
<li><code>AJP</code>：用于和 Web 服务器集成（如 Apache）。</li>
<li><code>HTTP/2</code>：HTTP 2.0 大幅度的提升了 Web 性能。</li>
</ul>
<p>所以一个容器可能对接多个连接器。连接器对 <code>Servlet</code> 容器屏蔽了网络协议与 <code>I/O</code> 模型的区别，无论是 <code>Http</code> 还是 <code>AJP</code>，在容器中获取到的都是一个标准的 <code>ServletRequest</code> 对象。</p>
<p>细化连接器的功能需求就是：</p>
<ul>
<li>监听网络端口。</li>
<li>接受网络连接请求。</li>
<li>读取请求网络字节流。</li>
<li>根据具体应用层协议（<code>HTTP/AJP</code>）解析字节流，生成统一的 <code>Tomcat Request</code> 对象。</li>
<li>将 <code>Tomcat Request</code> 对象转成标准的 <code>ServletRequest</code>。</li>
<li>调用 <code>Servlet</code>容器，得到 <code>ServletResponse</code>。</li>
<li>将 <code>ServletResponse</code>转成 <code>Tomcat Response</code> 对象。</li>
<li>将 <code>Tomcat Response</code> 转成网络字节流。</li>
<li>将响应字节流写回给浏览器。</li>
</ul>
<p>需求列清楚后，我们要考虑的下一个问题是，连接器应该有哪些子模块？优秀的模块化设计应该考虑<strong>高内聚、低耦合</strong>。</p>
<ul>
<li><strong>高内聚</strong>是指相关度比较高的功能要尽可能集中，不要分散。</li>
<li><strong>低耦合</strong>是指两个相关的模块要尽可能减少依赖的部分和降低依赖的程度，不要让两个模块产生强依赖。</li>
</ul>
<p>我们发现连接器需要完成 3 个<strong>高内聚</strong>的功能：</p>
<ul>
<li>网络通信。</li>
<li>应用层协议解析。</li>
<li><code>Tomcat Request/Response</code> 与 <code>ServletRequest/ServletResponse</code> 的转化。</li>
</ul>
<p>因此 Tomcat 的设计者设计了 3 个组件来实现这 3 个功能，分别是 <code>EndPoint、Processor 和 Adapter</code>。</p>
<p>网络通信的 I&#x2F;O 模型是变化的, 应用层协议也是变化的，但是整体的处理逻辑是不变的，<code>EndPoint</code> 负责提供字节流给 <code>Processor</code>，<code>Processor</code>负责提供 <code>Tomcat Request</code> 对象给 <code>Adapter</code>，<code>Adapter</code>负责提供 <code>ServletRequest</code>对象给容器。</p>
<p><strong>封装变与不变</strong></p>
<p>因此 Tomcat 设计了一系列抽象基类来<strong>封装这些稳定的部分</strong>，抽象基类 <code>AbstractProtocol</code>实现了 <code>ProtocolHandler</code>接口。每一种应用层协议有自己的抽象基类，比如 <code>AbstractAjpProtocol</code>和 <code>AbstractHttp11Protocol</code>，具体协议的实现类扩展了协议层抽象基类。</p>
<p>这就是模板方法设计模式的运用。</p>
<p><img src="/2022/10/25/Tomcat-%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/4.png" alt="图片">应用层协议抽象</p>
<p>总结下来，连接器的三个核心组件 <code>Endpoint</code>、<code>Processor</code>和 <code>Adapter</code>来分别做三件事情，其中 <code>Endpoint</code>和 <code>Processor</code>放在一起抽象成了 <code>ProtocolHandler</code>组件，它们的关系如下图所示。</p>
<p><img src="/2022/10/25/Tomcat-%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/5.png" alt="图片">连接器</p>
<h4 id="ProtocolHandler-组件"><a href="#ProtocolHandler-组件" class="headerlink" title="ProtocolHandler 组件"></a>ProtocolHandler 组件</h4><p>主要处理 <strong>网络连接</strong> 和 <strong>应用层协议</strong> ，包含了两个重要部件 EndPoint 和 Processor，两个组件组合形成 ProtocoHandler，下面我来详细介绍它们的工作原理。</p>
<h5 id="EndPoint"><a href="#EndPoint" class="headerlink" title="EndPoint"></a>EndPoint</h5><p><code>EndPoint</code>是通信端点，即通信监听的接口，是具体的 Socket 接收和发送处理器，是对传输层的抽象，因此 <code>EndPoint</code>是用来实现 <code>TCP/IP</code> 协议数据读写的，本质调用操作系统的 socket 接口。</p>
<p><code>EndPoint</code>是一个接口，对应的抽象实现类是 <code>AbstractEndpoint</code>，而 <code>AbstractEndpoint</code>的具体子类，比如在 <code>NioEndpoint</code>和 <code>Nio2Endpoint</code>中，有两个重要的子组件：<code>Acceptor</code>和 <code>SocketProcessor</code>。</p>
<p>其中 Acceptor 用于监听 Socket 连接请求。<code>SocketProcessor</code>用于处理 <code>Acceptor</code> 接收到的 <code>Socket</code>请求，它实现 <code>Runnable</code>接口，在 <code>Run</code>方法里调用应用层协议处理组件 <code>Processor</code> 进行处理。为了提高处理能力，<code>SocketProcessor</code>被提交到线程池来执行。</p>
<p>我们知道，对于 Java 的多路复用器的使用，无非是两步：</p>
<ol>
<li>创建一个 Seletor，在它身上注册各种感兴趣的事件，然后调用 select 方法，等待感兴趣的事情发生。</li>
<li>感兴趣的事情发生了，比如可以读了，这时便创建一个新的线程从 Channel 中读数据。</li>
</ol>
<p>在 Tomcat 中 <code>NioEndpoint</code> 则是 <code>AbstractEndpoint</code> 的具体实现，里面组件虽然很多，但是处理逻辑还是前面两步。它一共包含 <code>LimitLatch</code>、<code>Acceptor</code>、<code>Poller</code>、<code>SocketProcessor</code>和 <code>Executor</code> 共 5 个组件，分别分工合作实现整个 TCP&#x2F;IP 协议的处理。</p>
<ul>
<li>LimitLatch 是连接控制器，它负责控制最大连接数，NIO 模式下默认是 10000，达到这个阈值后，连接请求被拒绝。</li>
<li><code>Acceptor</code>跑在一个单独的线程里，它在一个死循环里调用 <code>accept</code>方法来接收新连接，一旦有新的连接请求到来，<code>accept</code>方法返回一个 <code>Channel</code> 对象，接着把 <code>Channel</code>对象交给 Poller 去处理。</li>
<li><code>Poller</code> 的本质是一个 <code>Selector</code>，也跑在单独线程里。<code>Poller</code>在内部维护一个 <code>Channel</code>数组，它在一个死循环里不断检测 <code>Channel</code>的数据就绪状态，一旦有 <code>Channel</code>可读，就生成一个 <code>SocketProcessor</code>任务对象扔给 <code>Executor</code>去处理。</li>
<li>SocketProcessor 实现了 Runnable 接口，其中 run 方法中的 <code>getHandler().process(socketWrapper, SocketEvent.CONNECT_FAIL);</code> 代码则是获取 handler 并执行处理 socketWrapper，最后通过 socket 获取合适应用层协议处理器，也就是调用 Http11Processor 组件来处理请求。Http11Processor 读取 Channel 的数据来生成 ServletRequest 对象，Http11Processor 并不是直接读取 Channel 的。这是因为 Tomcat 支持同步非阻塞 I&#x2F;O 模型和异步 I&#x2F;O 模型，在 Java API 中，相应的 Channel 类也是不一样的，比如有 AsynchronousSocketChannel 和 SocketChannel，为了对 Http11Processor 屏蔽这些差异，Tomcat 设计了一个包装类叫作 SocketWrapper，Http11Processor 只调用 SocketWrapper 的方法去读写数据。</li>
<li><code>Executor</code>就是线程池，负责运行 <code>SocketProcessor</code>任务类，<code>SocketProcessor</code> 的 <code>run</code>方法会调用 <code>Http11Processor</code> 来读取和解析请求数据。我们知道，<code>Http11Processor</code>是应用层协议的封装，它会调用容器获得响应，再把响应通过 <code>Channel</code>写出。</li>
</ul>
<p>工作流程如下所示：</p>
<p><img src="/2022/10/25/Tomcat-%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/6.png" alt="图片">NioEndPoint</p>
<h5 id="Processor"><a href="#Processor" class="headerlink" title="Processor"></a>Processor</h5><p>Processor 用来实现 HTTP 协议，Processor 接收来自 EndPoint 的 Socket，读取字节流解析成 Tomcat Request 和 Response 对象，并通过 Adapter 将其提交到容器处理，Processor 是对应用层协议的抽象。</p>
<p><img src="/2022/10/25/Tomcat-%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/7.png" alt="图片"></p>
<p><strong>从图中我们看到，EndPoint 接收到 Socket 连接后，生成一个 SocketProcessor 任务提交到线程池去处理，SocketProcessor 的 Run 方法会调用 HttpProcessor 组件去解析应用层协议，Processor 通过解析生成 Request 对象后，会调用 Adapter 的 Service 方法，方法内部通过 以下代码将请求传递到容器中。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Calling the container</span><br><span class="line">connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);</span><br></pre></td></tr></table></figure>

<h4 id="Adapter-组件"><a href="#Adapter-组件" class="headerlink" title="Adapter 组件"></a>Adapter 组件</h4><p>由于协议的不同，Tomcat 定义了自己的 <code>Request</code> 类来存放请求信息，这里其实体现了面向对象的思维。但是这个 Request 不是标准的 <code>ServletRequest</code> ，所以不能直接使用 Tomcat 定义 Request 作为参数直接容器。</p>
<p>Tomcat 设计者的解决方案是引入 <code>CoyoteAdapter</code>，这是适配器模式的经典运用，连接器调用 <code>CoyoteAdapter</code> 的 <code>Sevice</code> 方法，传入的是 <code>Tomcat Request</code> 对象，<code>CoyoteAdapter</code>负责将 <code>Tomcat Request</code> 转成 <code>ServletRequest</code>，再调用容器的 <code>Service</code>方法。</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>连接器负责外部交流，容器负责内部处理。具体来说就是，连接器处理 Socket 通信和应用层协议的解析，得到 <code>Servlet</code>请求；而容器则负责处理 <code>Servlet</code>请求。</p>
<p>容器：顾名思义就是拿来装东西的， 所以 Tomcat 容器就是拿来装载 <code>Servlet</code>。</p>
<p>Tomcat 设计了 4 种容器，分别是 <code>Engine</code>、<code>Host</code>、<code>Context</code>和 <code>Wrapper</code>。<code>Server</code> 代表 Tomcat 实例。</p>
<p>要注意的是这 4 种容器不是平行关系，属于父子关系，如下图所示：</p>
<p><img src="/2022/10/25/Tomcat-%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/8.png" alt="图片">容器</p>
<p>你可能会问，为啥要设计这么多层次的容器，这不是增加复杂度么？其实这背后的考虑是，<strong>Tomcat 通过一种分层的架构，使得 Servlet 容器具有很好的灵活性。因为这里正好符合一个 Host 多个 Context， 一个 Context 也包含多个 Servlet，而每个组件都需要统一生命周期管理，所以组合模式设计这些容器</strong></p>
<p><code>Wrapper</code> 表示一个 <code>Servlet</code> ，<code>Context</code> 表示一个 Web 应用程序，而一个 Web 程序可能有多个 <code>Servlet</code> ；<code>Host</code> 表示一个虚拟主机，或者说一个站点，一个 Tomcat 可以配置多个站点（Host）；一个站点（ Host） 可以部署多个 Web 应用；<code>Engine</code> 代表 引擎，用于管理多个站点（Host），一个 Service 只能有 一个 <code>Engine</code>。</p>
<p>可通过 Tomcat 配置文件加深对其层次关系理解。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">&quot;8005&quot;</span> <span class="attr">shutdown</span>=<span class="string">&quot;SHUTDOWN&quot;</span>&gt;</span> // 顶层组件，可包含多个 Service，代表一个 Tomcat 实例</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">&quot;Catalina&quot;</span>&gt;</span>  // 顶层组件，包含一个 Engine ，多个连接器</span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Define an AJP 1.3 Connector on port 8009 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8009&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;AJP/1.3&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span>  // 连接器</span><br><span class="line"></span><br><span class="line"> // 容器组件：一个 Engine 处理 Service 所有请求，包含多个 Host</span><br><span class="line">    <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">&quot;Catalina&quot;</span> <span class="attr">defaultHost</span>=<span class="string">&quot;localhost&quot;</span>&gt;</span></span><br><span class="line">   // 容器组件：处理指定Host下的客户端请求， 可包含多个 Context</span><br><span class="line">      <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">&quot;localhost&quot;</span>  <span class="attr">appBase</span>=<span class="string">&quot;webapps&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">unpackWARs</span>=<span class="string">&quot;true&quot;</span> <span class="attr">autoDeploy</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">   // 容器组件：处理特定 Context Web应用的所有客户端请求</span><br><span class="line">   <span class="tag">&lt;<span class="name">Context</span>&gt;</span><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如何管理这些容器？我们发现容器之间具有父子关系，形成一个树形结构，是不是想到了设计模式中的 <strong>组合模式</strong> 。</p>
<p>Tomcat 就是用组合模式来管理这些容器的。具体实现方法是，<strong>所有容器组件都实现了 <code>Container</code>接口，因此组合模式可以使得用户对单容器对象和组合容器对象的使用具有一致性</strong>。这里单容器对象指的是最底层的 <code>Wrapper</code>，组合容器对象指的是上面的 <code>Context</code>、<code>Host</code>或者 <code>Engine</code>。<code>Container</code> 接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Container</span> <span class="keyword">extends</span> <span class="title class_">Lifecycle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>;</span><br><span class="line">    <span class="keyword">public</span> Container <span class="title function_">getParent</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setParent</span><span class="params">(Container container)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addChild</span><span class="params">(Container child)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeChild</span><span class="params">(Container child)</span>;</span><br><span class="line">    <span class="keyword">public</span> Container <span class="title function_">findChild</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到了<code>getParent</code>、<code>SetParent</code>、<code>addChild</code>和 <code>removeChild</code>等方法，这里正好验证了我们说的组合模式。我们还看到 <code>Container</code>接口拓展了 <code>Lifecycle</code> ，Tomcat 就是通过 <code>Lifecycle</code> 统一管理所有容器的组件的生命周期。通过组合模式管理所有容器，拓展 <code>Lifecycle</code> 实现对每个组件的生命周期管理 ，<code>Lifecycle</code> 主要包含的方法<code>init()、start()、stop() 和 destroy()</code>。</p>
<h4 id="请求定位-Servlet-的过程"><a href="#请求定位-Servlet-的过程" class="headerlink" title="请求定位 Servlet 的过程"></a>请求定位 Servlet 的过程</h4><p>一个请求是如何定位到让哪个 <code>Wrapper</code> 的 <code>Servlet</code> 处理的？答案是，Tomcat 是用 Mapper 组件来完成这个任务的。</p>
<p><code>Mapper</code> 组件的功能就是将用户请求的 <code>URL</code> 定位到一个 <code>Servlet</code>，它的工作原理是：<code>Mapper</code>组件里保存了 Web 应用的配置信息，其实就是<strong>容器组件与访问路径的映射关系</strong>，比如 <code>Host</code>容器里配置的域名、<code>Context</code>容器里的 <code>Web</code>应用路径，以及 <code>Wrapper</code>容器里 <code>Servlet</code> 映射的路径，你可以想象这些配置信息就是一个多层次的 <code>Map</code>。</p>
<p>当一个请求到来时，<code>Mapper</code> 组件通过解析请求 URL 里的域名和路径，再到自己保存的 Map 里去查找，就能定位到一个 <code>Servlet</code>。请你注意，一个请求 URL 最后只会定位到一个 <code>Wrapper</code>容器，也就是一个 <code>Servlet</code>。</p>
<p><img src="/2022/10/25/Tomcat-%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/9.png" alt="图片"></p>
<p>假如有用户访问一个 URL，比如图中的<code>http://user.shopping.com:8080/order/buy</code>，Tomcat 如何将这个 URL 定位到一个 Servlet 呢？</p>
<ol>
<li><strong>首先根据协议和端口号确定 Service 和 Engine</strong>。Tomcat 默认的 HTTP 连接器监听 8080 端口、默认的 AJP 连接器监听 8009 端口。上面例子中的 URL 访问的是 8080 端口，因此这个请求会被 HTTP 连接器接收，而一个连接器是属于一个 Service 组件的，这样 Service 组件就确定了。我们还知道一个 Service 组件里除了有多个连接器，还有一个容器组件，具体来说就是一个 Engine 容器，因此 Service 确定了也就意味着 Engine 也确定了。</li>
<li><strong>根据域名选定 Host。</strong> Service 和 Engine 确定后，Mapper 组件通过 URL 中的域名去查找相应的 Host 容器，比如例子中的 URL 访问的域名是<code>user.shopping.com</code>，因此 Mapper 会找到 Host2 这个容器。</li>
<li><strong>根据 URL 路径找到 Context 组件。</strong> Host 确定以后，Mapper 根据 URL 的路径来匹配相应的 Web 应用的路径，比如例子中访问的是 &#x2F;order，因此找到了 Context4 这个 Context 容器。</li>
<li><strong>根据 URL 路径找到 Wrapper（Servlet）。</strong> Context 确定后，Mapper 再根据 web.xml 中配置的 Servlet 映射路径来找到具体的 Wrapper 和 Servlet。</li>
</ol>
<p>连接器中的 Adapter 会调用容器的 Service 方法来执行 Servlet，最先拿到请求的是 Engine 容器，Engine 容器对请求做一些处理后，会把请求传给自己子容器 Host 继续处理，依次类推，最后这个请求会传给 Wrapper 容器，Wrapper 会调用最终的 Servlet 来处理。那么这个调用过程具体是怎么实现的呢？答案是使用 Pipeline-Valve 管道。</p>
<p><code>Pipeline-Valve</code> 是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将再调用下一个处理者继续处理，Valve 表示一个处理点（也就是一个处理阀门），因此 <code>invoke</code>方法就是来处理请求的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Valve</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Valve <span class="title function_">getNext</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Valve valve)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request request, Response response)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续看 Pipeline 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Pipeline</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addValve</span><span class="params">(Valve valve)</span>;</span><br><span class="line">  <span class="keyword">public</span> Valve <span class="title function_">getBasic</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBasic</span><span class="params">(Valve valve)</span>;</span><br><span class="line">  <span class="keyword">public</span> Valve <span class="title function_">getFirst</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Pipeline</code>中有 <code>addValve</code>方法。Pipeline 中维护了 <code>Valve</code>链表，<code>Valve</code>可以插入到 <code>Pipeline</code>中，对请求做某些处理。我们还发现 Pipeline 中没有 invoke 方法，因为整个调用链的触发是 Valve 来完成的，<code>Valve</code>完成自己的处理后，调用 <code>getNext.invoke()</code> 来触发下一个 Valve 调用。</p>
<p>其实每个容器都有一个 Pipeline 对象，只要触发了这个 Pipeline 的第一个 Valve，这个容器里 <code>Pipeline</code>中的 Valve 就都会被调用到。但是，不同容器的 Pipeline 是怎么链式触发的呢，比如 Engine 中 Pipeline 需要调用下层容器 Host 中的 Pipeline。</p>
<p>这是因为 <code>Pipeline</code>中还有个 <code>getBasic</code>方法。这个 <code>BasicValve</code>处于 <code>Valve</code>链表的末端，它是 <code>Pipeline</code>中必不可少的一个 <code>Valve</code>，负责调用下层容器的 Pipeline 里的第一个 Valve。</p>
<p><img src="/2022/10/25/Tomcat-%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/10.png" alt="图片"></p>
<p>整个过程分是通过连接器中的 <code>CoyoteAdapter</code> 触发，它会调用 Engine 的第一个 Valve：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void service(org.apache.coyote.Request req, org.apache.coyote.Response res) &#123;</span><br><span class="line">    // 省略其他代码</span><br><span class="line">    // Calling the container</span><br><span class="line">    connector.getService().getContainer().getPipeline().getFirst().invoke(</span><br><span class="line">        request, response);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Wrapper 容器的最后一个 Valve 会创建一个 Filter 链，并调用 <code>doFilter()</code> 方法，最终会调到 <code>Servlet</code>的 <code>service</code>方法。</p>
<p>前面我们不是讲到了 <code>Filter</code>，似乎也有相似的功能，那 <code>Valve</code> 和 <code>Filter</code>有什么区别吗？它们的区别是：</p>
<ul>
<li><code>Valve</code>是 <code>Tomcat</code>的私有机制，与 Tomcat 的基础架构 <code>API</code>是紧耦合的。<code>Servlet API</code>是公有的标准，所有的 Web 容器包括 Jetty 都支持 Filter 机制。</li>
<li>另一个重要的区别是 <code>Valve</code>工作在 Web 容器级别，拦截所有应用的请求；而 <code>Servlet Filter</code> 工作在应用级别，只能拦截某个 <code>Web</code> 应用的所有请求。如果想做整个 <code>Web</code>容器的拦截器，必须通过 <code>Valve</code>来实现。</li>
</ul>
<h4 id="Lifecycle-生命周期"><a href="#Lifecycle-生命周期" class="headerlink" title="Lifecycle 生命周期"></a>Lifecycle 生命周期</h4><p>前面我们看到 <code>Container</code>容器 继承了 <code>Lifecycle</code> 生命周期。如果想让一个系统能够对外提供服务，我们需要创建、组装并启动这些组件；在服务停止的时候，我们还需要释放资源，销毁这些组件，因此这是一个动态的过程。也就是说，Tomcat 需要动态地管理这些组件的生命周期。</p>
<p>如何统一管理组件的创建、初始化、启动、停止和销毁？如何做到代码逻辑清晰？如何方便地添加或者删除组件？如何做到组件启动和停止不遗漏、不重复？</p>
<h5 id="一键式启停：LifeCycle-接口"><a href="#一键式启停：LifeCycle-接口" class="headerlink" title="一键式启停：LifeCycle 接口"></a>一键式启停：LifeCycle 接口</h5><p>设计就是要找到系统的变化点和不变点。这里的不变点就是每个组件都要经历创建、初始化、启动这几个过程，这些状态以及状态的转化是不变的。而变化点是每个具体组件的初始化方法，也就是启动方法是不一样的。</p>
<p>因此，Tomcat 把不变点抽象出来成为一个接口，这个接口跟生命周期有关，叫作 LifeCycle。LifeCycle 接口里定义这么几个方法：<code>init()、start()、stop() 和 destroy()</code>，每个具体的组件（也就是容器）去实现这些方法。</p>
<p>在父组件的 <code>init()</code> 方法里需要创建子组件并调用子组件的 <code>init()</code> 方法。同样，在父组件的 <code>start()</code>方法里也需要调用子组件的 <code>start()</code> 方法，因此调用者可以无差别的调用各组件的 <code>init()</code> 方法和 <code>start()</code> 方法，这就是<strong>组合模式</strong>的使用，并且只要调用最顶层组件，也就是 Server 组件的 <code>init()</code>和<code>start()</code> 方法，整个 Tomcat 就被启动起来了。所以 Tomcat 采取组合模式管理容器，容器继承 LifeCycle 接口，这样就可以向针对单个对象一样一键管理各个容器的生命周期，整个 Tomcat 就启动起来。</p>
<h5 id="可扩展性：LifeCycle-事件"><a href="#可扩展性：LifeCycle-事件" class="headerlink" title="可扩展性：LifeCycle 事件"></a>可扩展性：LifeCycle 事件</h5><p>我们再来考虑另一个问题，那就是系统的可扩展性。因为各个组件<code>init()</code> 和 <code>start()</code> 方法的具体实现是复杂多变的，比如在 Host 容器的启动方法里需要扫描 webapps 目录下的 Web 应用，创建相应的 Context 容器，如果将来需要增加新的逻辑，直接修改<code>start()</code> 方法？这样会违反开闭原则，那如何解决这个问题呢？开闭原则说的是为了扩展系统的功能，你不能直接修改系统中已有的类，但是你可以定义新的类。</p>
<p><strong>组件的 <code>init()</code> 和 <code>start()</code> 调用是由它的父组件的状态变化触发的，上层组件的初始化会触发子组件的初始化，上层组件的启动会触发子组件的启动，因此我们把组件的生命周期定义成一个个状态，把状态的转变看作是一个事件。而事件是有监听器的，在监听器里可以实现一些逻辑，并且监听器也可以方便的添加和删除</strong>，这就是典型的<strong>观察者模式</strong>。</p>
<p>以下就是 <code>Lyfecycle</code> 接口的定义:</p>
<p><img src="/2022/10/25/Tomcat-%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/11.png" alt="图片"><code>Lyfecycle</code></p>
<h5 id="重用性：LifeCycleBase-抽象基类"><a href="#重用性：LifeCycleBase-抽象基类" class="headerlink" title="重用性：LifeCycleBase 抽象基类"></a>重用性：LifeCycleBase 抽象基类</h5><p>再次看到抽象模板设计模式。</p>
<p>有了接口，我们就要用类去实现接口。一般来说实现类不止一个，不同的类在实现接口时往往会有一些相同的逻辑，如果让各个子类都去实现一遍，就会有重复代码。那子类如何重用这部分逻辑呢？其实就是定义一个基类来实现共同的逻辑，然后让各个子类去继承它，就达到了重用的目的。</p>
<p>Tomcat 定义一个基类 LifeCycleBase 来实现 LifeCycle 接口，把一些公共的逻辑放到基类中去，比如生命状态的转变与维护、生命事件的触发以及监听器的添加和删除等，而子类就负责实现自己的初始化、启动和停止等方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">LifecycleBase</span> <span class="keyword">implements</span> <span class="title class_">Lifecycle</span>&#123;</span><br><span class="line">    <span class="comment">// 持有所有的观察者</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;LifecycleListener&gt; lifecycleListeners = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发布事件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type  Event type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data  Data associated with event.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">fireLifecycleEvent</span><span class="params">(String type, Object data)</span> &#123;</span><br><span class="line">        <span class="type">LifecycleEvent</span> <span class="variable">event</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LifecycleEvent</span>(<span class="built_in">this</span>, type, data);</span><br><span class="line">        <span class="keyword">for</span> (LifecycleListener listener : lifecycleListeners) &#123;</span><br><span class="line">            listener.lifecycleEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 模板方法定义整个启动流程，启动所有容器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException &#123;</span><br><span class="line">        <span class="comment">//1. 状态检查</span></span><br><span class="line">        <span class="keyword">if</span> (!state.equals(LifecycleState.NEW)) &#123;</span><br><span class="line">            invalidTransition(Lifecycle.BEFORE_INIT_EVENT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2. 触发 INITIALIZING 事件的监听器</span></span><br><span class="line">            setStateInternal(LifecycleState.INITIALIZING, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="comment">// 3. 调用具体子类的初始化方法</span></span><br><span class="line">            initInternal();</span><br><span class="line">            <span class="comment">// 4. 触发 INITIALIZED 事件的监听器</span></span><br><span class="line">            setStateInternal(LifecycleState.INITIALIZED, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(t);</span><br><span class="line">            setStateInternal(LifecycleState.FAILED, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LifecycleException</span>(</span><br><span class="line">                    sm.getString(<span class="string">&quot;lifecycleBase.initFail&quot;</span>,toString()), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tomcat 为了实现一键式启停以及优雅的生命周期管理，并考虑到了可扩展性和可重用性，将面向对象思想和设计模式发挥到了极致，<code>Containaer</code>接口维护了容器的父子关系，<code>Lifecycle</code> 组合模式实现组件的生命周期维护，生命周期每个组件有变与不变的点，运用模板方法模式。分别运用了<strong>组合模式、观察者模式、骨架抽象类和模板方法</strong>。</p>
<p>如果你需要维护一堆具有父子关系的实体，可以考虑使用组合模式。</p>
<p>观察者模式听起来 “高大上”，其实就是当一个事件发生后，需要执行一连串更新操作。实现了低耦合、非侵入式的通知与更新机制。</p>
<p><img src="/2022/10/25/Tomcat-%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/12.png" alt="图片"></p>
<p><code>Container</code> 继承了 LifeCycle，StandardEngine、StandardHost、StandardContext 和 StandardWrapper 是相应容器组件的具体实现类，因为它们都是容器，所以继承了 ContainerBase 抽象基类，而 ContainerBase 实现了 Container 接口，也继承了 LifeCycleBase 类，它们的生命周期管理接口和功能接口是分开的，这也符合设计中<strong>接口分离的原则</strong>。</p>
<h3 id="Tomcat-为何打破双亲委派机制"><a href="#Tomcat-为何打破双亲委派机制" class="headerlink" title="Tomcat 为何打破双亲委派机制"></a>Tomcat 为何打破双亲委派机制</h3><h4 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h4><p>我们知道 <code>JVM</code>的类加载器加载 Class 的时候基于双亲委派机制，也就是会将加载交给自己的父加载器加载，如果 父加载器为空则查找<code>Bootstrap</code> 是否加载过，当无法加载的时候才让自己加载。JDK 提供一个抽象类 <code>ClassLoader</code>，这个抽象类中定义了三个关键方法。对外使用<code>loadClass(String name) 用于子类重写打破双亲委派：loadClass(String name, boolean resolve)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">return</span> loadClass(name, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 查找该 class 是否已经被加载过</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="comment">// 如果没有加载过</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 委托给父加载器去加载，递归调用</span></span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果父加载器为空，查找 Bootstrap 是否加载过</span></span><br><span class="line">                c = findBootstrapClassOrNull(name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若果依然加载不到，则调用自己的 findClass 去加载</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                c = findClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name)&#123;</span><br><span class="line">    <span class="comment">//1. 根据传入的类名 name，到在特定目录下去寻找类文件，把.class 文件读入内存</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 调用 defineClass 将字节数组转成 Class 对象</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(buf, off, len)；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字节码数组解析成一个 Class 对象，用 native 方法实现</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(<span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK 中有 3 个类加载器，另外你也可以自定义类加载器，它们的关系如下图所示。</p>
<p><img src="/2022/10/25/Tomcat-%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/13.png" alt="图片">类加载器</p>
<ul>
<li><code>BootstrapClassLoader</code>是启动类加载器，由 C 语言实现，用来加载 <code>JVM</code>启动时所需要的核心类，比如<code>rt.jar</code>、<code>resources.jar</code>等。</li>
<li><code>ExtClassLoader</code>是扩展类加载器，用来加载<code>\jre\lib\ext</code>目录下 JAR 包。</li>
<li><code>AppClassLoader</code>是系统类加载器，用来加载 <code>classpath</code>下的类，应用程序默认用它来加载类。</li>
<li>自定义类加载器，用来加载自定义路径下的类。</li>
</ul>
<p>这些类加载器的工作原理是一样的，区别是它们的加载路径不同，也就是说 <code>findClass</code>这个方法查找的路径不同。双亲委托机制是为了保证一个 Java 类在 JVM 中是唯一的，假如你不小心写了一个与 JRE 核心类同名的类，比如 <code>Object</code>类，双亲委托机制能保证加载的是 <code>JRE</code>里的那个 <code>Object</code>类，而不是你写的 <code>Object</code>类。这是因为 <code>AppClassLoader</code>在加载你的 Object 类时，会委托给 <code>ExtClassLoader</code>去加载，而 <code>ExtClassLoader</code>又会委托给 <code>BootstrapClassLoader</code>，<code>BootstrapClassLoader</code>发现自己已经加载过了 <code>Object</code>类，会直接返回，不会去加载你写的 <code>Object</code>类。我们最多只能 获取到 <code>ExtClassLoader</code>这里注意下。</p>
<h4 id="Tomcat-热加载"><a href="#Tomcat-热加载" class="headerlink" title="Tomcat 热加载"></a>Tomcat 热加载</h4><p>Tomcat 本质是通过一个后台线程做周期性的任务，定期检测类文件的变化，如果有变化就重新加载类。我们来看 <code>ContainerBackgroundProcessor</code>具体是如何实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">ContainerBackgroundProcessor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 请注意这里传入的参数是 &quot; 宿主类 &quot; 的实例</span></span><br><span class="line">        processChildren(ContainerBase.<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processChildren</span><span class="params">(Container container)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 调用当前容器的 backgroundProcess 方法。</span></span><br><span class="line">            container.backgroundProcess();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2. 遍历所有的子容器，递归调用 processChildren，</span></span><br><span class="line">            <span class="comment">// 这样当前容器的子孙都会被处理</span></span><br><span class="line">            Container[] children = container.findChildren();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 这里请你注意，容器基类有个变量叫做 backgroundProcessorDelay，如果大于 0，表明子容器有自己的后台线程，无需父容器来调用它的 processChildren 方法。</span></span><br><span class="line">                <span class="keyword">if</span> (children[i].getBackgroundProcessorDelay() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    processChildren(children[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>Tomcat 的热加载就是在 Context 容器实现，主要是调用了 Context 容器的 reload 方法。抛开细节从宏观上看主要完成以下任务：</p>
<ol>
<li>停止和销毁 Context 容器及其所有子容器，子容器其实就是 Wrapper，也就是说 Wrapper 里面 Servlet 实例也被销毁了。</li>
<li>停止和销毁 Context 容器关联的 Listener 和 Filter。</li>
<li>停止和销毁 Context 下的 Pipeline 和各种 Valve。</li>
<li>停止和销毁 Context 的类加载器，以及类加载器加载的类文件资源。</li>
<li>启动 Context 容器，在这个过程中会重新创建前面四步被销毁的资源。</li>
</ol>
<p>在这个过程中，类加载器发挥着关键作用。一个 Context 容器对应一个类加载器，类加载器在销毁的过程中会把它加载的所有类也全部销毁。Context 容器在启动过程中，会创建一个新的类加载器来加载新的类文件。</p>
<h4 id="Tomcat-的类加载器"><a href="#Tomcat-的类加载器" class="headerlink" title="Tomcat 的类加载器"></a>Tomcat 的类加载器</h4><p>Tomcat 的自定义类加载器 <code>WebAppClassLoader</code>打破了双亲委托机制，它<strong>首先自己尝试去加载某个类，如果找不到再代理给父类加载器</strong>，其目的是优先加载 Web 应用自己定义的类。具体实现就是重写 <code>ClassLoader</code>的两个方法：<code>findClass</code>和 <code>loadClass</code>。</p>
<h5 id="findClass-方法"><a href="#findClass-方法" class="headerlink" title="findClass 方法"></a>findClass 方法</h5><p><code>org.apache.catalina.loader.WebappClassLoaderBase#findClass</code>;为了方便理解和阅读，我去掉了一些细节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; clazz = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 先在 Web 应用目录下查找类</span></span><br><span class="line">            clazz = findClassInternal(name);</span><br><span class="line">    &#125;  <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> e;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2. 如果在本地目录没有找到，交给父加载器去查找</span></span><br><span class="line">            clazz = <span class="built_in">super</span>.findClass(name);</span><br><span class="line">    &#125;  <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> e;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 如果父类也没找到，抛出 ClassNotFoundException</span></span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>先在 Web 应用本地目录下查找要加载的类。</li>
<li>如果没有找到，交给父加载器去查找，它的父加载器就是上面提到的系统类加载器 <code>AppClassLoader</code>。</li>
<li>如何父加载器也没找到这个类，抛出 <code>ClassNotFound</code>异常。</li>
</ol>
<h5 id="loadClass-方法"><a href="#loadClass-方法" class="headerlink" title="loadClass 方法"></a>loadClass 方法</h5><p>再来看 Tomcat 类加载器的 <code>loadClass</code>方法的实现，同样我也去掉了一些细节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 先在本地 cache 查找该类是否已经加载过</span></span><br><span class="line">        clazz = findLoadedClass0(name);</span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resolve)</span><br><span class="line">                resolveClass(clazz);</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 从系统类加载器的 cache 中查找是否加载过</span></span><br><span class="line">        clazz = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resolve)</span><br><span class="line">                resolveClass(clazz);</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 尝试用 ExtClassLoader 类加载器类加载，为什么？</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">javaseLoader</span> <span class="operator">=</span> getJavaseClassLoader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = javaseLoader.loadClass(name);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (resolve)</span><br><span class="line">                    resolveClass(clazz);</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 尝试在本地目录搜索 class 并加载</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = findClass(name);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (resolve)</span><br><span class="line">                    resolveClass(clazz);</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 尝试用系统类加载器 (也就是 AppClassLoader) 来加载</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clazz = Class.forName(name, <span class="literal">false</span>, parent);</span><br><span class="line">                <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (resolve)</span><br><span class="line">                        resolveClass(clazz);</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6. 上述过程都加载失败，抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要有六个步骤：</p>
<ol>
<li>先在本地 Cache 查找该类是否已经加载过，也就是说 Tomcat 的类加载器是否已经加载过这个类。</li>
<li>如果 Tomcat 类加载器没有加载过这个类，再看看系统类加载器是否加载过。</li>
<li>如果都没有，就让<strong>ExtClassLoader</strong>去加载，这一步比较关键，目的 <strong>防止 Web 应用自己的类覆盖 JRE 的核心类</strong>。因为 Tomcat 需要打破双亲委托机制，假如 Web 应用里自定义了一个叫 Object 的类，如果先加载这个 Object 类，就会覆盖 JRE 里面的那个 Object 类，这就是为什么 Tomcat 的类加载器会优先尝试用 <code>ExtClassLoader</code>去加载，因为 <code>ExtClassLoader</code>会委托给 <code>BootstrapClassLoader</code>去加载，<code>BootstrapClassLoader</code>发现自己已经加载了 Object 类，直接返回给 Tomcat 的类加载器，这样 Tomcat 的类加载器就不会去加载 Web 应用下的 Object 类了，也就避免了覆盖 JRE 核心类的问题。</li>
<li>如果 <code>ExtClassLoader</code>加载器加载失败，也就是说 <code>JRE</code>核心类中没有这类，那么就在本地 Web 应用目录下查找并加载。</li>
<li>如果本地目录下没有这个类，说明不是 Web 应用自己定义的类，那么由系统类加载器去加载。这里请你注意，Web 应用是通过<code>Class.forName</code>调用交给系统类加载器的，因为<code>Class.forName</code>的默认加载器就是系统类加载器。</li>
<li>如果上述加载过程全部失败，抛出 <code>ClassNotFound</code>异常。</li>
</ol>
<h4 id="Tomcat-类加载器层次"><a href="#Tomcat-类加载器层次" class="headerlink" title="Tomcat 类加载器层次"></a>Tomcat 类加载器层次</h4><p>Tomcat 作为 <code>Servlet</code>容器，它负责加载我们的 <code>Servlet</code>类，此外它还负责加载 <code>Servlet</code>所依赖的 JAR 包。并且 <code>Tomcat</code>本身也是也是一个 Java 程序，因此它需要加载自己的类和依赖的 JAR 包。首先让我们思考这一下这几个问题：</p>
<ol>
<li>假如我们在 Tomcat 中运行了两个 Web 应用程序，两个 Web 应用中有同名的 <code>Servlet</code>，但是功能不同，Tomcat 需要同时加载和管理这两个同名的 <code>Servlet</code>类，保证它们不会冲突，因此 Web 应用之间的类需要隔离。</li>
<li>假如两个 Web 应用都依赖同一个第三方的 JAR 包，比如 <code>Spring</code>，那 <code>Spring</code>的 JAR 包被加载到内存后，<code>Tomcat</code>要保证这两个 Web 应用能够共享，也就是说 <code>Spring</code>的 JAR 包只被加载一次，否则随着依赖的第三方 JAR 包增多，<code>JVM</code>的内存会膨胀。</li>
<li>跟 JVM 一样，我们需要隔离 Tomcat 本身的类和 Web 应用的类。</li>
</ol>
<p><img src="/2022/10/25/Tomcat-%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/14.png" alt="图片"></p>
<h5 id="1-WebAppClassLoader"><a href="#1-WebAppClassLoader" class="headerlink" title="1. WebAppClassLoader"></a>1. WebAppClassLoader</h5><p>Tomcat 的解决方案是自定义一个类加载器 <code>WebAppClassLoader</code>， 并且给每个 Web 应用创建一个类加载器实例。我们知道，Context 容器组件对应一个 Web 应用，因此，每个 <code>Context</code>容器负责创建和维护一个 <code>WebAppClassLoader</code>加载器实例。这背后的原理是，<strong>不同的加载器实例加载的类被认为是不同的类</strong>，即使它们的类名相同。这就相当于在 Java 虚拟机内部创建了一个个相互隔离的 Java 类空间，每一个 Web 应用都有自己的类空间，Web 应用之间通过各自的类加载器互相隔离。</p>
<h5 id="2-SharedClassLoader"><a href="#2-SharedClassLoader" class="headerlink" title="2.SharedClassLoader"></a>2.SharedClassLoader</h5><p>本质需求是两个 Web 应用之间怎么共享库类,并且不能重复加载相同的类。在双亲委托机制里，各个子加载器都可以通过父加载器去加载类，那么把需要共享的类放到父加载器的加载路径下不就行了吗。</p>
<p>因此 Tomcat 的设计者又加了一个类加载器 <code>SharedClassLoader</code>，作为 <code>WebAppClassLoader</code>的父加载器，专门来加载 Web 应用之间共享的类。如果 <code>WebAppClassLoader</code>自己没有加载到某个类，就会委托父加载器 <code>SharedClassLoader</code>去加载这个类，<code>SharedClassLoader</code>会在指定目录下加载共享类，之后返回给 <code>WebAppClassLoader</code>，这样共享的问题就解决了。</p>
<h5 id="3-CatalinaClassloader"><a href="#3-CatalinaClassloader" class="headerlink" title="3. CatalinaClassloader"></a>3. CatalinaClassloader</h5><p>如何隔离 Tomcat 本身的类和 Web 应用的类？</p>
<p>要共享可以通过父子关系，要隔离那就需要兄弟关系了。兄弟关系就是指两个类加载器是平行的，它们可能拥有同一个父加载器，基于此 Tomcat 又设计一个类加载器 <code>CatalinaClassloader</code>，专门来加载 Tomcat 自身的类。</p>
<p>这样设计有个问题，那 Tomcat 和各 Web 应用之间需要共享一些类时该怎么办呢？</p>
<p>老办法，还是再增加一个 <code>CommonClassLoader</code>，作为 <code>CatalinaClassloader</code>和 <code>SharedClassLoader</code>的父加载器。<code>CommonClassLoader</code>能加载的类都可以被 <code>CatalinaClassLoader</code>和 <code>SharedClassLoader</code>使用</p>
<h2 id="整体架构设计解析收获总结"><a href="#整体架构设计解析收获总结" class="headerlink" title="整体架构设计解析收获总结"></a>整体架构设计解析收获总结</h2><p>通过前面对 Tomcat 整体架构的学习，知道了 Tomcat 有哪些核心组件，组件之间的关系。以及 Tomcat 是怎么处理一个 HTTP 请求的。下面我们通过一张简化的类图来回顾一下，从图上你可以看到各种组件的层次关系，图中的虚线表示一个请求在 Tomcat 中流转的过程。</p>
<p><img src="/2022/10/25/Tomcat-%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/15.png" alt="图片">Tomcat 整体组件关系</p>
<h3 id="连接器-1"><a href="#连接器-1" class="headerlink" title="连接器"></a>连接器</h3><p>Tomcat 的整体架构包含了两个核心组件连接器和容器。连接器负责对外交流，容器负责内部处理。连接器用 <code>ProtocolHandler</code>接口来封装通信协议和 <code>I/O</code>模型的差异，<code>ProtocolHandler</code>内部又分为 <code>EndPoint</code>和 <code>Processor</code>模块，<code>EndPoint</code>负责底层 <code>Socket</code>通信，<code>Proccesor</code>负责应用层协议解析。连接器通过适配器 <code>Adapter</code>调用容器。</p>
<p>对 Tomcat 整体架构的学习，我们可以得到一些设计复杂系统的基本思路。<strong>首先要分析需求，根据高内聚低耦合的原则确定子模块，然后找出子模块中的变化点和不变点，用接口和抽象基类去封装不变点，在抽象基类中定义模板方法，让子类自行实现抽象方法，也就是具体子类去实现变化点。</strong></p>
<h3 id="容器-1"><a href="#容器-1" class="headerlink" title="容器"></a>容器</h3><p>运用了<strong>组合模式 管理容器、通过 观察者模式 发布启动事件达到解耦、开闭原则。骨架抽象类和模板方法抽象变与不变，变化的交给子类实现，从而实现代码复用，以及灵活的拓展</strong>。使用责任链的方式处理请求，比如记录日志等。</p>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>Tomcat 的自定义类加载器 <code>WebAppClassLoader</code>为了隔离 Web 应用打破了双亲委托机制，它<strong>首先自己尝试去加载某个类，如果找不到再代理给父类加载器</strong>，其目的是优先加载 Web 应用自己定义的类。<strong>防止 Web 应用自己的类覆盖 JRE 的核心类</strong>，使用 <strong>ExtClassLoader</strong> 去加载，这样即打破了双亲委派，又能安全加载。</p>
<h2 id="如何阅读源码持续学习"><a href="#如何阅读源码持续学习" class="headerlink" title="如何阅读源码持续学习"></a>如何阅读源码持续学习</h2><p><strong>学习是一个反人类的过程，是比较痛苦的</strong>。尤其学习我们常用的优秀技术框架本身比较庞大，设计比较复杂，在学习初期很容易遇到 “挫折感”，debug 跳来跳去陷入恐怖细节之中无法自拔，往往就会放弃。</p>
<p><strong>找到适合自己的学习方法非常重要，同样关键的是要保持学习的兴趣和动力，并且得到学习反馈效果</strong>。</p>
<p>学习优秀源码，我们收获的就是架构设计能力，遇到复杂需求我们学习到可以利用合理模式与组件抽象设计了可拓展性强的代码能力。</p>
<h3 id="如何阅读"><a href="#如何阅读" class="headerlink" title="如何阅读"></a>如何阅读</h3><p>比如我最初在学习 Spring 框架的时候，一开始就钻进某个模块啃起来。然而由于 Spring 太庞大，模块之间也有联系，根本不明白为啥要这么写，只觉得为啥设计这么 “绕”。</p>
<h4 id="错误方式"><a href="#错误方式" class="headerlink" title="错误方式"></a>错误方式</h4><ul>
<li>陷入细节，不看全局：<strong>我还没弄清楚森林长啥样，就盯着叶子看</strong> ，看不到全貌和整体设计思路。所以阅读源码学习的时候不要一开始就进入细节，而是宏观看待整体架构设计思想，模块之间的关系。</li>
<li>还没学会用就研究如何设计：首先基本上框架都运用了设计模式，我们最起码也要了解常用的设计模式，即使是“背”，也得了然于胸。在学习一门技术，我推荐先看官方文档，看看有哪些模块、整体设计思想。然后下载示例跑一遍，最后才是看源码。</li>
<li>看源码深究细节：到了看具体某个模块源码的时候也要下意识的不要去深入细节，重要的是学习设计思路，而不是具体一个方法实现逻辑。除非自己要基于源码做二次开发。</li>
</ul>
<h4 id="正确方式"><a href="#正确方式" class="headerlink" title="正确方式"></a>正确方式</h4><ul>
<li>定焦原则：抓主线（抓住一个核心流程去分析，不要漫无目的的到处阅读）。</li>
<li>宏观思维：从全局的视角去看待，上帝视角理出主要核心架构设计，先森林后树叶。切勿不要试图去搞明白每一行代码。</li>
<li>断点：合理运用调用栈（观察调用过程上下文）。</li>
</ul>
<h3 id="带着目标去学"><a href="#带着目标去学" class="headerlink" title="带着目标去学"></a>带着目标去学</h3><p>比如某些知识点是面试的热点，那学习目标就是彻底理解和掌握它，当被问到相关问题时，你的回答能够使得面试官对你刮目相看，有时候往往凭着某一个亮点就能影响最后的录用结果。</p>
<p>又或者接到一个稍微复杂的需求，<strong>学习从优秀源码中借鉴设计思路与优化技巧。</strong></p>
<p><strong>最后就是动手实践</strong>，将所学运用在工作项目中。只有动手实践才会让我们对技术有最直观的感受。有时候我们听别人讲经验和理论，感觉似乎懂了，但是过一段时间便又忘记了。</p>
<h2 id="实际场景运用"><a href="#实际场景运用" class="headerlink" title="实际场景运用"></a>实际场景运用</h2><p>简单的分析了 Tomcat 整体架构设计，从 【连接器】 到 【容器】，并且分别细说了一些组件的设计思想以及设计模式。接下来就是如何学以致用，借鉴优雅的设计运用到实际工作开发中。<strong>学习，从模仿开始。</strong></p>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>在工作中，有这么一个需求，用户可以输入一些信息并可以选择查验该企业的 【工商信息】、【司法信息】、【中登情况】等如下如所示的一个或者多个模块，而且模块之间还有一些公共的东西是要各个模块复用。</p>
<p>这里就像一个请求，会被多个模块去处理。所以每个查询模块我们可以抽象为 <strong>处理阀门</strong>，使用一个 List 将这些 阀门保存起来，这样新增模块我们只需要新增一个<strong>阀门</strong>即可，实现了<strong>开闭原则</strong>，<strong>同时将一堆查验的代码解耦到不同的具体阀门中</strong>，使用抽象类提取 “<strong>不变的</strong>”功能。</p>
<p><img src="/2022/10/25/Tomcat-%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/16.png" alt="图片"></p>
<p>具体示例代码如下所示：</p>
<p>首先抽象我们的处理阀门， <code>NetCheckDTO</code>是请求信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 责任链模式：处理每个模块阀门</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Valve</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> netCheckDTO</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(NetCheckDTO netCheckDTO)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义抽象基类，复用代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractCheckValve</span> <span class="keyword">implements</span> <span class="title class_">Valve</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> AnalysisReportLogDO <span class="title function_">getLatestHistoryData</span><span class="params">(NetCheckDTO netCheckDTO, NetCheckDataTypeEnum checkDataTypeEnum)</span>&#123;</span><br><span class="line">        <span class="comment">// 获取历史记录，省略代码逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取查验数据源配置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getModuleSource</span><span class="params">(String querySource, ModuleEnum moduleEnum)</span>&#123;</span><br><span class="line">       <span class="comment">// 省略代码逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义具体每个模块处理的业务逻辑，比如 【百度负面新闻】对应的处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaiduNegativeValve</span> <span class="keyword">extends</span> <span class="title class_">AbstractCheckValve</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(NetCheckDTO netCheckDTO)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后就是管理用户选择要查验的模块，我们通过 List 保存。用于触发所需要的查验模块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NetCheckService</span> &#123;</span><br><span class="line">    <span class="comment">// 注入所有的阀门</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Valve&gt; valveMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送查验请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> netCheckDTO</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Async(&quot;asyncExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendCheckRequest</span><span class="params">(NetCheckDTO netCheckDTO)</span> &#123;</span><br><span class="line">        <span class="comment">// 用于保存客户选择处理的模块阀门</span></span><br><span class="line">        List&lt;Valve&gt; valves = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">CheckModuleConfigDTO</span> <span class="variable">checkModuleConfig</span> <span class="operator">=</span> netCheckDTO.getCheckModuleConfig();</span><br><span class="line">        <span class="comment">// 将用户选择查验的模块添加到 阀门链条中</span></span><br><span class="line">        <span class="keyword">if</span> (checkModuleConfig.getBaiduNegative()) &#123;</span><br><span class="line">            valves.add(valveMap.get(<span class="string">&quot;baiduNegativeValve&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略部分代码.......</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(valves)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;网查查验模块为空，没有需要查验的任务&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 触发处理</span></span><br><span class="line">        valves.forEach(valve -&gt; valve.invoke(netCheckDTO));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>需求是这样的，可根据客户录入的财报 excel 数据或者企业名称执行财报分析。</p>
<p>对于非上市的则解析 excel -&gt; 校验数据是否合法-&gt;执行计算。</p>
<p>上市企业：判断名称是否存在 ，不存在则发送邮件并中止计算-&gt; 从数据库拉取财报数据，初始化查验日志、生成一条报告记录，触发计算-&gt; 根据失败与成功修改任务状态 。</p>
<p><img src="/2022/10/25/Tomcat-%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/17.png" alt="图片"></p>
<p>重要的 ”变“ 与 ”不变“，</p>
<ul>
<li><strong>不变</strong>的是整个流程是<strong>初始化查验日志、初始化一条报告</strong>、<strong>前期校验数据</strong>（若是上市公司校验不通过还需要构建邮件数据并发送）、从不同来源拉取财报数据并且适配通用数据、然后触发计算，任务异常与成功都需要修改状态。</li>
<li><strong>变化</strong>的是上市与非上市校验规则不一样，获取财报数据方式不一样，两种方式的财报数据需要适配</li>
</ul>
<p>整个算法流程是固定的模板，但是需要将<strong>算法内部变化的部分</strong>具体实现延迟到不同子类实现，这正是模板方法模式的最佳场景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAnalysisTemplate</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交财报分析模板方法，定义骨架流程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> reportAnalysisRequest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> FinancialAnalysisResultDTO <span class="title function_">doProcess</span><span class="params">(FinancialReportAnalysisRequest reportAnalysisRequest)</span> &#123;</span><br><span class="line">        <span class="type">FinancialAnalysisResultDTO</span> <span class="variable">analysisDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FinancialAnalysisResultDTO</span>();</span><br><span class="line">  <span class="comment">// 抽象方法：提交查验的合法校验</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">prepareValidate</span> <span class="operator">=</span> prepareValidate(reportAnalysisRequest, analysisDTO);</span><br><span class="line">        log.info(<span class="string">&quot;prepareValidate 校验结果 = &#123;&#125; &quot;</span>, prepareValidate);</span><br><span class="line">        <span class="keyword">if</span> (!prepareValidate) &#123;</span><br><span class="line">   <span class="comment">// 抽象方法：构建通知邮件所需要的数据</span></span><br><span class="line">            buildEmailData(analysisDTO);</span><br><span class="line">            log.info(<span class="string">&quot;构建邮件信息，data = &#123;&#125;&quot;</span>, JSON.toJSONString(analysisDTO));</span><br><span class="line">            <span class="keyword">return</span> analysisDTO;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">reportNo</span> <span class="operator">=</span> FINANCIAL_REPORT_NO_PREFIX + reportAnalysisRequest.getUserId() + SerialNumGenerator.getFixLenthSerialNumber();</span><br><span class="line">        <span class="comment">// 生成分析日志</span></span><br><span class="line">        initFinancialAnalysisLog(reportAnalysisRequest, reportNo);</span><br><span class="line">  <span class="comment">// 生成分析记录</span></span><br><span class="line">        initAnalysisReport(reportAnalysisRequest, reportNo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 抽象方法：拉取财报数据，不同子类实现</span></span><br><span class="line">            <span class="type">FinancialDataDTO</span> <span class="variable">financialData</span> <span class="operator">=</span> pullFinancialData(reportAnalysisRequest);</span><br><span class="line">            log.info(<span class="string">&quot;拉取财报数据完成, 准备执行计算&quot;</span>);</span><br><span class="line">            <span class="comment">// 测算指标</span></span><br><span class="line">            financialCalcContext.calc(reportAnalysisRequest, financialData, reportNo);</span><br><span class="line">   <span class="comment">// 设置分析日志为成功</span></span><br><span class="line">            successCalc(reportNo);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;财报计算子任务出现异常&quot;</span>, e);</span><br><span class="line">   <span class="comment">// 设置分析日志失败</span></span><br><span class="line">            failCalc(reportNo);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> analysisDTO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后新建两个子类继承该模板，并实现抽象方法。这样就将上市与非上市两种类型的处理逻辑解耦，同时又复用了代码。</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>需求是这样，要做一个万能识别银行流水的 excel 接口，假设标准流水包含【交易时间、收入、支出、交易余额、付款人账号、付款人名字、收款人名称、收款人账号】等字段。现在我们解析出来每个必要字段所在 excel 表头的下标。但是流水有多种情况：</p>
<ol>
<li>一种就是包含所有标准字段。</li>
<li>收入、支出下标是同一列，通过正负来区分收入与支出。</li>
<li>收入与支出是同一列，有一个交易类型的字段来区分。</li>
<li>特殊银行的特殊处理。</li>
</ol>
<p>也就是我们要<strong>根据解析对应的下标找到对应的处理逻辑算法</strong>，我们可能在一个方法里面写超多 <code>if else</code> 的代码，整个流水处理都偶合在一起，假如未来再来一种新的流水类型，还要继续改老代码。最后可能出现 “又臭又长，难以维护” 的代码复杂度。</p>
<p>这个时候我们可以用到<strong>策略模式</strong>，<strong>将不同模板的流水使用不同的处理器处理，根据模板找到对应的策略算法去处理</strong>。即使未来再加一种类型，我们只要新加一种处理器即可，高内聚低耦合，且可拓展。</p>
<p><img src="/2022/10/25/Tomcat-%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/18.png" alt="图片"></p>
<p>定义处理器接口，不同处理器去实现处理逻辑。将所有的处理器注入到 <code>BankFlowDataHandler</code> 的<code>data_processor_map</code>中，根据不同的场景取出对已经的处理器处理流水。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DataProcessor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理流水数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bankFlowTemplateDO 流水下标数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BankTransactionFlowDO <span class="title function_">doProcess</span><span class="params">(BankFlowTemplateDO bankFlowTemplateDO, List&lt;String&gt; row)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否支持处理该模板,不同类型的流水策略根据模板数据判断是否支持解析</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isSupport</span><span class="params">(BankFlowTemplateDO bankFlowTemplateDO)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理器的上下文</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankFlowDataContext</span> &#123;</span><br><span class="line">    <span class="comment">// 将所有处理器注入到 map 中</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;DataProcessor&gt; processors;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找对对应的处理器处理流水</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="type">DataProcessor</span> <span class="variable">processor</span> <span class="operator">=</span> getProcessor(bankFlowTemplateDO);</span><br><span class="line">        <span class="keyword">for</span>(DataProcessor processor ：processors) &#123;</span><br><span class="line">           <span class="keyword">if</span> (processor.isSupport(bankFlowTemplateDO)) &#123;</span><br><span class="line">             <span class="comment">// row 就是一行流水数据</span></span><br><span class="line">           processor.doProcess(bankFlowTemplateDO, row);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义默认处理器，处理正常模板，新增模板只要新增处理器实现 <code>DataProcessor</code>即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认处理器：正对规范流水模板</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component(&quot;defaultDataProcessor&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultDataProcessor</span> <span class="keyword">implements</span> <span class="title class_">DataProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BankTransactionFlowDO <span class="title function_">doProcess</span><span class="params">(BankFlowTemplateDO bankFlowTemplateDO)</span> &#123;</span><br><span class="line">        <span class="comment">// 省略处理逻辑细节</span></span><br><span class="line">        <span class="keyword">return</span> bankTransactionFlowDO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">strategy</span><span class="params">(BankFlowTemplateDO bankFlowTemplateDO)</span> &#123;</span><br><span class="line">      <span class="comment">// 省略判断是否支持解析该流水</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">isDefault</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> isDefault;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过策略模式，我们将不同处理逻辑分配到不同的处理类中，这样完全解耦，便于拓展。</p>
<blockquote>
<p>使用内嵌 Tomcat 方式调试源代码：GitHub: <a href="https://github.com/UniqueDong/tomcat-embedded">https://github.com/UniqueDong/tomcat-embedded</a></p>
</blockquote>
]]></content>
      <categories>
        <category>tomcat</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>spring自动注入</title>
    <url>/2022/10/25/spring%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<blockquote>
<p>比如提到spring的自动注入作为一个java程序员肯定自信无比了解；但是笔者要说的自动注入可能会和你理解有很大出入。<br>首先搞明白什么是自动注入，自动注入也可以叫做自动装配（springboot也有一个自动装配但是我认为翻译的不够准确，springboot的应该叫做自动配置和这里说的自动注入是两回事，笔者不是什么大牛或者权威；所以读者如果你坚持认为springboot也叫自动装配那也无可厚非，只是在这篇文章里面所谓的自动注入就是自动装配，关于springboot的自动配置我以后更新文章再来说）；<br>自动注入需要相对于手动装配来说；在spring应用程序当中假设你的A类依赖了B类，需要在A类当中提供一个B类的属性，再加上setter，继而在xml当中配置、描述一下这两个类之间的依赖关系。如果做完当容器初始化过程中会实例化A，在实例化A的过程中会填充属性，由于在xml中已经配置、描述好两者的关系，故而spring会把B给A装配上；这种由程序员自己配置、描述好依赖关系的写法叫做手动装配；看个例子吧；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.luban.app;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	B b;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setB</span><span class="params">(B b)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.b = b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.luban.app;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;a&quot;</span> class=<span class="string">&quot;com.luban.app.A&quot;</span> &gt;</span><br><span class="line">		&lt;!-- 由程序员手动指定的依赖关系 称为手动装配--&gt;</span><br><span class="line">		&lt;property name=<span class="string">&quot;b&quot;</span>&gt;</span><br><span class="line">			&lt;ref bean=<span class="string">&quot;b&quot;</span> /&gt;</span><br><span class="line">		&lt;/property&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">	&lt;bean id=<span class="string">&quot;b&quot;</span>  class=<span class="string">&quot;com.luban.app.B&quot;</span>&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;	</span><br></pre></td></tr></table></figure>


<blockquote>
<p>但是实际开发中手动装配的场景比较少(比如在缺少源码的情况下可能会使用这种手动装配情况)；<br>关于依赖注入的资料可以参考官网<br><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-dependencies">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-dependencies</a><br>这一章节提到了一个非常重要的知识点，也是一个常见的spring面试题目。spring有几种依赖注入方式？那么这个问题应该怎么回答呢？</p>
</blockquote>
<p><img src="/2022/10/25/spring%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5/1.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>官网的意思是DI(依赖注入)一共有两种主要的变体（注意会考），分别是基于构造方法的依赖注入和基于setter（setXxxx(…)）的依赖注入，不管是手动装配还是自动装配都是基于这两种方式或者变体方式来的；但是这里一定要回答到主要和变体两个名词，因为有的注入方式就不是这两种，而是这两种其中一种的变体方式；比如在一个类的属性上面加@Autowired，这种方式注入属性的方式就是利用了java的反射知识，field.set(value,targetObject);关于这个我在后面的文章中对spring源码解析的时候会说明@Autowired的原理；所以@Autowired这种注入的方式是setter注入方式的一种变体<br>但是这里需要说明的是所谓的setter其实和属性无关，什么意思呢？一般的setter方法会对应一个属性，但是spring的基于setter的注入方式是不需要属性的，仅仅只需要一个setter方法，下面这个例子来说明这个问题</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">B.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setXxx</span><span class="params">(B b)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;spring 找到符合的setter&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;和属性无关，甚至可以不要属性&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;可以直接调用，这个A里面就没有任何属性&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xml配置文件</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">&quot;a&quot;</span> class=<span class="string">&quot;com.luban.app.A&quot;</span> &gt;</span><br><span class="line">	&lt;!-- 由程序员手动指定的依赖关系 称为手动装配--&gt;</span><br><span class="line">	&lt;property name=<span class="string">&quot;xxx&quot;</span>&gt;</span><br><span class="line">		&lt;ref bean=<span class="string">&quot;b&quot;</span> /&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">&quot;b&quot;</span>  class=<span class="string">&quot;com.luban.app.B&quot;</span>&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行上面的代码可以看到spring也会调用这个setXxx方法，如果仔细观察调用栈可以看到这个方法是在spring容器初始化的时候实例化A，完成A的注入功能时候调用过来的，下图是笔者运行结果的截图</p>
</blockquote>
<p><img src="/2022/10/25/spring%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5/2.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>可能有的读者会认为上面的xml配置文件中已经手动装配了B给A，肯定会调用setXxx方法，其实不然，即是我使用自动装配也还是会调用的（关于什么是自动装配，下文会详细介绍），因为前文说过，注入方式与手动注入、自动注入无关。笔者改一下代码，把A的注入模型改成自动注入来看看结果</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 程序员不指定装配的具体参数，容器自动查询后装配--&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;a&quot;</span> class=<span class="string">&quot;com.luban.app.A&quot;</span> autowire=<span class="string">&quot;byType&quot;</span>&gt;</span><br><span class="line">	</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">&quot;b&quot;</span>  class=<span class="string">&quot;com.luban.app.B&quot;</span>&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>把代码改成上面这样自动装配结果是一样的，A类当中的setXxx方法还是会调用，不需要提供任何属性，至于原理笔者后面更新到spring源码的时候再来详细说道；可能有读者会说如果使用注解呢？比如如下代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A.java</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	B b;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setB</span><span class="params">(B b)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;如果你使用注解，这个setter变得毫无意义&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;这个方法甚至都不会调用&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;因为前文说过这种方法用的是field.set&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面代码同样会注入b，但是是调用field.set去完成注入的，不是通过setter，当然再次说明一下这是setter的一种变体；上面代码直到A完成注入B后setter方法也不会调用；</p>
<p>重点来了，要考。笔者看过很多资料说@Autowired也算自动装配，关于这点笔者不敢苟同，在一个属性上面加@Autowired注解应该属于手动装配，我会通过大量源码和例子来证明笔者的这个理论。<br>之所以会有人把@Autowired也理解为自动装配的原因是因为bytype引起的，因为spring官网有说明自动装配有四种模型分表是no、bytype、byname、constructor；参考官网资料，而现在流行着这么一种说法：**@Autowired就是通过bytype来完成注入的**。如果你也认为这种说法成立，那么就是默认了@Autowired是自动装配且装配模型是bytype。笔者见过很多程序员和很多资料都支持这种说法，其实严格意义上来讲这句话大错特错，甚至有误人子弟的嫌疑。因为bytype仅仅是一种自动注入模型而已，这种模型有其固有的技术手段，而@Autowired是一个注解，这个注解会被spring的后置处理器解析，和处理bytype不是同一回事。如果需要讲清楚他们的区别和证明@Autowired不是自动装配则首先要搞明白什么自动装配。笔者接下来会花一定篇幅来解释自动装配的知识，然后回过头来讲他们的区别和证明@Autowired属性手动装配。</p>
</blockquote>
<blockquote>
<p>如果现在已经理解了手动装配也叫手动注入，也已经理解了注入方式(setter和构造方法)，那么接下来讨论自动注入或者叫自动装配；自动注入的出现是因为手动装配过于麻烦，比如某个类X当中依赖了10个其他类那么配置文件将会变的特别冗余和臃肿，spring的做法是可以为这个X类提供一种叫做自动装配的模型，无需程序员去手动配置X类的依赖关系。有读者会疑问，用注解不也是可以解决这个xml臃肿的问题？确实用注解可以解决，但是我们现在讨论的是自动装配的问题，就不能用注解；为什么不能用注解来讨论自动装配的问题呢？因为在不配置BeanFactoryPostProcessor和修改beanDefinition的情况下注解的类是不支持自动装配的（关于BeanFactoryPostProcessor和beanDefinition的知识笔者以后有时间更新）；这也是证明@Autowired默认不是自动装配的一个证据，那又如何证明注解类是默认不支持自动装配呢？下文我会解释一个注解类默认是不支持自动装配的。也就是说如果讨论自动装配最好是用xml形式来配置spring容器才会有意义；当然读者如果对spring比较精通其实通过修改注解类的beanDefinition来说明自动装配的问题，鉴于大部分读者对spring不精通故而笔者还是用xml来讨论吧；比如下面这个例子</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span></span><br><span class="line">		<span class="keyword">default</span>-autowire=<span class="string">&quot;byType&quot;</span>&gt;</span><br><span class="line">		&lt;!--<span class="keyword">default</span>-autowire=<span class="string">&quot;byType&quot;</span>--&gt;</span><br><span class="line">		&lt;!-- 程序员不指定装配的具体参数，容器自动查询后装配--&gt;</span><br><span class="line">		&lt;!--当然除了这种写法还可以直接在bean标签上为特定类指定自动装配模型--&gt;</span><br><span class="line">		&lt;bean id=<span class="string">&quot;a&quot;</span> class=<span class="string">&quot;com.luban.app.A&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">		&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">		&lt;bean id=<span class="string">&quot;b&quot;</span>  class=<span class="string">&quot;com.luban.app.B&quot;</span>&gt;</span><br><span class="line">		&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A.java</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	B b;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setB</span><span class="params">(B b)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;在不考虑注解的情况下&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;如果配置了自动装配则不需要手动配置&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面代码运行起来，A能注入B，但是在xml配置文件中并没有去手动维护、描述他们之间的依赖关系，而是在xml的根标签上面写了一行default-autowire&#x3D;“byType”，其实关于自动注入的歧义或者被人误解的地方就是这个default-autowire&#x3D;”byType”引起的；那么这行代码表示什么意思呢？表示所在配置在当前xml当中的bean都以bytype这种模式自动装配(如果没有特殊指定，因为bean还可以单独配置装配模式的)；这需要注意笔者的措辞，笔者说的bytype这自动装配模式，是一种模式，这个不是笔者信口开河，因为在官网文档里面spring也是这么定义的<br>首先官网介绍beanDefinition这一章节的时候有提到bean的Autowiring mode</p>
</blockquote>
<p><img src="/2022/10/25/spring%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5/3.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>再就是spring官网在介绍spring自动注入知识的章节也提到过这个名词</p>
</blockquote>
<p><img src="/2022/10/25/spring%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5/4.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>Autowiring mode 笔者姑且翻译为自动注入模型吧，如果有211、雅思读者可以给读者留言更合适的翻译<br>那为什么要锱铢在这个名词上呢？笔者觉得真的非常重要，很多初学spring的程序员都是粗学spring，忽略甚至混淆了很多关键的名词定义，导致很多观念根深蒂固后面想深入学习spring源码的时候就比较困难<br>这个名字叫做自动注入模型和前面提到的依赖注入方式(setter和构造方法)是两回事，简而言之：<strong>依赖注入是一个过程，主要通过setter和构造方法以及一些变体的方式完成把对象依赖、或者填充上的这个过程叫做依赖注入，不管手动装配还是自动装配都有这个过程</strong>；而自动装配模型是一种完成自动装配依赖的手段体现，每一种模型都使用了不同的技术去查找和填充bean；而从spring官网上面可以看到spring只提出了4中自动装配模型（严格意义上是三种、因为第一种是no，表示不使用自动装配、使用），这四个模型分别用一个整形来表示，存在spring的beanDefinition当中，任何一个类默认是no这个装配模型，也就是一个被注解的类默认的装配模型是no也就是手动装配；其中no用0来表示；bytype用2来表示；如果某个类X，假设X的bean对应的beanDefinition当中的autowireMode&#x3D;2则表示这个类X的自动装配模型为bytype；如果autowireMode&#x3D;1则表示为byname装配模型；需要注意的是官网上面说的四种注入模型其中并没有我们熟悉的@Autowired，这也再一次说明@Autowired不是自动装配；可能有读者会提出假设我在A类的某个属性上面加上@Autowired之后这个A类就会不会成了自动装配呢？@Autowired是不是会改变这个类A当中的autowireMode呢？我们可以写一个例子来证明一下</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span></span><br><span class="line">	   <span class="keyword">default</span>-autowire=<span class="string">&quot;byType&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">		&lt;bean id=<span class="string">&quot;a&quot;</span> class=<span class="string">&quot;com.luban.app.A&quot;</span>&gt;</span><br><span class="line">		&lt;/bean&gt;</span><br><span class="line">		&lt;bean id=<span class="string">&quot;b&quot;</span>  class=<span class="string">&quot;com.luban.app.B&quot;</span>&gt;</span><br><span class="line">		&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"></span><br><span class="line">xml配置了A 和B 都是自动装配模型为bytype讲道理要实现autowireMode=<span class="number">2</span></span><br><span class="line"></span><br><span class="line">A.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提供一个后置处理器来获取A的自动装配模型</span><br><span class="line">ZiluBeanFactoryPostprocessor.java</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZiluBeanFactoryPostprocessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">		<span class="type">GenericBeanDefinition</span> <span class="variable">a</span> <span class="operator">=</span> (GenericBeanDefinition)</span><br><span class="line">				beanFactory.getBeanDefinition(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">		<span class="comment">//打印A 的注入模型</span></span><br><span class="line">		System.out.println(<span class="string">&quot;a mode=&quot;</span>+a.getAutowireMode());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>讲道理由于是bytype所以应该打印出来2； 结果如图</p>
</blockquote>
<p><img src="/2022/10/25/spring%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5/5.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>如果笔者把注入模型改成byname则结果应该会改变</p>
</blockquote>
<p><img src="/2022/10/25/spring%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5/6.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>接下来笔者验证一个通过注解配置的类加上@Autowried后的注入模型的值</p>
</blockquote>
<p><img src="/2022/10/25/spring%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5/7.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>可以看到结果为0，说明这个A类不是自动装配，其实这已经能证明@Autowried不是自动装配了，但是还有更直接的证据证明他不是自动装配，就是通过spring源码当中处理@Autowried的代码可以看出，首先我们写一个bytype的例子看看spring如何处理的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span></span><br><span class="line">	   <span class="keyword">default</span>-autowire=<span class="string">&quot;byType&quot;</span>&gt;</span><br><span class="line">		&lt;!--自动装配--&gt;</span><br><span class="line">		&lt;bean id=<span class="string">&quot;a&quot;</span> class=<span class="string">&quot;com.luban.app.A&quot;</span>&gt;</span><br><span class="line">		&lt;/bean&gt;</span><br><span class="line">		&lt;bean id=<span class="string">&quot;b&quot;</span>  class=<span class="string">&quot;com.luban.app.B&quot;</span>&gt;</span><br><span class="line">		&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">	B b;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 如果是自动装配需要提供setter</span></span><br><span class="line"><span class="comment">	 * 或者提供构造方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setB</span><span class="params">(B b)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.b = b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面代码运行起来，调试spring源码当中的org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#populateBean方法，这个方法主要就是完成属性填充的，也就是大家说的注入</p>
</blockquote>
<p><img src="/2022/10/25/spring%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5/8.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>可以看上图1399行有一个判断，判断当前类的注入模式是否bynane或者bytype如果是其中一种则会进入1401行代码执行自动装配的逻辑；因为当前代码我在xml当中配置了自动注入模型为bytype所以这里一定会进入，从上图debug的结果我们可以得知确实也进入了1401行，那我们再看看@Autowried到底是否是一样的呢？好吧作为良心笔者特意录了一个gif</p>
</blockquote>
<p><img src="/2022/10/25/spring%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5/9.gif" alt="在这里插入图片描述"></p>
<blockquote>
<p>从上面那个笔者良心录制的gif可以看到当我们使用@Autowired注解去注入一个属性的时候spring在完成属性注入的过程中和自动注入（byname、bytype）的过程不同，spring注解跳过了那个判断，因为不成立，而是用后面的代码去完成属性注入；这也是能说明@Autowired不是自动装配的证据、更是直接打脸@Autowired是先bytype的这种说法；当然除了这个证据还有更加直接的证据，先看代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	B b;</span><br><span class="line">	<span class="keyword">public</span>  <span class="title function_">A</span><span class="params">(B b)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.b=b;</span><br><span class="line">		System.out.println(b);</span><br><span class="line">		System.out.println(<span class="string">&quot;这个b能正常打印，那这算不算自动装配呢？&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;看起来像是constructor这种自动装配模型&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;但是实际呢？我们通过源码来说明&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;这个构造方法没有加任何注解&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;这里主要来说明，一个注解类是不是自动装配&quot;</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明一下这个A类的构造方法注入的B是可以注入的，这样算不算注解类的自动注入呢？看起来像，其实本质上他用的也是自动注入的代码实现的，但是笔者还是认为他不是；为什么呢？我们先来分析一下这个b能被注入的原因是什么，同样给一个gif来说明<br><img src="/2022/10/25/spring%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5/10.gif" alt="在这里插入图片描述"></p>
</blockquote>
<blockquote>
<p>其实最关键的就是这行代码<br>if (ctors !&#x3D; null || mbd.getResolvedAutowireMode() &#x3D;&#x3D;<br>AUTOWIRE_CONSTRUCTOR ||<br>mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) { return autowireConstructor(beanName, mbd, ctors, args);<br>}<br>这里有个判断 首先判断 ctors !&#x3D; null 然后判断类的自动注入模型是不是等于AUTOWIRE_CONSTRUCTOR也是3；分两种情况来分析；</p>
</blockquote>
<blockquote>
<p>第一种情况：假设你指定了类的自动注入模型为constructor那么这个if一定成立因为他是||判断只要一个成立整个if成立；很显然我们这里不是这种情况，笔者并没有指定A类的自动注入模型为3，上面的那个gif里面我给读者展示了，后面那个判断不成立，因为mbd.getResolvedAutowireMode()&#x3D;0；再一次说明了一个注解类默认的自动注入模型为no也就是autowireMode&#x3D;0;</p>
</blockquote>
<blockquote>
<p>第二种情况：没有指定类的自动注入模型，笔者代码例子就是这种情况，那么spring会首先推断出构造方法，笔者A里面一个带参数的构造方法，所以再进行第一个判断ctors<br>!&#x3D; null的时候就已经成立了，于是也会进入</p>
</blockquote>
<blockquote>
<p>结论：在一个注解类里面提供了一个构造方法之所以能达到和自动注入的效果一样并不是因为这种方式就是自动装配，而是因为spring源码当中做了判断；使这种情况下调用的代码和自动装配调用的逻辑一下。但是有的读者会说那这样也能算自动装配啊，当然如果读者一定这么认为那么也无可厚非；仁者见仁智者见智</p>
</blockquote>
<blockquote>
<p>那哔哩哔哩说了这么多@Autowried到底和bytype有什么关系呢？为什么有资料会把他们联系在一起呢？<br>首先bytype是一种自动注入模型，spring会更加类型去查找一个符合条件的bean如果没找到则不注入，程序也不会报错；如果找到多个spring也不报错，但是也不完成注入，让这个属性等于null，比如你有个接口I，提供两个实现I1和I2都存在容器当中，然后在A类当中去注入I，并且指定自动注入模型为bytype那么这个时候会找到两个符合条件的bean，spring就迷茫了，注入哪个呢？spring哪个都不注入直接让这个属性为null而且也不出异常；但是如果找到了一个那么注入的时候会调用setter，如果没有提供setter就不会注入；</p>
<p><img src="/2022/10/25/spring%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5/11.gif" alt="在这里插入图片描述"></p>
<p>其次@Autowried是一个注解，加在属性上面spring，</p>
</blockquote>
<p><strong>spring会首先根据属性的类型去容器中找，如果没有找到在根据属性的名字找，找到了则注入，没有找到则异常，下图结果就是容器当中没有一个符合的类型和名字都不符合的则异常；</strong></p>
<p><img src="/2022/10/25/spring%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5/12.gif" alt="在这里插入图片描述"></p>
<p><strong>如果先根据类型找到了一个，那么直接注入，下图就是只有一个符合要求的类型能够完美注入；</strong></p>
<p><img src="/2022/10/25/spring%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5/13.gif" alt="在这里插入图片描述"></p>
<p>如果先根据类型找到了多个，那么spring不会立马异常，而是根据名字再找去找，如果根据名字找到一个合理的则注入这个合理的，下图就是I1和I2都符合，但是spring最后却没有异常，是因为属性名字叫i1故而先类型在名字找到了合理的；</p>
<p><img src="/2022/10/25/spring%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5/14.gif" alt="在这里插入图片描述"></p>
<p>如果先根据类型找到了多个，那么spring不会立马异常，而是根据名字再找去找，如果根据名字还是没有找到那么时候spring会异常，下图就是两个i1和i2都符合，于是spring通过名字找i3也找不到，故而出异常；</p>
<p><img src="/2022/10/25/spring%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5/15.gif" alt="在这里插入图片描述"></p>
<p>以后如果再听到@Autowried是bytype请你纠正他，bytype是一种自动注入模型；@Autowried是一个注解，两个人没有关系，一点关系都没有；@Autowried讲道理算是手动装配；那么一个注解的类到底能不能开启自动装配呢？答案是可以的，但是需要你对spring比较精通，以后笔者再更新；</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>框架源码</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务-CAP+Base理论</title>
    <url>/2022/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-CAP-Base%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在之前的<a href="http://mp.weixin.qq.com/s?__biz=Mzg4NjU0NTg2MA==&mid=2247483770&idx=1&sn=8f05f6edef012cfa64ce94553f84f748&chksm=cf994dd1f8eec4c73b768b040d2e42870cb3d03be445311bc1c8cc3b6e657c6be8354e2d03d1&scene=21#wechat_redirect">MySQL（二）、事务 </a>文章中我们介绍了MySQL事务的四个特性（ACID），本系列我们来讲解在分布式系统中事务可能遇到的问题以及对应的解决方案，本篇先来讲一下CAP以及BASE理论。</p>
<h1 id="事务的一致性"><a href="#事务的一致性" class="headerlink" title="事务的一致性"></a>事务的一致性</h1><ul>
<li><strong>强一致性</strong>：系统中的某个数据被成功更新后，后续的访问都能看到更新后的值；</li>
<li><strong>弱一致性</strong>：系统中的某个数据被更新后，后续的访问可能得到更新后的值，也可能是更改前的值；</li>
<li><strong>最终一致性</strong>：系统中的某个数据被更新，经过一段时间后，最终所有的访问都是更新的值；</li>
</ul>
<blockquote>
<p><strong>刚性事务</strong>：遵循ACID原则，强一致性；</p>
<p><strong>柔性事务</strong>：遵循BASE理论，最终一致性；</p>
</blockquote>
<p><strong>事务的四个特性（ACID）：</strong></p>
<ul>
<li><strong>原子性（Atomicity）</strong>：事务被视为一个不可分割的最小工作单元，事务中的所有操作要么全部提交成功，要么全部失败回滚；</li>
<li><strong>一致性（Consistency）</strong>：数据库总是从一个一致性的状态转换到另外一个一致性的状态；</li>
<li><strong>隔离性（Isolation）</strong>：一个事务所做的修改在最终提交以前，对其他事务是不可见的；</li>
<li><strong>持久性（Durability）</strong>：一旦事务提交，则其所做的修改就会永久保存到数据库中；</li>
</ul>
<p><strong>柔性事务对事务四个特性（ACID）的支持情况：</strong></p>
<ul>
<li>原子性：完全支持。</li>
<li>一致性：只提供最终一致性支持。</li>
<li>隔离性：不完全保证，通常为了系统的吞吐和性能，会一定程度上放弃对隔离性的要求。</li>
<li>持久性：完全支持。</li>
</ul>
<h1 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h1><p><strong>CAP理论</strong>：在一个分布式系统中，一致性（<strong>C</strong>onsistency）、可用性（<strong>A</strong>vailability）、分区容错性（<strong>P</strong>artition tolerance），这三个要素最多只能同时实现两点，不可能三者兼顾。</p>
<ul>
<li><strong>一致性（Consistency）</strong>：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本） ；</li>
<li><strong>可用性（Availability）</strong>：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）； </li>
<li><strong>分区容忍性（Partition tolerance）</strong>：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择；</li>
</ul>
<p><img src="/2022/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-CAP-Base%E7%90%86%E8%AE%BA/1.png" alt="图片"></p>
<p>图中重叠的部分就是在分布式环境下，必须做出的取舍：要么CP，要么AP，要么AC，但是不存在CAP。</p>
<ul>
<li><strong>CP</strong>：牺牲可用性。复制同步的协议一般使用严格的法定数协议 (Paxos、Raft、ZAB)或者2PC协议。CP类型的系统有MongoDB、HBase、 Zookeeper、Redis等。</li>
<li><strong>AP</strong>：牺牲一致性。复制同步的协议一般使用非严格的法定数协议。AP类型的系统有 Couch DB、Cassandra、Amazon Dynamo等。</li>
<li><strong>AC</strong>：抛开RDBMS的Oracle和MySQL不谈，分布式系统中宣称是CA系统的有谷歌的Spanner 和阿里的OceanBase。</li>
</ul>
<blockquote>
<p><strong>问：为什么分布式系统中无法同时保证一致性和可用性？</strong></p>
<p>答：首先一个前提，对于分布式系统而言，分区容错性是一个最基本的要求，因此基本上我们在设计分布式系统的时候只能从一致性（C）和可用性（A）之间进行取舍。</p>
<p>如果保证了一致性（C）：对于节点N1和N2，当往N1里写数据时，N2上的操作必须被暂停，只有当N1同步数据到N2时才能对N2进行读写请求，在N2被暂停操作期间客户端提交的请求会收到失败或超时。显然，这与可用性是相悖的。</p>
<p>如果保证了可用性（A）：那就不能暂停N2的读写操作，但同时N1在写数据的话，这就违背了一致性的要求。</p>
</blockquote>
<p><strong>CAP和ACID中的A和C是完全不一样的：</strong></p>
<p>C的区别：</p>
<ul>
<li>ACID一致性是有关数据库规则，数据库总是从一个一致性的状态转换到另外一个一致性的状态；</li>
<li>CAP的一致性是分布式多服务器之间复制数据令这些服务器拥有同样的数据，由于网速限制，这种复制在不同的服务器上所消耗的时间是不固定的，集群通过组织客户端查看不同节点上还未同步的数据维持逻辑视图，这是一种分布式领域的一致性概念；</li>
</ul>
<p>A的区别：</p>
<ul>
<li>ACID中的A指的是原子性(Atomicity)，是指事务被视为一个不可分割的最小工作单元，事务中的所有操作要么全部提交成功，要么全部失败回滚；</li>
<li>CAP中的A指的是可用性(Availability)，是指集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求；</li>
</ul>
<h1 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h1><p><strong>BASE</strong>是<strong>B</strong>asically <strong>A</strong>vailable（基本可用）、<strong>S</strong>oft state（软状态）和<strong>E</strong>ventually consistent（最终一致性）的缩写。</p>
<p>在分布式系统中，CAP理论是指导思维，而BASE理论是CAP理论中AP的延伸，是对 CAP 中的一致性和可用性进行一个权衡的结果，核心思想是：即使无法做到强一致性，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。</p>
<ul>
<li><strong>基本可用（Basically Available）</strong>：指分布式系统在出现故障的时候，允许损失部分可用性，保证核心可用。</li>
<li><strong>柔性状态（Soft state）</strong>：指允许系统存在中间状态，并认为该中间状态不会影响系统整体可用性。比如，允许不同节点间副本同步的延时就是柔性状态的体现。</li>
<li><strong>最终一致性（Eventually consistent）</strong>：指系统中的所有副本经过一定时间后，最终能够达到一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</li>
</ul>
<p>前面提到的柔性事务就是BASE理论的实现，在之后的文章中会详细讲解刚性事务和柔性事务的分类及实现。</p>
]]></content>
      <categories>
        <category>分布式事务</category>
      </categories>
      <tags>
        <tag>cAP</tag>
        <tag>BASE</tag>
        <tag>分布式事务</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务-Seata分布式事务框架</title>
    <url>/2022/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-Seata%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="1-Seata-概述"><a href="#1-Seata-概述" class="headerlink" title="1. Seata 概述"></a>1. <a href="https://so.csdn.net/so/search?q=Seata&spm=1001.2101.3001.7020">Seata</a> 概述</h2><p>Seata 是 Simple Extensible Autonomous Transaction Architecture 的简写，由 feascar 改名而来。</p>
<p>Seata 是阿里开源的<a href="https://so.csdn.net/so/search?q=%E5%88%86%E5%B8%83%E5%BC%8F&spm=1001.2101.3001.7020">分布式</a>事务框架，属于二阶段提交模式。</p>
<p>目前<a href="https://so.csdn.net/so/search?q=github&spm=1001.2101.3001.7020">github</a>上已经有 12267 颗星了，也很活跃，最新的提交时间很多都是几天前。</p>
<p>首先我们回顾一下在单体应用中，例如一个业务调用了3个模块，他们都使用同一个数据源，是靠本地事务来保证事务一致性。</p>
<p><img src="/2022/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-Seata%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A1%86%E6%9E%B6/1.png" alt="在这里插入图片描述"></p>
<p>但在<a href="https://so.csdn.net/so/search?q=%E5%BE%AE%E6%9C%8D%E5%8A%A1&spm=1001.2101.3001.7020">微服务</a>架构中，这3个模块会变为3个独立的微服务，各自有自己的数据源，调用逻辑就变为：<br><img src="/2022/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-Seata%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A1%86%E6%9E%B6/2.png" alt="在这里插入图片描述"></p>
<h3 id="Seata-如何处理呢？"><a href="#Seata-如何处理呢？" class="headerlink" title="Seata 如何处理呢？"></a>Seata 如何处理呢？</h3><p><img src="/2022/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-Seata%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A1%86%E6%9E%B6/3.png" alt="在这里插入图片描述"><br>Business 是业务入口，在程序中会通过注解来说明他是一个全局事务，这时他的角色为 TM（事务管理者）。</p>
<p>Business 会请求 TC（事务协调器，一个独立运行的服务），说明自己要开启一个全局事务，TC 会生成一个全局事务ID（XID），并返回给 Business。</p>
<p>Business 得到 XID 后，开始调用微服务，例如调用 Storage。<br><img src="/2022/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-Seata%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A1%86%E6%9E%B6/4.png" alt="在这里插入图片描述"><br>和上面的图一样，方便查看，防止滚到到这儿时已经看不到上面的图片了）</p>
<p>Storage 会收到 XID，知道自己的事务属于这个全局事务。Storage 执行自己的业务逻辑，操作本地数据库。</p>
<p>Storage 会把自己的事务注册到 TC，作为这个 XID 下面的一个分支事务，并且把自己的事务执行结果也告诉 TC。</p>
<p>此时 Storage 的角色是 RM（资源管理者），资源是指本地数据库。</p>
<p>Order、Account 的执行逻辑与 Storage 一致。</p>
<p>在各个微服务都执行完成后，TC 可以知道 XID 下各个分支事务的执行结果，TM（Business） 也就知道了。</p>
<p>Business 如果发现各个微服务的本地事务都执行成功了，就请求 TC 对这个 XID 提交，否则回滚。</p>
<p>TC 收到请求后，向 XID 下的所有分支事务发起相应请求。</p>
<p>各个微服务收到 TC 的请求后，执行相应指令，并把执行结果上报 TC。</p>
<p><strong>重要机制</strong></p>
<p><strong>（1）全局事务的回滚是如何实现的呢？</strong></p>
<p>Seata 有一个重要的机制：回滚日志。</p>
<p>每个分支事务对应的数据库中都需要有一个回滚日志表 UNDO_LOG，在真正修改数据库记录之前，都会先记录修改前的记录值，以便之后回滚。</p>
<p>在收到回滚请求后，就会根据 UNDO_LOG 生成回滚操作的 SQL 语句来执行。</p>
<p>如果收到的是提交请求，就把 UNDO_LOG 中的相应记录删除掉。</p>
<p><strong>（2）RM 是怎么自动和 TC 交互的？</strong></p>
<p>是通过监控拦截JDBC实现的，例如监控到开启本地事务了，就会自动向 TC 注册、生成回滚日志、向 TC 汇报执行结果。</p>
<p><strong>（3）二阶段回滚失败怎么办？</strong></p>
<p>例如 TC 命令各个 RM 回滚的时候，有一个微服务挂掉了，那么所有正常的微服务也都不会执行回滚，当这个微服务重新正常运行后，TC 会重新执行全局回滚。</p>
<h3 id="1-3-核心组件"><a href="#1-3-核心组件" class="headerlink" title="1.3 核心组件"></a>1.3 核心组件</h3><p>回顾一下其中的核心组件：</p>
<p>事务协调器 TC<br>维护全局和分支事务的状态，指示全局提交或者回滚。</p>
<p>事务管理者 TM<br>开启、提交或者回滚一个全局事务。</p>
<p>资源管理者 RM<br>管理执行分支事务的那些资源，向TC注册分支事务、上报分支事务状态、控制分支事务的提交或者回滚。</p>
<h3 id="1-4-具体工作过程"><a href="#1-4-具体工作过程" class="headerlink" title="1.4 具体工作过程"></a>1.4 具体工作过程</h3><p>再从宏观上梳理一下 Seata 的工作过程：<br><img src="/2022/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-Seata%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A1%86%E6%9E%B6/5.png" alt="在这里插入图片描述"><br>TM 请求 TC，开始一个新的全局事务，TC 会为这个全局事务生成一个 XID。<br>XID 通过微服务的调用链传递到其他微服务。<br>RM 把本地事务作为这个XID的分支事务注册到TC。<br>TM 请求 TC 对这个 XID 进行提交或回滚。<br>TC 指挥这个 XID 下面的所有分支事务进行提交、回滚。</p>
<h2 id="2-Seata-详细工作流程示例"><a href="#2-Seata-详细工作流程示例" class="headerlink" title="2. Seata 详细工作流程示例"></a>2. Seata 详细工作流程示例</h2><p>下面我们通过一个分支事务的执行过程来了解 Seata 的工作流程。</p>
<p>例如有一个业务表 product(id,name)，分支事务的业务逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update product set name = &#x27;GTS&#x27; where name = &#x27;TXC&#x27;;</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h3 id="2-1-一阶段"><a href="#2-1-一阶段" class="headerlink" title="2.1 一阶段"></a>2.1 一阶段</h3><p>（1）解析 SQL</p>
<p>得到 SQL 的类型（UPDATE），表（product），条件（where name &#x3D; ‘TXC’）等相关的信息。</p>
<p>（2）查询前镜像</p>
<p>根据解析得到的条件信息，生成查询语句，定位数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select id, name from product where name = &#x27;TXC&#x27;;</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>得到前镜像：<br><img src="/2022/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-Seata%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A1%86%E6%9E%B6/6.png" alt="在这里插入图片描述"></p>
<p>（3）执行业务 SQL</p>
<p>执行自己的业务逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update product set name = &#x27;GTS&#x27; where name = &#x27;TXC&#x27;;</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>把 name 改为了 GTS。</p>
<p>（4）查询后镜像</p>
<p>根据前镜像的结果，通过 主键 定位数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select id, name from product where id = 1;</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>得到后镜像：</p>
<p><img src="/2022/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-Seata%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A1%86%E6%9E%B6/6.png" alt="在这里插入图片描述"><br>（5）插入回滚日志</p>
<p>把前后镜像数据以及业务 SQL 相关的信息组成一条回滚日志记录，插入到 UNDO_LOG 表中。</p>
<p>（6）提交前，向 TC 注册分支：申请 product 表中，主键值等于 1 的记录的 全局锁 。</p>
<p>（7）本地事务提交：业务数据的更新和前面步骤中生成的 UNDO LOG 一并提交。</p>
<p>（8）将本地事务提交的结果上报给 TC。</p>
<h3 id="2-2-二阶段-回滚"><a href="#2-2-二阶段-回滚" class="headerlink" title="2.2 二阶段 - 回滚"></a>2.2 二阶段 - 回滚</h3><p>（1）收到 TC 的分支回滚请求，开启一个本地事务，执行如下操作。</p>
<p>（2）通过 XID 和 Branch ID 查找到相应的 UNDO LOG 记录。</p>
<p>（3）数据校验</p>
<p>拿 UNDO LOG 中的后镜与当前数据进行比较，根据校验结果决定是否做回滚。</p>
<p>（4）根据 UNDO LOG 中的前镜像和业务 SQL 的相关信息生成并执行回滚的语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update product set name = &#x27;TXC&#x27; where id = 1;</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>5）提交本地事务</p>
<p>并把本地事务的执行结果（即分支事务回滚的结果）上报给 TC。</p>
<p><strong>二阶段 - 提交</strong></p>
<p>（1）收到 TC 的分支提交请求，把请求放入一个异步任务的队列中，马上返回提交成功的结果给 TC。</p>
<p>（2）异步任务阶段的分支提交请求，将异步和批量地删除相应 UNDO LOG 记录。</p>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>上面介绍的是 Seata 的 AT 模式，就是自动化事务，使用非常简单，对业务代码没有侵入性。</p>
<p>不足的地方是目前文档比较少，网上的相关材料也不是很多，所以使用过程中遇到问题时可能就需要自己查看源码，分析原理。</p>
<p>Seata 还支持 TCC 和 Saga 模式，但支持的主要方式是 AT。</p>
]]></content>
      <categories>
        <category>分布式事务</category>
      </categories>
      <tags>
        <tag>cAP</tag>
        <tag>BASE</tag>
        <tag>分布式事务</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务-刚性事务2PC+3PC</title>
    <url>/2022/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E5%88%9A%E6%80%A7%E4%BA%8B%E5%8A%A12PC-3PC/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在前面的文章中我们提到了<strong>刚性事务遵循ACID原则，满足强一致性</strong>，本篇讲解刚性事务的标准实现2PC（二阶段提交）和3PC（三阶段提交）。</p>
<h1 id="XA"><a href="#XA" class="headerlink" title="XA"></a>XA</h1><p><strong>XA协议</strong>是X&#x2F;Open CAE Specification定义的一套DTP（Distributed Transaction Processing）分布式事务处理模型，主要包含四个部分：</p>
<ul>
<li><strong>应用程序（AP）</strong>：应用程序</li>
<li><strong>事务管理器（TM）</strong>：交易中间件</li>
<li><strong>资源管理器（RM）</strong>：数据库</li>
<li><strong>通信资源管理器（CRM）</strong>：消息中间件</li>
</ul>
<p>事务管理器作为一个全局的调度者，负责通知各个资源管理器事务的开始、结束、提交、回滚，把多个本地事务协调为全局统一的分布式事务。两阶段提交（2PC）和三阶段提交（3PC）就是基于此协议衍生出来的。Oracle、Mysql等数据库均已实现了XA接口。</p>
<h1 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h1><p><strong>2PC</strong> 是二阶段提交（Two-phase Commit）的缩写，分为两个阶段完成，第一个阶段是<strong>准备阶段（prepare）</strong>，第二个阶段是<strong>提交阶段（commit&#x2F;rollback）</strong>，准备阶段和提交阶段都是由事务管理器（协调者）发起的，协调的对象是资源管理器（参与者）。 </p>
<ol>
<li><strong>准备阶段</strong>：协调者向所有参与者发起指令，每个参与者评估自己的状态，如果参与者评估指令可以完成，参与者会写 redo 和 undo 日志，然后锁定资源，执行操作，但不提交。</li>
<li><strong>提交阶段</strong>：如果所有参与者返回准备成功，即预留资源和执行操作成功，协调者会向所有参与者发起提交指令，参与者提交资源变更的事务，释放锁定的资源；如果任何一个参与者返回准备失败，即预留资源或者执行操作失败，协调者会向所有参与者发起中止指令，参与者取消已经变更的事务，执行 undo 日志并释放锁定的资源。</li>
</ol>
<p><img src="/2022/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E5%88%9A%E6%80%A7%E4%BA%8B%E5%8A%A12PC-3PC/1.png" alt="图片"></p>
<p><strong>二阶段提交</strong>（2PC）的缺点：</p>
<ul>
<li><strong>阻塞</strong>：事务执行过程中所有参与者都是阻塞型的，占用的资源被一直锁定，不会被释放，第三方参与者访问参与者占有的资源时会被阻塞，影响性能；</li>
<li><strong>单点故障</strong>：协调者一旦发生故障，参与者与协调者失去同步，参与者会被一直阻塞。尤其在提交阶段，所有参与者都处于锁定资源状态中，无法完成事务操作；（虽然可以选举出新的协调者，但仍然无法解决参与者被阻塞的问题）；</li>
<li><strong>数据不一致</strong>：提交阶段协调者向参与者发送提交指令，发生局部网络故障，会出现一部分参与者未收到提交指令无法提交事务的情况，导致多个参与者之间出现数据不一致的现象；</li>
</ul>
<blockquote>
<p>二阶段提交协议在准备阶段需要等待所有参与者的反馈，因此可能造成数据库资源锁定时间过长，不适合高并发和子事务生命周长较长的业务场景。两阶段提交牺牲了一部分可用性来换取一致性。 </p>
</blockquote>
<h1 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h1><p><strong>3PC</strong>是三阶段提交（Three-phase Commit）的缩写，是对2PC 的改进，3PC在2PC的<strong>准备阶段</strong>和<strong>提交阶段</strong>中加入一个<strong>预提交阶段</strong>。保证了在最后提交阶段之前，各参与者节点的状态都一致。同时在协调者和参与者中都引入<strong>超时机制</strong>解决了阻塞的问题，当参与者由于各种原因未收到协调者的commit 请求后，会对本地事务进行commit，不会一直阻塞等待，解决了2PC的单点故障问题，因此维基百科中定义3PC为“非阻塞”协议。</p>
<p>3PC 的三个阶段：<strong>CanCommit（准备阶段）、PreCommit（预提交阶段）、DoCommit（提交阶段）</strong></p>
<ol>
<li><strong>准备阶段</strong>：协调者询问参与者是否可以执行事务提交操作，协调者只需要回答是还是不是，而不需要做真正的操作，这个阶段参与者在等待超时后会自动中止。</li>
<li><strong>预提交阶段</strong>：如果在CanCommit准备阶段所有的参与者都返回可以执行操作，协调者向所有参与者发送预提交请求，然后参与者写 redo 和 undo 日志，锁定资源，执行操作，但不提交；如果在CanCommit准备阶段任何一个参与者返回不能执行操作的结果，则协调者向所有参与者发送中止指令。这里与两阶段提交协议的准备阶段是相似的，此阶段的参与者在等待超时后会自动提交。</li>
<li><strong>提交阶段</strong>：如果所有参与者在PreCommit预提交阶段都返回成功，也就是预留资源和执行操作成功，协调者向参与者发起提交指令，参与者提交资源变更的事务，释放锁定的资源；如果任何一个参与者返回失败，也就是预留资源或者执行操作失败，协调者向所有参与者发起中止指令，参与者取消已经变更的事务，执行 undo 日志，释放锁定的资源。这里与两阶段提交协议的提交阶段一致。</li>
</ol>
<blockquote>
<p><strong>超时机制：</strong></p>
<ul>
<li>如果在CanCommit 准备阶段等待超时，则自动中止；</li>
<li>如果在PreCommit预提交阶段等待超时，则自动提交。</li>
</ul>
</blockquote>
<p><img src="/2022/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E5%88%9A%E6%80%A7%E4%BA%8B%E5%8A%A12PC-3PC/2.png" alt="图片"></p>
<p>3PC 通过预提交阶段可以减少故障恢复时候的复杂性，但3PC 还是没能从根本上解决数据一致性的问题，比如在预提交阶段时协调者和其中一个参与者都发生了故障，此时其他参与者在超时情况下会自动选择提交或回滚，当新选举出的协调者上任时也会给活着的参与者发送提交命令，但发生故障的那个参与者还未恢复且无法确定是否执行了事务，这里就出现了数据不一致的情况。</p>
<p>事实上 2PC 和 3PC 都无法保证完全的数据一致性，于是需要利用补偿机制尽量确保数据的一致性，在后面的文章中会具体介绍。</p>
]]></content>
      <categories>
        <category>分布式事务</category>
      </categories>
      <tags>
        <tag>cAP</tag>
        <tag>BASE</tag>
        <tag>分布式事务</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务-柔性事务TCC+事务消息</title>
    <url>/2022/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1TCC-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/</url>
    <content><![CDATA[<h1 id="【前言】"><a href="#【前言】" class="headerlink" title="【前言】"></a>【前言】</h1><p>在前面的文章中我们提到了<strong>柔性事务遵循BASE理论，满足最终一致性</strong>，柔性事务主要分为<strong>补偿型</strong>和<strong>通知型</strong>。补偿型事务又分TCC、Saga，通知型事务分事务消息、最大努力通知型。补偿型事务都是同步的，通知型事务都是异步的。本篇介绍柔性事务的这几种实现方案：TCC、Saga、事务消息、本地消息表、最大努力通知。</p>
<h1 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h1><p><strong>TCC（Try-Confirm-Cancel）</strong>采用补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。TCC模型通过对业务逻辑的分解来实现分布式事务：</p>
<ol>
<li><strong>Try</strong>：尝试执行业务，完成所有业务检查(一致性)，预留必要的业务资源(准隔离性)。</li>
<li><strong>Confirm</strong>：确认执行业务，不再做业务检查。只使用Try阶段预留的业务资源，Confirm操作满足幂等性。</li>
<li><strong>Cancel</strong>： 若业务执行失败，则取消执行业务并释放Try阶段预留的业务资源。</li>
</ol>
<p><strong>TCC分布式事务模型包括如下三部分：</strong></p>
<ul>
<li><strong>主业务服务</strong>：负责发起并完成整个业务活动。</li>
<li><strong>从业务服务</strong>：是整个业务活动的参与方，实现 Try、Confirm、Cancel 操作，供主业务服务调用。</li>
<li><strong>事务管理器</strong>：管理整个业务活动，包括记录事务状态，调用从业务服务的 Confirm&#x2F;Cancel 操作等。</li>
</ul>
<p><img src="/2022/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1TCC-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/1.png" alt="图片"></p>
<p><strong>TCC对比2PC</strong></p>
<p>可以看出，TCC也是把事务分成了两个阶段，Try是阶段一，Confirm 和 Cancel 是阶段二的两个分支。这有点像2PC（二阶段提交），但其实他们是不一样的，下面是他们的区别：</p>
<ol>
<li>2PC和3PC都是数据库层面的操作，对于开发人员无感知；而TCC是业务层的操作，对开发人员来说具有较高的开发成本。</li>
<li>2PC是一个整体的长事务，是刚性事务；而TCC是一组本地短事务，是柔性事务；</li>
<li>2PC是全局锁定资源，所有参与者阻塞等待事务管理器的通知；而TCC的资源锁定在于Try操作，业务方可以灵活选择业务资源的锁定粒度。</li>
</ol>
<p><strong>TCC优缺点</strong></p>
<p>优点：</p>
<ul>
<li>应用可以自定义数据操作的粒度，降低了锁冲突，提升吞吐量。</li>
</ul>
<p>缺点： </p>
<ul>
<li>应用侵入性强， Try、Confirm、Cancel 三个阶段都需要业务逻辑实现。</li>
<li>需要根据网络、系统故障等不同失败原因实现不同的回滚策略， 实现难度大，一般借助 TCC 开源框架，ByteTCC，TCC-transaction，Himly。</li>
</ul>
<h1 id="Saga"><a href="#Saga" class="headerlink" title="Saga"></a>Saga</h1><p><strong>Saga</strong>模型是把一个分布式事务拆分为多个本地事务，每个本地事务都有相应的执行模块和补偿模块（对应TCC中的Confirm和Cancel），当Saga事务中任意一个本地事务出错时，可以通过调用相关的补偿方法恢复之前的事务，达到事务最终一致性。</p>
<p><strong>Saga 模型由三部分组成</strong>：</p>
<ul>
<li><strong>LLT</strong>（Long Live Transaction）：由一个个本地事务组成的事务链<strong>。</strong></li>
<li><strong>本地事务</strong>：事务链由一个个子事务（本地事务）组成，LLT &#x3D; T1+T2+T3+…+Ti。</li>
<li><strong>补偿</strong>：每个本地事务 Ti 有对应的补偿 Ci。</li>
</ul>
<p><strong>Saga 的执行顺序</strong>：</p>
<ul>
<li>正常情况：T1,T2,T3,…,Ti</li>
<li>异常情况：T1,T2,T3,..Ti,Ci,…C3,C2,C1</li>
</ul>
<p><strong>Saga 两种恢复策略</strong>：</p>
<ul>
<li><strong>向后恢复</strong>（Backward Recovery）：撤销掉之前所有成功子事务。如果任意本地子事务失败，则补偿已完成的事务。如异常情况的执行顺序T1,T2,T3,..Ti,Ci,…C3,C2,C1。</li>
<li><strong>向前恢复</strong>（Forward Recovery）：即重试失败的事务，适用于必须要成功的场景，该情况下不需要Ci。执行顺序：T1,T2,…,Tj（失败）,Tj（重试）,…,Ti。</li>
</ul>
<p><strong>Saga 模型可以满足事务的三个特性ACD</strong>：</p>
<ul>
<li>原子性：Saga 协调器协调事务链中的本地事务要么全部提交，要么全部回滚。</li>
<li>一致性：Saga 事务可以实现最终一致性。</li>
<li>持久性：基于本地事务，所以这个特性可以很好实现。</li>
</ul>
<p>Saga缺乏隔离性会带来<a href="http://mp.weixin.qq.com/s?__biz=Mzg4NjU0NTg2MA==&mid=2247483770&idx=1&sn=8f05f6edef012cfa64ce94553f84f748&chksm=cf994dd1f8eec4c73b768b040d2e42870cb3d03be445311bc1c8cc3b6e657c6be8354e2d03d1&scene=21#wechat_redirect">脏读，幻读，不可重复读</a>的问题。由于Saga 事务和 TCC 事务一样，都是强依靠业务改造，因此需要在业务设计上去解决这个问题：</p>
<ul>
<li>在应⽤层⾯加⼊逻辑锁的逻辑。</li>
<li>Session 层⾯隔离来保证串⾏化操作。</li>
<li>业务层⾯采⽤预先冻结数据的方式隔离此部分数据。</li>
<li>业务操作过程中通过及时读取当前状态的⽅式获取更新。</li>
</ul>
<blockquote>
<p> <strong>实现Saga的注意事项</strong>：</p>
<ol>
<li>Ti和Ci必须是幂等的。如向后恢复和向前恢复时候如果不是幂等操作会导致数据不一致。</li>
<li>Ci必须是能够成功的，如果无法成功则需要人工介入。</li>
<li>Ti-&gt;Ci和Ci-&gt;Ti的执行结果必须是一样的。</li>
</ol>
</blockquote>
<p><strong>Saga对比TCC</strong></p>
<p>Saga和TCC都是补偿型事务，他们的区别为：</p>
<p>劣势：</p>
<ul>
<li>无法保证隔离性；</li>
</ul>
<p>优势：</p>
<ul>
<li>一阶段提交本地事务，无锁，高性能；</li>
<li>事件驱动模式，参与者可异步执行，高吞吐；</li>
<li>Saga 对业务侵入较小，只需要提供一个逆向操作的Cancel即可；而TCC需要对业务进行全局性的流程改造；</li>
</ul>
<hr>
<h1 id="【通知型事务】"><a href="#【通知型事务】" class="headerlink" title="【通知型事务】"></a>【通知型事务】</h1><p>上面提到柔性事务主要分为<strong>补偿型</strong>和<strong>通知型</strong>，我们已经介绍了补偿型的TCC，Saga模型，下面继续介绍通知型事务。</p>
<p>通知型事务的主流实现是通过MQ（消息队列）来通知其他事务参与者自己事务的执行状态，MQ组件的引入有效的将事务参与者进行解耦，各参与者都可以异步执行，所以通知型事务又被称为<strong>异步事务</strong>。通知型事务主要适用于那些需要异步更新数据，并且对数据的实时性要求较低的场景，主要包含<strong>事务消息</strong>和<strong>最大努力通知事务</strong>两种。</p>
<p><strong>事务消息</strong>：主要适用于内部系统的数据最终一致性保障，因为内部相对比较可控，如订单和购物车、收货与清算、支付与结算等等场景；</p>
<p><strong>最大努力通知</strong>：主要用于外部系统，因为外部的网络环境更加复杂和不可信，所以只能尽最大努力去通知实现数据最终一致性，比如充值平台与运营商、支付对接等等跨网络系统级别对接；</p>
<p>普通消息是无法解决本地事务执行和消息发送的一致性问题的。因为消息发送是一个网络通信的过程，发送消息的过程就有可能出现发送失败、或者超时的情况。超时有可能发送成功了，有可能发送失败了，消息的发送方是无法确定的，所以此时消息发送方无论是提交事务还是回滚事务，都有可能不一致性出现。因此通知型事务的难点在于投递消息和参与者自身本地事务的一致性保障。目前业界解决这个一致性的方案有两个分支：</p>
<ul>
<li>基于MQ自身的事务消息方案</li>
<li>基于DB的本地消息表方案</li>
</ul>
<h1 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h1><p>本地消息表最初由eBay 提出来解决分布式事务的问题。是目前业界使用的比较多的方案之一，它的核心思想就是将分布式事务<strong>拆分</strong>成本地事务进行处理。</p>
<p><strong>流程</strong></p>
<p><img src="/2022/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1TCC-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/2.png" alt="图片"></p>
<p>发送消息方：</p>
<ul>
<li>需要有一个消息表，记录着消息状态相关信息。</li>
<li>业务数据和消息表在同一个数据库，要保证它俩在同一个本地事务。</li>
<li>在本地事务中处理完业务数据和写消息表操作后，通过写消息到 MQ 消息队列。</li>
<li>消息会发到消息消费方，如果发送失败，即进行重试。</li>
</ul>
<p>消息消费方：</p>
<ul>
<li>处理消息队列中的消息，完成自己的业务逻辑。</li>
<li>如果本地事务处理成功，则表明已经处理成功了。</li>
<li>如果本地事务处理失败，那么就会重试执行。</li>
<li>如果是业务层面的失败，给消息生产方发送一个业务补偿消息，通知进行回滚等操作。</li>
</ul>
<p>生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。如果有靠谱的自动对账补账逻辑，这种方案还是非常实用的。</p>
<p><strong>本地消息表优缺点：</strong></p>
<p>优点：</p>
<ul>
<li>本地消息表建设成本比较低，实现了可靠消息的传递确保了分布式事务的最终一致性。</li>
</ul>
<p>缺点：</p>
<ul>
<li>本地消息表与业务耦合在一起，难于做成通用性，不可独立伸缩。</li>
<li>本地消息表是基于数据库来做的，而数据库是要读写磁盘IO的，因此在高并发下是有性能瓶颈的</li>
</ul>
<h1 id="MQ事务消息"><a href="#MQ事务消息" class="headerlink" title="MQ事务消息"></a>MQ事务消息</h1><p>基于MQ的事务消息方案主要依靠MQ的<strong>半消息机制</strong>来实现投递消息和参与者自身本地事务的一致性保障。半消息机制实现原理其实借鉴的2PC的思路，是二阶段提交的广义拓展。</p>
<blockquote>
<p><strong>半消息</strong>：在原有队列消息执行后的逻辑，如果后面的本地逻辑出错，则不发送该消息，如果通过则告知MQ发送；</p>
</blockquote>
<p><strong>流程</strong></p>
<p><img src="/2022/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1TCC-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/3.png" alt="图片"></p>
<ol>
<li>事务发起方首先发送半消息到MQ；</li>
<li>MQ通知发送方消息发送成功；</li>
<li>在发送半消息成功后执行本地事务；</li>
<li>根据本地事务执行结果返回commit或者是rollback；</li>
<li>如果消息是rollback, MQ将丢弃该消息不投递；如果是commit，MQ将会消息发送给消息订阅方；</li>
<li>订阅方根据消息执行本地事务；</li>
<li>订阅方执行本地事务成功后再从MQ中将该消息标记为已消费；</li>
<li>如果执行本地事务过程中，执行端挂掉，或者超时，MQ服务器端将不停的询问producer来获取事务状态；</li>
<li>Consumer端的消费成功机制有MQ保证；</li>
</ol>
<p><strong>MQ事务消息对比本地消息表</strong></p>
<p>MQ事务消息：</p>
<ul>
<li>需要MQ支持半消息机制或者类似特性，在重复投递上具有比较好的去重处理；</li>
<li>具有比较大的业务侵入性，需要业务方进行改造，提供对应的本地操作成功的回查功能；</li>
</ul>
<p>DB本地消息表：</p>
<ul>
<li>使用了数据库来存储事务消息，降低了对MQ的要求，但是增加了存储成本；</li>
<li>事务消息使用了异步投递，增大了消息重复投递的可能性；</li>
</ul>
<h1 id="最大努力通知"><a href="#最大努力通知" class="headerlink" title="最大努力通知"></a>最大努力通知</h1><p>最大努力通知方案的目标，就是发起通知方通过一定的机制，最大努力将业务处理结果通知到接收方。本质是通过引入<strong>定期校验机制</strong>实现最终一致性，对业务的侵入性较低，适合于对最终一致性敏感度比较低、业务链路较短的场景。</p>
<p><strong>最大努力通知解决方案：</strong>要实现最大努力通知，可以采用 MQ 的 ACK 机制。</p>
<p><img src="/2022/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1TCC-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/4.png" alt="图片"></p>
<ol>
<li>业务活动的主动方，在完成业务处理之后，向业务活动的被动方发送消息，允许消息丢失。</li>
<li>主动方可以设置时间阶梯型通知规则，在通知失败后按规则重复通知，直到通知N次后不再通知。</li>
<li>主动方提供校对查询接口给被动方按需校对查询，用于恢复丢失的业务消息。</li>
<li>业务活动的被动方如果正常接收了数据，就正常返回响应，并结束事务。</li>
<li>如果被动方没有正常接收，根据定时策略，向业务活动主动方查询，恢复丢失的业务消息。</li>
</ol>
<p><strong>特点</strong></p>
<ol>
<li>用到的服务模式：可查询操作、幂等操作；</li>
<li>被动方的处理结果不影响主动方的处理结果；</li>
<li>适用于对业务最终一致性的时间敏感度低的系统；</li>
<li>适合跨企业的系统间的操作，或者企业内部比较独立的系统间的操作，比如银行通知、商户通知等；</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>方案对比：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">2PC</th>
<th align="left">TCC</th>
<th align="left">Saga</th>
<th align="left">本地消息表</th>
<th align="left">事务消息</th>
<th align="left">尽最大努力通知</th>
</tr>
</thead>
<tbody><tr>
<td align="left">事务一致性</td>
<td align="left">强</td>
<td align="left">弱</td>
<td align="left">弱</td>
<td align="left">弱</td>
<td align="left">弱</td>
<td align="left">弱</td>
</tr>
<tr>
<td align="left">复杂性</td>
<td align="left">中</td>
<td align="left">高</td>
<td align="left">中</td>
<td align="left">低</td>
<td align="left">低</td>
<td align="left">低</td>
</tr>
<tr>
<td align="left">业务侵入性</td>
<td align="left">小</td>
<td align="left">大</td>
<td align="left">小</td>
<td align="left">中</td>
<td align="left">中</td>
<td align="left">中</td>
</tr>
<tr>
<td align="left">使用局限性</td>
<td align="left">大</td>
<td align="left">大</td>
<td align="left">中</td>
<td align="left">小</td>
<td align="left">中</td>
<td align="left">中</td>
</tr>
<tr>
<td align="left">性能</td>
<td align="left">低</td>
<td align="left">中</td>
<td align="left">高</td>
<td align="left">高</td>
<td align="left">高</td>
<td align="left">高</td>
</tr>
<tr>
<td align="left">维护成本</td>
<td align="left">低</td>
<td align="left">高</td>
<td align="left">中</td>
<td align="left">低</td>
<td align="left">中</td>
<td align="left">中</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>分布式事务</category>
      </categories>
      <tags>
        <tag>cAP</tag>
        <tag>BASE</tag>
        <tag>分布式事务</tag>
      </tags>
  </entry>
  <entry>
    <title>大话聊DDD</title>
    <url>/2022/10/25/%E5%A4%A7%E8%AF%9D%E8%81%8ADDD/</url>
    <content><![CDATA[<p>p2-大话聊DDD</p>
<div class="pdf-container" data-target="./p2-大白话聊DDD.pdf" data-height="1000px"></div>]]></content>
      <categories>
        <category>DDD领域驱动设计</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>去哪儿网DDD系列公开课</tag>
      </tags>
  </entry>
  <entry>
    <title>战术设计</title>
    <url>/2022/10/25/%E6%88%98%E6%9C%AF%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>p6-战术设计</p>
<div class="pdf-container" data-target="./p6-战术设计.pdf" data-height="1000px"></div>]]></content>
      <categories>
        <category>DDD领域驱动设计</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>去哪儿网DDD系列公开课</tag>
      </tags>
  </entry>
  <entry>
    <title>战略设计</title>
    <url>/2022/10/25/%E6%88%98%E7%95%A5%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>p5-战略设计</p>
<div class="pdf-container" data-target="./p5-战略设计.pdf" data-height="1000px"></div>

]]></content>
      <categories>
        <category>DDD领域驱动设计</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>去哪儿网DDD系列公开课</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-DMA和零拷贝</title>
    <url>/2022/10/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-DMA%E5%92%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>磁盘可以说是计算机系统最慢的硬件之一，读写速度相差内存 10 倍以上，所以针对优化磁盘的技术非常的多，比如零拷贝、直接 I&#x2F;O、异步 I&#x2F;O 等等，这些优化的目的就是为了提高系统的吞吐量，另外操作系统内核中的磁盘高速缓存区，可以有效的减少磁盘的访问次数。</p>
<p>这次，我们就以「文件传输」作为切入点，来分析 I&#x2F;O 工作方式，以及如何优化传输文件的性能。</p>
<p><img src="/2022/10/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-DMA%E5%92%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D/1.png" alt="在这里插入图片描述"></p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="为什么要有-DMA-技术"><a href="#为什么要有-DMA-技术" class="headerlink" title="为什么要有 DMA 技术?"></a>为什么要有 DMA 技术?</h3><p>在没有 DMA 技术前，I&#x2F;O 的过程是这样的：</p>
<ul>
<li>CPU 发出对应的指令给磁盘控制器，然后返回；</li>
<li>磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个<strong>中断</strong>；</li>
<li>CPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的。</li>
</ul>
<p>为了方便你理解，我画了一副图：<br><img src="/2022/10/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-DMA%E5%92%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D/2.png" alt="在这里插入图片描述"></p>
<p>可以看到，整个数据的传输过程，都要需要 CPU 亲自参与搬运数据的过程，而且这个过程，CPU 是不能做其他事情的。</p>
<p>简单的搬运几个字符数据那没问题，但是如果我们用千兆网卡或者硬盘传输大量数据的时候，都用 CPU 来搬运的话，肯定忙不过来。</p>
<p>计算机科学家们发现了事情的严重性后，于是就发明了 DMA 技术，也就是<strong>直接内存访问（Direct Memory Access）</strong> 技术。</p>
<p>什么是 DMA 技术？简单理解就是，<strong>在进行 I&#x2F;O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务</strong>。</p>
<p>那使用 DMA 控制器进行数据传输的过程究竟是什么样的呢？下面我们来具体看看。</p>
<p><img src="/2022/10/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-DMA%E5%92%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D/3.png" alt="在这里插入图片描述"></p>
<p>具体过程：</p>
<ul>
<li>用户进程调用 read 方法，向操作系统发出 I&#x2F;O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态；</li>
<li>操作系统收到请求后，进一步将 I&#x2F;O 请求发送 DMA，然后让 CPU 执行其他任务；</li>
<li>DMA 进一步将 I&#x2F;O 请求发送给磁盘；</li>
<li>磁盘收到 DMA 的 I&#x2F;O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满；</li>
<li><strong>DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务</strong>；</li>
<li>当 DMA 读取了足够多的数据，就会发送中断信号给 CPU；</li>
<li>CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回；</li>
</ul>
<p>可以看到， 整个数据传输的过程，CPU 不再参与数据搬运的工作，而是全程由 DMA 完成，但是 CPU 在这个过程中也是必不可少的，因为传输什么数据，从哪里传输到哪里，都需要 CPU 来告诉 DMA 控制器。</p>
<p>早期 DRM 只存在在主板上，如今由于 I&#x2F;O 设备越来越多，数据传输的需求也不尽相同，所以每个 I&#x2F;O 设备里面都有自己的 DMA 控制器。</p>
<h3 id="传统的文件传输有多糟糕？"><a href="#传统的文件传输有多糟糕？" class="headerlink" title="传统的文件传输有多糟糕？"></a>传统的文件传输有多糟糕？</h3><p>如果服务端要提供文件传输的功能，我们能想到的最简单的方式是：将磁盘上的文件读取出来，然后通过网络协议发送给客户端。</p>
<p>传统 I&#x2F;O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I&#x2F;O 接口从磁盘读取或写入。</p>
<p>代码通常如下，一般会需要两个系统调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read(file, tmp_buf, len);</span><br><span class="line">write(socket, tmp_buf, len);</span><br></pre></td></tr></table></figure>

<p>代码很简单，虽然就两行代码，但是这里面发生了不少的事情。</p>
<p><img src="/2022/10/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-DMA%E5%92%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D/4.png" alt="在这里插入图片描述"></p>
<p>首先，期间共<strong>发生了 4 次用户态与内核态的上下文切换</strong>，因为发生了两次系统调用，一次是 <code>read()</code> ，一次是 <code>write()</code>，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。</p>
<p>上下文切换到成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。</p>
<p>其次，还<strong>发生了 4 次数据拷贝</strong>，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的，下面说一下这个过程：</p>
<ul>
<li><em>第一次拷贝</em>，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。</li>
<li><em>第二次拷贝</em>，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。</li>
<li><em>第三次拷贝</em>，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。</li>
<li><em>第四次拷贝</em>，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。</li>
</ul>
<p>我们回过头看这个文件传输的过程，我们只是搬运一份数据，结果却搬运了 4 次，过多的数据拷贝无疑会消耗 CPU 资源，大大降低了系统性能。</p>
<p>这种简单又传统的文件传输方式，存在冗余的上文切换和数据拷贝，在高并发系统里是非常糟糕的，多了很多不必要的开销，会严重影响系统性能。</p>
<p>所以，<strong>要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数</strong>。</p>
<h3 id="如何优化文件传输的性能？"><a href="#如何优化文件传输的性能？" class="headerlink" title="如何优化文件传输的性能？"></a>如何优化文件传输的性能？</h3><blockquote>
<p>先来看看，如何减少「用户态与内核态的上下文切换」的次数呢？</p>
</blockquote>
<p>读取磁盘数据的时候，之所以要发生上下文切换，这是因为用户空间没有权限操作磁盘或网卡，内核的权限最高，这些操作设备的过程都需要交由操作系统内核来完成，所以一般要通过内核去完成某些任务的时候，就需要使用操作系统提供的系统调用函数。</p>
<p>而一次系统调用必然会发生 2 次上下文切换：首先从用户态切换到内核态，当内核执行完任务后，再切换回用户态交由进程代码执行。</p>
<p>所以，<strong>要想减少上下文切换到次数，就要减少系统调用的次数</strong>。</p>
<blockquote>
<p>再来看看，如何减少「数据拷贝」的次数？</p>
</blockquote>
<p>在前面我们知道了，传统的文件传输方式会历经 4 次数据拷贝，而且这里面，「从内核的读缓冲区拷贝到用户的缓冲区里，再从用户的缓冲区里拷贝到 socket 的缓冲区里」，这个过程是没有必要的。</p>
<p>因为文件传输的应用场景中，在用户空间我们并不会对数据「再加工」，所以数据实际上可以不用搬运到用户空间，因此<strong>用户的缓冲区是没有必要存在的</strong>。</p>
<h3 id="如何实现零拷贝？"><a href="#如何实现零拷贝？" class="headerlink" title="如何实现零拷贝？"></a>如何实现零拷贝？</h3><p>零拷贝技术实现的方式通常有 2 种：</p>
<ul>
<li>mmap + write</li>
<li>sendfile</li>
</ul>
<p>下面就谈一谈，它们是如何减少「上下文切换」和「数据拷贝」的次数。</p>
<h4 id="mmap-write"><a href="#mmap-write" class="headerlink" title="mmap + write"></a>mmap + write</h4><p>在前面我们知道，<code>read()</code> 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 <code>mmap()</code> 替换 <code>read()</code> 系统调用函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buf = mmap(file, len);</span><br><span class="line">write(sockfd, buf, len);</span><br></pre></td></tr></table></figure>

<p><code>mmap()</code> 系统调用函数会直接把内核缓冲区里的数据「<strong>映射</strong>」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。<br><img src="/2022/10/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-DMA%E5%92%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D/5.png" alt="在这里插入图片描述"></p>
<p>具体过程如下：</p>
<ul>
<li>应用进程调用了 <code>mmap()</code> 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核「共享」这个缓冲区；</li>
<li>应用进程再调用 <code>write()</code>，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据；</li>
<li>最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。</li>
</ul>
<p>我们可以得知，通过使用 <code>mmap()</code> 来代替 <code>read()</code>， 可以减少一次数据拷贝的过程。</p>
<p>但这还不是最理想的零拷贝，因为仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次。</p>
<h4 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h4><p>在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 <code>sendfile()</code>，函数形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);</span><br></pre></td></tr></table></figure>

<p>它的前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。</p>
<p>首先，它可以替代前面的 <code>read()</code> 和 <code>write()</code> 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。</p>
<p>其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。如下图：<br><img src="/2022/10/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-DMA%E5%92%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D/6.png" alt="在这里插入图片描述"></p>
<p>但是这还不是真正的零拷贝技术，如果网卡支持 SG-DMA（<em>The Scatter-Gather Direct Memory Access</em>）技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。</p>
<p>你可以在你的 Linux 系统通过下面这个命令，查看网卡是否支持 scatter-gather 特性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ethtool -k eth0 | grep scatter-gather</span><br><span class="line">scatter-gather: on</span><br></pre></td></tr></table></figure>

<p>于是，从 Linux 内核 <code>2.4</code> 版本开始起，对于支持网卡支持 SG-DMA 技术的情况下， <code>sendfile()</code> 系统调用的过程发生了点变化，具体过程如下：</p>
<ul>
<li>第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；</li>
<li>第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；</li>
</ul>
<p>所以，这个过程之中，只进行了 2 次数据拷贝，如下图：</p>
<p><img src="/2022/10/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-DMA%E5%92%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D/7.png" alt="在这里插入图片描述"></p>
<p>这就是所谓的<strong>零拷贝（Zero-copy）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。</strong></p>
<p>零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，<strong>只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。</strong></p>
<p>所以，总体来看，<strong>零拷贝技术可以把文件传输的性能提高至少一倍以上</strong>。</p>
<h4 id="使用零拷贝技术的项目"><a href="#使用零拷贝技术的项目" class="headerlink" title="使用零拷贝技术的项目"></a>使用零拷贝技术的项目</h4><p>事实上，Kafka 这个开源项目，就利用了「零拷贝」技术，从而大幅提升了 I&#x2F;O 的吞吐率，这也是 Kafka 在处理海量数据为什么这么快的原因之一。</p>
<p>如果你追溯 Kafka 文件传输的代码，你会发现，最终它调用了 Java NIO 库里的 <code>transferTo</code>方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Overridepublic </span><br><span class="line">long transferFrom(FileChannel fileChannel, long position, long count) throws IOException &#123; </span><br><span class="line">    return fileChannel.transferTo(position, count, socketChannel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 Linux 系统支持 <code>sendfile()</code> 系统调用，那么 <code>transferTo()</code> 实际上最后就会使用到 <code>sendfile()</code> 系统调用函数。</p>
<p>曾经有大佬专门写过程序测试过，在同样的硬件条件下，传统文件传输和零拷拷贝文件传输的性能差异，你可以看到下面这张测试数据图，使用了零拷贝能够缩短 <code>65%</code> 的时间，大幅度提升了机器传输数据的吞吐量。<br><img src="/2022/10/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-DMA%E5%92%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D/8.png" alt="在这里插入图片描述"></p>
<p><a href="https://developer.ibm.com/articles/j-zerocopy/">https://developer.ibm.com/articles/j-zerocopy/</a></p>
<p>另外，Nginx 也支持零拷贝技术，一般默认是开启零拷贝技术，这样有利于提高文件传输的效率，是否开启零拷贝技术的配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">...</span><br><span class="line">    sendfile on</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sendfile 配置的具体意思: </p>
<ul>
<li>设置为 on 表示，使用零拷贝技术来传输文件：sendfile ，这样只需要 2 次上下文切换，和 2 次数据拷贝。</li>
<li>设置为 off 表示，使用传统的文件传输技术：read + write，这时就需要 4 次上下文切换，和 4 次数据拷贝。</li>
</ul>
<p>当然，要使用 sendfile，Linux 内核版本必须要 2.1 以上的版本。</p>
<h3 id="PageCache-有什么作用？"><a href="#PageCache-有什么作用？" class="headerlink" title="PageCache 有什么作用？"></a>PageCache 有什么作用？</h3><p>回顾前面说道文件传输过程，其中第一步都是先需要先把磁盘文件数据拷贝「内核缓冲区」里，这个「内核缓冲区」实际上是<strong>磁盘高速缓存（PageCache）</strong>。</p>
<p>由于零拷贝使用了 PageCache 技术，可以使得零拷贝进一步提升了性能，我们接下来看看 PageCache 是如何做到这一点的。</p>
<p>读写磁盘相比读写内存的速度慢太多了，所以我们应该想办法把「读写磁盘」替换成「读写内存」。于是，我们会通过 DMA 把磁盘里的数据搬运到内存里，这样就可以用读内存替换读磁盘。</p>
<p>但是，内存空间远比磁盘要小，内存注定只能拷贝磁盘里的一小部分数据。</p>
<p>那问题来了，选择哪些磁盘数据拷贝到内存呢？</p>
<p>我们都知道程序运行的时候，具有「局部性」，所以通常，刚被访问的数据在短时间内再次被访问的概率很高，于是我们可以用 <strong>PageCache 来缓存最近被访问的数据</strong>，当空间不足时淘汰最久未被访问的缓存。</p>
<p>所以，读磁盘数据的时候，优先在 PageCache 找，如果数据存在则可以直接返回；如果没有，则从磁盘中读取，然后缓存 PageCache 中。</p>
<p>还有一点，读取磁盘数据的时候，需要找到数据所在的位置，但是对于机械磁盘来说，就是通过磁头旋转到数据所在的扇区，再开始「顺序」读取数据，但是旋转磁头这个物理动作是非常耗时的，为了降低它的影响，<strong>PageCache 使用了「预读功能」</strong>。</p>
<p>比如，假设 read 方法每次只会读 <code>32 KB</code> 的字节，虽然 read 刚开始只会读 0 ～ 32 KB 的字节，但内核会把其后面的 32～64 KB 也读取到 PageCache，这样后面读取 32～64 KB 的成本就很低，如果在 32～64 KB 淘汰出 PageCache 前，进程读取到它了，收益就非常大。</p>
<p>所以，PageCache 的优点主要是两个：</p>
<ul>
<li>缓存最近被访问的数据；</li>
<li>预读功能；</li>
</ul>
<p>这两个做法，将大大提高读写磁盘的性能。</p>
<p><strong>但是，在传输大文件（GB 级别的文件）的时候，PageCache 会不起作用，那就白白浪费 DRM 多做的一次数据拷贝，造成性能的降低，即使使用了 PageCache 的零拷贝也会损失性能</strong></p>
<p>这是因为如果你有很多 GB 级别文件需要传输，每当用户访问这些大文件的时候，内核就会把它们载入 PageCache 中，于是 PageCache 空间很快被这些大文件占满。</p>
<p>另外，由于文件太大，可能某些部分的文件数据被再次访问的概率比较低，这样就会带来 2 个问题：</p>
<ul>
<li>PageCache 由于长时间被大文件占据，其他「热点」的小文件可能就无法充分使用到 PageCache，于是这样磁盘读写的性能就会下降了；</li>
<li>PageCache 中的大文件数据，由于没有享受到缓存带来的好处，但却耗费 DMA 多拷贝到 PageCache 一次；</li>
</ul>
<p>所以，针对大文件的传输，不应该使用 PageCache，也就是说不应该使用零拷贝技术，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache，这样在高并发的环境下，会带来严重的性能问题。</p>
<h3 id="大文件传输用什么方式实现？"><a href="#大文件传输用什么方式实现？" class="headerlink" title="大文件传输用什么方式实现？"></a>大文件传输用什么方式实现？</h3><p>那针对大文件的传输，我们应该使用什么方式呢？</p>
<p>我们先来看看最初的例子，当调用 read 方法读取文件时，进程实际上会阻塞在 read 方法调用，因为要等待磁盘数据的返回，如下图：</p>
<p><img src="/2022/10/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-DMA%E5%92%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D/9.png" alt="在这里插入图片描述"></p>
<p>具体过程：</p>
<ul>
<li>当调用 read 方法时，会阻塞着，此时内核会向磁盘发起 I&#x2F;O 请求，磁盘收到请求后，便会寻址，当磁盘数据准备好后，就会向内核发起 I&#x2F;O 中断，告知内核磁盘数据已经准备好；</li>
<li>内核收到 I&#x2F;O 中断后，就将数据从磁盘控制器缓冲区拷贝到 PageCache 里；</li>
<li>最后，内核再把 PageCache 中的数据拷贝到用户缓冲区，于是 read 调用就正常返回了。</li>
</ul>
<p>对于阻塞的问题，可以用异步 I&#x2F;O 来解决，它工作方式如下图：</p>
<p><img src="/2022/10/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-DMA%E5%92%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D/10.png" alt="在这里插入图片描述"></p>
<p>它把读操作分为两部分：</p>
<ul>
<li>前半部分，内核向磁盘发起读请求，但是可以<strong>不等待数据就位就可以返回</strong>，于是进程此时可以处理其他任务；</li>
<li>后半部分，当内核将磁盘中的数据拷贝到进程缓冲区后，进程将接收到内核的<strong>通知</strong>，再去处理数据；</li>
</ul>
<p>而且，我们可以发现，异步 I&#x2F;O 并没有涉及到 PageCache，所以使用异步 I&#x2F;O 就意味着要绕开 PageCache。</p>
<p>绕开 PageCache 的 I&#x2F;O 叫直接 I&#x2F;O，使用 PageCache 的 I&#x2F;O 则叫缓存 I&#x2F;O。通常，对于磁盘，异步 I&#x2F;O 只支持直接 I&#x2F;O。</p>
<p>前面也提到，大文件的传输不应该使用 PageCache，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache。</p>
<p>于是，<strong>在高并发的场景下，针对大文件的传输的方式，应该使用「异步 I&#x2F;O + 直接 I&#x2F;O」来替代零拷贝技术</strong>。</p>
<p>直接 I&#x2F;O 应用场景常见的两种：</p>
<ul>
<li>应用程序已经实现了磁盘数据的缓存，那么可以不需要 PageCache 再次缓存，减少额外的性能损耗。在 MySQL 数据库中，可以通过参数设置开启直接 I&#x2F;O，默认是不开启；</li>
<li>传输大文件的时候，由于大文件难以命中 PageCache 缓存，而且会占满 PageCache 导致「热点」文件无法充分利用缓存，从而增大了性能开销，因此，这时应该使用直接 I&#x2F;O。</li>
</ul>
<p>另外，由于直接 I&#x2F;O 绕过了 PageCache，就无法享受内核的这两点的优化：</p>
<ul>
<li>内核的 I&#x2F;O 调度算法会缓存尽可能多的 I&#x2F;O 请求在 PageCache 中，最后「<strong>合并</strong>」成一个更大的 I&#x2F;O 请求再发给磁盘，这样做是为了减少磁盘的寻址操作；</li>
<li>内核也会「<strong>预读</strong>」后续的 I&#x2F;O 请求放在 PageCache 中，一样是为了减少对磁盘的操作；</li>
</ul>
<p>于是，传输大文件的时候，使用「异步 I&#x2F;O + 直接 I&#x2F;O」了，就可以无阻塞地读取文件了。</p>
<p>所以，传输文件的时候，我们要根据文件的大小来使用不同的方式：</p>
<ul>
<li>传输大文件的时候，使用「异步 I&#x2F;O + 直接 I&#x2F;O」；</li>
<li>传输小文件的时候，则使用「零拷贝技术」；</li>
</ul>
<p>在 nginx 中，我们可以用如下配置，来根据文件的大小来使用不同的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /video/ &#123; </span><br><span class="line">    sendfile on; </span><br><span class="line">    aio on; </span><br><span class="line">    directio 1024m; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当文件大小大于 <code>directio</code> 值后，使用「异步 I&#x2F;O + 直接 I&#x2F;O」，否则使用「零拷贝技术」。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>早期 I&#x2F;O 操作，内存与磁盘的数据传输的工作都是由 CPU 完成的，而此时 CPU 不能执行其他任务，会特别浪费 CPU 资源。</p>
<p>于是，为了解决这一问题，DMA 技术就出现了，每个 I&#x2F;O 设备都有自己的 DMA 控制器，通过这个 DMA 控制器，CPU 只需要告诉 DMA 控制器，我们要传输什么数据，从哪里来，到哪里去，就可以放心离开了。后续的实际数据传输工作，都会由 DMA 控制器来完成，CPU 不需要参与数据传输的工作。</p>
<p>传统 IO 的工作方式，从硬盘读取数据，然后再通过网卡向外发送，我们需要进行 4 上下文切换，和 4 次数据拷贝，其中 2 次数据拷贝发生在内存里的缓冲区和对应的硬件设备之间，这个是由 DMA 完成，另外 2 次则发生在内核态和用户态之间，这个数据搬移工作是由 CPU 完成的。</p>
<p>为了提高文件传输的性能，于是就出现了零拷贝技术，它通过一次系统调用（<code>sendfile</code> 方法）合并了磁盘读取与网络发送两个操作，降低了上下文切换次数。另外，拷贝数据都是发生在内核中的，天然就降低了数据拷贝的次数。</p>
<p>Kafka 和 Nginx 都有实现零拷贝技术，这将大大提高文件传输的性能。</p>
<p>零拷贝技术是基于 PageCache 的，PageCache 会缓存最近访问的数据，提升了访问缓存数据的性能，同时，为了解决机械硬盘寻址慢的问题，它还协助 I&#x2F;O 调度算法实现了 IO 合并与预读，这也是顺序读比随机读性能好的原因。这些优势，进一步提升了零拷贝的性能。</p>
<p>需要注意的是，零拷贝技术是不允许进程对文件内容作进一步的加工的，比如压缩数据再发送。</p>
<p>另外，当传输大文件时，不能使用零拷贝，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache，并且大文件的缓存命中率不高，这时就需要使用「异步 IO + 直接 IO 」的方式。</p>
<p>在 Nginx 里，可以通过配置，设定一个文件大小阈值，针对大文件使用异步 IO 和直接 IO，而对小文件使用零拷贝。</p>
<h1 id="Buffer-Cache和Page-Cache"><a href="#Buffer-Cache和Page-Cache" class="headerlink" title="Buffer Cache和Page Cache"></a>Buffer Cache和Page Cache</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>如高速缓存（cache）产生的原理类似，在I&#x2F;O过程中，读取磁盘的速度相对内存读取速度要慢的多。因此为了能够加快处理数据的速度，需要将读取过的数据缓存在内存里。而这些缓存在内存里的数据就是高速缓冲区（buffer cache），下面简称为“buffer”。</p>
<p>具体来说，buffer（缓冲区）是一个用于存储速度不同步的设备或优先级不同的设备之间传输数据的区域。一方面，通过缓冲区，可以使进程之间的相互等待变少，从而使从速度慢的设备读入数据时，速度快的设备的操作进程不发生间断。另一方面，可以保护硬盘或减少网络传输的次数。</p>
<h3 id="Buffer和Cache"><a href="#Buffer和Cache" class="headerlink" title="Buffer和Cache"></a>Buffer和Cache</h3><p>buffer和cache是两个不同的概念：cache是高速缓存，用于CPU和内存之间的缓冲；buffer是I&#x2F;O缓存，用于内存和硬盘的缓冲；简单的说，cache是加速“读”，而buffer是缓冲“写”，前者解决读的问题，保存从磁盘上读出的数据，后者是解决写的问题，保存即将要写入到磁盘上的数据。</p>
<h3 id="Buffer-Cache和-Page-Cache"><a href="#Buffer-Cache和-Page-Cache" class="headerlink" title="Buffer Cache和 Page Cache"></a>Buffer Cache和 Page Cache</h3><p>buffer cache和page cache都是为了处理设备和内存交互时高速访问的问题。buffer cache可称为块缓冲器，page cache可称为页缓冲器。在linux不支持虚拟内存机制之前，还没有页的概念，因此缓冲区以块为单位对设备进行。在linux采用虚拟内存的机制来管理内存后，页是虚拟内存管理的最小单位，开始采用页缓冲的机制来缓冲内存。Linux2.6之后内核将这两个缓存整合，页和块可以相互映射，同时，页缓存page cache面向的是虚拟内存，块I&#x2F;O缓存Buffer cache是面向块设备。需要强调的是，页缓存和块缓存对进程来说就是一个存储系统，进程不需要关注底层的设备的读写。</p>
<p>buffer cache和page cache两者最大的区别是缓存的粒度。buffer cache面向的是文件系统的块。而内核的内存管理组件采用了比文件系统的块更高级别的抽象：页page，其处理的性能更高。因此和内存管理交互的缓存组件，都使用页缓存。</p>
<ol>
<li><p>page cache确实是内核空间.page cache,”页高速缓存”,用来缓存在存储在慢速硬盘中文件的数据。<br>也就是说它是相对于文件而言,而不是进程而言. 文件在文件系统中通过inode来描述,<br>文件可以通过inode-&gt;i_mapping（address_space描述的是page cache）来得到Page cache.<br>进程打开文件: –&gt;file descripter—-&gt;file —–&gt; inode, 不管有多少个进程打开(open)同一个文件,最终都是会访问同一个inode的,不同的是fd和file.<br>不同进程看到同一个文件的page cache是一样的. 至于大小,这是可变的.address_sspace通过一个radix tree来管理page cache中的物理页。这棵树是可以变化的</p>
</li>
<li><p>write的操作不一定会触发实际的IO.通常你write的时候,数据从用户空间缓存在内核空间的page cache中,然后标记这个页是脏页,然后就直接返回了,所以有时候write比read<br>  的动作要快..</p>
</li>
</ol>
<p>  实际写入到硬盘中的动作交由特定的内核线程bdflush来完成.内核线程会遍历所有文件的page cache,找到所有的脏页逐一进行IO,这是才实际更新硬盘中文件的数据.</p>
<p>pagecache肯定在内核态，大小不限(新版本内核可以限制)，只要有空闲内存，就会尽量将其用作cache，在free命令中可以看到cache的实际用量。</p>
<p>write时，如果数据不拷贝到内核空间，就无法将其写入存储设备了。(当然专用的零拷贝方案除外~)</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>DMA</tag>
        <tag>零拷贝</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-IO多路复用</title>
    <url>/2022/10/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<p>为了讲多路复用，当然还是要跟风，采用鞭尸的思路，先讲讲传统的网络 IO 的弊端，用拉踩的方式捧起多路复用 IO 的优势。</p>
<p>为了方便理解，以下所有代码都是伪代码，知道其表达的意思即可。</p>
<p><strong>Let’s go</strong></p>
<h1 id="阻塞-IO"><a href="#阻塞-IO" class="headerlink" title="阻塞 IO"></a>阻塞 IO</h1><p>服务端为了处理客户端的连接和请求的数据，写了如下代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">listenfd = socket();   <span class="comment">// 打开一个网络通信端口</span></span><br><span class="line">bind(listenfd);        <span class="comment">// 绑定</span></span><br><span class="line">listen(listenfd);      <span class="comment">// 监听</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  connfd = accept(listenfd);  <span class="comment">// 阻塞建立连接</span></span><br><span class="line">  <span class="type">int</span> n = read(connfd, buf);  <span class="comment">// 阻塞读数据</span></span><br><span class="line">  doSomeThing(buf);  <span class="comment">// 利用读到的数据做些什么</span></span><br><span class="line">  close(connfd);     <span class="comment">// 关闭连接，循环等待下一个连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码会执行得磕磕绊绊，就像这样。</p>
<p><img src="/2022/10/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/1.gif" alt="在这里插入图片描述"></p>
<p>可以看到，服务端的线程阻塞在了两个地方，一个是 accept 函数，一个是 read 函数。</p>
<p>如果再把 read 函数的细节展开，我们会发现其阻塞在了两个阶段。<br><img src="/2022/10/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/2.gif" alt="在这里插入图片描述"></p>
<p>这就是传统的阻塞 IO。</p>
<p>整体流程如下图。<br><img src="/2022/10/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/3.png" alt="在这里插入图片描述"></p>
<p>所以，如果这个连接的客户端一直不发数据，那么服务端线程将会一直阻塞在 read 函数上不返回，也无法接受其他客户端连接。</p>
<p>这肯定是不行的。</p>
<h1 id="非阻塞-IO"><a href="#非阻塞-IO" class="headerlink" title="非阻塞 IO"></a>非阻塞 IO</h1><p>为了解决上面的问题，其关键在于改造这个 read 函数。</p>
<p>有一种聪明的办法是，每次都创建一个新的进程或线程，去调用 read 函数，并做业务处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  connfd = accept(listenfd);  <span class="comment">// 阻塞建立连接</span></span><br><span class="line">  pthread_create（doWork);  <span class="comment">// 创建一个新的线程</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">doWork</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> n = read(connfd, buf);  <span class="comment">// 阻塞读数据</span></span><br><span class="line">  doSomeThing(buf);  <span class="comment">// 利用读到的数据做些什么</span></span><br><span class="line">  close(connfd);     <span class="comment">// 关闭连接，循环等待下一个连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，当给一个客户端建立好连接后，就可以立刻等待新的客户端连接，而不用阻塞在原客户端的 read 请求上。</p>
<p><img src="/2022/10/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/4.gif" alt="在这里插入图片描述"></p>
<p>不过，这不叫非阻塞 IO，只不过用了多线程的手段使得主线程没有卡在 read 函数上不往下走罢了。操作系统为我们提供的 read 函数仍然是阻塞的。</p>
<p>所以真正的非阻塞 IO，不能是通过我们用户层的小把戏，而是要恳请操作系统为我们提供一个非阻塞的 read 函数。</p>
<p>这个 read 函数的效果是，如果没有数据到达时（到达网卡并拷贝到了内核缓冲区），立刻返回一个错误值（-1），而不是阻塞地等待。</p>
<p>操作系统提供了这样的功能，只需要在调用 read 前，将文件描述符设置为非阻塞即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fcntl(connfd, F_SETFL, O_NONBLOCK);</span><br><span class="line"><span class="type">int</span> n = read(connfd, buffer) != SUCCESS);</span><br></pre></td></tr></table></figure>

<p>这样，就需要用户线程循环调用 read，直到返回值不为 -1，再开始处理业务。</p>
<p><img src="/2022/10/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/5.gif" alt="在这里插入图片描述"></p>
<p>这里我们注意到一个细节。</p>
<p>非阻塞的 read，指的是在数据到达前，即数据还未到达网卡，或者到达网卡但还没有拷贝到内核缓冲区之前，这个阶段是非阻塞的。</p>
<p>当数据已到达内核缓冲区，此时调用 read 函数仍然是阻塞的，需要等待数据从内核缓冲区拷贝到用户缓冲区，才能返回。</p>
<p>整体流程如下图</p>
<p><img src="/2022/10/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/6.png" alt="在这里插入图片描述"></p>
<h1 id="IO-多路复用"><a href="#IO-多路复用" class="headerlink" title="IO 多路复用"></a>IO 多路复用</h1><p>为每个客户端创建一个线程，服务器端的线程资源很容易被耗光。</p>
<p><img src="/2022/10/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/8.png" alt="在这里插入图片描述"></p>
<p>当然还有个聪明的办法，我们可以每 accept 一个客户端连接后，将这个文件描述符（connfd）放到一个数组里。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fdlist.add(connfd);</span><br></pre></td></tr></table></figure>

<p>然后弄一个新的线程去不断遍历这个数组，调用每一个元素的非阻塞 read 方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span>(fd &lt;-- fdlist) &#123;</span><br><span class="line">    <span class="keyword">if</span>(read(fd) != <span class="number">-1</span>) &#123;</span><br><span class="line">      doSomeThing();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就成功用一个线程处理了多个客户端连接。<br><img src="/2022/10/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/9.gif" alt="在这里插入图片描述"></p>
<p>你是不是觉得这有些多路复用的意思？</p>
<p>但这和我们用多线程去将阻塞 IO 改造成看起来是非阻塞 IO 一样，这种遍历方式也只是我们用户自己想出的小把戏，每次遍历遇到 read 返回 -1 时仍然是一次浪费资源的系统调用。</p>
<p>在 while 循环里做系统调用，就好比你做分布式项目时在 while 里做 rpc 请求一样，是不划算的。</p>
<p>所以，还是得恳请操作系统老大，提供给我们一个有这样效果的函数，我们将一批文件描述符通过一次系统调用传给内核，由内核层去遍历，才能真正解决这个问题。</p>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>select 是操作系统提供的系统调用函数，通过它，我们可以把一个文件描述符的数组发给操作系统， 让操作系统去遍历，确定哪个文件描述符可以读写， 然后告诉我们去处理：<br><img src="/2022/10/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/10.gif" alt="在这里插入图片描述"></p>
<p>select系统调用的函数定义如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> nfds,</span></span><br><span class="line"><span class="params">    fd_set *readfds,</span></span><br><span class="line"><span class="params">    fd_set *writefds,</span></span><br><span class="line"><span class="params">    fd_set *exceptfds,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> timeval *timeout)</span>;</span><br><span class="line"><span class="comment">// nfds:监控的文件描述符集里最大文件描述符加1</span></span><br><span class="line"><span class="comment">// readfds：监控有读数据到达文件描述符集合，传入传出参数</span></span><br><span class="line"><span class="comment">// writefds：监控写数据到达文件描述符集合，传入传出参数</span></span><br><span class="line"><span class="comment">// exceptfds：监控异常发生达文件描述符集合, 传入传出参数</span></span><br><span class="line"><span class="comment">// timeout：定时阻塞监控时间，3种情况</span></span><br><span class="line"><span class="comment">//  1.NULL，永远等下去</span></span><br><span class="line"><span class="comment">//  2.设置timeval，等待固定时间</span></span><br><span class="line"><span class="comment">//  3.设置timeval里时间均为0，检查描述字后立即返回，轮询</span></span><br></pre></td></tr></table></figure>

<p>服务端代码，这样来写。</p>
<p>首先一个线程不断接受客户端连接，并把 socket 文件描述符放到一个 list 里。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  connfd = accept(listenfd);</span><br><span class="line">  fcntl(connfd, F_SETFL, O_NONBLOCK);</span><br><span class="line">  fdlist.add(connfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，另一个线程不再自己遍历，而是调用 select，将这批文件描述符 list 交给操作系统去遍历。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// 把一堆文件描述符 list 传给 select 函数</span></span><br><span class="line">  <span class="comment">// 有已就绪的文件描述符就返回，nready 表示有多少个就绪的</span></span><br><span class="line">  nready = select(<span class="built_in">list</span>);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，当 select 函数返回后，用户依然需要遍历刚刚提交给操作系统的 list。</p>
<p>只不过，操作系统会将准备就绪的文件描述符做上标识，用户层将不会再有无意义的系统调用开销。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  nready = select(<span class="built_in">list</span>);</span><br><span class="line">  <span class="comment">// 用户层依然要遍历，只不过少了很多无效的系统调用</span></span><br><span class="line">  <span class="keyword">for</span>(fd &lt;-- fdlist) &#123;</span><br><span class="line">    <span class="keyword">if</span>(fd != <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="comment">// 只读已就绪的文件描述符</span></span><br><span class="line">      read(fd, buf);</span><br><span class="line">      <span class="comment">// 总共只有 nready 个已就绪描述符，不用过多遍历</span></span><br><span class="line">      <span class="keyword">if</span>(--nready == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如刚刚的动图中所描述的，其直观效果如下。（同一个动图消耗了你两次流量，气不气？）</p>
<p><img src="/2022/10/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/11.gif" alt="在这里插入图片描述"></p>
<p>可以看出几个细节：</p>
<ol>
<li>select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）</li>
<li>select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）</li>
<li>select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）<br>整个 select 的流程图如下。</li>
</ol>
<p><img src="/2022/10/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/12.png" alt="在这里插入图片描述"></p>
<p>可以看到，这种方式，既做到了一个线程处理多个客户端连接（文件描述符），又减少了系统调用的开销（多个文件描述符只有一次 select 的系统调用 + n 次就绪状态的文件描述符的 read 系统调用）。</p>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>poll 也是操作系统提供的系统调用函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, nfds_tnfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">  intfd; <span class="comment">/*文件描述符*/</span></span><br><span class="line">  shortevents; <span class="comment">/*监控的事件*/</span></span><br><span class="line">  shortrevents; <span class="comment">/*监控事件中满足条件返回的事件*/</span></span><br><span class="line">&#125;;</span><br><span class="line">它和 select 的主要区别就是，去掉了 select 只能监听 <span class="number">1024</span> 个文件描述符的限制。</span><br></pre></td></tr></table></figure>


<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll 是最终的大 boss，它解决了 select 和 poll 的一些问题。</p>
<p>还记得上面说的 select 的三个细节么？</p>
<ol>
<li>select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）</li>
<li>select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）</li>
<li>select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）</li>
</ol>
<p>所以 epoll 主要就是针对这三点进行了改进。</p>
<ol>
<li>内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可。</li>
<li>内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。</li>
<li>内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。<br>具体，操作系统提供了这三个函数。</li>
</ol>
<p>第一步，创建一个 epoll 句柄</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int epoll_create(int size);</span><br></pre></td></tr></table></figure>

<p>第二步，向内核添加、修改或删除要监控的文件描述符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br></pre></td></tr></table></figure>

<p>第三步，类似发起了 select() 调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> max events, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>

<p>使用起来，其内部原理就像如下一般丝滑。<br><img src="/2022/10/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/13.gif" alt="在这里插入图片描述"></p>
<p>如果你想继续深入了解 epoll 的底层原理，推荐阅读飞哥的《图解 | 深入揭秘 epoll 是如何实现 IO 多路复用的！》，从 linux 源码级别，一行一行非常硬核地解读 epoll 的实现原理，且配有大量方便理解的图片，非常适合源码控的小伙伴阅读。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>大白话总结一下。<br>一切的开始，都起源于这个 read 函数是操作系统提供的，而且是阻塞的，我们叫它 阻塞 IO。<br>为了破这个局，程序员在用户态通过多线程来防止主线程卡死。<br>后来操作系统发现这个需求比较大，于是在操作系统层面提供了非阻塞的 read 函数，这样程序员就可以在一个线程内完成多个文件描述符的读取，这就是 非阻塞 IO。<br>但多个文件描述符的读取就需要遍历，当高并发场景越来越多时，用户态遍历的文件描述符也越来越多，相当于在 while 循环里进行了越来越多的系统调用。<br>后来操作系统又发现这个场景需求量较大，于是又在操作系统层面提供了这样的遍历文件描述符的机制，这就是 IO 多路复用。<br>多路复用有三个函数，最开始是 select，然后又发明了 poll 解决了 select 文件描述符的限制，然后又发明了 epoll 解决 select 的三个不足。<br>所以，IO 模型的演进，其实就是时代的变化，倒逼着操作系统将更多的功能加到自己的内核而已。<br>如果你建立了这样的思维，很容易发现网上的一些错误。<br>比如好多文章说，多路复用之所以效率高，是因为用一个线程就可以监控多个文件描述符。<br>这显然是知其然而不知其所以然，多路复用产生的效果，完全可以由用户态去遍历文件描述符并调用其非阻塞的 read 函数实现。而多路复用快的原因在于，操作系统提供了这样的系统调用，使得原来的 while 循环里多次系统调用，变成了一次系统调用 + 内核层遍历这些文件描述符。<br>就好比我们平时写业务代码，把原来 while 循环里调 http 接口进行批量，改成了让对方提供一个批量添加的 http 接口，然后我们一次 rpc 请求就完成了批量添加。<br>一个道理。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>多路复用</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-图解系统</title>
    <url>/2022/10/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>图解系统</p>
<div class="pdf-container" data-target="./图解系统.pdf" data-height="1000px"></div>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>多路复用</tag>
      </tags>
  </entry>
  <entry>
    <title>方舟DDD实践下</title>
    <url>/2022/10/25/%E6%96%B9%E8%88%9FDDD%E5%AE%9E%E8%B7%B5%E4%B8%8B/</url>
    <content><![CDATA[<p>p4-方舟DDD实践（下）</p>
<div class="pdf-container" data-target="./p4-方舟DDD实践下.pdf" data-height="1000px"></div>]]></content>
      <categories>
        <category>DDD领域驱动设计</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>去哪儿网DDD系列公开课</tag>
      </tags>
  </entry>
  <entry>
    <title>方舟DDD实践上</title>
    <url>/2022/10/25/%E6%96%B9%E8%88%9FDDD%E5%AE%9E%E8%B7%B5%E4%B8%8A/</url>
    <content><![CDATA[<p>p3-方舟DDD实践（上）</p>
<div class="pdf-container" data-target="./p3-方舟DDD实践上.pdf" data-height="1000px"></div>]]></content>
      <categories>
        <category>DDD领域驱动设计</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>去哪儿网DDD系列公开课</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈命令查询职责分离CQRS模式</title>
    <url>/2022/10/24/%E6%B5%85%E8%B0%88%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2%E8%81%8C%E8%B4%A3%E5%88%86%E7%A6%BBCQRS%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="浅谈命令查询职责分离-CQRS-模式"><a href="#浅谈命令查询职责分离-CQRS-模式" class="headerlink" title="浅谈命令查询职责分离(CQRS)模式"></a>浅谈命令查询职责分离(CQRS)模式</h1><p>在常用的三层架构中，通常都是通过数据访问层来修改或者查询数据，一般修改和查询使用的是相同的实体。在一些业务逻辑简单的系统中可能没有什么问题，但是随着系统逻辑变得复杂，用户增多，这种设计就会出现一些性能问题。虽然在DB上可以做一些读写分离的设计，但在业务上如果在读写方面混合在一起的话，仍然会出现一些问题。</p>
<p>本文介绍了命令查询职责分离模式(Command Query Responsibility Segregation，CQRS)，该模式从业务上分离修改 (Command，增，删，改，会对系统状态进行修改)和查询（Query，查，不会对系统状态进行修改)的行为。从而使得逻辑更加清晰，便于对不同部分进行针对性的优化。文章首先简要介绍了传统的CRUD方式存在的问题，接着介绍了CQRS模式，最后以一个简单的在线日记系统演示了如何实现CQRS模式。要谈到读写操作，首先我们来看传统的CRUD的问题。</p>
<h1 id="一-CRUD方式的问题"><a href="#一-CRUD方式的问题" class="headerlink" title="一 CRUD方式的问题"></a>一 CRUD方式的问题</h1><p>在以前的管理系统中，命令(Command，通常用来更新数据，操作DB)和查询(Query)通常使用的是在数据访问层中Repository中的实体对象(这些对象是对DB中表的映射)，这些实体有可能是SQLServer中的一行数据或者多个表。</p>
<p>通常对DB执行的增，删，改，查（CRUD）都是针对的系统的实体对象。如通过数据访问层获取数据，然后通过数据传输对象DTO传给表现层。或者，用户需要更新数据，通过DTO对象将数据传给Model，然后通过数据访问层写回数据库，系统中的所有交互都是和数据查询和存储有关，可以认为是数据驱动（<a href="http://en.wikipedia.org/wiki/Data-driven_programming">Data-Driven</a>）的，如下图：</p>
<p> <a href="http://images.cnitblog.com/blog/94031/201408/261851410161370.png"><img src="/2022/10/24/%E6%B5%85%E8%B0%88%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2%E8%81%8C%E8%B4%A3%E5%88%86%E7%A6%BBCQRS%E6%A8%A1%E5%BC%8F/1.png" alt="Traditional CRUD Architecture"></a></p>
<p>对于一些比较简单的系统，使用这种CRUD的设计方式能够满足要求。特别是通过一些代码生成工具及ORM等能够非常方便快速的实现功能。</p>
<p>但是传统的<a href="http://msdn.microsoft.com/en-us/library/ms978509.aspx">CRUD方法有一些问题</a>：</p>
<ul>
<li>使用同一个对象实体来进行数据库读写可能会太粗糙，大多数情况下，比如编辑的时候可能只需要更新个别字段，但是却需要将整个对象都穿进去，有些字段其实是不需要更新的。在查询的时候在表现层可能只需要个别字段，但是需要查询和返回整个实体对象。</li>
<li>使用同一实体对象对同一数据进行读写操作的时候，可能会遇到资源竞争的情况，经常要处理的锁的问题，在写入数据的时候，需要加锁。读取数据的时候需要判断是否允许脏读。这样使得系统的逻辑性和复杂性增加，并且会对系统吞吐量的增长会产生影响。</li>
<li>同步的，直接与数据库进行交互在大数据量同时访问的情况下可能会影响性能和响应性，并且可能会产生性能瓶颈。</li>
<li>由于同一实体对象都会在读写操作中用到，所以对于安全和权限的管理会变得比较复杂。</li>
</ul>
<p>这里面很重要的一个问题是，系统中的读写频率比，是偏向读，还是偏向写，就如同一般的数据结构在查找和修改上时间复杂度不一样，在设计系统的结构时也需要考虑这样的问题。解决方法就是我们经常用到的对数据库进行读写分离。 让主数据库处理事务性的增，删，改操作(Insert,Update,Delete)操作，让从数据库处理查询操作(Select操作)，数据库复制被用来将事务性操作导致的变更同步到集群中的从数据库。这只是从DB角度处理了读写分离，但是从业务或者系统上面读和写仍然是存放在一起的。他们都是用的同一个实体对象。</p>
<p>要从业务上将读和写分离，就是接下来要介绍的命令查询职责分离模式。</p>
<h1 id="二-什么是CQRS"><a href="#二-什么是CQRS" class="headerlink" title="二 什么是CQRS"></a>二 什么是CQRS</h1><p>CQRS最早来自于Betrand Meyer（Eiffel语言之父，<a href="http://msdn.microsoft.com/en-us/magazine/cc546578.aspx">开-闭原则</a>OCP提出者）在 <a href="http://www.amazon.com/gp/product/0136291554">Object-Oriented Software Construction</a> 这本书中提到的一种 <a href="http://martinfowler.com/bliki/CommandQuerySeparation.html">命令查询分离</a> (<a href="http://en.wikipedia.org/wiki/Command-query_separation">Command Query Separation</a>,CQS) 的概念。其基本思想在于，任何一个对象的方法可以分为两大类：</p>
<ul>
<li>命令(Command):不返回任何结果(void)，但会改变对象的状态。</li>
<li>查询(Query):返回结果，但是不会改变对象的状态，对系统没有副作用。</li>
</ul>
<p>根据CQS的思想，任何一个方法都可以拆分为命令和查询两部分，比如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">int</span> <span class="title">Increase</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    i += <span class="keyword">value</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法，我们执行了一个命令即对变量i进行相加，同时又执行了一个Query，即查询返回了i的值，如果按照CQS的思想，该方法可以拆成Command和Query两个方法，如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">IncreaseCommand</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    i += <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">int</span> <span class="title">QueryValue</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>操作和查询分离使得我们能够更好的把握对象的细节，能够更好的理解哪些操作会改变系统的状态。当然<a href="http://en.wikipedia.org/wiki/Command-query_separation">CQS</a>也有一些缺点，比如代码需要处理多线程的情况。</p>
<p>CQRS是对CQS模式的进一步改进成的一种简单模式。 它由Greg Young在<a href="http://codebetter.com/gregyoung/2010/02/16/cqrs-task-based-uis-event-sourcing-agh/">CQRS, Task Based UIs, Event Sourcing agh!</a> 这篇文章中提出。“CQRS只是简单的将之前只需要创建一个对象拆分成了两个对象，这种分离是基于方法是执行命令还是执行查询这一原则来定的(这个和CQS的定义一致)”。</p>
<p>CQRS使用分离的接口将数据查询操作(Queries)和数据修改操作(Commands)分离开来，这也意味着在查询和更新过程中使用的数据模型也是不一样的。这样读和写逻辑就隔离开来了。</p>
<p><a href="http://images.cnitblog.com/blog/94031/201408/261851415951714.png"><img src="/2022/10/24/%E6%B5%85%E8%B0%88%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2%E8%81%8C%E8%B4%A3%E5%88%86%E7%A6%BBCQRS%E6%A8%A1%E5%BC%8F/2.png" alt="A basic CQRS architecture"></a></p>
<p>使用CQRS分离了读写职责之后，可以对数据进行读写分离操作来改进性能，可扩展性和安全。如下图：</p>
<p><a href="http://images.cnitblog.com/blog/94031/201408/261851421105570.png"><img src="/2022/10/24/%E6%B5%85%E8%B0%88%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2%E8%81%8C%E8%B4%A3%E5%88%86%E7%A6%BBCQRS%E6%A8%A1%E5%BC%8F/3.png" alt="A CQRS architecture with separate read and write stores"></a></p>
<p>主数据库处理CUD，从库处理R，从库的的结构可以和主库的结构完全一样，也可以不一样，从库主要用来进行只读的查询操作。在数量上从库的个数也可以根据查询的规模进行扩展，在业务逻辑上，也可以根据专题从主库中划分出不同的从库。从库也可以实现成<a href="http://martinfowler.com/bliki/ReportingDatabase.html">ReportingDatabase</a>，根据查询的业务需求，从主库中抽取一些必要的数据生成一系列查询报表来存储。</p>
<p><a href="http://images.cnitblog.com/blog/94031/201408/261851428451429.png"><img src="/2022/10/24/%E6%B5%85%E8%B0%88%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2%E8%81%8C%E8%B4%A3%E5%88%86%E7%A6%BBCQRS%E6%A8%A1%E5%BC%8F/4.png" alt="reportingDatabase"></a></p>
<p>使用ReportingDatabase的一些优点通常可以使得查询变得更加简单高效：</p>
<ul>
<li>ReportingDatabase的结构和数据表会针对常用的查询请求进行设计。</li>
<li>ReportingDatabase数据库通常会去正规化，存储一些冗余而减少必要的Join等联合查询操作，使得查询简化和高效，一些在主数据库中用不到的数据信息，在ReportingDatabase可以不用存储。</li>
<li>可以对ReportingDatabase重构优化，而不用去改变操作数据库。</li>
<li>对ReportingDatabase数据库的查询不会给操作数据库带来任何压力。</li>
<li>可以针对不同的查询请求建立不同的ReportingDatabase库。</li>
</ul>
<p>当然这也有一些缺点，比如从库数据的更新。如果使用SQLServer，本身也提供了一些如故障转移和复制机制来方便部署。</p>
<h1 id="三-什么时候可以考虑CQRS"><a href="#三-什么时候可以考虑CQRS" class="headerlink" title="三 什么时候可以考虑CQRS"></a>三 什么时候可以考虑CQRS</h1><p>CQRS模式有一些优点：</p>
<ol>
<li>分工明确，可以负责不同的部分</li>
<li>将业务上的命令和查询的职责分离能够提高系统的性能、可扩展性和安全性。并且在系统的演化中能够保持高度的灵活性，能够防止出现CRUD模式中，对查询或者修改中的某一方进行改动，导致另一方出现问题的情况。</li>
<li>逻辑清晰，能够看到系统中的那些行为或者操作导致了系统的状态变化。</li>
<li>可以从数据驱动(Data-Driven) 转到任务驱动(Task-Driven)以及事件驱动(<a href="http://en.wikipedia.org/wiki/Event-driven_programming">Event-Driven</a>).</li>
</ol>
<p>在下场景中，可以考虑使用CQRS模式：</p>
<ol>
<li>当在业务逻辑层有很多操作需要相同的实体或者对象进行操作的时候。CQRS使得我们可以对读和写定义不同的实体和方法，从而可以减少或者避免对某一方面的更改造成冲突</li>
<li>对于一些基于任务的用户交互系统，通常这类系统会引导用户通过一系列复杂的步骤和操作，通常会需要一些复杂的领域模型，并且整个团队已经熟悉领域驱动设计技术。写模型有很多和业务逻辑相关的命令操作的堆，输入验证，业务逻辑验证来保证数据的一致性。读模型没有业务逻辑以及验证堆，仅仅是返回DTO对象为视图模型提供数据。读模型最终和写模型相一致。</li>
<li>适用于一些需要对查询性能和写入性能分开进行优化的系统，尤其是读&#x2F;写比非常高的系统，横向扩展是必须的。比如，在很多系统中读操作的请求时远大于写操作。为适应这种场景，可以考虑将写模型抽离出来单独扩展，而将写模型运行在一个或者少数几个实例上。少量的写模型实例能够减少合并冲突发生的情况</li>
<li>适用于一些团队中，一些有经验的开发者可以关注复杂的领域模型，这些用到写操作，而另一些经验较少的开发者可以关注用户界面上的读模型。</li>
<li>对于系统在将来会随着时间不段演化，有可能会包含不同版本的模型，或者业务规则经常变化的系统</li>
<li>需要和其他系统整合，特别是需要和事件溯源Event Sourcing进行整合的系统，这样子系统的临时异常不会影响整个系统的其他部分。</li>
</ol>
<p>但是在以下场景中，可能不适宜使用CQRS：</p>
<ol>
<li>领域模型或者业务逻辑比较简单，这种情况下使用CQRS会把系统搞复杂。</li>
<li>对于简单的，CRUD模式的用户界面以及与之相关的数据访问操作已经足够的话，没必要使用CQRS，这些都是一个简单的对数据进行增删改查。</li>
<li>不适合在整个系统中到处使用该模式。在整个数据管理场景中的特定模块中CQRS可能比较有用。但是在有些地方使用CQRS会增加系统不必要的复杂性。</li>
</ol>
<h1 id="四-CQRS与Event-Sourcing的关系"><a href="#四-CQRS与Event-Sourcing的关系" class="headerlink" title="四 CQRS与Event Sourcing的关系"></a>四 CQRS与Event Sourcing的关系</h1><p>在CQRS中，查询方面，直接通过方法查询数据库，然后通过DTO将数据返回。在操作(Command)方面，是通过发送Command实现，由CommandBus处理特定的Command，然后由Command将特定的Event发布到EventBus上，然后EventBus使用特定的Handler来处理事件，执行一些诸如，修改，删除，更新等操作。这里，所有与Command相关的操作都通过Event实现。这样我们可以通过记录Event来记录系统的运行历史记录，并且能够方便的回滚到某一历史状态。<a href="http://msdn.microsoft.com/en-us/library/dn589792.aspx">Event Sourcing</a>就是用来进行存储和管理事件的。这里不展开介绍。</p>
<h1 id="五-CQRS的简单实现"><a href="#五-CQRS的简单实现" class="headerlink" title="五 CQRS的简单实现"></a>五 CQRS的简单实现</h1><p>CQRS模式在思想上比较简单，但是实现上还是有些复杂。它涉及到DDD，以及Event Sourcing，这里使用codeproject上的 <a href="http://www.codeproject.com/Articles/555855/Introduction-to-CQRS">Introduction to CQRS</a> 这篇文章的例子来说明CQRS模式。这个例子是一个简单的在线记日志(Diary)系统，实现了日志的增删改查功能。整体结构如下：</p>
<p><a href="http://images.cnitblog.com/blog/94031/201408/261851438603372.jpg"><img src="/2022/10/24/%E6%B5%85%E8%B0%88%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2%E8%81%8C%E8%B4%A3%E5%88%86%E7%A6%BBCQRS%E6%A8%A1%E5%BC%8F/5.png" alt="CQRS"></a></p>
<p>上图很清晰的说明了CQRS在读写方面的分离，在读方面，通过QueryFacade到数据库里去读取数据，这个库有可能是ReportingDB。在写方面，比较复杂，操作通过Command发送到CommandBus上，然后特定的CommandHandler处理请求，产生对应的Event，将Eevnt持久化后，通过EventBus特定的EevntHandler对数据库进行修改等操作。</p>
<p>例子代码可以到<a href="http://www.codeproject.com/Articles/555855/Introduction-to-CQRS">codeproject</a>上下载，整体结构如下：</p>
<p><a href="http://images.cnitblog.com/blog/94031/201408/261851446735785.png"><img src="/2022/10/24/%E6%B5%85%E8%B0%88%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2%E8%81%8C%E8%B4%A3%E5%88%86%E7%A6%BBCQRS%E6%A8%A1%E5%BC%8F/6.png" alt="DiaryCQRS project"></a></p>
<p>由三个项目构成，Diary.CQRS包含了所有的Domain和消息对象。Configuration通过使用一个名为StructMap的IOC来初始化一些变量方便Web调用，Web是一个简单的MVC3项目，在Controller中有与CQRS交互的代码。</p>
<p>下面分别看Query和Command方面的实现：</p>
<h2 id="Query方向的实现"><a href="#Query方向的实现" class="headerlink" title="Query方向的实现"></a>Query方向的实现</h2><p>查询方面很简单，日志列表和明细获取就是简单的查询。下面先看列表查询部分的代码。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActionResult <span class="title">Index</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    ViewBag.Model = ServiceLocator.ReportDatabase.GetItems();</span><br><span class="line">    <span class="keyword">return</span> View();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ActionResult <span class="title">Edit</span>(<span class="params">Guid id</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> item = ServiceLocator.ReportDatabase.GetById(id);</span><br><span class="line">    <span class="keyword">var</span> model = <span class="keyword">new</span> DiaryItemDto()</span><br><span class="line">    &#123;</span><br><span class="line">        Description = item.Description,</span><br><span class="line">        From = item.From,</span><br><span class="line">        Id = item.Id,</span><br><span class="line">        Title = item.Title,</span><br><span class="line">        To = item.To,</span><br><span class="line">        Version = item.Version</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> View(model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReportDatabase的GetItems和GetById(id)方法就是简单的查询，从命名可以看出他是ReportDatabase。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ReportDatabase</span> : <span class="title">IReportDatabase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;DiaryItemDto&gt; items = <span class="keyword">new</span> List&lt;DiaryItemDto&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DiaryItemDto <span class="title">GetById</span>(<span class="params">Guid id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> items.Where(a =&gt; a.Id == id).FirstOrDefault();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">DiaryItemDto item</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        items.Add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Delete</span>(<span class="params">Guid id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        items.RemoveAll(i =&gt; i.Id == id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;DiaryItemDto&gt; <span class="title">GetItems</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> items;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReportDataBase只是在内部维护了一个List的DiaryItemDto列表。在使用的时候，是通过IRepositoryDatabase对其进行操作的，这样便于mock代码。</p>
<p>Query方面的代码很简单。在实际的应用中，这一块就是直接对DB进行查询，然后通过DTO对象返回，这个DB可能是应对特定场景的报表数据库，这样可以提升查询性能。</p>
<p>下面来看Command方向的实现：</p>
<h2 id="Command方向的实现"><a href="#Command方向的实现" class="headerlink" title="Command方向的实现"></a>Command方向的实现</h2><p>Command的实现比较复杂，下面以简单的创建一个新的日志来说明。</p>
<p>在MVC的Control中，可以看到Add的Controller中只调用了一句话:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> ActionResult <span class="title">Add</span>(<span class="params">DiaryItemDto item</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ServiceLocator.CommandBus.Send(<span class="keyword">new</span> CreateItemCommand(Guid.NewGuid(), item.Title, item.Description, <span class="number">-1</span>, item.From, item.To));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RedirectToAction(<span class="string">&quot;Index&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先声明了一个CreateItemCommand，这个Command只是保存了一些必要的信息。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CreateItemCommand</span>:<span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Description &#123; <span class="keyword">get</span>;<span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTime From &#123; <span class="keyword">get</span>; <span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTime To &#123; <span class="keyword">get</span>; <span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CreateItemCommand</span>(<span class="params">Guid aggregateId, <span class="built_in">string</span> title, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">string</span> description,<span class="built_in">int</span> version,DateTime <span class="keyword">from</span>, DateTime to</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">aggregateId,version</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Title = title;</span><br><span class="line">        Description = description;</span><br><span class="line">        From = <span class="keyword">from</span>;</span><br><span class="line">        To = to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将Command发送到了CommandBus上，其实就是让CommandBus来选择合适的CommandHandler来处理。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CommandBus</span>:<span class="title">ICommandBus</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ICommandHandlerFactory _commandHandlerFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommandBus</span>(<span class="params">ICommandHandlerFactory commandHandlerFactory</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _commandHandlerFactory = commandHandlerFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span>&lt;<span class="title">T</span>&gt;(<span class="params">T command</span>) <span class="keyword">where</span> T : Command</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> handler = _commandHandlerFactory.GetHandler&lt;T&gt;();</span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            handler.Execute(command);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnregisteredDomainCommandException(<span class="string">&quot;no handler registered&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个里面需要值得注意的是CommandHandlerFactory这个类型的GetHandler方法，他接受一个类型为T的泛型，这里就是我们之前传入的CreateItemCommand。来看他的GetHandler方法。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StructureMapCommandHandlerFactory</span> : <span class="title">ICommandHandlerFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ICommandHandler</span>&lt;<span class="title">T</span>&gt; <span class="title">GetHandler</span>&lt;<span class="title">T</span>&gt;() <span class="keyword">where</span> T : Command</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> handlers = GetHandlerTypes&lt;T&gt;().ToList();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> cmdHandler = handlers.Select(handler =&gt; </span><br><span class="line">            (ICommandHandler&lt;T&gt;)ObjectFactory.GetInstance(handler)).FirstOrDefault();</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> cmdHandler;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IEnumerable</span>&lt;<span class="title">Type</span>&gt; <span class="title">GetHandlerTypes</span>&lt;<span class="title">T</span>&gt;() <span class="keyword">where</span> T : Command</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> handlers = <span class="keyword">typeof</span>(ICommandHandler&lt;&gt;).Assembly.GetExportedTypes()</span><br><span class="line">            .Where(x =&gt; x.GetInterfaces()</span><br><span class="line">                .Any(a =&gt; a.IsGenericType &amp;&amp; a.GetGenericTypeDefinition() == <span class="keyword">typeof</span>(ICommandHandler&lt;&gt;) ))</span><br><span class="line">                .Where(h=&gt;h.GetInterfaces()</span><br><span class="line">                    .Any(ii=&gt;ii.GetGenericArguments()</span><br><span class="line">                        .Any(aa=&gt;aa==<span class="keyword">typeof</span>(T)))).ToList();</span><br><span class="line"></span><br><span class="line">           </span><br><span class="line">        <span class="keyword">return</span> handlers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到，他首先查找当前的程序集中(ICommandHandler)所在的程序集中的所有的实现了ICommandHandler的接口的类型，然后在所有的类型找查找实现了该泛型接口并且泛型的类型参数类型为T类型的所有类型。以上面的代码为例，就是要找出实现了ICommandHandler<CreateItemCommand>接口的类型。可以看到就是CreateItemCommandHandler类型。</CreateItemCommand></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CreateItemCommandHandler</span> : <span class="title">ICommandHandler</span>&lt;<span class="title">CreateItemCommand</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IRepository&lt;DiaryItem&gt; _repository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CreateItemCommandHandler</span>(<span class="params">IRepository&lt;DiaryItem&gt; repository</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _repository = repository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">CreateItemCommand command</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="string">&quot;command&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_repository == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">&quot;Repository is not initialized.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> aggregate = <span class="keyword">new</span> DiaryItem(command.Id, command.Title, command.Description, command.From, command.To);</span><br><span class="line">        aggregate.Version = <span class="number">-1</span>;</span><br><span class="line">        _repository.Save(aggregate, aggregate.Version);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到之后然后使用IOC实例化了该对象返回。</p>
<p>现在CommandBus中，找到了处理特定Command的Handler。然后执行该类型的Execute方法。</p>
<p>可以看到在该类型中实例化了一个名为aggregate的DiaryItem对象。这个和我们之前查询所用到的DiaryItemDto有所不同，这个一个领域对象，里面包含了一系列事件。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DiaryItem</span> : <span class="title">AggregateRoot</span>, </span><br><span class="line">    <span class="title">IHandle</span>&lt;<span class="title">ItemCreatedEvent</span>&gt;,</span><br><span class="line">    <span class="title">IHandle</span>&lt;<span class="title">ItemRenamedEvent</span>&gt;,</span><br><span class="line">    <span class="title">IHandle</span>&lt;<span class="title">ItemFromChangedEvent</span>&gt;, </span><br><span class="line">    <span class="title">IHandle</span>&lt;<span class="title">ItemToChangedEvent</span>&gt;,</span><br><span class="line">    <span class="title">IHandle</span>&lt;<span class="title">ItemDescriptionChangedEvent</span>&gt;,</span><br><span class="line">    <span class="title">IOriginator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> DateTime From &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTime To &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Description &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiaryItem</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiaryItem</span>(<span class="params">Guid id,<span class="built_in">string</span> title, <span class="built_in">string</span> description,  DateTime <span class="keyword">from</span>, DateTime to</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ApplyChange(<span class="keyword">new</span> ItemCreatedEvent(id, title,description, <span class="keyword">from</span>, to));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangeTitle</span>(<span class="params"><span class="built_in">string</span> title</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ApplyChange(<span class="keyword">new</span> ItemRenamedEvent(Id, title));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span>(<span class="params">ItemCreatedEvent e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Title = e.Title;</span><br><span class="line">        From = e.From;</span><br><span class="line">        To = e.To;</span><br><span class="line">        Id = e.AggregateId;</span><br><span class="line">        Description = e.Description;</span><br><span class="line">        Version = e.Version;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span>(<span class="params">ItemRenamedEvent e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Title = e.Title;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ItemCreatedEvent 事件的定义如下，其实就是用来存储传输过程中需要用到的数据。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ItemCreatedEvent</span>:<span class="title">Event</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTime From &#123; <span class="keyword">get</span>; <span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTime To &#123; <span class="keyword">get</span>; <span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Description &#123; <span class="keyword">get</span>;<span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ItemCreatedEvent</span>(<span class="params">Guid aggregateId, <span class="built_in">string</span> title ,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">string</span> description, DateTime <span class="keyword">from</span>, DateTime to</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        AggregateId = aggregateId;</span><br><span class="line">        Title = title;</span><br><span class="line">        From = <span class="keyword">from</span>;</span><br><span class="line">        To = to;</span><br><span class="line">        Description = description;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在Domain对象中，除了定义基本的字段外，还定义了一些相应的事件，比如在构造函数中，实际上是发起了一个名为ItemCreateEvent的事件，同时还定义了处理时间的逻辑，这些逻辑都放在名为Handle的接口方法发，例如ItemCerateEvent的处理方法为Handle(ItemCreateEvent)方法。</p>
<p>ApplyChange方法在AggregateRoot对象中，他是聚集根，这是DDD中的概念。通过这个根可以串起所有对象。 该类实现了IEventProvider接口，他保存了所有在_changes中的所有没有提交的变更，其中的ApplyChange的用来为特定的Event查找Eventhandler的方法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AggregateRoot</span> : <span class="title">IEventProvider</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> List&lt;Event&gt; _changes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Guid Id &#123; <span class="keyword">get</span>; <span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Version &#123; <span class="keyword">get</span>; <span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> EventVersion &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AggregateRoot</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _changes = <span class="keyword">new</span> List&lt;Event&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;Event&gt; <span class="title">GetUncommittedChanges</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _changes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MarkChangesAsCommitted</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _changes.Clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadsFromHistory</span>(<span class="params">IEnumerable&lt;Event&gt; history</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> e <span class="keyword">in</span> history) ApplyChange(e, <span class="literal">false</span>);</span><br><span class="line">        Version = history.Last().Version;</span><br><span class="line">        EventVersion = Version;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">ApplyChange</span>(<span class="params">Event @<span class="keyword">event</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ApplyChange(@event, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ApplyChange</span>(<span class="params">Event @<span class="keyword">event</span>, <span class="built_in">bool</span> isNew</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dynamic</span> d = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        d.Handle(Converter.ChangeTo(@event, @event.GetType()));</span><br><span class="line">        <span class="keyword">if</span> (isNew)</span><br><span class="line">        &#123;</span><br><span class="line">            _changes.Add(@event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ApplyChange的实现中，this其实就是对应的实现了AggregateRoot的DiaryItem的Domain对象，调用的Handle方法就是我们之前在DiaryItem中定义的行为。然后将该event保存在内部的未提交的事件列表中。相关的信息及事件都保存在了定义的aggregate对象中并返回。</p>
<p>然后Command继续执行，然后调用了_repository.Save(aggregate, aggregate.Version);这个方法。先看这个Repository对象。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Repository</span>&lt;<span class="title">T</span>&gt; : <span class="title">IRepository</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">AggregateRoot</span>, <span class="title">new</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IEventStorage _storage;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">object</span> _lockStorage = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Repository</span>(<span class="params">IEventStorage storage</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _storage = storage;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Save</span>(<span class="params">AggregateRoot aggregate, <span class="built_in">int</span> expectedVersion</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (aggregate.GetUncommittedChanges().Any())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">lock</span> (_lockStorage)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> item = <span class="keyword">new</span> T();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (expectedVersion != <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    item = GetById(aggregate.Id);</span><br><span class="line">                    <span class="keyword">if</span> (item.Version != expectedVersion)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrencyException(<span class="built_in">string</span>.Format(<span class="string">&quot;Aggregate &#123;0&#125; has been previously modified&quot;</span>,</span><br><span class="line">                                                                        item.Id));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                _storage.Save(aggregate);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">GetById</span>(<span class="params">Guid id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        IEnumerable&lt;Event&gt; events;</span><br><span class="line">        <span class="keyword">var</span> memento = _storage.GetMemento&lt;BaseMemento&gt;(id);</span><br><span class="line">        <span class="keyword">if</span> (memento != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            events = _storage.GetEvents(id).Where(e=&gt;e.Version&gt;=memento.Version);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            events = _storage.GetEvents(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> obj = <span class="keyword">new</span> T();</span><br><span class="line">        <span class="keyword">if</span>(memento!=<span class="literal">null</span>)</span><br><span class="line">            ((IOriginator)obj).SetMemento(memento);</span><br><span class="line">            </span><br><span class="line">        obj.LoadsFromHistory(events);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要是用来对事件进行持久化的。 所有的聚合的变动都会存在该Repository中，首先，检查当前的聚合是否和之前存储在storage中的聚合一致，如果不一致，则表示对象在其他地方被更改过，抛出ConcurrencyException，否则将该变动保存在Event Storage中。</p>
<p>IEventStorage用来存储所有的事件，其实现类型为InMemoryEventStorage。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InMemoryEventStorage</span>:<span class="title">IEventStorage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Event&gt; _events;</span><br><span class="line">    <span class="keyword">private</span> List&lt;BaseMemento&gt; _mementos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IEventBus _eventBus;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InMemoryEventStorage</span>(<span class="params">IEventBus eventBus</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _events = <span class="keyword">new</span> List&lt;Event&gt;();</span><br><span class="line">        _mementos = <span class="keyword">new</span> List&lt;BaseMemento&gt;();</span><br><span class="line">        _eventBus = eventBus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;Event&gt; <span class="title">GetEvents</span>(<span class="params">Guid aggregateId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> events = _events.Where(p =&gt; p.AggregateId == aggregateId).Select(p =&gt; p);</span><br><span class="line">        <span class="keyword">if</span> (events.Count() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AggregateNotFoundException(<span class="built_in">string</span>.Format(<span class="string">&quot;Aggregate with Id: &#123;0&#125; was not found&quot;</span>, aggregateId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> events;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Save</span>(<span class="params">AggregateRoot aggregate</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> uncommittedChanges = aggregate.GetUncommittedChanges();</span><br><span class="line">        <span class="keyword">var</span> version = aggregate.Version;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> @event <span class="keyword">in</span> uncommittedChanges)</span><br><span class="line">        &#123;</span><br><span class="line">            version++;</span><br><span class="line">            <span class="keyword">if</span> (version &gt; <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (version % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> originator = (IOriginator)aggregate;</span><br><span class="line">                    <span class="keyword">var</span> memento = originator.GetMemento();</span><br><span class="line">                    memento.Version = version;</span><br><span class="line">                    SaveMemento(memento);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            @event.Version=version;</span><br><span class="line">            _events.Add(@event);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> @event <span class="keyword">in</span> uncommittedChanges)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> desEvent = Converter.ChangeTo(@event, @event.GetType());</span><br><span class="line">            _eventBus.Publish(desEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">GetMemento</span>&lt;<span class="title">T</span>&gt;(<span class="params">Guid aggregateId</span>) <span class="keyword">where</span> T : BaseMemento</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> memento = _mementos.Where(m =&gt; m.Id == aggregateId).Select(m=&gt;m).LastOrDefault();</span><br><span class="line">        <span class="keyword">if</span> (memento != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> (T) memento;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SaveMemento</span>(<span class="params">BaseMemento memento</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _mementos.Add(memento);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在GetEvent方法中，会找到所有的聚合根Id相关的事件。在Save方法中，将所有的事件保存在内存中，然后每隔三个事件建立一个快照。可以看到这里面使用了备忘录模式。</p>
<p>然后在foreach循环中，对于所有的没有提交的变更，EventBus将该事件发布出去。</p>
<p>现在，所有的发生变更的事件已经记录下来了。事件已经被发布到EventBus上，然后对应的EventHandler再处理对应的事件，然后与DB交互。现在来看EventBus的Publish方法。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventBus</span>:<span class="title">IEventBus</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IEventHandlerFactory _eventHandlerFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventBus</span>(<span class="params">IEventHandlerFactory eventHandlerFactory</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _eventHandlerFactory = eventHandlerFactory;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Publish</span>&lt;<span class="title">T</span>&gt;(<span class="params">T @<span class="keyword">event</span></span>) <span class="keyword">where</span> T : Event</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> handlers = _eventHandlerFactory.GetHandlers&lt;T&gt;();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> eventHandler <span class="keyword">in</span> handlers)</span><br><span class="line">        &#123;</span><br><span class="line">            eventHandler.Handle(@event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到EventBus的Publish和CommandBus中的Send方法很相似，都是首先通过EventHandlerFactory查找对应Event的Handler，然后调用其Handler方法。比如</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StructureMapEventHandlerFactory</span> : <span class="title">IEventHandlerFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IEnumerable</span>&lt;<span class="title">IEventHandler</span>&lt;<span class="title">T</span>&gt;&gt; <span class="title">GetHandlers</span>&lt;<span class="title">T</span>&gt;() <span class="keyword">where</span> T : Event</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> handlers = GetHandlerType&lt;T&gt;();</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">var</span> lstHandlers = handlers.Select(handler =&gt; (IEventHandler&lt;T&gt;) ObjectFactory.GetInstance(handler)).ToList();</span><br><span class="line">        <span class="keyword">return</span> lstHandlers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="title">IEnumerable</span>&lt;<span class="title">Type</span>&gt; <span class="title">GetHandlerType</span>&lt;<span class="title">T</span>&gt;() <span class="keyword">where</span> T : Event</span></span><br><span class="line">    &#123;</span><br><span class="line">           </span><br><span class="line">        <span class="keyword">var</span> handlers = <span class="keyword">typeof</span>(IEventHandler&lt;&gt;).Assembly.GetExportedTypes()</span><br><span class="line">            .Where(x =&gt; x.GetInterfaces()</span><br><span class="line">                .Any(a =&gt; a.IsGenericType &amp;&amp; a.GetGenericTypeDefinition() == <span class="keyword">typeof</span>(IEventHandler&lt;&gt;)))</span><br><span class="line">                .Where(h =&gt; h.GetInterfaces()</span><br><span class="line">                    .Any(ii =&gt; ii.GetGenericArguments()</span><br><span class="line">                        .Any(aa =&gt; aa == <span class="keyword">typeof</span>(T))))</span><br><span class="line">                 .ToList();</span><br><span class="line">        <span class="keyword">return</span> handlers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后返回并实例化了ItemCreatedEventHandler 对象，该对象的实现如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ItemCreatedEventHandler</span> : <span class="title">IEventHandler</span>&lt;<span class="title">ItemCreatedEvent</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IReportDatabase _reportDatabase;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ItemCreatedEventHandler</span>(<span class="params">IReportDatabase reportDatabase</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _reportDatabase = reportDatabase;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span>(<span class="params">ItemCreatedEvent handle</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        DiaryItemDto item = <span class="keyword">new</span> DiaryItemDto()</span><br><span class="line">            &#123;</span><br><span class="line">                Id = handle.AggregateId,</span><br><span class="line">                Description =  handle.Description,</span><br><span class="line">                From = handle.From,</span><br><span class="line">                Title = handle.Title,</span><br><span class="line">                To=handle.To,</span><br><span class="line">                Version =  handle.Version</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">        _reportDatabase.Add(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在Handler方法中，从事件中获取参数，然后新建DTO对象，然后将该对象更新到DB中。</p>
<p>到此，整个Command执行完成。</p>
<h1 id="六-结语"><a href="#六-结语" class="headerlink" title="六 结语"></a>六 结语</h1><p>CQRS是一种思想很简单清晰的设计模式，他通过在业务上分离操作和查询来使得系统具有更好的可扩展性及性能，使得能够对系统的不同部分进行扩展和优化。在CQRS中，所有的涉及到对DB的操作都是通过发送Command，然后特定的Command触发对应事件来完成操作，这个过程是异步的，并且所有涉及到对系统的变更行为都包含在具体的事件中，结合Eventing Source模式，可以记录下所有的事件，而不是以往的某一点的数据信息，这些信息可以作为系统的操作日志，可以来对系统进行回退或者重放。</p>
<p>CQRS 模式在实现上有些复杂，很多地方比如AggregationRoot、Domain Object都涉及到DDD中的相关概念，本人对DDD不太懂。这里仅为了演示CQRS模式，所以使用的例子是codeproject上的，末尾列出了一些参考文章，如果您想了解更多，可以有针对性的阅读。</p>
<p>最后，希望CQRS模式能让您在设计高性能，可扩展性的程序时能够多一种选择和考虑。</p>
<h1 id="七-参考文献"><a href="#七-参考文献" class="headerlink" title="七 参考文献"></a>七 参考文献</h1><ol>
<li>Introduction to CQRS <a href="http://www.codeproject.com/Articles/555855/Introduction-to-CQRS">http://www.codeproject.com/Articles/555855/Introduction-to-CQRS</a></li>
<li>CQRS <a href="http://martinfowler.com/bliki/CQRS.html">http://martinfowler.com/bliki/CQRS.html</a></li>
<li>CQRS Journey <a href="http://msdn.microsoft.com/en-us/library/jj554200.aspx">http://msdn.microsoft.com/en-us/library/jj554200.aspx</a></li>
<li>Command and Query Responsibility Segregation (CQRS) Pattern <a href="http://msdn.microsoft.com/en-us/library/dn568103.aspx">http://msdn.microsoft.com/en-us/library/dn568103.aspx</a></li>
<li>EntityFramework之领域驱动设计实践：CQRS体系结构模式 <a href="http://www.cnblogs.com/daxnet/archive/2010/08/02/1790299.html">http://www.cnblogs.com/daxnet/archive/2010/08/02/1790299.html</a></li>
<li>Event Sourcing Pattern <a href="http://msdn.microsoft.com/en-us/library/dn589792.aspx">http://msdn.microsoft.com/en-us/library/dn589792.aspx</a></li>
</ol>
]]></content>
      <categories>
        <category>DDD领域驱动设计</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>第316场力扣周赛</title>
    <url>/2022/10/24/%E7%AC%AC316%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h4 id="1-6214-判断两个事件是否存在冲突"><a href="#1-6214-判断两个事件是否存在冲突" class="headerlink" title="1.6214. 判断两个事件是否存在冲突"></a>1.<a href="https://leetcode.cn/problems/determine-if-two-events-have-conflict/">6214. 判断两个事件是否存在冲突</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">haveConflict</span><span class="params">(String[] event1, String[] event2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start1</span> <span class="operator">=</span> helper(event1[<span class="number">0</span>]), end1 = helper(event1[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">start2</span> <span class="operator">=</span> helper(event2[<span class="number">0</span>]), end2 = helper(event2[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (start1 &gt; end2 || start2 &gt; end1) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">helper</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">//将时间全部转化为分钟</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> (str.charAt(<span class="number">0</span>) - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + (str.charAt(<span class="number">1</span>) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (str.charAt(<span class="number">3</span>) - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + (str.charAt(<span class="number">4</span>) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> h * <span class="number">60</span> + m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-2447-最大公因数等于-K-的子数组数目"><a href="#2-2447-最大公因数等于-K-的子数组数目" class="headerlink" title="2.2447. 最大公因数等于 K 的子数组数目"></a>2.<a href="https://leetcode.cn/problems/number-of-subarrays-with-gcd-equal-to-k/">2447. 最大公因数等于 K 的子数组数目</a></h4><p>两个或多个<a href="https://baike.baidu.com/item/%E6%95%B4%E6%95%B0/1293937?fromModule=lemma_inlink">整数</a>公有的<a href="https://baike.baidu.com/item/%E5%80%8D%E6%95%B0/7827981?fromModule=lemma_inlink">倍数</a>叫做它们的公倍数，其中除0以外最小的一个公倍数就叫做这几个整数的最小公倍数。整数a，b的最小公倍数记为[a，b]，同样的，a，b，c的最小公倍数记为[a，b，c]，多个整数的最小公倍数也有同样的记号。</p>
<p>与最小公倍数相对应的概念是<a href="https://baike.baidu.com/item/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/869308?fromModule=lemma_inlink">最大公约数</a>，a，b的最大公约数记为（a，b）。关于最小公倍数与最大公约数，我们有这样的定理：(a,b)x[a,b]&#x3D;ab(a,b均为整数)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarrayGCD</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; k) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == k) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                temp = gcd(temp, nums[j]);</span><br><span class="line">                <span class="keyword">if</span> (temp &lt; k) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == k) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-6216-使数组相等的最小开销"><a href="#3-6216-使数组相等的最小开销" class="headerlink" title="3.6216. 使数组相等的最小开销"></a>3.<a href="https://leetcode.cn/problems/minimum-cost-to-make-array-equal/">6216. 使数组相等的最小开销</a></h4><p>显然，我们可以得到下面的目标函数：</p>
<p>$$<br>min:z&#x3D;<br>i&#x3D;0<br>∑<br>size<br>​	<br> (∣target−nums[i]∣∗cost[i])<br>$$<br>问题转化为：如何找到使目标函数值最小的target？这需要一点高中知识：当n个绝对值相加，在何处取到最小？</p>
<p>也就是说，考虑下面的问题：</p>
<p>$$<br>min:∣x−a<br>1<br>​	<br> ∣+∣x−a<br>2<br>​	<br> ∣+…+∣x−a<br>n<br>​	<br> ∣<br>$$<br>在x为何值时最小？其实就是在a1~an的中位数处。这和<a href="https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/">462. 最小操作次数使数组元素相等 II</a> 的思想是类似的。推广到这一题，也就是说，我们要找到nums[i]的加权中位数。也就是每个nums[i]，都视为有cost[i]个，然后找到它们的中位数，就是target，然后算出目标函数就行了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">minCost</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; o1[<span class="number">0</span>] - o2[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">long</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nums[i], cost[i]&#125;);</span><br><span class="line">            len += cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">pivot</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">targetNum</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span>[] temp = queue.poll();</span><br><span class="line">            pivot += temp[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (pivot &gt;= len / <span class="number">2</span>) &#123;</span><br><span class="line">                targetNum = temp[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            res += (<span class="type">long</span>) Math.abs(targetNum - nums[i]) * cost[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>扩展</strong>： <a href="https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/">462. 最小操作次数使数组元素相等 II</a></p>
<p>思路：<a href="https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/solution/java-wu-xu-shu-xue-zheng-ming-si-lu-qing-01v2/">https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/solution/java-wu-xu-shu-xue-zheng-ming-si-lu-qing-01v2/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMoves2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="literal">null</span> || nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> target=nums[nums.length/<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            res+=Math.abs(nums[i]-target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-2449-使数组相似的最少操作次数"><a href="#4-2449-使数组相似的最少操作次数" class="headerlink" title="4.2449. 使数组相似的最少操作次数"></a>4.<a href="https://leetcode.cn/problems/minimum-number-of-operations-to-make-arrays-similar/">2449. 使数组相似的最少操作次数</a></h4><p>思路：<a href="https://leetcode.cn/problems/minimum-number-of-operations-to-make-arrays-similar/solution/by-endlesscheng-lusx/">https://leetcode.cn/problems/minimum-number-of-operations-to-make-arrays-similar/solution/by-endlesscheng-lusx/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">makeSimilar</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span>[] target)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        Arrays.sort(target);</span><br><span class="line">        List&lt;Integer&gt; odd = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; even = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; oddTarget = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; evenTarget = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((nums[i] &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                odd.add(nums[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                even.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((target[i] &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                oddTarget.add(target[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                evenTarget.add(target[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">stepOdd</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stepEven</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//2 4 4 6    //4 4 4 4</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; odd.size(); i++) &#123;</span><br><span class="line">            stepOdd += Math.abs(odd.get(i) - oddTarget.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; even.size(); i++) &#123;</span><br><span class="line">            stepEven += Math.abs(even.get(i) - evenTarget.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (stepOdd + stepEven) / <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-HTTPS详解</title>
    <url>/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTPS%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>每篇文章都希望你能收获到东西，这篇将带你深入 HTTPS 加解密原理，希望看完能够有这些收获：</p>
<ul>
<li><p>明白 HTTPS 到底解决了什么问题</p>
</li>
<li><p>理解对称加密与非对称加密的原理和使用场景</p>
</li>
<li><p>明白 CA 机构和根证书到底起了什么作用</p>
</li>
</ul>
<h2 id="Why-HTTPS"><a href="#Why-HTTPS" class="headerlink" title="Why HTTPS"></a>Why HTTPS</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">近几年来，各大公司都在大力推进 HTTPS 的建设。Google Chrome将非 HTTPS 的网站标注为「不安全」，苹果要求 APP 中需要使用HTTPS进行通信，微信小程序也要求使用HTTPS协议。那么，我们为什么非要做这么一件事呢？</span><br></pre></td></tr></table></figure>

<p>我们先来看看HTTP。HTTP（Hypertext Transfer Protocol）超文本传输协议，是一种用于分布式、协作式和超媒体信息系统的应用层协议，可以说 HTTP 是当代互联网通信的基础。</p>
<p>但是，HTTP 有着一个致命的缺陷，那就是内容是<strong>明文传输</strong>的，没有经过任何加密，而这些明文数据会经过WiFi、路由器、运营商、机房等多个物理设备节点，如果在这中间任意一个节点被监听，传输的内容就会完全暴露，，这一攻击手法叫做MITM（Man In The Middle）中间人攻击。</p>
<p><strong>举个例子，稍微有点长，但这个例子透露出了怪怪我对安全如此痴迷的原因</strong>😝~~<br>可以拿小时候上课传纸条来类比，你坐在教室靠墙的一边，想要传一句「<strong>晚上放学操场我等你</strong>」给坐在窗边的小红，中间要经过六七个人的传递。虽然你把纸条对折了一下，但是防君子不防小人，中间的所有人都可以很轻易地打开纸条看到你想要说什么。</p>
<p>只是看还好，如果有小刚也喜欢小红，看到你俩马上就要甜甜蜜蜜地回家了，心有不甘，换了一张纸条，改成了「<strong>晚上放学你自己回家吧，我要去网吧玩游戏</strong>」。</p>
<p>小红看到你要抛弃她自己去玩游戏，非常伤心，开始在纸条上质问「<strong>说好的一起回家呢，为什么要去打游戏，哼</strong>」。</p>
<p>在小红的纸条传回来的路上，小刚又改了纸条「<strong>你玩你的游戏去吧，我要和小刚回家</strong>」。</p>
<p>于是，你和小红都倍感伤心，小刚横刀夺爱，而你一头雾水。</p>
<p>回忆一下几年前遍地都是的<strong>运营商劫持</strong>，当你访问一个本来很正常的网页，但页面上却莫名其妙出现了一些广告标签、跳转脚本、欺骗性的红包按钮，甚至有时候本来要下载一个文件，最后下下来却变成了另外一个完全不同的东西，这些都是被运营商劫持了HTTP明文数据的现象。</p>
<p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTPS%E8%AF%A6%E8%A7%A3/1.png" alt="在这里插入图片描述"><br>还有各大公司的员工<strong>安全培训</strong>里都有一条「不要连陌生的WiFi」，也是类似的原因，恶意WiFi的控制者可以看到和篡改HTTP明文传输的信息。</p>
<p>为了解决HTTP明文传输数据可能导致的安全问题，1994年网景公司提出了HTTPS（HyperText Transfer Protocol Secure）超文本传输安全协议，数据通信仍然是HTTP，但利用<strong>SSL&#x2F;TLS加密数据包。</strong></p>
<h2 id="HTTPS实现原理"><a href="#HTTPS实现原理" class="headerlink" title="HTTPS实现原理"></a>HTTPS实现原理</h2><p>前面说到，HTTPS其实就是将HTTP的数据包再通过SSL&#x2F;TLS加密后传输，那么SSL&#x2F;TLS又是什么呢？</p>
<p>SSL（Secure Sockets Layer）安全套接层和TLS（Transport Layer Security）传输层安全协议其实是一套东西。</p>
<p>网景公司在1994年提出HTTPS协议时，使用的是SSL进行加密。后来IETF（Internet Engineering Task Force）互联网工程任务组将SSL进一步标准化，于1999年公布第一版TLS协议文件TLS 1.0。目前最新版的TLS协议是TLS 1.3，于2018年公布。</p>
<p>工作流程<br>我们先来看看HTTPS的加解密流程。<br><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTPS%E8%AF%A6%E8%A7%A3/2.png" alt="在这里插入图片描述"></p>
<p>1.用户在浏览器发起HTTPS请求（如 <a href="https://www.mogu.com/%EF%BC%89%EF%BC%8C%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84443%E7%AB%AF%E5%8F%A3%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5%EF%BC%9B">https://www.mogu.com/），默认使用服务端的443端口进行连接；</a></p>
<p>2.HTTPS需要使用一套<strong>CA数字证书</strong>，证书内会附带一个<strong>公钥Pub</strong>，而与之对应的<strong>私钥Private</strong>保留在服务端不公开；</p>
<p>3.服务端收到请求，返回配置好的包含公钥Pub的证书给客户端；</p>
<p>4.客户端收到<strong>证书</strong>，校验合法性，主要包括是否在有效期内、证书的域名与请求的域名是否匹配，上一级证书是否有效（递归判断，直到判断到系统内置或浏览器配置好的根证书），如果不通过，则显示HTTPS警告信息，如果通过则继续；</p>
<p>5.客户端生成一个用于对称加密的<strong>随机Key</strong>，并用证书内的<strong>公钥Pub</strong>进行加密，发送给服务端；</p>
<p>6.服务端收到<strong>随机Key</strong>的密文，使用与<strong>公钥Pub</strong>配对的私钥Private进行解密，得到客户端真正想发送的随机Key；</p>
<p>7.服务端使用客户端发送过来的<strong>随机Key</strong>对要传输的HTTP数据进行对称加密，将密文返回客户端；</p>
<p>8.客户端使用<strong>随机Key</strong>对称解密密文，得到HTTP数据明文；</p>
<p>9.后续HTTPS请求使用之前交换好的随机Key进行对称加解密。</p>
<h2 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">又是对称加密又是非对称加密，一会公钥一会私钥一会随机Key，为什么要这么复杂呢，一套搞到底不好么？</span><br></pre></td></tr></table></figure>

<p>对称加密是指有一个密钥，用它可以对一段明文加密，加密之后也只能用这个密钥来解密得到明文。如果通信双方都持有密钥，且天知地知你知我知，绝对不会有别的人知道，那么通信安全自然是可以得到保证的（在<strong>密钥足够强</strong>的情况下）。</p>
<p>然而，在HTTPS的传输场景下，服务端事先并不知道客户端是谁，你也<strong>不可能在事先不通过互联网和每一个网站的管理员都悄悄商量好一个通信密钥</strong>出来，那么必然存在一个密钥在互联网上传输的过程，如果在传输过程中被别人监听到了，那么后续的所有加密都是无用功。</p>
<p>这时，我们就需要另一种神奇的加密类型，非对称加密。</p>
<p>非对称加密有两个密钥，一个是公钥，另一个是私钥。一般来说，公钥用来加密，这时密文只能用私钥才能解开。</p>
<p>那么，当客户端发起连接请求，服务端将公钥传输过去，客户端利用公钥加密好信息，再将密文发送给服务端，服务端里有私钥可以解密。</p>
<p>但是，当服务端要返回数据，如果用公钥加密，那么客户端并没有私钥用来解密，而如果用私钥加密，客户端虽然有公钥可以解密，但这个公钥之前就在互联网上传输过，很有可能已经有人拿到，并不安全，所以这一过程只用非对称加密是不能满足的。</p>
<p><strong>注意，严格来讲，私钥并不能用来加密，只能用作签名使用，这是由于密码学中生成公钥私钥时对不同变量的数学要求是不同的，因此公钥私钥抵抗攻击的能力也不同，在实际使用中不可互换。签名的功能在HTTPS里也有用到，下文中会说明。</strong></p>
<p>只有一组公钥私钥只能保证单程的加解密，那么如果我们准备<strong>两组公钥私钥</strong>呢，是不是可以解决这个问题？来看下面这个过程。</p>
<p>1.服务端有非对称加密的公钥A1，私钥A2；</p>
<p>2.客户端有非对称加密的公钥B1，私钥B2；</p>
<p>3.客户端向服务端发起请求，服务端将公钥A1返回给客户端；</p>
<p>4.浏览器收到公钥A1，将自己保存的公钥B1发送给服务端；</p>
<p>5.之后浏览器所有向客户端发送的数据，使用公钥B1加密，客户端可以使用私钥B2解密；</p>
<p>6.客户端所有向服务端发送的数据，使用公钥A1加密，服务端可以使用私钥A2解密。</p>
<p>此时，两条传输方向的数据都经过非对称加密，都能保证安全性，那么为什么不采用这种方案呢？</p>
<p>最主要的原因是<strong>非对称加解密耗时要远大于对称加解密</strong>，对性能有很大损耗，大家的使用体验很差。</p>
<p>所以，我们才最终选用了上文介绍到非对称加密+对称加密的方案，再复习一下↓↓↓😝</p>
<p>1.服务端有非对称加密的公钥A1，私钥A2；</p>
<p>2.客户端发起请求，服务端将公钥A1返回给客户端；</p>
<p>3.客户端随机生成一个对称加密的密钥K，用公钥A1加密后发送给服务端；</p>
<p>4.服务端收到密文后用自己的私钥A2解密，得到对称密钥K，此时完成了安全的对称密钥交换，解决了对称加密时密钥传输被人窃取的问题</p>
<p>5.之后双方通信都使用密钥K进行对称加解密。</p>
<p>看起来是一个非常完美的方案，兼顾了安全性和性能，但是，真的就安全了么？</p>
<h2 id="CA颁发机构"><a href="#CA颁发机构" class="headerlink" title="CA颁发机构"></a>CA颁发机构</h2><p>依然考虑<strong>中间人攻击</strong>的情况，非对称加密的算法都是公开的，所有人都可以自己生成一对公钥私钥。</p>
<p>当服务端向客户端返回公钥A1的时候，中间人将其替换成自己的公钥B1传送给浏览器。</p>
<p>而浏览器此时一无所知，傻乎乎地使用公钥B1加密了密钥K发送出去，又被中间人截获，中间人利用自己的私钥B2解密，得到密钥K，再使用服务端的公钥A1加密传送给服务端，完成了通信链路，而服务端和客户端毫无感知。</p>
<p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTPS%E8%AF%A6%E8%A7%A3/3.png" alt="在这里插入图片描述"></p>
<p>出现这一问题的核心原因是<strong>客户端无法确认收到的公钥是不是真的是服务端发来的</strong>。为了解决这个问题，互联网引入了一个公信机构，这就是CA。</p>
<p>服务端在使用HTTPS前，去经过认证的CA机构申请颁发一份数字证书，数字证书里包含有证书持有者、证书有效期、公钥等信息，服务端将证书发送给客户端，客户端校验证书身份和要访问的网站身份确实一致后再进行后续的加密操作。</p>
<p>但是，如果中间人也聪明一点，<strong>只改动了证书中的公钥部分</strong>，客户端依然不能确认证书是否被篡改，这时我们就需要一些防伪技术了。</p>
<p>前面说过，非对称加密中一般公钥用来加密，私钥用来解密，虽然私钥加密理论上可行，但由于数学上的设计这么做并不适合，那么私钥就只有解密这个功能了么？</p>
<p>私钥除了解密外的真正用途其实还有一个，就是数字签名，其实就是一种防伪技术，只要有人篡改了证书，那么数字签名必然校验失败。具体过程如下</p>
<p>1.CA机构拥有自己的一对公钥和私钥</p>
<p>2.CA机构在颁发证书时对证书明文信息进行哈希</p>
<p>3.将哈希值用私钥进行加签，得到数字签名</p>
<h3 id="明文数据和数字签名组成证书，传递给客户端。"><a href="#明文数据和数字签名组成证书，传递给客户端。" class="headerlink" title="明文数据和数字签名组成证书，传递给客户端。"></a>明文数据和数字签名组成证书，传递给客户端。</h3><p>1.客户端得到证书，分解成明文部分Text和数字签名Sig1</p>
<p>2.用CA机构的公钥进行解签，得到Sig2（由于CA机构是一种公信身份，因此在系统或浏览器中会内置CA机构的证书和公钥信息）</p>
<p>3.用证书里声明的哈希算法对明文Text部分进行哈希得到H</p>
<p>4.当自己计算得到的哈希值T与解签后的Sig2相等，表示证书可信，没有被篡改</p>
<p>这时，签名是由CA机构的私钥生成的，中间人篡改信息后无法拿到CA机构的私钥，保证了证书可信。</p>
<p><strong>注意，这里有一个比较难以理解的地方，非对称加密的签名过程是，私钥将一段消息进行加签，然后将签名部分和消息本身一起发送给对方，收到消息后对签名部分利用公钥验签，如果验签出来的内容和消息本身一致，表明消息没有被篡改。</strong></p>
<p>在这个过程中，系统或浏览器中内置的CA机构的证书和公钥成为了至关重要的环节，这也是CA机构公信身份的证明，如果系统或浏览器中没有这个CA机构，那么客户端可以不接受服务端传回的证书，显示HTTPS警告。</p>
<p>实际上CA机构的证书是一条信任链，A信任B，B信任C，以掘金的证书为例，掘金向RapidSSL申请一张证书，而RapidSSL的CA身份是由DigiCert Global根CA认证的，构成了一条信任链。</p>
<p>各级CA机构的私钥是绝对的私密信息，一旦CA机构的私钥泄露，其公信力就会一败涂地。之前就有过几次CA机构私钥泄露，引发信任危机，各大系统和浏览器只能纷纷吊销内置的对应CA的根证书。</p>
<p>有些老旧的网站会要求使用前下载安装他自己的根证书，这就是这个网站使用的证书并不能在系统内置的CA机构和根证书之间形成一条信任链，需要自己安装根证书来构成信任链，这里的风险就要使用者自己承担了。<br><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTPS%E8%AF%A6%E8%A7%A3/4.png" alt="在这里插入图片描述"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>HTTPS 的出发点是解决HTTP明文传输时信息被篡改和监听的问题。</p>
<p>为了兼顾性能和安全性，使用了非对称加密+对称加密的方案。</p>
<ul>
<li>为了保证公钥传输中不被篡改，又使用了非对称加密的数字签名功能，</li>
<li>借助CA机构和系统根证书的机制保证了HTTPS证书的公信力。</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-OSI案例详解+ARP+DNS</title>
    <url>/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-OSI%E6%A1%88%E4%BE%8B%E8%AF%A6%E8%A7%A3-ARP-DNS/</url>
    <content><![CDATA[<h1 id="OSI案例详解-ARP-DNS"><a href="#OSI案例详解-ARP-DNS" class="headerlink" title="OSI案例详解+ARP+DNS"></a>OSI案例详解+ARP+DNS</h1><h4 id="案例，淘宝买东西案例，淘宝买东西"><a href="#案例，淘宝买东西案例，淘宝买东西" class="headerlink" title="案例，淘宝买东西案例，淘宝买东西"></a>案例，淘宝买东西案例，淘宝买东西</h4><p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-OSI%E6%A1%88%E4%BE%8B%E8%AF%A6%E8%A7%A3-ARP-DNS/1.jpg" alt="img"></p>
<h4 id="DNS（走的UDP）"><a href="#DNS（走的UDP）" class="headerlink" title="DNS（走的UDP）"></a>DNS（走的UDP）</h4><p>域名的作用其实就是相对ip地址来说更好记忆和识别，DNS就是根据域名解析出ip</p>
<p><strong>一次请求，DNS解析的过程</strong></p>
<p>1.在浏览器输入一个域名，操作系统首先会检查自己的本地hosts文件是否存在这个域名的映射关系，如果有就解析完成</p>
<p>2.如果1没有对应的关系，然后就会去配置的服务器找</p>
<p>3.最后到根DNS服务器去寻找，就算这个DNS不知道IP地址，但是它会告诉你哪一台知道，最后把结果返回（全球只有13台根DNS服务器，9台美国，亚洲只有日本有一台）</p>
<p><strong>为啥只有13台？</strong></p>
<p>因为UDP一个包一般为512字节，刚好能放下13个根地址</p>
<p><strong>DNS配置</strong></p>
<p>域名-ipv4 A记录</p>
<p>域名-ipv6 AAAA记录</p>
<p>域名-域名 CName</p>
<p>域名-URL URL</p>
<p>域名-文本 TXT</p>
<h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><p>arp在数据传输中起着非常重要的作用，它在数据链路层中起作用</p>
<p><strong>常见问题，数据怎么知道发送的ip地址？</strong></p>
<p>这个问题其实很普通，数据发送的时候是肯定知道对方的ip地址的，只是我们发送数据的时候我们看不见而已，他是发送数据的一个重要的基础<br><strong>数据怎么知道发送的mac地址？</strong></p>
<p>这个问题就比较高级一点了，我们知道数据传输其实真正起作用的是mac地址，怎么知道对方的mac地址呢，其实这就是arp协议在做的工作</p>
<h4 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a><strong>工作过程</strong></h4><p>分两种，一种是在同一个网段（广播域），还有一种是在不同网段</p>
<p><strong>当数据到达数据链路层层</strong></p>
<p><strong>同一网段</strong></p>
<p>数据链路层的功能就是填源mac和目标mac，其实到这一步计算机就会判断目标ip是不是在一个网段，是的话就去本机的mac表找有没有目标ip的mac地址，没有的话，就把mac地址填FFFFFFFF，发送广播，接收到的机器拿出目标ip地址判断，如果是自己就返回响应</p>
<p><strong>不同网段</strong></p>
<p>如果计算出不是一个网段的，那么目标mac地址就直接填写网关的mac地址，数据发送到网关，mac地址就换成下一站的mac地址，直到找到目标的机器的网段的网关，最后网关发送一个类似上面的包找到目标机器</p>
<h4 id="应用层-DNS，HTTP，HTTPS"><a href="#应用层-DNS，HTTP，HTTPS" class="headerlink" title="应用层 DNS，HTTP，HTTPS"></a>应用层 DNS，HTTP，HTTPS</h4><p>1.我们在浏览器输入<a href="https://www.taobao.com网址,然后按下回车/">https://www.taobao.com网址，然后按下回车</a></p>
<p>2.浏览器并不知道<a href="https://www.taobao.com这个URL的具体地点，它会去作为地址簿协议的DNS去查找，最终返回淘宝服务器的IP地址，假如为122.123.34.21">https://www.taobao.com这个URL的具体地点，它会去作为地址簿协议的DNS去查找，最终返回淘宝服务器的IP地址，假如为122.123.34.21</a></p>
<p>3.浏览器知道了目标地址，就会开始打包它的请求，对于普通的浏览请求，通常会使用HTTP协议，但是对于购物等私密性比较重要的请求，选择了HTTPS加密的协议，给数据加上了HTTP头</p>
<p>4.将请求数据打包，然后交给下一层传输层</p>
<p><a href="https://static001.geekbang.org/resource/image/d8/c6/d8a65ca347ad26acc9f1de49b10320c6.png"><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-OSI%E6%A1%88%E4%BE%8B%E8%AF%A6%E8%A7%A3-ARP-DNS/2.png" alt="img"></a></p>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>在应用层和传输层之间，抽象出来了一层socket层，socket层相当于把传输层封装了一下，把tcp&#x2F;ip层复杂的操作抽象成了几个简单的接口提供给应用层使用。</p>
<p>1.数据进入传输层，传输层有两种协议，一种是无连接协议UDP和面向连接的协议TCP，因为TCP是可靠的协议，所以选择了TCP协议，TCP协议里面有两个端口，一个是自己的浏览器端口，还有一个是淘宝应用的端口，于是给数据加上了TCP头</p>
<p>2.传输层数据封装完毕，交给下一层网络层</p>
<p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-OSI%E6%A1%88%E4%BE%8B%E8%AF%A6%E8%A7%A3-ARP-DNS/3.png" alt="img"></p>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>1.网络层的协议是IP协议，IP协议中有浏览器的IP和淘宝服务器的IP</p>
<p>2.给数据加上IP头，交给下一层数据链路层</p>
<p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-OSI%E6%A1%88%E4%BE%8B%E8%AF%A6%E8%A7%A3-ARP-DNS/50.png" alt="img"></p>
<h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>1.既然知道了目的IP地址，就会想如何找到目标机器，通过判断IP地址判断，这台机器是局域网中的还是外网的，如果是外网的话就会去问路由器中的网关。</p>
<p>2.默认的网关的IP地址是192.168.1.1，在局域网中广播的方式，找谁是192.168.1.1，网关就会回答他，并告诉他网关的MAC地址（通过IP找MAC地址的过程就是ARP协议，地址解析协议）</p>
<p>3.既然知道了网关的MAC地址，就给数据加上了MAC头，接下来就可以交给物理层传输了</p>
<p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-OSI%E6%A1%88%E4%BE%8B%E8%AF%A6%E8%A7%A3-ARP-DNS/4.png" alt="img"></p>
<h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>传输数据</p>
<h4 id="传输过程"><a href="#传输过程" class="headerlink" title="传输过程"></a>传输过程</h4><p>1.数据终于从电脑出发了，首先它经过了交换机，交换机,交换机问数据你去哪呀，数据回答，找一个网关的MAC地址，交换机知道了，就告诉他怎么走</p>
<p>2.找到了网关，网关一般是路由器，路由器问数据你去哪呀，数据拿出了淘宝的IP，说，你看，我要去这里，路由器回答说哦，去这里，先去路由器B吧，他会告诉你接下来怎么走的（路由器之间也经常沟通，知道怎么走，这种沟通就是路由协议，有OSPF开放式最短路径优先和BGP边界网关协议）</p>
<p>3.最后终于到了最后一个路由器，路由器就会向某一个网络广播，数据找到交换机问，谁是淘宝服务器，淘宝服务器收到后，回复一个带MAC地址的数据，最后成功找到了淘宝服务器</p>
<p>4.目标服务器发现MAC地址对上了，就脱下MAC头，IP也对上了，脱下了IP头，然后就是TCP头了，把数据交给传输层，由于是TCP协议，每收到一个数据都会告诉发送者，我收到了，不然的话，发送者会一直发送没有响应的数据的。最后根据端口号，把数据交给监听这个端口的进程。</p>
<p>5.终于到达了进程，这时候就剩下一层HTTP头了，通过解析淘宝进程知道发送者要买东西了，于是操作数据库等，最后返回一个响应。</p>
<p>6.最后，发送者的浏览器，弹出了购买成功，他开心的流出了眼泪！</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>HTTP</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-RPC和HTTP区别</title>
    <url>/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-RPC%E5%92%8CHTTP%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>网上充斥着各类类似于这样的文章：rpc 比 http 快了多少倍？既然有了 http，为什么还要用 rpc 调用等等。遇到这类文章，说明对 http 和 rpc 是由理解误区的。</p>
<p>　　这里再次重复强调一遍，通信协议不是 rpc 最重要的部分，不要被这类回答带偏。如果要了解 rpc 请更多的去了解服务治理(SOA)的一些基本策略，推荐去看看 dubbo 的相关文档。</p>
<h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><p>　　rpc是远端过程调用，其调用协议通常包含：传输协议 和 序列化协议。</p>
<p>　　<strong>传输协议</strong></p>
<p>　　比如著名的 grpc，它底层使用的是 http2 协议；还有 dubbo 一类的自定义报文的 tcp 协议</p>
<p>　　<strong>序列化协议</strong></p>
<p>　　例如基于文本编码的 json 协议；也有二进制编码的 protobuf、hession 等协议；还有针对 java 高性能、高吞吐量的 kryo 和 ftc 等序列化协议</p>
<p>　　因此我理解大部人理解误区的问题应该是：</p>
<p>　　<strong>为什么要使用自定义 tcp 协议的 rpc 做后端进程通信？</strong></p>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a><strong>解答</strong></h3><p>　　要解决这个问题就应该搞清楚 http 使用的 tcp 协议，和我们自定义的 tcp 协议在报文上的区别。</p>
<p>　　首先要 否认 一点 http 协议相较于 自定义tcp 报文协议，增加的开销在于连接的建立与断开。</p>
<p>　　第一、http协议是支持连接池复用的，也就是建立一定数量的连接不断开，并不会频繁的创建和销毁连接</p>
<p>　　第二、http也可以使用 protobuf 这种二进制编码协议对内容进行编码</p>
<p>　　因此二者即 http 和 rpc 最大的区别还是在传输协议上。</p>
<p>　　通用定义的http1.1协议的tcp报文包含太多废信息，一个POST协议的格式大致如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.0 200 OK </span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 137582</span><br><span class="line">Expires: Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line">Last-Modified: Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line">Server: Apache 0.84</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>　　即使编码协议也就是 body 是使用二进制编码协议，报文元数据也就是header头的键值对却使用了文本编码，非常占字节数。如上图所使用的报文中有效字节数仅仅占约 30%，也就是70%的时间用于传输元数据废编码。当然实际情况下报文内容可能会比这个长，但是报头所占的比例也是非常可观的。</p>
<p>　　那么假如我们使用自定义tcp协议的报文如下</p>
<p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-RPC%E5%92%8CHTTP%E5%8C%BA%E5%88%AB/1.png" alt="img"></p>
<p>　　报头占用的字节数也就只有16个byte，极大地精简了传输内容。</p>
<p>　　这也就是为什么后端进程间通常会采用 自定义tcp协议 的 rpc 来进行通信的原因。</p>
<h3 id="不单效率那么简单"><a href="#不单效率那么简单" class="headerlink" title="不单效率那么简单"></a>不单效率那么简单</h3><p>　　所谓的效率优势是针对 http1.1协议 来讲的，http2.0协议 已经优化编码效率问题，像 grpc 这种 rpc 库使用的就是 http2.0协议。这么来说吧，http容器的性能测试单位通常是kqps，自定义tpc协议则通常是以 10kqps 到 100kqps 为基准</p>
<p>　　简单来说成熟的 rpc库相对 http容器，更多的是封装了 “服务发现”，”负载均衡”，“熔断降级” 一类面向服务的高级特性。可以这么理解，rpc框架是面向服务的更高级的封装。如果把一个http servlet 容器上封装一层服务发现 和 函数代理调用，那它就已经可以做一个rpc框架了。</p>
<p>所以为什么要用rpc调用？</p>
<p>　　因为良好的 rpc 调用是 面向服务的封装，针对服务的 可用性 和 效率 等都做了优化。单纯使用http调用则缺少了这些特性。</p>
<p>　　可以这样说：用http不是因为它性能好，而是因为它普适，随便一个web容器就能跑起来你的应用。</p>
<h3 id="RPC-底层是怎么实现的"><a href="#RPC-底层是怎么实现的" class="headerlink" title="RPC 底层是怎么实现的"></a>RPC 底层是怎么实现的</h3><p>　　之前有看过几个帖子，评论区有激烈的争吵，主要围绕两点，具体如下：</p>
<p>  　　1. HTTP 和 RPC 是同一级别，还是被 RPC 包含？</p>
<p>  　　2. Restful 也属于 RPC 吗？</p>
<p>　　对于以上两个问题，这里用一个图来一一说明：</p>
<p>　　<img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-RPC%E5%92%8CHTTP%E5%8C%BA%E5%88%AB/2.png" alt="img"></p>
<p>　　上图是一个比较完整的关系图，这时我们发现HTTP（图中蓝色框）出现了两次。</p>
<p>　　其中一个是 和 RPC并列的，都是跨应用调用方法的解决方案；</p>
<p>　　另一个则是被RPC包含的，是RPC通信过程的可选协议之一。</p>
<p>　　因此，<strong>第一个问题的答案是都对。看指的是哪一个蓝色框。</strong>从题主的提问看，既然题主在纠结这两者，应该是指与RPC并列的蓝色框。</p>
<p>　　<strong>第二个问题</strong>是在问远程过程调用（红色框）是不是包含了Restful（黄色框），这种理解的关键在于对RPC的理解。</p>
<p>　　RPC字面理解是”远程过程调用”，即在一个应用中调用另一个应用的方法。那Restful是满足的，通过它可以实现在一个应用中调用另一个应用的方法。</p>
<p>　　但是，上述理解使得RPC的定义过于宽泛。RPC通常特指在一个应用中调用另一个应用的接口而实现的远程调用，即红色框所指的范围。这样，RPC是不包含Restful的。</p>
<p>　　因此，<strong>第二个问题的答案是Restful不属于RPC。</strong></p>
<p>　　RPC的英文全称是：Remote Procedure Call，翻译为中文叫 “远程过程调用”。其中稍显晦涩的其实就是“过程”，过程其实就是“方法”。所以，可以把RPC理解为“远程方法调用”。</p>
<p>　　要了解远程过程调用，那先理解过程调用。非常简单，如下图，就是调用一个方法。这太常见了，不多解释。</p>
<p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-RPC%E5%92%8CHTTP%E5%8C%BA%E5%88%AB/3.png" alt="img"></p>
<p> 　而在分布式系统中，因为每个服务的边界都很小，很有可能调用别的服务提供的方法。这就出现了服务A 调用 服务B 中方法的需求，即远程过程调用。</p>
<p>　　要想让服务A 调用 服务B 中的方法，最先想到的就是通过 HTTP 请求实现。是的，这是很常见的，例如 服务B 暴露 Restful接口，然后让 服务A 调用它的接口。基于Restful的调用方式因为可读性好（服务B暴露出的是Restful接口，可读性当然好）而且HTTP请求可以通过各种防火墙，因此非常不错。</p>
<p>　　然而，如前面所述，基于Restful的远程过程调用有着明显的缺点，主要是效率低、封装调用复杂。当存在大量的服务间调用时，这些缺点变得更为突出。</p>
<p>　　服务A 调用 服务B 的过程是应用间的内部过程，<strong>牺牲可读性提升效率、易用性是可取的</strong>。基于这种思路，RPC产生了。</p>
<p>　　通常，RPC要求在调用方中放置被调用的方法的接口。<strong>调用方只要调用了这些接口，就相当于调用了被调用方的实际方法，十分易用</strong>。于是，调用方可以像调用内部接口一样调用远程的方法，而不用封装参数名和参数值等操作。</p>
<p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-RPC%E5%92%8CHTTP%E5%8C%BA%E5%88%AB/4.png" alt="img"></p>
<p> 　那要想实现这个过程该怎么办呢？别急，咱们一步一步来。</p>
<p>　　第一、首先，调用方调用的是接口，必须得为接口构造一个假的实现。显然，要使用动态代理。这样，调用方的调用就被动态代理接收到了。</p>
<p>　　第二、动态代理接收到调用后，应该想办法调用远程的实际实现。这包括下面几步：</p>
<p>   　　　　1. 识别具体要调用的远程方法的 IP、端口</p>
<pre><code>      2. 将调用方法的入参进行序列化

            　　　　3. 通过通信将请求发送到远程的方法中
</code></pre>
<p>　　第三、这样，远程的服务就接收到了调用方的请求。它应该：</p>
<p>   　　　　1. 反序列化各个调用参数</p>
<pre><code>      2. 定位到实际要调用的方法，然后输入参数，执行方法

            　　　　3. 按照调用的路径返回调用的结果
</code></pre>
<p>　　整个过程如下所示。</p>
<p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-RPC%E5%92%8CHTTP%E5%8C%BA%E5%88%AB/5.png" alt="img"></p>
<p> 　这样，RPC操作就完成了。</p>
<p>　　调用方调用内部的一个方法，但是被RPC框架偷梁换柱为远程的一个方法。之间的<strong>通信数据可读性不需要好</strong>，只需要RPC框架能读懂即可，因此<strong>效率可以更高</strong>。通常使用UDP或者TCP作为通讯协议，当然也可以使用HTTP。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>HTTP</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-TCP保证高可靠的方式</title>
    <url>/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>相信大家都知道 TCP 是一个可靠传输的协议，那它是如何保证可靠的呢？</p>
<p>为了实现可靠性传输，需要考虑很多事情，例如数据的破坏、丢包、重复以及分片顺序混乱等问题。如不能解决这些问题，也就无从谈起可靠传输。</p>
<p>那么，TCP 是通过序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输的。</p>
<p>今天，将重点介绍 TCP 的<strong>重传机制、滑动窗口、流量控制、拥塞控制</strong>。<br><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%96%B9%E5%BC%8F/1.png" alt="在这里插入图片描述"></p>
<h2 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h2><p>TCP 实现可靠传输的方式之一，是通过序列号与确认应答。</p>
<p>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。<br><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%96%B9%E5%BC%8F/2.png" alt="在这里插入图片描述"><br>但在错综复杂的网络，并不一定能如上图那么顺利能正常的数据传输，万一数据在传输过程中丢失了呢？</p>
<p>所以 TCP 针对数据包丢失的情况，会用<strong>重传机制</strong>解决。</p>
<p>接下来说说常见的重传机制：</p>
<p><strong>超时重传<br>快速重传<br>SACK<br>D-SACK</strong></p>
<h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p>重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据，也就是我们常说的超时重传。</p>
<p>TCP 会在以下两种情况发生超时重传：</p>
<p>数据包丢失</p>
<p>确认应答丢失<br><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%96%B9%E5%BC%8F/3.png" alt="在这里插入图片描述"><br>超时时间应该设置为多少呢？<br>我们先来了解一下什么是 <strong>RTT</strong>（Round-Trip Time 往返时延），从下图我们就可以知道：<br><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%96%B9%E5%BC%8F/4.png" alt="在这里插入图片描述"><br><strong>RTT</strong> 就是<strong>数据从网络一端传送到另一端所需的时间</strong>，也就是包的往返时间。</p>
<p>超时重传时间是以 <strong>RTO</strong> （Retransmission Timeout 超时重传时间）表示。</p>
<p>假设在重传的情况下，超时时间 <strong>RTO</strong> 「较长或较短」时，会发生什么事情呢？<br><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%96%B9%E5%BC%8F/5.png" alt="在这里插入图片描述"><br>上图中有两种超时时间不同的情况：</p>
<p>当超时时间 <strong>RTO 较大</strong>时，重发就慢，丢了老半天才重发，没有效率，性能差；</p>
<p>当超时时间 <strong>RTO 较小</strong>时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</p>
<p>精确的测量超时时间 <strong>RTO</strong> 的值是非常重要的，这可让我们的重传机制更高效。</p>
<p>根据上述的两种情况，我们可以得知，<strong>超时重传时间 RTO 的值应该略大于报文往返  RTT 的值</strong>。<br><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%96%B9%E5%BC%8F/6.png" alt="在这里插入图片描述"><br>至此，可能大家觉得超时重传时间 <strong>RTO</strong> 的值计算，也不是很复杂嘛。</p>
<p>好像就是在发送端发包时记下 <strong>t0</strong> ，然后接收端再把这个 <strong>ack</strong> 回来时再记一个 <strong>t1</strong>，于是 <strong>RTT &#x3D; t1 – t0</strong>。没那么简单，<strong>这只是一个采样，不能代表普遍情况</strong>。</p>
<p>实际上「报文往返 RTT 的值」是经常变化的，因为我们的网络也是时常变化的。也就因为「报文往返 RTT 的值」 是经常波动变化的，所以「超时重传时间 RTO 的值」应该是一个<strong>动态变化的值</strong>。</p>
<p>我们来看看 Linux 是如何计算 <strong>RTO</strong> 的呢？</p>
<p>估计往返时间，通常需要采样以下两个：</p>
<p>需要 TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个平滑 RTT 的值，而且这个值还是要不断变化的，因为网络状况不断地变化。</p>
<p>除了采样 RTT，还要采样 RTT 的波动范围，这样就避免如果 RTT 有一个大的波动的话，很难被发现的情况。</p>
<p>RFC6289 建议使用以下的公式计算 RTO：<br><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%96%B9%E5%BC%8F/7.png" alt="在这里插入图片描述"><br>其中 <strong>SRTT</strong> 是计算平滑的RTT ，<strong>DevRTR</strong> 是计算平滑的RTT 与 最新 RTT 的差距。</p>
<p>在 Linux 下，<strong>α &#x3D; 0.125，β &#x3D; 0.25， μ &#x3D; 1，∂ &#x3D; 4</strong>。别问怎么来的，问就是大量实验中调出来的。</p>
<p>如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是<strong>超时间隔加倍</strong>。</p>
<p>也就是<strong>每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。</strong></p>
<p>超时触发重传存在的问题是，超时周期可能相对较长。那是不是可以有更快的方式呢？</p>
<p>于是就可以用「快速重传」机制来解决超时重发的时间等待。</p>
<h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p>TCP 还有另外一种<strong>快速重传（Fast Retransmit）机制</strong>，它<strong>不以时间为驱动，而是以数据驱动重传</strong>。</p>
<p>快速重传机制，是如何工作的呢？其实很简单，一图胜千言。<br><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%96%B9%E5%BC%8F/8.png" alt="在这里插入图片描述"><br>在上图，发送方发出了 1，2，3，4，5 份数据：</p>
<p>第一份 Seq1 先送到了，于是就 Ack 回 2；</p>
<p>结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；</p>
<p>后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；</p>
<p><strong>发送端收到了三个 Ack &#x3D; 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。</strong></p>
<p>最后，接收到收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。</p>
<p>所以，快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</p>
<p>快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是<strong>重传的时候，是重传之前的一个，还是重传所有的问题。</strong></p>
<p>比如对于上面的例子，是重传 Seq2 呢？还是重传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的。</p>
<p>根据 TCP 不同的实现，以上两种情况都是有可能的。可见，这是一把双刃剑。</p>
<p>为了解决不知道该重传哪些 TCP 报文，于是就有 SACK 方法。</p>
<h3 id="SACK-方法"><a href="#SACK-方法" class="headerlink" title="SACK 方法"></a>SACK 方法</h3><p>还有一种实现重传机制的方式叫：<strong>SACK</strong>（ Selective Acknowledgment 选择性确认）。</p>
<p>这种方式需要在 TCP 头部「选项」字段里加一个 SACK 的东西，它<strong>可以将缓存的地图发送给发送方</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。</p>
<p>如下图，发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 <strong>SACK</strong> 信息发现只有 200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复。<br><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%96%B9%E5%BC%8F/9.png" alt="在这里插入图片描述"><br>如果要支持 <strong>SACK</strong>，必须双方都要支持。在 Linux 下，可以通过 net.ipv4.tcp_sack 参数打开这个功能（Linux 2.4 后默认打开）。</p>
<h3 id="Duplicate-SACK"><a href="#Duplicate-SACK" class="headerlink" title="Duplicate SACK"></a>Duplicate SACK</h3><p>Duplicate SACK 又称 D-SACK，其主要<strong>使用了 SACK 来告诉「发送方」有哪些数据被重复接收了</strong>。</p>
<p>下面举例两个栗子，来说明 D-SACK 的作用。</p>
<p><em>栗子一号：ACK 丢包</em><br><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%96%B9%E5%BC%8F/10.png" alt="在这里插入图片描述"><br>「接收方」发给「发送方」的两个 ACK 确认应答都丢失了，所以发送方超时后，重传第一个数据包（3000 ~ 3499）</p>
<p><strong>于是「接收方」发现数据是重复收到的，于是回了一个 SACK &#x3D; 3000<del>3500，告诉「发送方」 3000</del>3500</strong> 的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个 SACK 就代表着 D-SACK。</p>
<p>这样「发送方」就知道了，数据没有丢，是「接收方」的 ACK 确认报文丢了。</p>
<p><em>栗子二号：网络延时</em></p>
<p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%96%B9%E5%BC%8F/11.png" alt="在这里插入图片描述"><br>数据包（1000~1499） 被网络延迟了，导致「发送方」没有收到 Ack 1500 的确认报文。</p>
<p>而后面报文到达的三个相同的 ACK 确认报文，就触发了快速重传机制，但是在重传后，被延迟的数据包（1000~1499）又到了「接收方」；</p>
<p><strong>所以「接收方」回了一个 SACK&#x3D;1000~1500，因为 ACK 已经到了 3000，所以这个 SACK 是 D-SACK，表示收到了重复的包。</strong></p>
<p>这样发送方就知道快速重传触发的原因不是发出去的包丢了，也不是因为回应的 ACK 包丢了，而是因为网络延迟了。</p>
<p>可见，<strong>D-SACK</strong> 有这么几个好处：</p>
<p>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</p>
<p>可以知道是不是「发送方」的数据包被网络延迟了;</p>
<p>可以知道网络中是不是把「发送方」的数据包给复制了;</p>
<p>在 Linux 下可以通过 <strong>net.ipv4.tcp_dsack</strong> 参数开启&#x2F;关闭这个功能（Linux 2.4 后默认打开）。</p>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>引入窗口概念的原因</p>
<p>我们都知道 TCP 是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。</p>
<p>这个模式就有点像我和你面对面聊天，你一句我一句。但这种方式的缺点是效率比较低的。</p>
<p>如果你说完一句话，我在处理其他事情，没有及时回复你，那你不是要干等着我做完其他事情后，我回复你，你才能说下一句话，很显然这不现实。<br><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%96%B9%E5%BC%8F/12.png" alt="在这里插入图片描述"><br>所以，这样的传输方式有一个缺点：<strong>数据包的往返时间越长，通信的效率就越低</strong>。</p>
<p>为解决这个问题，TCP 引入了<strong>窗口</strong>这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。</p>
<p>那么有了窗口，就可以指定窗口大小，窗口大小就是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。</p>
<p>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p>
<p>假设窗口大小为 3 个 TCP 段，那么发送方就可以「连续发送」 3 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」。如下图：<br><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%96%B9%E5%BC%8F/13.png" alt="在这里插入图片描述"><br>图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通话下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫<strong>累计确认</strong>或者<strong>累计应答</strong>。</p>
<p>窗口大小由哪一方决定？</p>
<p>TCP 头里有一个字段叫 <strong>Window</strong>，也就是窗口大小。</p>
<p><strong>这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</strong></p>
<p>所以，通常窗口的大小是由接收方的决定的。</p>
<p>发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。</p>
<h4 id="发送方的滑动窗口"><a href="#发送方的滑动窗口" class="headerlink" title="发送方的滑动窗口"></a>发送方的滑动窗口</h4><p>我们先来看看发送方的窗口，下图就是发送方缓存的数据，根据处理的情况分成四个部分，其中深蓝色方框是发送窗口，紫色方框是可用窗口：<br><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%96%B9%E5%BC%8F/14.png" alt="在这里插入图片描述"><br>#1 是已发送并收到 ACK确认的数据：1~31 字节</p>
<p>#2 是已发送但未收到 ACK确认的数据：32~45 字节</p>
<p>#3 是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51字节</p>
<p>#4 是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后</p>
<p>在下图，当发送方把数据「全部」都一下发送出去后，可用窗口的大小就为 0 了，表明可用窗口耗尽，在没收到 ACK 确认之前是无法继续发送数据了。<br><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%96%B9%E5%BC%8F/15.png" alt="在这里插入图片描述"><br>在下图，当收到之前发送的数据 32<del>36 字节的 ACK 确认应答后，如果发送窗口的大小没有变化，则<strong>滑动窗口往右边移动 5 个字节，因为有 5 个字节的数据被应答确认</strong>，接下来 52</del>56 字节又变成了可用窗口，那么后续也就可以发送 52~56 这 5 个字节的数据了。<br><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%96%B9%E5%BC%8F/16.png" alt="在这里插入图片描述"></p>
<h4 id="程序是如何表示发送方的四个部分的呢？"><a href="#程序是如何表示发送方的四个部分的呢？" class="headerlink" title="程序是如何表示发送方的四个部分的呢？"></a>程序是如何表示发送方的四个部分的呢？</h4><p>TCP 滑动窗口方案使用三个指针来跟踪在四个传输类别中的每一个类别中的字节。其中两个指针是绝对指针（指特定的序列号），一个是相对指针（需要做偏移）。<br><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%96%B9%E5%BC%8F/17.png" alt="在这里插入图片描述"><br><strong>SND.WND</strong>：表示发送窗口的大小（大小是由接收方指定的）；</p>
<p><strong>SND.UNA</strong>：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节。</p>
<p><strong>SND.NXT</strong>：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节。</p>
<p>指向 #4 的第一个字节是个相对指针，它需要 <strong>SND.UNA</strong> 指针加上 <strong>SND.WND</strong> 大小的偏移量，就可以指向 #4 的第一个字节了。</p>
<p>那么可用窗口大小的计算就可以是：</p>
<p><strong>可用窗口大 &#x3D; SND.WND -（SND.NXT - SND.UNA）</strong></p>
<p>接收方的滑动窗口</p>
<p>接下来我们看看接收方的窗口，接收窗口相对简单一些，根据处理的情况划分成三个部分：</p>
<p>#1 + #2 是已成功接收并确认的数据（等待应用进程读取）；</p>
<p>#3 是未收到数据但可以接收的数据；</p>
<p>#4 未收到数据并不可以接收的数据；<br><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%96%B9%E5%BC%8F/18.png" alt="在这里插入图片描述"><br>其中三个接收部分，使用两个指针进行划分:</p>
<p><strong>RCV.WND</strong>：表示接收窗口的大小，它会通告给发送方。</p>
<p><strong>RCV.NXT</strong>：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 #3 的第一个字节。</p>
<p>指向 #4 的第一个字节是个相对指针，它需要 <strong>RCV.NXT</strong> 指针加上 <strong>RCV.WND</strong> 大小的偏移量，就可以指向 #4 的第一个字节了。</p>
<h4 id="接收窗口和发送窗口的大小是相等的吗？"><a href="#接收窗口和发送窗口的大小是相等的吗？" class="headerlink" title="接收窗口和发送窗口的大小是相等的吗？"></a>接收窗口和发送窗口的大小是相等的吗？</h4><p>并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。</p>
<p>因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。</p>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。</p>
<p>如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。</p>
<p>为了解决这种现象发生，<strong>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</strong></p>
<p>下面举个栗子，为了简单起见，假设以下场景：</p>
<p>客户端是接收方，服务端是发送方</p>
<p>假设接收窗口和发送窗口相同，都为 200</p>
<p>假设两个设备在整个传输过程中都保持相同的窗口大小，不受外界影响<br><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%96%B9%E5%BC%8F/19.png" alt="在这里插入图片描述"><br>根据上图的流量控制，说明下每个过程：</p>
<p>客户端向服务端发送请求数据报文。这里要说明下，本次例子是把服务端作为发送方，所以没有画出服务端的接收窗口。</p>
<p>服务端收到请求报文后，发送确认报文和 80 字节的数据，于是可用窗口 Usable 减少为 120 字节，同时 SND.NXT 指针也向右偏移 80 字节后，指向 321，这意味着下次发送数据的时候，序列号是 321。</p>
<p>客户端收到 80 字节数据后，于是接收窗口往右移动 80 字节，RCV.NXT 也就指向 321，<strong>这意味着客户端期望的下一个报文的序列号是 321，接着发送确认报文给服务端。</strong></p>
<p>服务端再次发送了 120 字节数据，于是可用窗口耗尽为 0，服务端无法在继续发送数据。</p>
<p>客户端收到 120 字节的数据后，于是接收窗口往右移动 120 字节，RCV.NXT 也就指向 441，接着发送确认报文给服务端。</p>
<p>服务端收到对 80 字节数据的确认报文后，SND.UNA 指针往右偏移后指向 321，于是可用窗口 Usable 增大到 80。</p>
<p>服务端收到对 120 字节数据的确认报文后，SND.UNA 指针往右偏移后指向 441，于是可用窗口 Usable 增大到 200。</p>
<p>服务端可以继续发送了，于是发送了 160 字节的数据后，SND.NXT 指向 601，于是可用窗口  Usable 减少到 40。</p>
<p>客户端收到 160 字节后，接收窗口往右移动了 160 字节，RCV.NXT 也就是指向了 601，接着发送确认报文给服务端。</p>
<p>服务端收到对 160 字节数据的确认报文后，发送窗口往右移动了 160 字节，于是 SND.UNA 指针偏移了 160 后指向 601，可用窗口 Usable 也就增大至了 200。</p>
<h3 id="操作系统缓冲区与滑动窗口的关系"><a href="#操作系统缓冲区与滑动窗口的关系" class="headerlink" title="操作系统缓冲区与滑动窗口的关系"></a>操作系统缓冲区与滑动窗口的关系</h3><p>前面的流量控制例子，我们假定了发送窗口和接收窗口是不变的，但是实际上，发送窗口和接收窗口中所存放的字节数，都是放在操作系统内存缓冲区中的，而操作系统的缓冲区，会被操作系统调整。</p>
<p>当应用进程没办法及时读取缓冲区的内容时，也会对我们的缓冲区造成影响。</p>
<h4 id="那操心系统的缓冲区，是如何影响发送窗口和接收窗口的呢？"><a href="#那操心系统的缓冲区，是如何影响发送窗口和接收窗口的呢？" class="headerlink" title="那操心系统的缓冲区，是如何影响发送窗口和接收窗口的呢？"></a>那操心系统的缓冲区，是如何影响发送窗口和接收窗口的呢？</h4><p>我们先来看看第一个例子。</p>
<p>当应用程序没有及时读取缓存时，发送窗口和接收窗口的变化。</p>
<p>考虑以下场景：</p>
<p>客户端作为发送方，服务端作为接收方，发送窗口和接收窗口初始大小为 360；</p>
<p>服务端非常的繁忙，当收到客户端的数据时，应用层不能及时读取数据。<br><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%96%B9%E5%BC%8F/20.png" alt="在这里插入图片描述"><br>根据上图的流量控制，说明下每个过程：</p>
<p>客户端发送 140 字节数据后，可用窗口变为 220 （360 - 140）。</p>
<p>服务端收到 140 字节数据，<strong>但是服务端非常繁忙，应用进程只读取了 40 个字节，还有 100 字节占用着缓冲区，于是接收窗口收缩到了 260 （360 - 100）</strong>，最后发送确认信息时，将窗口大小通过给客户端。</p>
<p>客户端收到确认和窗口通告报文后，发送窗口减少为 260。</p>
<p>客户端发送 180 字节数据，此时可用窗口减少到 80。</p>
<p>服务端收到 180 字节数据，<strong>但是应用程序没有读取任何数据，这 180 字节直接就留在了缓冲区，于是接收窗口收缩到了 80 （260 - 180）</strong>，并在发送确认信息时，通过窗口大小给客户端。</p>
<p>客户端收到确认和窗口通告报文后，发送窗口减少为 80。</p>
<p>客户端发送 80 字节数据后，可用窗口耗尽。</p>
<p>服务端收到 80 字节数据，<strong>但是应用程序依然没有读取任何数据，这 80 字节留在了缓冲区，于是接收窗口收缩到了 0，并在发送确认信息时，通过窗口大小给客户端。</strong></p>
<p>客户端收到确认和窗口通告报文后，发送窗口减少为 0。</p>
<p>可见最后窗口都收缩为 0 了，也就是发生了窗口关闭。当发送方可用窗口变为 0 时，发送方实际上会定时发送窗口探测报文，以便知道接收方的窗口是否发生了改变，这个内容后面会说，这里先简单提一下。</p>
<p><em>我们先来看看第二个例子。</em></p>
<p>当服务端系统资源非常紧张的时候，操心系统可能会直接减少了接收缓冲区大小，这时应用程序又无法及时读取缓存数据，那么这时候就有严重的事情发生了，会出现数据包丢失的现象。<br><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%96%B9%E5%BC%8F/21.png" alt="在这里插入图片描述"><br>说明下每个过程：</p>
<p>客户端发送 140 字节的数据，于是可用窗口减少到了 220。</p>
<p><strong>服务端因为现在非常的繁忙，操作系统于是就把接收缓存减少了 100 字节，当收到 对 140 数据确认报文后，又因为应用程序没有读取任何数据，所以 140 字节留在了缓冲区中，于是接收窗口大小从 360 收缩成了 100</strong>，最后发送确认信息时，通告窗口大小给对方。</p>
<p>此时客户端因为还没有收到服务端的通告窗口报文，所以不知道此时接收窗口收缩成了 100，客户端只会看自己的可用窗口还有 220，所以客户端就发送了 180 字节数据，于是可用窗口减少到 40。</p>
<p>服务端收到了 180 字节数据时，<strong>发现数据大小超过了接收窗口的大小，于是就把数据包丢失了</strong>。</p>
<p>客户端收到第 2 步时，服务端发送的确认报文和通告窗口报文，尝试减少发送窗口到 100，把窗口的右端向左收缩了 80，此时可用窗口的大小就会出现诡异的负值。</p>
<p>所以，如果发生了先减少缓存，再收缩窗口，就会出现丢包的现象。</p>
<p><strong>为了防止这种情况发生，TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间在减少缓存，这样就可以避免了丢包情况。</strong></p>
<h4 id="窗口关闭"><a href="#窗口关闭" class="headerlink" title="窗口关闭"></a>窗口关闭</h4><p>在前面我们都看到了，TCP 通过让接收方指明希望从发送方接收的数据大小（窗口大小）来进行流量控制。</p>
<p><strong>如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。</strong></p>
<p><strong>窗口关闭潜在的危险</strong></p>
<p>接收方向发送方通告窗口大小时，是通过 ACK 报文来通告的。</p>
<p>那么，当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，那麻烦就大了。</p>
<p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%96%B9%E5%BC%8F/22.png" alt="在这里插入图片描述"><br>这会导致发送方一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，如不不采取措施，这种相互等待的过程，会造成了死锁的现象。</p>
<p><strong>TCP 是如何解决窗口关闭时，潜在的死锁现象呢？</strong></p>
<p>为了解决这个问题，TCP 为每个连接设有一个持续定时器，<strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</strong></p>
<p>如果持续计时器超时，就会发送<strong>窗口探测 ( Window probe ) 报文</strong>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。<br><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%96%B9%E5%BC%8F/23.png" alt="在这里插入图片描述"><br>如果接收窗口仍然为 0，那么收到这个报文的一方就会重新启动持续计时器；</p>
<p>如果接收窗口不是 0，那么死锁的局面就可以被打破了。</p>
<p>窗口探查探测的次数一般为 3 此次，每次次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 RST 报文来中断连接。</p>
<h3 id="糊涂窗口综合症"><a href="#糊涂窗口综合症" class="headerlink" title="糊涂窗口综合症"></a>糊涂窗口综合症</h3><p>如果接收方太忙了，来不及取走接收窗口里的数据，那么就会导致发送方的发送窗口越来越小。</p>
<p>到最后，<strong>如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症。</strong></p>
<p>要知道，我们的 <strong>TCP + IP</strong> 头有 40 个字节，为了传输那几个字节的数据，要达上这么大的开销，这太不经济了。</p>
<p>就好像一个可以承载 50 人的大巴车，每次来了一两个人，就直接发车。除非家里有矿的大巴司机，才敢这样玩，不然迟早破产。要解决这个问题也不难，大巴司机等乘客数量超过了 25 个，才认定可以发车。</p>
<p>现举个糊涂窗口综合症的栗子，考虑以下场景：</p>
<p>接收方的窗口大小是 360 字节，但接收方由于某些原因陷入困境，假设接收方的应用层读取的能力如下：</p>
<p>接收方每接收 3 个字节，应用程序就只能从缓冲区中读取 1 个字节的数据；</p>
<p>在下一个发送方的 TCP 段到达之前，应用程序<br>还从缓冲区中读取了 40 个额外的字节；</p>
<p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%96%B9%E5%BC%8F/24.png" alt="在这里插入图片描述"><br>每个过程的窗口大小的变化，在图中都描述的很清楚了，可以发现窗口不断减少了，并且发送的数据都是比较小的了。</p>
<p>所以，糊涂窗口综合症的现象是可以发生在发送方和接收方：</p>
<p>接收方可以通告一个小的窗口</p>
<p>而发送方可以发送小数据</p>
<p>于是，要解决糊涂窗口综合症，就解决上面两个问题就可以了</p>
<p>让接收方不通告小窗口给发送方</p>
<p>让发送方避免发送小数据</p>
<p><strong>怎么让接收方不通告小窗口呢？</strong></p>
<p>接收方通常的策略如下:</p>
<p>当「窗口大小」小于 min( MSS，缓存空间&#x2F;2 ) ，也就是小于 MSS 与 1&#x2F;2 缓存大小中的最小值时，就会向发送方通告窗口为 0，也就阻止了发送方再发数据过来。</p>
<p>等到接收方处理了一些数据后，窗口大小 &gt;&#x3D; MSS，或者接收方缓存空间有一半可以使用，就可以把窗口打开让发送方发送数据过来。</p>
<p><strong>怎么让发送方避免发送小数据呢？</strong></p>
<p>发送方通常的策略:</p>
<p>使用 <strong>Nagle</strong> 算法，该算法的思路是延时处理，它满足以下两个条件中的一条才可以发送数据：</p>
<p>要等到窗口大小 &gt;&#x3D; <strong>MSS</strong> 或是 数据大小 &gt;&#x3D; <strong>MSS</strong></p>
<p>收到之前发送数据的 <strong>ack</strong> 回包</p>
<p>只要没满足上面条件中的一条，发送方一直在囤积数据，直到满足上面的发送条件。</p>
<p>另外，Nagle 算法默认是打开的，如果对于一些需要小数据包交互的场景的程序，比如，telnet 或 ssh 这样的交互性比较强的程序，则需要关闭 Nagle 算法。</p>
<p>可以在 Socket 设置 <strong>TCP_NODELAY</strong> 选项来关闭这个算法（关闭 Nagle 算法没有全局参数，需要根据每个应用自己的特点来关闭）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (char *)&amp;value, sizeof(int));</span><br></pre></td></tr></table></figure>


<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p><strong>为什么要有拥塞控制呀，不是有流量控制了吗？</strong></p>
<p>前面的流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。</p>
<p>一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。</p>
<p><strong>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….</strong></p>
<p>所以，TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。</p>
<p>于是，就有了<strong>拥塞控制</strong>，控制的目的就是<strong>避免「发送方」的数据填满整个网络</strong>。</p>
<p>为了在「发送方」调节所要发送数据的量，定义了一个叫做「<strong>拥塞窗口</strong>」的概念。</p>
<p><strong>什么是拥塞窗口？和发送窗口有什么关系呢？</strong></p>
<p>拥塞窗口 cwnd是发送方维护的一个 的状态变量，它会根据网络的拥塞程度动态变化的。</p>
<p>我们在前面提到过发送窗口 swnd 和接收窗口 rwnd 是约等于的关系，那么由于入了拥塞窗口的概念后，此时发送窗口的值是swnd &#x3D; min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。</p>
<p>拥塞窗口 <strong>cwnd</strong> 变化的规则：</p>
<p>只要网络中没有出现拥塞，<strong>cwnd</strong> 就会增大；</p>
<p>但网络中出现了拥塞，<strong>cwnd</strong> 就减少；</p>
<p><strong>那么怎么知道当前网络是否出现了拥塞呢？</strong></p>
<p>其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是<strong>发生了超时重传，就会认为网络出现了用拥塞。</strong></p>
<p><strong>拥塞控制有哪些控制算法？</strong></p>
<p>拥塞控制主要是四个算法：</p>
<p>慢启动</p>
<p>拥塞避免</p>
<p>拥塞发生</p>
<p>快速恢复</p>
<h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><p>TCP 在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动的意思就是一点一点的提高发送数据包的数量，如果一上来就发大量的数据，这不是给网络添堵吗？</p>
<p>慢启动的算法记住一个规则就行：<strong>当发送方每收到一个 ACK，就拥塞窗口 cwnd 的大小就会加 1。</strong></p>
<p>这里假定拥塞窗口 <strong>cwnd</strong> 和发送窗口 <strong>swnd</strong> 相等，下面举个栗子：</p>
<p>连接建立完成后，一开始初始化 <strong>cwnd &#x3D; 1</strong>，表示可以传一个 MSS 大小的数据。</p>
<p>当收到一个 ACK 确认应答后，<strong>cwnd</strong> 增加 1，于是一次能够发送 2 个</p>
<p>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以比之前多发2 个，所以这一次能够发送 4 个</p>
<p>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以比之前多发 4 个，所以这一次能够发送 8 个。</p>
<p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%96%B9%E5%BC%8F/25.png" alt="慢启动算法"><br>可以看出慢启动算法，发包的个数是指数性的增长。</p>
<h4 id="那慢启动涨到什么时候是个头呢？"><a href="#那慢启动涨到什么时候是个头呢？" class="headerlink" title="那慢启动涨到什么时候是个头呢？"></a>那慢启动涨到什么时候是个头呢？</h4><p>有一个叫慢启动门限  <strong>ssthresh</strong> （slow start threshold）状态变量。</p>
<p>当 <strong>cwnd &lt; ssthresh</strong> 时，使用慢启动算法。</p>
<p>当 <strong>cwnd &gt;&#x3D; ssthresh</strong> 时，就会使用「拥塞避免算法」。</p>
<h4 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h4><p>前面说道，当拥塞窗口 cwnd 「超过」慢启动门限 ssthresh 就会进入拥塞避免算法。</p>
<p>一般来说 <strong>ssthresh</strong> 的大小是 <strong>65535</strong> 字节。</p>
<p>那么进入拥塞避免算法后，它的规则是：<strong>每当收到一个 ACK 时，cwnd 增加 1&#x2F;cwnd。</strong></p>
<p>接上前面的慢启动的栗子，现假定 <strong>ssthresh</strong> 为 8：</p>
<p>当 8 个 ACK 应答确认到来时，每个确认增加 1&#x2F;8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 MSS 大小的数据，变成了<strong>线性增长</strong>。</p>
<p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%96%B9%E5%BC%8F/26.png" alt="拥塞避免"><br>所以，我们可以发现，拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。</p>
<p>就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。</p>
<p>当触发了重传机制，也就进入了「拥塞发生算法」。</p>
<h3 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a>拥塞发生</h3><p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：</p>
<p>超时重传</p>
<p>快速重传</p>
<p>这两种使用的拥塞发送算法是不同的，接下来分别来说说。</p>
<h4 id="发生超时重传的拥塞发生算法"><a href="#发生超时重传的拥塞发生算法" class="headerlink" title="发生超时重传的拥塞发生算法"></a>发生超时重传的拥塞发生算法</h4><p>当发生了「超时重传」，则就会使用拥塞发生算法。</p>
<p>这个时候，sshresh 和 cwnd 的值会发生变化：</p>
<p>ssthresh 设为 <strong>cwnd&#x2F;2</strong>，</p>
<p><strong>cwnd</strong> 重置为 1<br><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%96%B9%E5%BC%8F/27.png" alt="在这里插入图片描述"><br>接着，就重新开始慢启动，慢启动是会突然减少数据流的。这真是一旦「超时重传」，马上回到解放前。但是这种方式太激进了，反应也很强烈，会造成网络卡顿。</p>
<p>就好像本来在秋名山高速漂移着，突然来个紧急刹车，轮胎受得了吗。。。</p>
<p><strong>发生快速重传的拥塞发生算法</strong></p>
<p>还有更好的方式，前面我们讲过「快速重传算法」。当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。</p>
<p>TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 <strong>ssthresh</strong> 和 <strong>cwnd</strong> 变化如下：</p>
<p><strong>cwnd &#x3D; cwnd&#x2F;2</strong> ，也就是设置为原来的一半;</p>
<p><strong>ssthresh &#x3D; cwnd</strong>;</p>
<p>进入快速恢复算法</p>
<h3 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h3><p>快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 <strong>RTO</strong> 超时那么强烈。</p>
<p>正如前面所说，进入快速恢复之前，<strong>cwnd</strong> 和 <strong>ssthresh</strong> 已被更新了：</p>
<p><strong>cwnd &#x3D; cwnd&#x2F;2</strong> ，也就是设置为原来的一半;</p>
<p><strong>ssthresh &#x3D; cwnd;</strong></p>
<p>然后，进入快速恢复算法如下：</p>
<p>拥塞窗口 <strong>cwnd &#x3D; ssthresh + 3</strong> （ 3 的意思是确认有 3 个数据包被收到了）</p>
<p>重传丢失的数据包</p>
<p>如果再收到重复的 ACK，那么 cwnd 增加 1</p>
<p>如果收到新数据的 ACK 后，设置 cwnd 为 ssthresh，接着就进入了拥塞避免算法</p>
<p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%96%B9%E5%BC%8F/28.png" alt="快速重传和快速恢复"><br>也就是没有像「超时重传」一夜回到解放前，而是还在比较高的值，后续呈线性增长。</p>
<hr>
<p><strong>巨人的肩膀</strong><br>[1] 趣谈网络协议专栏.刘超.极客时间</p>
<p>[2] Web协议详解与抓包实战专栏.陶辉.极客时间</p>
<p>[3] TCP&#x2F;IP详解 卷1：协议.范建华 译.机械工业出版社</p>
<p>[4] 图解TCP&#x2F;IP.竹下隆史.人民邮电出版社</p>
<p>[5] The TCP&#x2F;IP Guide.Charles M. Kozierok.</p>
<p>[6] TCP那些事（上）.陈皓.酷壳博客.<br><a href="https://coolshell.cn/articles/11564.html">https://coolshell.cn/articles/11564.html</a></p>
<p>[7] TCP那些事（下）.陈皓.酷壳博客.<a href="https://coolshell.cn/articles/11609.html">https://coolshell.cn/articles/11609.html</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>HTTP</tag>
        <tag>RPC</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-图解网络书籍</title>
    <url>/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E4%B9%A6%E7%B1%8D/</url>
    <content><![CDATA[<p>图解网络</p>
<div class="pdf-container" data-target="./图解网络.pdf" data-height="1000px"></div>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>HTTP</tag>
        <tag>RPC</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-网络是怎样连接的书籍</title>
    <url>/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B9%A6%E7%B1%8D/</url>
    <content><![CDATA[<p>网络是怎样连接的</p>
<div class="pdf-container" data-target="./网络是怎样连接的_户根勤.pdf" data-height="1000px"></div>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>HTTP</tag>
        <tag>RPC</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-有了HTTP协议为什么还要有websocket协议</title>
    <url>/2022/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%89%E4%BA%86HTTP%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89websocket%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>平时我们打开网页，比如购物网站某宝。都是点一下「列表商品」，跳转一下网页就到了「商品详情」。</p>
<p>从 HTTP 协议的角度来看，就是点一下网页上的某个按钮，<strong>前端发一次 HTTP请 求，网站返回一次 HTTP 响应</strong>。这种由客户端主动请求，服务器响应的方式也满足大部分网页的功能场景。</p>
<p>但有没有发现，这种情况下，服务器从来就「不会主动」给客户端发一次消息。就像你喜欢的女生从来不会主动找你一样。</p>
<p>但如果现在，你在刷网页的时候「右下角」突然弹出一个小广告，提示你【一个人在家偷偷才能玩哦】。</p>
<p><strong>求知，好学，勤奋</strong>，这些刻在你 DNA 里的东西都动起来了。</p>
<p>你点开后发现。</p>
<p>长相平平无奇的古某提示你”道士 9 条狗，全服横着走”。</p>
<p>影帝某辉老师跟你说”系兄弟就来砍我”。</p>
<p><img src="/2022/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%89%E4%BA%86HTTP%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89websocket%E5%8D%8F%E8%AE%AE/1.png" alt="图片"></p>
<p>来都来了，你就选了个角色进到了游戏界面里。</p>
<p><img src="/2022/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%89%E4%BA%86HTTP%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89websocket%E5%8D%8F%E8%AE%AE/2.png" alt="图片">创建角色页面</p>
<p>这时候，上来就是一个小怪，从远处走来，然后疯狂拿木棒子抽你。</p>
<p><strong>你全程没点任何一次鼠标</strong>。服务器就自动将怪物的移动数据和攻击数据源源不断发给你了。</p>
<p>这….太暖心了。</p>
<p>感动之余，问题就来了，</p>
<p>像这种<strong>看起来服务器主动发消息给客户端的场景</strong>，是怎么做到的？</p>
<p>在真正回答这个问题之前，我们先来聊下一些相关的知识背景。</p>
<p><img src="/2022/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%89%E4%BA%86HTTP%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89websocket%E5%8D%8F%E8%AE%AE/3.png" alt="图片"></p>
<h2 id="使用-HTTP-不断轮询"><a href="#使用-HTTP-不断轮询" class="headerlink" title="使用 HTTP 不断轮询"></a>使用 HTTP 不断轮询</h2><p>其实问题的痛点在于，<strong>怎么样才能在用户不做任何操作的情况下，网页能收到消息并发生变更。</strong></p>
<p>最常见的解决方案是，<strong>网页的前端代码里不断定时发 HTTP 请求到服务器，服务器收到请求后给客户端响应消息。</strong></p>
<p>这其实时一种「<strong>伪</strong>」服务器推的形式。</p>
<p>它其实并不是服务器主动发消息到客户端，而是客户端自己不断偷偷请求服务器，只是用户无感知而已。</p>
<p>用这种方式的场景也有很多，最常见的就是<strong>扫码登录</strong>。</p>
<p>比如，某信公众号平台，登录页面二维码出现之后，<strong>前端</strong>网页根本不知道用户扫没扫，于是不断去向<strong>后端</strong>服务器询问，看有没有人扫过这个码。而且是以大概 1 到 2 秒的间隔去不断发出请求，这样可以保证用户在扫码后能在 1 到 2 秒内得到及时的反馈，不至于<strong>等太久</strong>。</p>
<p><img src="/2022/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%89%E4%BA%86HTTP%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89websocket%E5%8D%8F%E8%AE%AE/4.png" alt="图片">使用HTTP定时轮询</p>
<p>但这样，会有两个比较明显的问题：</p>
<ul>
<li>当你打开 F12 页面时，你会发现满屏的 HTTP 请求。虽然很小，但这其实也消耗带宽，同时也会增加下游服务器的负担。</li>
<li>最坏情况下，用户在扫码后，需要等个 1~2 秒，正好才触发下一次 HTTP 请求，然后才跳转页面，用户会感到<strong>明显的卡顿</strong>。</li>
</ul>
<p>使用起来的体验就是，二维码出现后，手机扫一扫，然后在手机上点个确认，这时候<strong>卡顿等个 1~2 秒</strong>，页面才跳转。</p>
<p><img src="/2022/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%89%E4%BA%86HTTP%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89websocket%E5%8D%8F%E8%AE%AE/5.png" alt="图片">不断轮询查看是否有扫码</p>
<p>那么问题又来了，<strong>有没有更好的解决方案？</strong></p>
<p>有，而且实现起来成本还非常低。</p>
<h2 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h2><p>我们知道，HTTP 请求发出后，一般会给服务器留一定的时间做响应，比如 3 秒，规定时间内没返回，就认为是超时。</p>
<p>如果我们的 HTTP 请求<strong>将超时设置的很大</strong>，比如 30 秒，<strong>在这 30 秒内只要服务器收到了扫码请求，就立马返回给客户端网页。如果超时，那就立马发起下一次请求。</strong></p>
<p>这样就减少了 HTTP 请求的个数，并且由于大部分情况下，用户都会在某个 30 秒的区间内做扫码操作，所以响应也是及时的。</p>
<p><img src="/2022/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%89%E4%BA%86HTTP%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89websocket%E5%8D%8F%E8%AE%AE/6.png" alt="图片">长轮询</p>
<p>比如，某度云网盘就是这么干的。所以你会发现一扫码，手机上点个确认，电脑端网页就<strong>秒跳转</strong>，体验很好。</p>
<p><img src="/2022/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%89%E4%BA%86HTTP%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89websocket%E5%8D%8F%E8%AE%AE/7.png" alt="图片">长轮询的方式来替代</p>
<p>像这种发起一个请求，在较长时间内等待服务器响应的机制，就是所谓的<strong>长训轮机制</strong>。我们常用的消息队列 RocketMQ 中，消费者去取数据时，也用到了这种方式。</p>
<p><img src="/2022/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%89%E4%BA%86HTTP%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89websocket%E5%8D%8F%E8%AE%AE/8.png" alt="图片">RocketMQ的消费者通过长轮询获取数据</p>
<p>像这种，在用户不感知的情况下，服务器将数据推送给浏览器的技术，就是所谓的<strong>服务器推送</strong>技术，它还有个毫不沾边的英文名，<strong>comet</strong> 技术，大家听过就好。</p>
<p>上面提到的两种解决方案（不断轮询和长轮询），本质上，其实还是客户端主动去取数据。</p>
<p>对于像扫码登录这样的<strong>简单场景</strong>还能用用。但如果是网页游戏呢，游戏一般会有大量的数据需要从服务器主动推送到客户端。</p>
<p>这就得说下 <strong>websocket</strong> 了。</p>
<h2 id="websocket是什么"><a href="#websocket是什么" class="headerlink" title="websocket是什么"></a>websocket是什么</h2><p>我们知道 TCP 连接的两端，<strong>同一时间里</strong>，<strong>双方</strong>都可以<strong>主动</strong>向对方发送数据。这就是所谓的<strong>全双工</strong>。</p>
<p>而现在使用最广泛的<code>HTTP/1.1</code>，也是基于TCP协议的，<strong>同一时间里</strong>，客户端和服务器<strong>只能有一方主动</strong>发数据，这就是所谓的<strong>半双工</strong>。</p>
<p>也就是说，好好的全双工 TCP，被 HTTP&#x2F;1.1 用成了半双工。</p>
<p>为什么？</p>
<p>这是由于 HTTP 协议设计之初，考虑的是看看网页文本的场景，能做到<strong>客户端发起请求再由服务器响应</strong>，就够了，根本就没考虑网页游戏这种，客户端和服务器之间都要互相主动发大量数据的场景。</p>
<p>所以，为了更好的支持这样的场景，我们需要另外一个<strong>基于TCP的新协议</strong>。</p>
<p>于是新的应用层协议<strong>websocket</strong>就被设计出来了。</p>
<p>大家别被这个名字给带偏了。虽然名字带了个socket，但其实 <strong>socket 和 websocket 之间，就跟雷峰和雷峰塔一样，二者接近毫无关系</strong>。</p>
<p><img src="/2022/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%89%E4%BA%86HTTP%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89websocket%E5%8D%8F%E8%AE%AE/9.png" alt="图片">websocket在四层网络协议中的位置</p>
<h3 id="怎么建立websocket连接"><a href="#怎么建立websocket连接" class="headerlink" title="怎么建立websocket连接"></a>怎么建立websocket连接</h3><p>我们平时刷网页，一般都是在浏览器上刷的，一会刷刷图文，这时候用的是 <strong>HTTP 协议</strong>，一会打开网页游戏，这时候就得切换成我们新介绍的 <strong>websocket 协议</strong>。</p>
<p>为了兼容这些使用场景。浏览器在 <strong>TCP 三次握手</strong>建立连接之后，都<strong>统一使用 HTTP 协议</strong>先进行一次通信。</p>
<ul>
<li>如果此时是<strong>普通的 HTTP 请求</strong>，那后续双方就还是老样子继续用普通 HTTP 协议进行交互，这点没啥疑问。</li>
<li>如果这时候是<strong>想建立 websocket 连接</strong>，就会在 HTTP 请求里带上一些<strong>特殊的header 头</strong>，如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Key: T2a6wZlAwhgQNqruZ2YUyg==\r\n</span><br></pre></td></tr></table></figure>

<p>这些 header 头的意思是，浏览器想<strong>升级协议（Connection: Upgrade）</strong>，并且<strong>想升级成 websocket 协议（Upgrade: websocket）</strong>。同时带上一段<strong>随机生成的 base64 码（Sec-WebSocket-Key）</strong>，发给服务器。</p>
<p>如果服务器正好支持升级成 websocket 协议。就会走 websocket 握手流程，同时根据客户端生成的 base64 码，用某个<strong>公开的</strong>算法变成另一段字符串，放在 HTTP 响应的 <code>Sec-WebSocket-Accept</code> 头里，同时带上<code>101状态码</code>，发回给浏览器。HTTP 的响应如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols\r\n</span><br><span class="line">Sec-WebSocket-Accept: iBJKv/ALIW2DobfoA4dmr3JHBCY=\r\n</span><br><span class="line">Upgrade: websocket\r\n</span><br><span class="line">Connection: Upgrade\r\n</span><br></pre></td></tr></table></figure>

<p>HTTP 状态码&#x3D;200（正常响应）的情况，大家见得多了。101 确实不常见，它其实是指<strong>协议切换</strong>。</p>
<p><img src="/2022/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%89%E4%BA%86HTTP%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89websocket%E5%8D%8F%E8%AE%AE/10.png" alt="图片">base64转为新的字符串</p>
<p>之后，浏览器也用同样的<strong>公开算法</strong>将<code>base64码</code>转成另一段字符串，如果这段字符串跟服务器传回来的<strong>字符串一致</strong>，那验证通过。</p>
<p><img src="/2022/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%89%E4%BA%86HTTP%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89websocket%E5%8D%8F%E8%AE%AE/11.png" alt="图片">对比客户端和服务端生成的字符串</p>
<p>就这样经历了一来一回两次 HTTP 握手，websocket就建立完成了，后续双方就可以使用 webscoket 的数据格式进行通信了。</p>
<p><img src="/2022/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%89%E4%BA%86HTTP%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89websocket%E5%8D%8F%E8%AE%AE/12.png" alt="图片">建立websocket连接.drawio</p>
<h3 id="websocket抓包"><a href="#websocket抓包" class="headerlink" title="websocket抓包"></a>websocket抓包</h3><p>我们可以用wireshark抓个包，实际看下数据包的情况。</p>
<p><img src="/2022/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%89%E4%BA%86HTTP%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89websocket%E5%8D%8F%E8%AE%AE/13.png" alt="图片">客户端请求升级为websocket</p>
<p>上面这张图，注意画了红框的第<code>2445</code>行报文，是websocket的<strong>第一次握手</strong>，意思是发起了一次带有<code>特殊Header</code>的HTTP请求。</p>
<p><img src="/2022/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%89%E4%BA%86HTTP%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89websocket%E5%8D%8F%E8%AE%AE/14.png" alt="图片">服务器同意升级为websocket协议</p>
<p>上面这个图里画了红框的<code>4714</code>行报文，就是服务器在得到第一次握手后，响应的<strong>第二次握手</strong>，可以看到这也是个 HTTP 类型的报文，返回的状态码是 101。同时可以看到返回的报文 header 中也带有各种<code>websocket</code>相关的信息，比如<code>Sec-WebSocket-Accept</code>。</p>
<p><img src="/2022/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%89%E4%BA%86HTTP%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89websocket%E5%8D%8F%E8%AE%AE/15.png" alt="图片">两次HTTP请求之后正式使用websocket通信</p>
<p>上面这张图就是全貌了，从截图上的注释可以看出，websocket和HTTP一样都是基于TCP的协议。<strong>经历了三次TCP握手之后，利用 HTTP 协议升级为 websocket 协议</strong>。</p>
<p>你在网上可能会看到一种说法：”websocket 是基于HTTP的新协议”，<strong>其实这并不对</strong>，因为websocket只有在建立连接时才用到了HTTP，<strong>升级完成之后就跟HTTP没有任何关系了</strong>。</p>
<p>这就好像你喜欢的女生通过你要到了你大学室友的微信，然后他们自己就聊起来了。你能说这个女生是通过你去跟你室友沟通的吗？不能。你跟HTTP一样，都只是个<strong>工具人</strong>。</p>
<p><img src="/2022/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%89%E4%BA%86HTTP%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89websocket%E5%8D%8F%E8%AE%AE/16.png" alt="图片">都是工具人</p>
<p>这就有点”<strong>借壳生蛋</strong>“的那意思。</p>
<p><img src="/2022/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%89%E4%BA%86HTTP%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89websocket%E5%8D%8F%E8%AE%AE/17.png" alt="图片">HTTP和websocket的关系</p>
<h3 id="websocket的消息格式"><a href="#websocket的消息格式" class="headerlink" title="websocket的消息格式"></a>websocket的消息格式</h3><p>上面提到在完成协议升级之后，两端就会用webscoket的数据格式进行通信。</p>
<p>数据包在websocket中被叫做<strong>帧</strong>，我们来看下它的数据格式长什么样子。</p>
<p><img src="/2022/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%89%E4%BA%86HTTP%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89websocket%E5%8D%8F%E8%AE%AE/18.png" alt="图片">websocket报文格式</p>
<p>这里面字段很多，但我们只需要关注下面这几个。</p>
<p><strong>opcode字段</strong>：这个是用来标志这是个<strong>什么类型</strong>的数据帧。比如。</p>
<ul>
<li>等于 1 ，是指text类型（<code>string</code>）的数据包</li>
<li>等于 2 ，是二进制数据类型（<code>[]byte</code>）的数据包</li>
<li>等于 8 ，是关闭连接的信号</li>
</ul>
<p><strong>payload字段</strong>：存放的是我们<strong>真正想要传输的数据的长度</strong>，单位是<strong>字节</strong>。比如你要发送的数据是<code>字符串&quot;111&quot;</code>，那它的长度就是<code>3</code>。</p>
<p><img src="/2022/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%89%E4%BA%86HTTP%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89websocket%E5%8D%8F%E8%AE%AE/19.png" alt="图片">img</p>
<p>另外，可以看到，我们存放** payload 长度的字段有好几个**，我们既可以用最前面的<code>7bit</code>, 也可以用后面的<code>7+16bit 或 7+64bit。</code></p>
<p>那么问题就来了。</p>
<p>我们知道，在数据层面，大家都是 01 二进制流。我怎么知道<strong>什么情况下应该读 7 bit，什么情况下应该读7+16bit呢？</strong></p>
<p>websocket会用最开始的7bit做标志位。不管接下来的数据有多大，都<strong>先读最先的7个bit</strong>，根据它的取值决定还要不要再读个 16bit 或 64bit。</p>
<ul>
<li>如果<code>最开始的7bit</code>的值是 0~125，那么它就表示了 <strong>payload 全部长度</strong>，只读最开始的<code>7个bit</code>就完事了。</li>
</ul>
<p><img src="/2022/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%89%E4%BA%86HTTP%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89websocket%E5%8D%8F%E8%AE%AE/20.png" alt="图片">payload长度在0到125之间</p>
<ul>
<li>如果是<code>126（0x7E）</code>。那它表示payload的长度范围在 <code>126~65535</code> 之间，接下来还需要<strong>再读16bit</strong>。这16bit会包含payload的真实长度。</li>
</ul>
<p><img src="/2022/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%89%E4%BA%86HTTP%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89websocket%E5%8D%8F%E8%AE%AE/21.png" alt="图片">payload长度在126到65535之间</p>
<ul>
<li>如果是<code>127（0x7F）</code>。那它表示payload的长度范围<code>&gt;=65536</code>，接下来还需要<strong>再读64bit</strong>。这64bit会包含payload的长度。这能放2的64次方byte的数据，换算一下好多个TB，肯定够用了。</li>
</ul>
<p><img src="/2022/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%89%E4%BA%86HTTP%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89websocket%E5%8D%8F%E8%AE%AE/22.png" alt="图片">payload长度大于等于65536的情况</p>
<p><strong>payload data字段</strong>：这里存放的就是真正要传输的数据，在知道了上面的payload长度后，就可以根据这个值去截取对应的数据。</p>
<p>大家有没有发现一个小细节，websocket的数据格式也是<strong>数据头（内含payload长度） + payload data</strong> 的形式。</p>
<p><img src="/2022/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%89%E4%BA%86HTTP%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89websocket%E5%8D%8F%E8%AE%AE/23.png" alt="图片"></p>
<p>这是因为 TCP 协议本身就是全双工，但直接使用<strong>纯裸TCP</strong>去传输数据，会有<strong>粘包</strong>的”问题”。为了解决这个问题，上层协议一般会用<strong>消息头+消息体</strong>的格式去重新包装要发的数据。</p>
<p>而<strong>消息头</strong>里一般含有<strong>消息体的长度</strong>，通过这个长度可以去截取真正的消息体。</p>
<p>HTTP 协议和大部分 RPC 协议，以及我们今天介绍的websocket协议，都是这样设计的。</p>
<p><img src="/2022/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%89%E4%BA%86HTTP%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89websocket%E5%8D%8F%E8%AE%AE/24.png" alt="图片">消息边界长度标志</p>
<h3 id="websocket的使用场景"><a href="#websocket的使用场景" class="headerlink" title="websocket的使用场景"></a>websocket的使用场景</h3><p>websocket完美继承了 TCP 协议的<strong>全双工</strong>能力，并且还贴心的提供了解决粘包的方案。</p>
<p>它适用于<strong>需要服务器和客户端（浏览器）频繁交互</strong>的大部分场景，比如网页&#x2F;小程序游戏，网页聊天室，以及一些类似飞书这样的网页协同办公软件。</p>
<p>回到文章开头的问题，在使用 websocket 协议的网页游戏里，怪物移动以及攻击玩家的行为是<strong>服务器逻辑</strong>产生的，对玩家产生的伤害等数据，都需要由<strong>服务器主动发送给客户端</strong>，客户端获得数据后展示对应的效果。</p>
<p><img src="/2022/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%89%E4%BA%86HTTP%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89websocket%E5%8D%8F%E8%AE%AE/25.png" alt="图片">websocket的使用场景</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>TCP 协议本身是<strong>全双工</strong>的，但我们最常用的 HTTP&#x2F;1.1，虽然是基于 TCP 的协议，但它是<strong>半双工</strong>的，对于大部分需要服务器主动推送数据到客户端的场景，都不太友好，因此我们需要使用支持全双工的 websocket 协议。</li>
<li>在 HTTP&#x2F;1.1 里，只要客户端不问，服务端就不答。基于这样的特点，对于登录页面这样的简单场景，可以使用<strong>定时轮询或者长轮询</strong>的方式实现<strong>服务器推送</strong>(comet)的效果。</li>
<li>对于客户端和服务端之间需要频繁交互的复杂场景，比如网页游戏，都可以考虑使用 websocket 协议。</li>
<li>websocket 和 socket 几乎没有任何关系，只是叫法相似。</li>
<li>正因为各个浏览器都支持 HTTP协 议，所以 websocket 会先利用HTTP协议加上一些特殊的 header 头进行握手升级操作，升级成功后就跟 HTTP 没有任何关系了，之后就用 websocket 的数据格式进行收发数据。</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>HTTP</tag>
        <tag>RPC</tag>
        <tag>TCP</tag>
        <tag>websocket</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-单例模式</title>
    <url>/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>我不知道大家工作或者面试时候遇到过单例模式没，面试的话我记得我当时在17年第一次实习的时候，就遇到了单例模式，面试官是我后来的leader，当时就让我手写单例，我记得我就写出了饿汉式，懒汉式，但是并没说出懒汉和饿汉的区别，当时他给我一通解释我才知道了其中的奥秘。</p>
<p>写这篇文章之前我刻意的在我手上的项目里面去找了找，我发现单例在每个项目里面都有运用到，而且我后面所说的几种实现还基本上都涉及了，还挺有意思的。</p>
<p><strong>开篇我就给大家一个思考题</strong>：为什么不用静态方法而用单例模式？</p>
<p>问题的答案我会在最后公布，大家可以带着问题看下去，看看大家的思考是不是跟我一样的。</p>
<p>大家肯定也能经常听到身边的同学说单例很简单，自己也会，但是真到自己的时候你能就一个知识点讲的很透彻，并且能够发散思考引出更多的答案吗？或者能说出他每种模式更适合的场景么？这是值得深思的。</p>
<p>首先给单例下一个定义：<strong>在当前进程中，通过单例模式创建的类有且只有一个实例</strong>。</p>
<p>单例有如下几个特点：</p>
<ul>
<li>在Java应用中，单例模式能保证在一个JVM中，该对象只有一个实例存在</li>
<li>构造器必须是私有的，外部类无法通过调用构造器方法创建该实例</li>
<li>没有公开的set方法，外部类无法调用set方法创建该实例</li>
<li>提供一个公开的get方法获取唯一的这个实例</li>
</ul>
<p>那单例模式有什么好处呢？</p>
<ul>
<li>某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销</li>
<li>省去了new操作符，降低了系统内存的使用频率，减轻GC压力</li>
<li>系统中某些类，如spring里的controller，控制着处理流程，如果该类可以创建多个的话，系统完全乱了</li>
<li>避免了对资源的重复占用</li>
</ul>
<p>好了，单例模式的定义也清楚了，好处也了解了，先看一个饿汉式的写法</p>
<h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="comment">// 创建一个实例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造方法，防止被实例化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态get方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之所以叫饿汉式大家可以理解为他饿，他想提前把对象new出来，这样别人哪怕是<strong>第一次</strong>获取这个类对象的时候直接就存在这个类了，省去了创建类这一步的开销。</p>
<p>等我介绍完懒汉之后，对比一下大家就知道两者的区别，以及各自适用在什么场景了。</p>
<h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>线程不安全的模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉式大家可以理解为他懒，别人<strong>第一次</strong>调用的时候他发现自己的实例是空的，然后去初始化了，再赋值，后面的调用就和饿汉没区别了。</p>
<p>懒汉和饿汉的对比：大家可以发现两者的区别基本上就是第一次创作时候的开销问题，以及线程安全问题（线程不安全模式的懒汉）。</p>
<p>那有了这个对比，那他们的场景好理解了，在很多电商场景，如果这个数据是经常访问的热点数据，那我就可以在系统启动的时候使用饿汉模式提前加载（类似缓存的预热）这样哪怕是第一个用户调用都不会存在创建开销，而且调用频繁也不存在内存浪费了。</p>
<p>而懒汉式呢我们可以用在不怎么热的地方，比如那个数据你不确定很长一段时间是不是有人会调用，那就用懒汉，如果你使用了饿汉，但是过了几个月还没人调用，提前加载的类在内存中是有资源浪费的。</p>
<h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p>上面的懒汉我是故意没加锁的，大家肯定都知道懒汉的线程安全问题的吧？</p>
<p>？？？忘了？那好吧，暖男带你回忆一波吧。</p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/10.png" alt="图片"></p>
<p>在运行过程中可能存在这么一种情况：多个线程去调用getInstance方法来获取Singleton的实例，那么就有可能发生这样一种情况，当第一个线程在执行if（instance&#x3D;&#x3D;null）时，此时instance是为null的进入语句。</p>
<p>在还没有执行instance&#x3D;new Singleton()时（此时instance是为null的）第二个线程也进入了if(instance&#x3D;&#x3D;null)这个语句，因为之前进入这个语句的线程中还没有执行instance&#x3D;new Singleton()，所以它会执行instance &#x3D; new Singleton()来实例化Singleton对象，因为第二个线程也进入了if语句所以它会实例化Singleton对象。</p>
<p>这样就导致了实例化了两个Singleton对象，那怎么解决？</p>
<p>简单粗暴，加锁就好了，这是加锁之后的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造方法，防止被实例化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态get方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一种典型的时间换空间的写法，不管三七二十一，每次创建实例时先锁起来，再进行判断，严重降低了系统的处理速度。</p>
<p>有没有更好的处理方式呢？</p>
<p>有，通过双检锁做两次判断，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//先检查实例是否存在，如果不存在才进入下面的同步块</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//同步块，线程安全的创建实例</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//再次检查实例是否存在，如果不存在才真正的创建实例</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将synchronized关键字加在了内部，也就是说当调用的时候是不需要加锁的，只有在instance为null，并创建对象的时候才需要加锁，性能有一定的提升。</p>
<p>但是，这样就没有问题了吗？</p>
<p>看下面的情况：在Java指令中创建对象和赋值操作是分开进行的，也就是说instance &#x3D; new Singleton();语句是分两步执行的。</p>
<p>但是JVM并不保证这两个操作的先后顺序，也就是说有可能JVM会为新的Singleton实例分配空间，然后直接赋值给instance成员，然后再去初始化这个Singleton实例。</p>
<p>这样就可能出错了，我们以A、B两个线程为例：</p>
<ol>
<li><p>A、B线程同时进入了第一个if判断</p>
</li>
<li><p>A首先进入synchronized块，由于instance为null，所以它执行instance &#x3D; new Singleton();</p>
</li>
<li><p>由于JVM内部的优化机制，JVM先画出了一些分配给Singleton实例的空白内存，并赋值给instance成员（注意此时JVM没有开始初始化这个实例），然后A离开了synchronized块。</p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/11.png" alt="图片">B进入synchronized块，由于instance此时不是null，因此它马上离开了synchronized块并将结果返回给调用该方法的程序。</p>
</li>
<li><p>此时B线程打算使用Singleton实例，却发现它没有被初始化，于是错误发生了。</p>
</li>
</ol>
<p>加上volatile修饰Singleton，再做一次优化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//先检查实例是否存在，如果不存在才进入下面的同步块</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//同步块，线程安全的创建实例</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//再次检查实例是否存在，如果不存在才真正的创建实例</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过volatile修饰的变量，不会被线程本地缓存，所有线程对该对象的读写都会第一时间同步到主内存，从而保证多个线程间该对象的准确性</strong> </p>
<p><strong>volatile的作用</strong></p>
<ul>
<li>防止指令重排序，因为instance &#x3D; new Singleton()不是原子操作</li>
<li>保证内存可见</li>
</ul>
<p>这个是比较完美的写法了，这种方式能够安全的创建唯一的一个实例，又不会对性能有太大的影响。</p>
<p>但是由于volatile关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高，还有更优的写法吗？</p>
<p>通过静态内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 私有构造方法，防止被实例化 */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/* 此处使用一个内部类来维护单例 */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonFactory</span> &#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/* 获取实例 */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonFactory.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */</span>  </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> getInstance();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>使用内部类来维护单例的实现，JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的。</p>
<p>这样当我们第一次调用getInstance的时候，JVM能够帮我们保证instance只被创建一次，并且会保证把赋值给instance的内存初始化完毕， 这样我们就不用担心上面的问题。</p>
<p>同时该方法也只会在第一次调用的时候使用互斥机制，这样就解决了低性能问题。这样我们暂时总结一个完美的单例模式。</p>
<p>还有更完美的写法吗，通过枚举：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个枚举的元素，它就代表了Singleton的一个实例。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用枚举来实现单实例控制会更加简洁，而且JVM从根本上提供保障，绝对防止多次实例化，是更简洁、高效、安全的实现单例的方式。</p>
<p>最后这种也是我最青睐的一种（代码少）。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后大家应该都知道单例模式的写法了，也知道优劣势和使用场景了，那开头的那个问题大家心里有答案了么？</p>
<p>什么？连问题都忘了？问题：为什么不用静态方法而用单例模式？</p>
<p>两者其实都能实现我们加载的最终目的，但是他们一个是基于对象，一个是面向对象的，就像我们不面向对象也能解决问题一样，面向对象的代码提供一个更好的编程思想。</p>
<p>如果一个方法和他所在类的实例对象无关，那么它就应该是静态的，反之他就应该是非静态的。如果我们确实应该使用非静态的方法，但是在创建类时又确实只需要维护一份实例时，就需要用单例模式了。</p>
<p>我们的电商系统中就有很多类，有很多配置和属性，这些配置和属性是一定存在了，又是公共的，同时需要在整个生命周期中都存在，所以只需要一份就行，这个时候如果需要我再需要的时候new一个，再给他分配值，显然是浪费内存并且再赋值没什么意义。</p>
<p>所以我们用单例模式或静态方法去维持一份这些值有且只有这一份值，但此时这些配置和属性又是通过面向对象的编码方式得到的，我们就应该使用单例模式，或者不是面向对象的，但他本身的属性应该是面对对象的，我们使用静态方法虽然能同样解决问题，但是最好的解决方案也应该是使用单例模式。</p>
<p>资料参考：《java设计模式》、《为什么要用单例模式？》</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-原型模式</title>
    <url>/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>前言</strong></p>
<p>在设计模式的系列文章中，我们前面已经写了<strong>工厂模式</strong>、<strong>单列模式</strong>、<strong>建造者模式</strong>，在针对创建型模式中，今天想跟大家分享的是<strong>原型模式</strong></p>
<p>其实原型模式在我们的代码中是很常见的，但是又容易被我们所忽视的一种模式，那么什么是原型模式呢？</p>
<blockquote>
<p>原型模式其实就是一种克隆对象的方法，在我们的编码时候是很常见的，比如我们常用的的BeanUtils.copyProperties就是一种对象的<strong>浅copy</strong>，其实现在我们实例化对象操作并不是特别耗费性能，所以在针对一些特殊场景我们还是需要克隆那些已经实例化的对象的：</p>
<ul>
<li>依赖外部资源或硬件密集型操作，比如数据库查询，或者一些存在IO操作的场景</li>
<li>获取相同对象在相同状态的拷贝从而不需要重复创建获取状态的操作的情况</li>
</ul>
</blockquote>
<p>看下我们的类图：</p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/25.png" alt="图片"></p>
<blockquote>
<p>在上面的图中我们可以看出原型模式其实很简单：</p>
<ul>
<li>第一个是抽象原型(prototype)声明clone方法，可以是接口可以是基类，在简单的场景下我们都可以不用基类直接具体类就可以了。</li>
<li>第二个就是具体原型类(concreteprototype)实现或者扩展clone方法，当我们在具体的原型类中的对象方法时，就会返回一个基类的抽象原型对象</li>
</ul>
</blockquote>
<p>针对上面理论知识，我们还是实际的举一个例子吧!</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>假设现在我们有这么一种场景，公司搞一场活动有五万个商品参加此次活动，我们需要从后台能定时同步每个商品的销量，方便我们为后面的活动做商品分析，我们要怎么处理这个销量同步问题？</p>
<blockquote>
<p>首先在这里销量和库存都是属于热点数据，但肯定都是相互隔离的因为库存是要求实时性很高的，销量可以允许有短暂延时，只要能保证数据能够最终一致性就行，所以下单的同时我们可以根据一个MQ去更新我们数据库里的商品销量。</p>
</blockquote>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/26.png" alt="图片"></p>
<p>在我们去查看销量的时候我们不能每次都是去查DB所以我们可以通过redis缓存来处理，同时我们在缓存中记录一下我们当前查询的更新时间。</p>
<p>再次查询时通过redis数据里面的更新时间，作为查询条件去查询DB中的更新时间大于我们当前redis中的记录时间，这样就减少了SQL的扫表的行数（更新的数据与全量数据相比，更新的数据量还是占少数的）</p>
<p>基于上面流程我们开始写demo了</p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/27.png" alt="图片"></p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/28.png" alt="图片"></p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/29.png" alt="图片"></p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/30.png" alt="图片"></p>
<p>在这里demo中我们先是创建了一个ItemSold类，以及一个SkuSold类同时ItemSold重写Cloneable里面的clone方法。然后在最后的测试类mian方法中我调用了clone方法，copy一个新的商品销量类。</p>
<p>细心的同学在看结果的时候不知道有没有发现一个问题？在for循环里面，我分别打印出来的ItemSold 以及 SkuSold对象他们的内存地址。</p>
<p>复制出来的SkuSold的内存地址居然和原型地址<strong>一样</strong>，ItemSold的复制就和原型地址<strong>不一样</strong>了，针对这个问题这里我们就要聊聊<strong>原型模式</strong>的两种实现<strong>浅拷贝</strong>和<strong>深拷贝</strong>了。</p>
<blockquote>
<p>这里说明一下我们在for循环里面是做数据convert，一般来说我们不会引用底层模型来做返回结果模型，需要做一层转化，来达到防腐的效果。为了体现深浅拷贝，所以写的比较简单，具体还是需要自己根据实际情况来做。</p>
</blockquote>
<h2 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h2><blockquote>
<ul>
<li>浅拷贝：当拷贝对象只包含简单的数据类型比如int、float 或者不可变的对象（字符串）时，就直接将这些字段复制到新的对象中。而引用的对象并没有复制而是将引用对象的地址复制一份给克隆对象</li>
<li>深拷贝：不管拷贝对象里面简单数据类型还是引用对象类型都是会完全的复制一份到新的对象中</li>
</ul>
</blockquote>
<p>举个例子这就好比两兄弟大家买衣服可以一人一套，然后房子大家住在一套房子里（浅拷贝），当两个人成家立业了，房子分开了一人一套互不影响（深拷贝）</p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/31.png" alt="图片"></p>
<p>看完这张图，大家也就明白了，上面的demo是一个浅拷贝，那么我们要怎么做才能实现深拷贝呢？</p>
<p>首先我们先来看下 Java的提供的<strong>Cloneable</strong> 接口</p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/32.png" alt="图片"></p>
<p>看接口上面的解释大致可以理解为：</p>
<blockquote>
<p>一个类实现了Cloneable接口，来实现这个类的clone方法从而可以合法地对该类实例进行按字段复制，假设这个类没有实现Cloneable接口的实例上调用Object的clone()方法，则会导致抛出CloneNotSupporteddException异常。</p>
</blockquote>
<p>那么我们这里怎么实现深拷贝呢？</p>
<p>第一种：在重写ItemSold里面的clone方法时，再针对SkuSold也进行一次拷贝 （因为我们这里时List对象，只能是先拿到浅拷贝，再通过浅拷贝的List对象进行遍历再调用引用对象的clone方法来实现深拷贝）</p>
<p>这里如果引用对象存在多级情况下我们可能就要考虑用递归了实现，但是代码看上去就会复杂很多了。</p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/33.png" alt="图片"></p>
<p>第二种：通过序列化把对象写入流中再从流中取出来</p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/34.png" alt="图片"></p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/35.png" alt="图片"></p>
<p>针对上面的两种写法其实都是可以实现的，但是不管用哪种方式，深拷贝都比浅拷贝花时间和空间，所以还是酌情考虑。其实在现在已经有很多针对浅拷贝和深拷贝的工具类</p>
<ul>
<li>深拷贝(deep copy):SerializationUtils</li>
<li>浅拷贝(shallow copy):BeanUtils</li>
</ul>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>针对上面的业务场景我们也可以通过其他的方式统计商品销量，可以再通过一个MQ去增加销量的同时再去更新redis缓存，但是需要我们注意的是在针对一些核心业务数据和非核心业务数据尽量不要共用一个消费者组，防止影响核心数据的消费速率。同时我们在做设计的时候多想想这么做有什么优点，又有什么缺点，开发成本问题等。</p>
<p>其实在其他的地方我们可以用到原型模式，比如我们在发松活动的PUSH通知，针对平台百万、千万、甚至上亿的用户发送通知的时候通知的内容基本都是一样的只是推送用户不一样或者有些特别字段值的小改动，那我们这里就可以用原型模式来做，同时开启多线程来做push，需要注意的是这里的线程安全问题，所以在每个线程内部去做copy对象。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>原型模式使用起来简单，但是在我们每次在clone基类或者有引用对象的时候需要我们去修改原型对象的clone方法，这不符合我们开闭原则。</p>
<p>在一般情况下是不建议用这种模式的除非创建的对象成本特别大，或者在一些特殊场景使用，最后针对一些不常用的模式我不会详细跟大家分享，但是我会在后面做个分享总结，后面开始为大家分享行为型模式。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-工厂模式</title>
    <url>/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>1.简单工厂模式：代替new产生对象，产品的类型比较少时。</p>
<p>   我们要获得三种不同的数据库对象，如Mysql,SQLserver,Oracle，它们拥有共同的特征，即可以进行抽象，简单工厂目的是将获得具体数据库实体的任务交给工厂类。</p>
<p> 接口DataBase：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DataBase</span> &#123;</span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;</span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 类Mysql:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mysql</span> <span class="keyword">implements</span> <span class="title class_">DataBase</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;open mysql&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;close mysql&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>类Oracle:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Oracle</span> <span class="keyword">implements</span> <span class="title class_">DataBase</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;open Oracle&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;close Oracle&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>类SQLserver:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SQLServer</span> <span class="keyword">implements</span> <span class="title class_">DataBase</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;open SQLServer&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;close SQLServer&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>工厂类及测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> DataBase <span class="title function_">getDataBase</span><span class="params">(String Type)</span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(Type == <span class="literal">null</span>)&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">          &#125;        </span><br><span class="line">          <span class="keyword">if</span>(Type.equalsIgnoreCase(<span class="string">&quot;MYSQL&quot;</span>))&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Mysql</span>();</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span>(Type.equalsIgnoreCase(<span class="string">&quot;ORACLE&quot;</span>))&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Oracle</span>();</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span>(Type.equalsIgnoreCase(<span class="string">&quot;SQLSERVER&quot;</span>))&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQLServer</span>();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">     <span class="meta">@Test</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">          <span class="type">Factory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Factory</span>();      </span><br><span class="line">          DataBase d1= factory.getDataBase(<span class="string">&quot;MYSQL&quot;</span>);</span><br><span class="line">          d1.open();</span><br><span class="line">          DataBase d2= factory.getDataBase(<span class="string">&quot;ORACLE&quot;</span>);</span><br><span class="line">          d2.open();</span><br><span class="line">          DataBase d3= factory.getDataBase(<span class="string">&quot;SQLSERVER&quot;</span>);</span><br><span class="line">          d3.open();</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>   特点： 如果要新增其他数据库，只需创建新数据库类实现功能接口，修改工厂类。</p>
<p>​         问题1：根据“开闭原则”：对现有功能进行拓展，但不允许修改原有代码。很明显，这时简单工厂模式需多次修改工厂类。</p>
<p>​         问题2：使用者实际使用时并不知道类名，他只知道有DataBase这个接口,使用这个接口就能创建对象，使用open()函数,当然实际中肯定还需传入用户名和密码等参数。</p>
<p>针对问题2：可以使用枚举的方式，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factory2</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">DatabaseType</span>&#123;</span><br><span class="line">        MYSQL,</span><br><span class="line">        SQLSERVER,</span><br><span class="line">        ORACLE</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DataBase <span class="title function_">getDataBase</span><span class="params">(DatabaseType type)</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">            <span class="keyword">case</span> MYSQL:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Mysql</span>();</span><br><span class="line">            <span class="keyword">case</span> ORACLE:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Oracle</span>();</span><br><span class="line">            <span class="keyword">case</span> SQLSERVER:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQLServer</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnknownTypeException</span>(<span class="literal">null</span>, type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">       DataBase s1=Factory2.getDataBase(DatabaseType.MYSQL);</span><br><span class="line">       s1.open();</span><br><span class="line">       DataBase s2=Factory2.getDataBase(DatabaseType.ORACLE);</span><br><span class="line">       s2.open();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p> 2.工厂方法模式(Factory Method)：定义一个用于创建对象的接口，让子类决定实例化哪一个类，使一个类的实例化延迟到其子类。</p>
<p>​    使用简单工厂方式使得工厂函数很难维护，而且请求者还需知道被实例化的类，而工厂方法模式可避免之。</p>
<p>​    新建抽象工厂 IFactory，对于每个数据库都新建相应的工厂类，如MysqlFactory,OracleFactory实现 IFactory，这样在新增一种数据库时，不必修改工厂类而造成破坏封闭原则。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>  DataBase <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SqlFactory</span> <span class="keyword">implements</span> <span class="title class_">IFactory</span>&#123;</span><br><span class="line">       <span class="keyword">public</span> DataBase <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Mysql</span>();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OracleFactory</span> <span class="keyword">implements</span> <span class="title class_">IFactory</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> DataBase <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Oracle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">SQLserverFactory</span> <span class="keyword">implements</span> <span class="title class_">IFactory</span>&#123;</span><br><span class="line">     <span class="keyword">public</span> DataBase <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQLServer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//测试  </span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryMethod</span>&#123; </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">         DataBase d1=<span class="keyword">new</span> <span class="title class_">SqlFactory</span>().get();</span><br><span class="line">         d1.open();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p>​    问题1：如果数据库类型越来越多，将无限的增加工厂子类，使用者同样还是需要知道工厂子类的名称。</p>
<p>​    问题2：在使用时数据库时可能还需与其他的类相关联，工厂方法模式无法解决。</p>
<p>3.抽象工厂模式（Abstract Factory）：提供一个创建一系列相关或者相互依赖对象的接口，而无需指定它们具体的类。</p>
<p>   场景：若在新建数据库连接时需指定方言，而且不同数据库的SQL语言也不相同的情况下。</p>
<p>   组成元素：</p>
<p>​    1.方言类和接口，如图所示：</p>
<p> <img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/12.png" alt="img"></p>
<p>   2.之前的数据库类和接口</p>
<p>   <img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/13.png" alt="img"></p>
<p>   3.operFactory抽象工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">operFactory</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> IDialect dialect;       </span><br><span class="line">        <span class="keyword">abstract</span> <span class="keyword">void</span>  <span class="title function_">add</span><span class="params">()</span>;</span><br><span class="line">        <span class="keyword">abstract</span> <span class="keyword">void</span>  <span class="title function_">delete</span><span class="params">()</span>;</span><br><span class="line">        <span class="keyword">abstract</span> <span class="keyword">void</span>  <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDialect</span><span class="params">(String classname)</span>&#123;</span><br><span class="line">                IDialect cf=<span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cf=(IDialect)Class.forName(classname).newInstance();</span><br><span class="line">                    setDialect(cf);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | ClassNotFoundException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> IDialect <span class="title function_">getDialect</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dialect;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDialect</span><span class="params">(IDialect dialect)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.dialect = dialect;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>MysqlFatory，OracleFactory（ 均继承上面的抽象工厂类）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MysqlFatory</span> <span class="keyword">extends</span> <span class="title class_">operFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;    </span><br><span class="line">        System.out.println(<span class="string">&quot;使用的方言为：&quot;</span>+<span class="built_in">this</span>.getDialect().showDialect());</span><br><span class="line">        System.out.println(<span class="string">&quot;mysql add()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用的方言为：&quot;</span>+<span class="built_in">this</span>.getDialect().showDialect());</span><br><span class="line">        System.out.println(<span class="string">&quot;mysql delete()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用的方言为：&quot;</span>+<span class="built_in">this</span>.getDialect().showDialect());</span><br><span class="line">        System.out.println(<span class="string">&quot;mysql update()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OracleFactory</span> <span class="keyword">extends</span> <span class="title class_">operFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用的方言为：&quot;</span>+<span class="built_in">this</span>.getDialect().showDialect());</span><br><span class="line">        System.out.println(<span class="string">&quot;Oracle add()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用的方言为：&quot;</span>+<span class="built_in">this</span>.getDialect().showDialect());</span><br><span class="line">        System.out.println(<span class="string">&quot;Oracle delete()&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用的方言为：&quot;</span>+<span class="built_in">this</span>.getDialect().showDialect());</span><br><span class="line">        System.out.println(<span class="string">&quot;Oracle update()&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>   5.工厂构造器类 FactoryProducer 负责生成想要的数据库工厂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryProducer</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> operFactory <span class="title function_">getFactory</span><span class="params">(String class_name)</span> &#123;</span><br><span class="line">         operFactory cf=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cf=(operFactory)Class.forName(class_name).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cf;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p> 6.测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;  </span><br><span class="line">          operFactory of2=FactoryProducer.getFactory(DatabaseFactoryType.MYSQL);</span><br><span class="line">          of2.setDialect(DialectType.MySQL5InnoDBDialect);</span><br><span class="line">          of2.update();</span><br><span class="line">          </span><br><span class="line">          operFactory of= FactoryProducer.getFactory(DatabaseFactoryType.ORALCE);</span><br><span class="line">          of.setDialect(DialectType.Oracle10gDialect);</span><br><span class="line">          of.add();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>



<p> 结果：</p>
<p> <img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/14.png" alt="img"></p>
<p> 总之抽象工厂总是关于创建一系列相关或相互有依赖的对象，以上例子中即DataBase对象与Dialect对象具有相关性。但是使用者要了解各种工厂和方言。</p>
<p>三者区别：</p>
<p>​      简单工厂实现简单，扩展也很容易，但是会频繁修改工厂类代码，难以维护，在维护的时候容易引发新的BUG。</p>
<p>​      工厂方法模式则是把对象的实例化延迟到了继承的子类里面，这样就变成了扩展工厂，从而满足了“开闭”原则， 但是不支持产品切换，也就是只能满足一层的产品（算法）抽象，当需与其他对象合作时无能为力。</p>
<p>​      抽象工厂则是继续把产品进行再次抽象，最后得到一个可以支持产品切换的结构，但问题过于复杂，不过我们使用反射机制，可以弥补这个缺点，但是使用者却需要知道工厂的名称。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-建造者模式</title>
    <url>/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>什么叫建造者？他的应用场景又是什么呢？</p>
<blockquote>
<p>当我们需要实列化一个复杂的类，以得到不同结构类型和不同的内部状态的对象时，我们可以用不同的类对它们的实列化操作逻辑分别进行封装，这些类我们就称之为建造者。</p>
<p>当我们需要来之同一个类，但是要就有不同结构对象时，就可以通过构造另一个建造者来进行实列化。</p>
<p>———-以上定义来自《设计模式之美》。</p>
</blockquote>
<p>为了加深理解我们再来一个流程图</p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/15.png" alt="图片"></p>
<p>从图中我们主以看出建造者主要分为4种角色：</p>
<blockquote>
<ul>
<li>Product(产品类) :我们具体需要生成的类对象</li>
<li>Builder(抽象建造者类)：为我们需要生成的类对象，构建不同的模块属性，即：公开构建产品类的属性，隐藏产品类的其他功能</li>
<li>ConcreteBuilder(具体建造者类)：实现我们要生成的类对象</li>
<li>Director(导演类)：确定构建我们的类对象具体有哪些模块属性，在实际应用中可以不需要这个角色，直接通过client处理</li>
</ul>
</blockquote>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>在电商中有多种不同类型的商品 <strong>普通实物商品</strong>，<strong>电子卡券商品</strong>，<strong>虚拟视频学习商品</strong> 等多种不同的商品，他们都是商品但是他们的属性却不一样，电子卡券：独有券码，学习视频：独有视频链接等。</p>
<p>那我们要怎么实现这种这种创建商品呢？</p>
<p>我们先看下最普通的创建方式：</p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/16.png" alt="图片"></p>
<p>我们先创建一个基础商品Item类：</p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/17.png" alt="图片"></p>
<p>这里我们可以看到根据请求类型，也可以完全创建出我们想要的类型商品，但是一个商品属性不可能只有这么一点属性，那以后扩展更多呢？那这个代码我们看上去就会很臃肿，也不好维护。</p>
<p>接下来我们就看下建造者模式怎么去实现：</p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/18.png" alt="图片"></p>
<p>第一步：创建我们的抽象建造者类。这里面我们看下有三个抽象方法，来确定不同的商品类型，我们调用不同的方法，达到解偶的思想</p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/19.png" alt="图片"></p>
<p>第二步：创建具体建造者类。对<strong>抽象建造者类</strong>的抽象方法进行实现赋值，达到我们所需要的结果。</p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/20.png" alt="图片"></p>
<p>第三步：创建我们的导演类。指导我们怎么去创建对象，这个我们是可以简化的，视具体使用场景确定吧！</p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/21.png" alt="图片"></p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/22.png" alt="图片"></p>
<p>最后就是看我们的测试结果了。在省略导演类的时候其实我们也完全可以的构建出我们想要的结果，因为我这写的是测试demo所以没有写传参，这个大家可以根据自己的实际应用场景去做改造。</p>
<p>与普通的写法相比<strong>建造者模式</strong>的写法使的这个代码可读性高，而且易扩展，不同类型的商品达到了解耦合的效果。</p>
<h3 id="举例二："><a href="#举例二：" class="headerlink" title="举例二："></a>举例二：</h3><p>假设我们现在有另外的一种场景，我们复制一个商品时，当没有填写库存时我们默认是0，当用户填写了时我们库存数量不能大于999999999。</p>
<p>那我们要怎么去实现呢？</p>
<blockquote>
<p>PS：商品复制这个功能在电商领域是很普通的一个操作，对用户来说简化操作成本，提升用户体检。技术服务于业务，业务决定公司的长远利益</p>
</blockquote>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/23.png" alt="图片"></p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/24.png" alt="图片"></p>
<p>我们在内部创建了一个ItemBuilder，来处理我们的校验逻辑。当然我们使用普通的get，set方式其实也是可以实现的。</p>
<p>看到这里可能有人会问这个与我们使用get或者set方法又有什么区别呢？</p>
<p>解释：主要是为了解决我们的赋值处于一种无效状态</p>
<blockquote>
<p>无效状态指的是对象属性之间存在依赖关系，合法校验等，如果使用set方式会导致这种关系和校验得不到验证，所有可能会存在无效的状态，即A、B两个属性必须同时设置，缺一不可，然后set方法可能导致遗漏等</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是我要跟大家了解的建造者模式，其实我还是想跟大家分享这种思想吧，像第二个列子大家也可以用于写配置文件(<strong>比如我们的链接池，里面很多必填或者不必填参数，同时也可以避免在因为属性值过多而写构造方法时产生不好维护，不雅观的现象</strong>)等，因为我一直在电商公司工作，所以我举的列子都是以电商为主。</p>
<p>只有我们了解了每种设计模式解决了什么问题，我们才知道哪种场景用什么模式或者多种设计模式进行组合，避免产生因强行使用设计模式，反而使得代码更加的不好维护了。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-模板方法模式</title>
    <url>/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/1.png" alt="图片"></p>
<p>还是老规矩从上图五个方面来分别具体和大家聊聊模版方法模式</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>模版方法模式的定义以及目的？</p>
<blockquote>
<ul>
<li><p>定义：模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤</p>
</li>
<li><p>目的：1.使用模版方法模式的目的是避免编写重复代码，以便开发人员可以专注于核心业务逻辑的实现</p>
<p>2.解决接口与接口实现类之间继承矛盾问题</p>
<p>以上定义来自《设计模式之美》</p>
</li>
</ul>
</blockquote>
<p>结构图：</p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/2.png" alt="图片"></p>
<blockquote>
<ul>
<li>AbstractTemplate（抽象模版）：定义一系列抽象方法，或者实现的方法，又或者是钩子方法。即：定义流程</li>
<li>ConcreteTemplate（具体模版）：实现父类抽象方法，基于本身不同的模版业务逻辑，实现不同的业务逻辑代码。即：抽象方法实现相同，内部逻辑不同</li>
</ul>
</blockquote>
<p>整个结构图看起来还是很简单的，但是还是要理解设计模式解决什么问题。</p>
<p>代码实现？还是举例吧。</p>
<p>还是以上面的请假举例吧，假设现在A公司请假需要直属领导审批以及通知HR有人请假了就可以了，B公司需要直属领导，部门负责人审批最后通知HR，方能完成整个请假流程。那作为OA办公流程怎么去处理这个问题嘛？直接看代码实现吧！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AskForLeaveFlow</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一级组长直接审批</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">firstGroupLeader</span><span class="params">(String name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二级组长部门负责人审批</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">secondGroupLeader</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告知HR有人请假了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">notifyHr</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前有人请假了，请假人：&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请假流模版</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">askForLeave</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        firstGroupLeader(name);</span><br><span class="line">        secondGroupLeader(name);</span><br><span class="line">        notifyHr(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先还是定义一个请假流程，其中：</p>
<blockquote>
<p>firstGroupLeader方法为abstract修饰，则作为子类都是必须要实现的</p>
<p>secondGroupLeader 二级领导审批，在子类中可以重写，也可不重写</p>
<p>notifyHr 方法为通知HR，已经内部实现</p>
</blockquote>
<p>最后一个askForLeave请假流程方法，把以上模版方法串起来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompanyA</span> <span class="keyword">extends</span> <span class="title class_">AskForLeaveFlow</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">firstGroupLeader</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CompanyA 组内有人请假，请假人：&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompanyB</span> <span class="keyword">extends</span> <span class="title class_">AskForLeaveFlow</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">firstGroupLeader</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CompanyB 组内有人请假，请假人：&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">secondGroupLeader</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CompanyB 部门有人请假，请假人：&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在CompanyA以及CompanyB中，secondGroupLeader二级领导可以选择重写或者不重写，这个类模版方法简称为钩子方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testTemplate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 公司A请假流程模版</span></span><br><span class="line">        <span class="type">AskForLeaveFlow</span> <span class="variable">companyA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompanyA</span>();</span><br><span class="line">        companyA.askForLeave(<span class="string">&quot;敖丙&quot;</span>);</span><br><span class="line">        <span class="comment">// 结果：CompanyA 组内有人请假，请假人：敖丙</span></span><br><span class="line">        <span class="comment">//       当前有人请假了，请假人：敖丙</span></span><br><span class="line"></span><br><span class="line">        <span class="type">AskForLeaveFlow</span> <span class="variable">companyB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompanyB</span>();</span><br><span class="line">        companyB.askForLeave(<span class="string">&quot;敖丙&quot;</span>);</span><br><span class="line">        <span class="comment">// 结果：CompanyB 组内有人请假，请假人：敖丙</span></span><br><span class="line">        <span class="comment">//      CompanyB 部门有人请假，请假人：敖丙</span></span><br><span class="line">        <span class="comment">//      当前有人请假了，请假人：敖丙</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后就是看测试dome结果了。companyA和companyB分别输出了对应的请假流程。</p>
<p>细心的同学可能已经发现了，做为模版方法中里面除了可以有抽象方法外，还可以有具体的实现方法以及钩子方法。</p>
<p>所以大家在应用的过程可以多考虑考虑在内部定义模版方法时，应该定义成抽象方法还是其它的。</p>
<h2 id="框架中的应用"><a href="#框架中的应用" class="headerlink" title="框架中的应用"></a>框架中的应用</h2><p>模版方法模式在我们常见的Java的框架中也是非常常见的，只是可能我们平时没有注意到这一点而已。</p>
<p>第一个：首先我们学SpringMVC的时候，最开始都会写一些Servlet来作为处理一些post或者get请求等。</p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/3.png" alt="图片"></p>
<p>这里直接看这个源码大家就可以发现这也是直接使用模版方法模式的思想，期间在HttpServlet 继承GenericServlet中也还是模版方法的体现，这说明了可以多次抽象构建模版。</p>
<p>第二个：常见问的文件流中，Java IO 类中的InputStream、OutputStream、Reader、Writer等都能看到模版方法模式的身影。</p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/4.png" alt="图片"></p>
<p>上面是我贴出的部分InputStream的源码，主要看这个read模版方法，也就是模版方法模式的体现。</p>
<p>当然IO类中还有很多其他的，我就不一一贴源码出来了，感情兴趣的同学，可以自己打开源码了解了解。</p>
<h2 id="业务举例"><a href="#业务举例" class="headerlink" title="业务举例"></a>业务举例</h2><p><strong>在业务中怎么使用模版方法？</strong></p>
<p>首先需要理解模版方法它是为了增加代码的复用性，以及扩展性而存在的，所以本着这个思想我还是给大家举一个例子吧。</p>
<p>之前写责任链模式最后给大家举例商品详情，这次还是用商品详情，但是用模版方法模式来实现这个问题，理解为商详2.0版本。</p>
<p>商品详情展示我们可以是分模块展示的，比如头图，商品信息，sku信息，配送地址，分期付费等等。</p>
<p><strong>那么怎么进行组装到商品详情的展示呢？</strong></p>
<p>流程图：</p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/5.png" alt="图片"></p>
<p>可以看到一个请求过来，可以有模块组装器选择组装返回结果。</p>
<blockquote>
<p>提一个点，在第二步请求的模块的时候为了减少整个链路的请求时间可以考虑是串行，或者并行（开线程池处理）。</p>
</blockquote>
<p>接下来直接看代码吧</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractTemplateBlock</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 组装结果</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">template</span><span class="params">(ModelContainer modelContainer)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">block</span> <span class="operator">=</span> initBlock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.doWork(modelContainer, block);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 可以选择捕获异常，是中断流程，还是只打印日志，不中断流程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> block;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化构建返回结果模型</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title function_">initBlock</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 定义抽象模版</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">(ModelContainer modelContainer, T block)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是先创建模版Block</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ItemInfoBlock extends AbstractTemplateBlock&lt;ItemInfoBlock.ItemInfo&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected ItemInfoBlock.ItemInfo initBlock() &#123;</span><br><span class="line">        return new ItemInfoBlock.ItemInfo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 模拟业务逻辑，组装返回商品信息模块数据</span><br><span class="line">    @Override</span><br><span class="line">    protected void doWork(ModelContainer modelContainer, ItemInfo block) throws Exception &#123;</span><br><span class="line">        block.setItemId(123L);</span><br><span class="line">        block.setItemName(&quot;测试&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Data</span><br><span class="line">    public static class ItemInfo &#123;</span><br><span class="line">        private Long itemId;</span><br><span class="line">        private String itemName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只写了一个ItemInfoBlock，其他的模块也是这一样的写法，所以就不全写出来了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.模拟获取SpringBean</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:applicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="type">ItemInfoBlock</span> <span class="variable">itemInfoBlock</span> <span class="operator">=</span> (ItemInfoBlock) applicationContext.getBean(<span class="string">&quot;itemInfoBlock&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. ModelContainer可以理解为贯穿上下文中的请求参数，或者一些组装数据需要的预加载数据</span></span><br><span class="line">   <span class="type">ModelContainer</span> <span class="variable">modelContainer</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelContainer</span>();</span><br><span class="line">   <span class="comment">// 3. 获取返回结果</span></span><br><span class="line">   ItemInfoBlock.<span class="type">ItemInfo</span> <span class="variable">itemInfo</span> <span class="operator">=</span> itemInfoBlock.template(modelContainer);</span><br><span class="line">   System.out.println(JSON.toJSONString(itemInfo));</span><br><span class="line">   <span class="comment">// 结果：&#123;&quot;itemId&quot;:123,&quot;itemName&quot;:&quot;测试&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后就是看测试demo了，可以看到再每一个模块中都是有一个AbstractTemplateBlock，内部包含doWork抽象方法，由子类去实现当前自己的业务逻辑。</p>
<p>同时第三步获取返回结果时，我只是单独列出来，大家可以根据实际情况还能做改造。比如说返回map结构等 mapKey 是模块名称，value是数据。</p>
<p>当前这种组装商品详情的模式也是比较常见的一种方式。代码的复用性高，同时扩展性也有一定的体现，符合模版方法模式的思想。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>模版方法模式的特点大家应该也能体会到了，适用场景还是为了增加代码的复用性，以及扩展性。</p>
<p>还是那句话<strong>存在即合理</strong>，不要因设计模式而在写代码时强行嵌套。合理的学习每种设计模式适合场景，解决什么问题。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-计算机网络面试突击</title>
    <url>/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/</url>
    <content><![CDATA[<h1 id="计算机网络面试突击"><a href="#计算机网络面试突击" class="headerlink" title="计算机网络面试突击"></a>计算机网络面试突击</h1><h2 id="一：各协议层以及它们的服务类型"><a href="#一：各协议层以及它们的服务类型" class="headerlink" title="一：各协议层以及它们的服务类型"></a>一：各协议层以及它们的服务类型</h2><h3 id="1-OSI-七层模型"><a href="#1-OSI-七层模型" class="headerlink" title="1. OSI 七层模型"></a>1. OSI 七层模型</h3><p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/1.png" alt="img"> OSI 模型全称为开放式通信系统互连参考模型，是国际标准化组织 ( ISO ) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架。 OSI 将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI 的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。各层所提供的服务与这些服务是怎么实现的无关。</p>
<p>① 应用层</p>
<p>应用层位于 OSI 参考模型的第七层，其作用是通过应用程序间的交互来完成特定的网络应用。该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。例如域名系统 DNS，支持万维网应用的 HTTP 协议，电子邮件系统采用的 SMTP 协议等。在应用层交互的数据单元我们称之为报文。</p>
<p>② 表示层</p>
<p>表示层的作用是使通信的应用程序能够解释交换数据的含义，其位于 OSI 参考模型的第六层，向上为应用层提供服务，向下接收来自会话层的服务。该层提供的服务主要包括数据压缩，数据加密以及数据描述。这使得应用程序不必担心在各台计算机中表示和存储的内部格式差异。</p>
<p>③ 会话层</p>
<p>会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法。</p>
<p>④ 传输层</p>
<p>传输层的主要任务是为两台主机进程之间的通信提供服务。应用程序利用该服务传送应用层报文。该服务并不针对某一特定的应用，多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p>
<p>⑤ 网络层</p>
<p>两台计算机之间传送数据时其通信链路往往不止一条，所传输的信息甚至可能经过很多通信子网。网络层的主要任务就是选择合适的网间路由和交换节点，确保数据按时成功传送。在发送数据时，网络层把运输层产生的报文或用户数据报封装成分组和包向下传输到数据链路层。在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议，因此我们通常把该层简单地成为 IP 层。</p>
<p>⑥ 数据链路层</p>
<p>数据链路层通常也叫做链路层，在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息。通过控制信息我们可以知道一个帧的起止比特位置，此外，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源。</p>
<p>⑦ 物理层</p>
<p>作为 OSI 参考模型中最低的一层，物理层的作用是实现计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。该层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）。</p>
<h3 id="2-TCP-x2F-IP-参考模型"><a href="#2-TCP-x2F-IP-参考模型" class="headerlink" title="2. TCP&#x2F;IP 参考模型"></a>2. TCP&#x2F;IP 参考模型</h3><p>OSI 七层模型在提出时的出发点是基于标准化的考虑，而没有考虑到具体的市场需求，使得该模型结构复杂，部分功能冗余，因而完全实现 OSI 参考模型的系统不多。而 TCP&#x2F;IP 参考模型直接面向市场需求，实现起来也比较容易，因此在一经提出便得到了广泛的应用。基于 TCP&#x2F;IP 的参考模型将协议分成四个层次，如上图所示，它们分别是：网络访问层、网际互联层、传输层、和应用层。</p>
<p>① 应用层</p>
<p>TCP&#x2F;IP 模型将 OSI 参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务。例如：FTP、Telnet、DNS、SMTP 等。</p>
<p>② 传输层</p>
<p>该层对应于 OSI 参考模型的传输层，为上层实体提供源端到对端主机的通信功能。传输层定义了两个主要协议：传输控制协议（TCP）和用户数据报协议（UDP）。其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输。</p>
<p>③ 网际互联层</p>
<p>网际互联层对应 OSI 参考模型的网络层，主要负责相同或不同网络中计算机之间的通信。在网际互联层， IP 协议提供的是一个可靠、无连接的数据报传递服务。该协议实现两个基本功能：寻址和分段。根据数据报报头中的目的地址将数据传送到目的地址，在这个过程中 IP 负责选择传送路线。除了 IP 协议外，该层另外两个主要协议是互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。</p>
<p>④ 网络接入层</p>
<p>网络接入层的功能对应于 OSI 参考模型中的物理层和数据链路层，它负责监视数据在主机和网络之间的交换。事实上，TCP&#x2F;IP 并未真正描述这一层的实现，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与 TCP&#x2F;IP 的网络接入层进行连接，因此具体的实现方法将随着网络类型的不同而有所差异。</p>
<h3 id="3-TCP-x2F-IP-五层参考模型"><a href="#3-TCP-x2F-IP-五层参考模型" class="headerlink" title="3. TCP&#x2F;IP 五层参考模型"></a>3. TCP&#x2F;IP 五层参考模型</h3><p>五层体系的协议结构是综合了 OSI 和 TCP&#x2F;IP 优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层。其中应用层对应 OSI 的上三层，下四层和 OSI 相同。五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP&#x2F;IP 四层体系结构。</p>
<h3 id="4-OSI-模型和-TCP-x2F-IP-模型的异同比较"><a href="#4-OSI-模型和-TCP-x2F-IP-模型的异同比较" class="headerlink" title="4. OSI 模型和 TCP&#x2F;IP 模型的异同比较"></a>4. OSI 模型和 TCP&#x2F;IP 模型的异同比较</h3><p>相同点</p>
<p>① OSI 参考模型与 TCP&#x2F;IP 参考模型都采用了层次结构。</p>
<p>② 都能够提供面向连接和无连接两种通信服务机制。</p>
<p>不同点</p>
<p>① OSI 采用的七层模型； TCP&#x2F;IP 是四层结构。</p>
<p>② TCP&#x2F;IP 参考模型没有对网络接口层进行细分，只是一些概念性的描述； OSI 参考模型对服务和协议做了明确的区分。</p>
<p>③ OSI 先有模型，后有协议规范，适合于描述各种网络；TCP&#x2F;IP 是先有协议集然后建立模型，不适用于非 TCP&#x2F;IP 网络。</p>
<p>④ TCP&#x2F;IP 一开始就提出面向连接和无连接服务，而 OSI 一开始只强调面向连接服务，直到很晚才开始制定无连接的服务标准。</p>
<p>⑤ OSI 参考模型虽然被看好，但将网络划分为七层，实现起来较困难；相反，TCP&#x2F;IP 参考模型虽然有许多不尽人意的地方，但作为一种简化的分层结构还是比较成功的。</p>
<h3 id="5-OSI-和-TCP-x2F-IP-协议之间对应关系"><a href="#5-OSI-和-TCP-x2F-IP-协议之间对应关系" class="headerlink" title="5. OSI 和 TCP&#x2F;IP 协议之间对应关系"></a>5. OSI 和 TCP&#x2F;IP 协议之间对应关系</h3><p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/2.png" alt="img"></p>
<h3 id="6-为什么-ICP-x2F-IP-去除了表示层和会话层"><a href="#6-为什么-ICP-x2F-IP-去除了表示层和会话层" class="headerlink" title="6. 为什么 ICP&#x2F;IP 去除了表示层和会话层"></a>6. 为什么 ICP&#x2F;IP 去除了表示层和会话层</h3><p>OSI 参考模型在提出时，他们的理想是非常好的，但实际上，由于会话层、表示层、应用层都是在应用程序内部实现的，最终产出的是一个应用数据包，而应用程序之间是几乎无法实现代码的抽象共享的，这也就造成 OSI 设想中的应用程序维度的分层是无法实现的，例如，我们几乎不会认为数据的压缩、加密算法算是一种协议，而会话的概念则更为抽象，难以用协议来进行描述，所以在后来的 TCP&#x2F;IP 协议框架的设计中，便将表示层和会话层与应用层整合在一起，让整个过程更为清晰明了。</p>
<h3 id="7-数据如何在各层之间传输"><a href="#7-数据如何在各层之间传输" class="headerlink" title="7. 数据如何在各层之间传输"></a>7. 数据如何在各层之间传输</h3><p>在发送主机端，一个应用层报文被传送到运输层。在最简单的情况下，运输层收取到报文并附上附加信息，该首部将被接收端的运输层使用。应用层报文和运输层首部信息一道构成了运输层报文段。附加的信息可能包括：允许接收端运输层向上向适当的应用程序交付报文的信息以及差错检测位信息。该信息让接收端能够判断报文中的比特是否在途中已被改变。运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，生成了网络层数据报。该数据报接下来被传递给链路层，在数据链路层数据包添加发送端 MAC 地址和接收端 MAC 地址后被封装成数据帧，在物理层数据帧被封装成比特流，之后通过传输介质传送到对端。</p>
<h2 id="二：应用层"><a href="#二：应用层" class="headerlink" title="二：应用层"></a>二：应用层</h2><h3 id="1-HTTP-头部包含哪些信息"><a href="#1-HTTP-头部包含哪些信息" class="headerlink" title="1. HTTP 头部包含哪些信息"></a>1. HTTP 头部包含哪些信息</h3><p>HTTP 头部本质上是一个传递额外重要信息的键值对。主要分为：通用头部，请求头部，响应头部和实体头部。</p>
<p><strong>通用头部</strong></p>
<p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/3.png" alt="img"></p>
<p><strong>请求头部</strong></p>
<p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/4.png" alt="img"></p>
<p><strong>响应头部</strong></p>
<p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/5.png" alt="img"></p>
<p><strong>实体头部</strong></p>
<p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/6.png" alt="img"></p>
<h3 id="2-Keep-Alive-和非-Keep-Alive-区别，对服务器性能有影响吗"><a href="#2-Keep-Alive-和非-Keep-Alive-区别，对服务器性能有影响吗" class="headerlink" title="2. Keep-Alive 和非 Keep-Alive 区别，对服务器性能有影响吗"></a>2. Keep-Alive 和非 Keep-Alive 区别，对服务器性能有影响吗</h3><p>在早期的 HTTP&#x2F;1.0 中，浏览器每次 发起 HTTP 请求都要与服务器创建一个新的 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每个客户也不记录过去的请求。然而创建和关闭连接的过程需要消耗资源和时间，为了减少资源消耗，缩短响应时间，就需要重用连接。在 HTTP&#x2F;1.1 版本中默认使用持久连接，在此之前的 HTTP 版本的默认连接都是使用非持久连接，如果想要在旧版本的 HTTP 协议上维持持久连接，则需要指定 connection 的首部字段的值为 Keep-Alive 来告诉对方这个请求响应完成后不要关闭，下一次咱们还用这个请求继续交流，我们用一个示意图来更加生动的表示两者的区别：</p>
<p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/7.png" alt="img"></p>
<p>对于非 Keep&#x3D;Alive 来说，必须为每一个请求的对象建立和维护一个全新的连接。对于每一个这样的连接，客户机和服务器都要分配 TCP 的缓冲区和变量，这给服务器带来的严重的负担，因为一台 Web 服务器可能同时服务于数以百计的客户机请求。在 Keep-Alive 方式下，服务器在响应后保持该 TCP 连接打开，在同一个客户机与服务器之间的后续请求和响应报文可通过相同的连接进行传送。甚至位于同一台服务器的多个 Web 页面在从该服务器发送给同一个客户机时，可以在单个持久 TCP 连接上进行。</p>
<p>然而，Keep-Alive 并不是没有缺点的，当长时间的保持 TCP 连接时容易导致系统资源被无效占用，若对 Keep-Alive 模式配置不当，将有可能比非 Keep-Alive 模式带来的损失更大。因此，我们需要正确地设置 keep-alive timeout 参数，当 TCP 连接在传送完最后一个 HTTP 响应，该连接会保持 keepalive_timeout 秒，之后就开始关闭这个链接。</p>
<h3 id="3-HTTP-长连接短连接使用场景是什么"><a href="#3-HTTP-长连接短连接使用场景是什么" class="headerlink" title="3. HTTP 长连接短连接使用场景是什么"></a>3. HTTP 长连接短连接使用场景是什么</h3><p>长连接：多用于操作频繁，点对点的通讯，而且客户端连接数目较少的情况。例如即时通讯、网络游戏等。</p>
<p>短连接：用户数目较多的Web网站的 HTTP 服务一般用短连接。例如京东，淘宝这样的大型网站一般客户端数量达到千万级甚至上亿，若采用长连接势必会使得服务端大量的资源被无效占用，所以一般使用的是短连接。</p>
<h3 id="4-怎么知道-HTTP-的报文长度"><a href="#4-怎么知道-HTTP-的报文长度" class="headerlink" title="4. 怎么知道 HTTP 的报文长度"></a>4. 怎么知道 HTTP 的报文长度</h3><p>当响应消息中存在 Content-Length 字段时，我们可以直接根据这个值来判断数据是否接收完成，例如客户端向服务器请求一个静态页面或者一张图片时，服务器能够很清楚的知道请求内容的大小，因此可以通过消息首部字段 Content- Length 来告诉客户端需要接收多少数据，但是如果服务器预先不知道请求内容的大小，例如加载动态页面的时候，就需要使用 Transfer-Encoding: chunked 的方式来代替 Content-Length。</p>
<p>分块传输编码（Chunked transfer encoding）是 HTTP&#x2F;1.1 中引入的一种数据传输机制，其允许 HTTP 由服务器发送给客户端的数据可以分成多个部分，当数据分解成一系列数据块发送时，服务器就可以发送数据而不需要预先知道发送内容的总大小，每一个分块包含十六进制的长度值和数据，最后一个分块长度值为0，表示实体结束，客户机可以以此为标志确认数据已经接收完毕。</p>
<h3 id="5-HTTP-方法了解哪些"><a href="#5-HTTP-方法了解哪些" class="headerlink" title="5. HTTP 方法了解哪些"></a>5. HTTP 方法了解哪些</h3><p>HTTP&#x2F;1.0 定义了三种请求方法：GET, POST 和 HEAD 方法。</p>
<p>HTTP&#x2F;1.1 增加了六种请求方法：OPTIONS, PUT, PATCH, DELETE, TRACE 和 CONNECT 方法。</p>
<p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/8.png" alt="img"></p>
<h3 id="6-GET-和-POST-的区别"><a href="#6-GET-和-POST-的区别" class="headerlink" title="6. GET 和 POST 的区别"></a>6. GET 和 POST 的区别</h3><ol>
<li>get 提交的数据会放在 URL 之后，并且请求参数会被完整的保留在浏览器的记录里，由于参数直接暴露在 URL 中，可能会存在安全问题，因此往往用于获取资源信息。而 post 参数放在请求主体中，并且参数不会被保留，相比 get 方法，post 方法更安全，主要用于修改服务器上的资源。</li>
<li>get 请求只支持 URL 编码，post 请求支持多种编码格式。</li>
<li>get 只支持 ASCII 字符格式的参数，而 post 方法没有限制。</li>
<li>get 提交的数据大小有限制（这里所说的限制是针对浏览器而言的），而 post 方法提交的数据没限制</li>
<li>get 方式需要使用 Request.QueryString 来取得变量的值，而 post 方式通过 Request.Form 来获取。</li>
<li>get 方法产生一个 TCP 数据包，post 方法产生两个（并不是所有的浏览器中都产生两个）。</li>
</ol>
<h3 id="7-GET-的长度限制是多少"><a href="#7-GET-的长度限制是多少" class="headerlink" title="7. GET 的长度限制是多少"></a>7. GET 的长度限制是多少</h3><p>HTTP 中的 GET 方法是通过 URL 传递数据的，而 URL 本身并没有对数据的长度进行限制，真正限制 GET 长度的是浏览器，例如 IE 浏览器对 URL 的最大限制为 2000多个字符，大概 2KB左右，像 Chrome, FireFox 等浏览器能支持的 URL 字符数更多，其中 FireFox 中 URL 最大长度限制为 65536 个字符，Chrome 浏览器中 URL 最大长度限制为 8182 个字符。并且这个长度不是只针对数据部分，而是针对整个 URL 而言，在这之中，不同的服务器同样影响 URL 的最大长度限制。因此对于特定的浏览器，GET的长度限制不同。</p>
<p>由于 POST 方法请求参数在请求主体中，理论上讲，post 方法是没有大小限制的，而真正起限制作用的是服务器处理程序的处理能力。</p>
<h3 id="8-HTTP-与-HTTPs-的工作方式【建立连接的过程】"><a href="#8-HTTP-与-HTTPs-的工作方式【建立连接的过程】" class="headerlink" title="8. HTTP 与 HTTPs 的工作方式【建立连接的过程】"></a>8. HTTP 与 HTTPs 的工作方式【建立连接的过程】</h3><p>HTTP</p>
<p>HTTP（Hyper Text Transfer Protocol: 超文本传输协议） 是一种简单的请求 - 响应协议，被用于在 Web 浏览器和网站服务器之间传递消息。HTTP 使用 TCP（而不是 UDP）作为它的支撑运输层协议。其默认工作在 TCP 协议 80 端口，HTTP 客户机发起一个与服务器的 TCP 连接，一旦连接建立，浏览器和服务器进程就可以通过套接字接口访问 TCP。客户机从套接字接口发送 HTTP 请求报文和接收 HTTP 响应报文。类似地，服务器也是从套接字接口接收 HTTP 请求报文和发送 HTTP 响应报文。其通信内容以明文的方式发送，不通过任何方式的数据加密。当通信结束时，客户端与服务器关闭连接。</p>
<p>HTTPS</p>
<p>HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer）是以安全为目标的 HTTP 协议，在 HTTP 的基础上通过传输加密和身份认证的方式保证了传输过程的安全性。其工作流程如下：</p>
<p>① 客户端发起一个 HTTPS 请求，并连接到服务器的 443 端口，发送的信息主要包括自身所支持的算法列表和密钥长度等；</p>
<p>② 服务端将自身所支持的所有加密算法与客户端的算法列表进行对比并选择一种支持的加密算法，然后将它和其它密钥组件一同发送给客户端。</p>
<p>③ 服务器向客户端发送一个包含数字证书的报文，该数字证书中包含证书的颁发机构、过期时间、服务端的公钥等信息。</p>
<p>④ 最后服务端发送一个完成报文通知客户端 SSL 的第一阶段已经协商完成。</p>
<p>⑤ SSL 第一次协商完成后，客户端发送一个回应报文，报文中包含一个客户端生成的随机密码串，称为 pre_master_secre，并且该报文是经过证书中的公钥加密过的。</p>
<p>⑥ 紧接着客户端会发送一个报文提示服务端在此之后的报文是采用pre_master_secre 加密的。</p>
<p>⑦ 客户端向服务端发送一个 finish 报文，这次握手中包含第一次握手至今所有报文的整体校验值，最终协商是否完成取决于服务端能否成功解密。</p>
<p>⑧ 服务端同样发送与第 ⑥ 步中相同作用的报文，已让客户端进行确认，最后发送 finish 报文告诉客户端自己能够正确解密报文。</p>
<p>当服务端和客户端的 finish 报文交换完成之后，SSL 连接就算建立完成了，之后就进行和 HTTP 相同的通信过程，唯一不同的是在 HTTP 通信过程中并不是采用明文传输，而是采用对称加密的方式，其中对称密钥已经在 SSL 的建立过程中协商好了。</p>
<h3 id="9-HTTPS-和-HTTP-的区别"><a href="#9-HTTPS-和-HTTP-的区别" class="headerlink" title="9. HTTPS 和 HTTP 的区别"></a>9. HTTPS 和 HTTP 的区别</h3><ol>
<li>HTTP 协议以明文方式发送内容，数据都是未加密的，安全性较差。HTTPS 数据传输过程是加密的，安全性较好。</li>
<li>HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80 端口，后者是 443 端口。</li>
<li>HTTPS 协议需要到数字认证机构（Certificate Authority, CA）申请证书，一般需要一定的费用。</li>
<li>HTTP 页面响应比 HTTPS 快，主要因为 HTTP 使用 3 次握手建立连接，客户端和服务器需要握手 3 次，而 HTTPS 除了 TCP 的 3 次握手，还需要经历一个 SSL 协商过程。</li>
</ol>
<h3 id="10-HTTPS-的加密方式"><a href="#10-HTTPS-的加密方式" class="headerlink" title="10. HTTPS 的加密方式"></a>10. HTTPS 的加密方式</h3><p>HTTPS 采用对称加密和非对称加密相结合的方式，首先使用 SSL&#x2F;TLS 协议进行加密传输，为了弥补非对称加密的缺点，HTTPS 采用证书来进一步加强非对称加密的安全性，通过非对称加密，客户端和服务端协商好之后进行通信传输的对称密钥，后续的所有信息都通过该对称秘钥进行加密解密，完成整个 HTTPS 的流程。</p>
<h3 id="11-客户端为什么信任第三方证书"><a href="#11-客户端为什么信任第三方证书" class="headerlink" title="11. 客户端为什么信任第三方证书"></a>11. 客户端为什么信任第三方证书</h3><p>假设中间人篡改了证书原文，由于他没有 CA 机构的私钥，所以无法得到此时加密后的签名，因此无法篡改签名。客户端浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书被中间人篡改，证书不可信，从而终止向服务器传输信息。</p>
<p>上述过程说明证书无法被篡改，我们考虑更严重的情况，例如中间人拿到了 CA 机构认证的证书，它想窃取网站 A 发送给客户端的信息，于是它成为中间人拦截到了 A 传给客户端的证书，然后将其替换为自己的证书。此时客户端浏览器收到的是被中间人掉包后的证书，但由于证书里包含了客户端请求的网站信息，因此客户端浏览器只需要把证书里的域名与自己请求的域名比对一下就知道证书有没有被掉包了。</p>
<h3 id="12-HTTP-是不保存状态的协议-如何保存用户状态"><a href="#12-HTTP-是不保存状态的协议-如何保存用户状态" class="headerlink" title="12. HTTP 是不保存状态的协议,如何保存用户状态"></a>12. HTTP 是不保存状态的协议,如何保存用户状态</h3><p>我们知道，假如某个特定的客户机在短时间内两次请求同一个对象，服务器并不会因为刚刚为该用户提供了该对象就不再做出反应，而是重新发送该对象，就像该服务器已经完全忘记不久之前所做过的是一样。因为一个 HTTP 服务器并不保存关于客户机的任何信息，所以我们说 HTTP 是一个无状态协议。</p>
<p>通常有两种解决方案：</p>
<p>① 基于 Session 实现的会话保持</p>
<p>在客户端第一次向服务器发送 HTTP 请求后，服务器会创建一个 Session 对象并将客户端的身份信息以键值对的形式存储下来，然后分配一个会话标识（SessionId）给客户端，这个会话标识一般保存在客户端 Cookie 中，之后每次该浏览器发送 HTTP 请求都会带上 Cookie 中的 SessionId 到服务器，服务器根据会话标识就可以将之前的状态信息与会话联系起来，从而实现会话保持。</p>
<p>优点：安全性高，因为状态信息保存在服务器端。</p>
<p>缺点：由于大型网站往往采用的是分布式服务器，浏览器发送的 HTTP 请求一般要先通过负载均衡器才能到达具体的后台服务器，倘若同一个浏览器两次 HTTP 请求分别落在不同的服务器上时，基于 Session 的方法就不能实现会话保持了。</p>
<p>【解决方法：采用中间件，例如 Redis，我们通过将 Session 的信息存储在 Redis 中，使得每个服务器都可以访问到之前的状态信息】</p>
<p>② 基于 Cookie 实现的会话保持</p>
<p>当服务器发送响应消息时，在 HTTP 响应头中设置 Set-Cookie 字段，用来存储客户端的状态信息。客户端解析出 HTTP 响应头中的字段信息，并根据其生命周期创建不同的 Cookie，这样一来每次浏览器发送 HTTP 请求的时候都会带上 Cookie 字段，从而实现状态保持。基于 Cookie 的会话保持与基于 Session 实现的会话保持最主要的区别是前者完全将会话状态信息存储在浏览器 Cookie 中。</p>
<p>优点：服务器不用保存状态信息， 减轻服务器存储压力，同时便于服务端做水平拓展。</p>
<p>缺点：该方式不够安全，因为状态信息存储在客户端，这意味着不能在会话中保存机密数据。除此之外，浏览器每次发起 HTTP 请求时都需要发送额外的 Cookie 到服务器端，会占用更多带宽。</p>
<p>拓展：Cookie被禁用了怎么办？</p>
<p>若遇到 Cookie 被禁用的情况，则可以通过重写 URL 的方式将会话标识放在 URL 的参数里，也可以实现会话保持。</p>
<h3 id="13-状态码"><a href="#13-状态码" class="headerlink" title="13. 状态码"></a>13. 状态码</h3><p>HTTP 状态码由三个十进制数字组成，第一个数字定义了状态码的类型，后两个并没有起到分类的作用。HTTP 状态码共有 5 种类型： <img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/9.png" alt="img"></p>
<p>面试时针对状态码的常见问法：</p>
<p>① 状态码 301 和 302 的区别？</p>
<p>301：永久移动。请求的资源已被永久的移动到新的URI，旧的地址已经被永久的删除了。返回信息会包括新的URI，浏览器会自动定向到新的URI。今后新的请求都应使用新的URI代替。</p>
<p>302：临时移动。与301类似，客户端拿到服务端的响应消息后会跳转到一个新的 URL 地址。但资源只是临时被移动，旧的地址还在，客户端应继续使用原有URI。</p>
<p>② HTTP 异常状态码知道哪些？</p>
<p>该问题一般只需要回答 3, 4 , 5 开头的一些常见异常状态码即可。</p>
<h3 id="14-HTTP-x2F-1-1-和-HTTP-x2F-1-0-的区别"><a href="#14-HTTP-x2F-1-1-和-HTTP-x2F-1-0-的区别" class="headerlink" title="14. HTTP&#x2F;1.1 和 HTTP&#x2F;1.0 的区别"></a>14. HTTP&#x2F;1.1 和 HTTP&#x2F;1.0 的区别</h3><p>主要区别如下：</p>
<p>缓存处理：在 HTTP&#x2F;1.0 中主要使用 header 里的 if-modified-Since, Expries 来做缓存判断的标准。而 HTTP&#x2F;1.1 请求头中添加了更多与缓存相关的字段，从而支持更为灵活的缓存策略，例如 Entity-tag, If-Unmodified-Since, If-Match, If-None-Match 等可供选择的缓存头来控制缓存策略。</p>
<p>节约带宽： 当客户端请求某个资源时，HTTP&#x2F;1.0 默认将该资源相关的整个对象传送给请求方，但很多时候可能客户端并不需要对象的所有信息。而在 HTTP&#x2F;1.1 的请求头中引入了 range 头域，它允许只请求部分资源，其使得开发者可以多线程请求某一资源，从而充分的利用带宽资源，实现高效并发。</p>
<p>错误通知的管理：HTTP&#x2F;1.1 在 1.0 的基础上新增了 24 个错误状态响应码，例如 414 表示客户端请求中所包含的 URL 地址太长，以至于服务器无法处理；410 表示所请求的资源已经被永久删除。</p>
<p>Host 请求头：早期 HTTP&#x2F;1.0 中认为每台服务器都绑定一个唯一的 IP 地址并提供单一的服务，请求消息中的 URL 并没有传递主机名。而随着虚拟主机的出现，一台物理服务器上可以存在多个虚拟主机，并且它们共享同一个 IP 地址。为了支持虚拟主机，HTTP&#x2F;1.1 中添加了 host 请求头，请求消息和响应消息中应声明这个字段，若请求消息中缺少该字段时服务端会响应一个 404 错误状态码。</p>
<p>长连接：HTTP&#x2F;1.0 默认浏览器和服务器之间保持短暂连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成后立即断开 TCP 连接。HTTP&#x2F;1.1 默认使用的是持久连接，其支持在同一个 TCP 请求中传送多个 HTTP 请求和响应。此之前的 HTTP 版本的默认连接都是使用非持久连接，如果想要在旧版本的 HTTP 协议上维持持久连接，则需要指定 Connection 的首部字段的值为 Keep-Alive。</p>
<h3 id="15-HTTP-x2F-1-X-和-HTTP-x2F-2-0-的区别"><a href="#15-HTTP-x2F-1-X-和-HTTP-x2F-2-0-的区别" class="headerlink" title="15. HTTP&#x2F;1.X 和 HTTP&#x2F;2.0 的区别"></a>15. HTTP&#x2F;1.X 和 HTTP&#x2F;2.0 的区别</h3><ol>
<li>相比于 HTTP&#x2F;1.X 的文本（字符串）传送， HTTP&#x2F;2.0 采用二进制传送。客户端和服务器传输数据时把数据分成帧，帧组成了数据流，流具有流 ID 标识和优先级，通过优先级以及流依赖能够一定程度上解决关键请求被阻塞的问题。</li>
<li>HTTP&#x2F;2.0 支持多路复用。因为流 ID 的存在， 通过同一个 HTTP 请求可以实现多个 HTTP 请求传输，客户端和服务器可以通过流 ID 来标识究竟是哪个流从而定位到是哪个 HTTP 请求。</li>
<li>HTTP&#x2F;2.0 头部压缩。HTTP&#x2F;2.0 通过 gzip 和 compress 压缩头部然后再发送，同时通信双方会维护一张头信息表，所有字段都记录在这张表中，在每次 HTTP 传输时只需要传头字段在表中的索引即可，大大减小了重传次数和数据量。</li>
<li>HTTP&#x2F;2.0 支持服务器推送。 服务器在客户端未经请求许可的情况下，可预先向客户端推送需要的内容，客户端在退出服务时可通过发送复位相关的请求来取消服务端的推送。</li>
</ol>
<h3 id="16-HTTP-x2F-3-了解吗"><a href="#16-HTTP-x2F-3-了解吗" class="headerlink" title="16. HTTP&#x2F;3 了解吗"></a>16. HTTP&#x2F;3 了解吗</h3><p>HTTP&#x2F;2 存在的问题</p>
<p>我们知道，传统 Web 平台的数据传输都基于 TCP 协议，而 TCP 协议在创建连接之前不可避免的需要三次握手，如果需要提高数据交互的安全性，即增加传输层安全协议（TLS），还会增加更多的握手次数。 HTTP 从 1.0 到 2.0，其传输层都是基于 TCP 协议的。即使是带来巨大性能提升的 HTTP&#x2F;2，也无法完全解决 TCP 协议存在的固有问题（慢启动，拥塞窗口尺寸的设置等）。此外，HTTP&#x2F;2 多路复用只是减少了连接数，其队头的拥塞问题并没有完全解决，倘若 TCP 丢包率过大，则 HTTP&#x2F;2 的表现将不如 HTTP&#x2F;1.1。</p>
<p>QUIC 协议</p>
<p>QUIC（Quick UDP Internet Connections），直译为快速 UDP 网络连接，是谷歌制定的一种基于 UDP 的低延迟传输协议。其主要目的是解决采用传输层 TCP 协议存在的问题，同时满足传输层和应用层对多连接、低延迟等的需求。该协议融合了 TCP, TLS, HTTP&#x2F;2 等协议的特性，并基于 UDP传输。该协议带来的主要提升有：</p>
<p>低延迟连接。当客户端第一次连接服务器时，QUIC 只需要 1 RTT（Round-Trid Time）延迟就可以建立安全可靠的连接（采用 TLS 1.3 版本），相比于 TCP + TLS 的 3 次 RTT 要更加快捷。之后，客户端可以在本地缓存加密的认证信息，当再次与服务器建立连接时可以实现 0 RTT 的连接建立延迟。</p>
<p>QUIC 复用了 HTTP&#x2F;2 协议的多路复用功能，由于 QUIC 基于 UDP，所以也避免了 HTTP&#x2F;2存在的队头阻塞问题。</p>
<p>基于 UDP 协议的 QUIC 运行在用户域而不是系统内核，这使得 QUIC 协议可以快速的更新和部署，从而很好地解决了 TPC 协议部署及更新的困难。</p>
<p>QUIC 的报文是经过加密和认证的，除了少量的报文，其它所有的 QUIC 报文头部都经过了认证，报文主体经过了加密。只要有攻击者篡改 QUIC 报文，接收端都能及时发现。</p>
<p>具有向前纠错机制，每个数据包携带了除了本身内容外的部分其他数据包的内容，使得在出现少量丢包的情况下，尽量地减少其它包的重传次数，其通过牺牲单个包所携带的有效数据大小换来更少的重传次数，这在丢包数量较小的场景下能够带来一定程度的性能提升。</p>
<p>HTTP&#x2F;3</p>
<p>HTTP&#x2F;3 是在 QUIC 基础上发展起来的，其底层使用 UDP 进行数据传输，上层仍然使用 HTTP&#x2F;2。在 UDP 与 HTTP&#x2F;2 之间存在一个 QUIC 层，其中 TLS 加密过程在该层进行处理。HTTP&#x2F;3 主要有以下几个特点：</p>
<p>① 使用 UDP 作为传输层进行通信；</p>
<p>② 在 UDP 之上的 QUIC 协议保证了 HTTP&#x2F;3 的安全性。QUIC 在建立连接的过程中就完成了 TLS 加密握手；</p>
<p>③ 建立连接快，正常只需要 1 RTT 即可建立连接。如果有缓存之前的会话信息，则直接验证和建立连接，此过程 0 RTT。建立连接时，也可以带有少量业务数据；</p>
<p>④ 不和具体底层连接绑定，QUIC 为每个连接的两端分别分配了一个唯一 ID，上层连接只认这对逻辑 ID。网络切换或者断连时，只需要继续发送数据包即可完成连接的建立；</p>
<p>⑤ 使用 QPACK 进行头部压缩，因为 在 HTTP&#x2F;2 中的 HPACK 要求传输过程有序，这会导致队头阻塞，而 QPACK 不存在这个问题。</p>
<p>最后我们使用一张图来清晰的表示出 HTTP 协议的发展变化： <img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/10.png" alt="img"></p>
<h3 id="17-DNS-的作用和原理"><a href="#17-DNS-的作用和原理" class="headerlink" title="17. DNS 的作用和原理"></a>17. DNS 的作用和原理</h3><p>DNS</p>
<p>DNS（Domain Name System）是域名系统的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，用于 TCP&#x2F;IP 网络。</p>
<p>DNS 的作用</p>
<p>通常我们有两种方式识别主机：通过主机名或者 IP 地址。人们喜欢便于记忆的主机名表示，而路由器则喜欢定长的、有着层次结构的 IP 地址。为了满足这些不同的偏好，我们就需要一种能够进行主机名到 IP 地址转换的目录服务，域名系统作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。</p>
<p>DNS 域名解析原理</p>
<p>DNS 采用了分布式的设计方案，其域名空间采用一种树形的层次结构： <img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/11.png" alt="img"></p>
<p>上图展示了 DNS 服务器的部分层次结构，从上到下依次为根域名服务器、顶级域名服务器和权威域名服务器。其实根域名服务器在因特网上有13个，大部分位于北美洲。第二层为顶级域服务器，这些服务器负责顶级域名（如 com、org、net、edu）和所有国家的顶级域名（如uk、fr、ca 和 jp）。在第三层为权威 DNS 服务器，因特网上具有公共可访问主机（例如 Web 服务器和邮件服务器）的每个组织机构必须提供公共可访问的 DNS 记录，这些记录由组织机构的权威 DNS 服务器负责保存，这些记录将这些主机的名称映射为 IP 地址。</p>
<p>除此之外，还有一类重要的 DNS 服务器，叫做本地 DNS 服务器。本地 DNS 服务器严格来说不在 DNS 服务器的层次结构中，但它对 DNS 层次结构是很重要的。一般来说，每个网络服务提供商（ISP） 都有一台本地 DNS 服务器。当主机与某个 ISP 相连时，该 ISP 提供一台主机的 IP 地址，该主机具有一台或多台其本地 DNS 服务器的 IP 地址。主机的本地 DNS 服务器通常和主机距离较近，当主机发起 DNS 请求时，该请求被发送到本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 服务器层次结构中。</p>
<p>我们以一个例子来了解 DNS 的工作原理，假设主机 A（IP 地址为 abc.xyz.edu） 想知道主机 B 的 IP 地址 （def.mn.edu），如下图所示，主机 A 首先向它的本地 DNS 服务器发送一个 DNS 查询报文。该查询报文含有被转换的主机名 def.mn.edu。本地 DNS 服务器将该报文转发到根 DNS 服务器，根 DNS 服务器注意到查询的 IP 地址前缀为 edu 后向本地 DNS 服务器返回负责 edu 的顶级域名服务器的 IP 地址列表。该本地 DNS 服务器则再次向这些 顶级域名服务器发送查询报文。该顶级域名服务器注意到 mn.edu 的前缀，并用权威域名服务器的 IP 地址进行响应。通常情况下，顶级域名服务器并不总是知道每台主机的权威 DNS 服务器的 IP 地址，而只知道中间的某个服务器，该中间 DNS 服务器依次能找到用于相应主机的 IP 地址，我们假设中间经历了权威服务器 ① 和 ②，最后找到了负责 def.mn.edu 的权威 DNS 服务器 ③，之后，本地 DNS 服务器直接向该服务器发送查询报文从而获得主机 B 的IP 地址。</p>
<p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/12.png" alt="img"></p>
<p>在上图中，IP 地址的查询其实经历了两种查询方式，分别是递归查询和迭代查询。</p>
<p><strong>拓展：域名解析查询的两种方式</strong></p>
<p><strong>递归查询</strong>：如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户端的身份，向其他根域名服务器继续发出查询请求报文，即替主机继续查询，而不是让主机自己进行下一步查询，如上图步骤（1）和（10）。</p>
<p><strong>迭代查询</strong>：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应该找哪个域名服务器进行查询，然后让本地服务器进行后续的查询，如上图步骤（2）~（9）。</p>
<h3 id="19-DNS-为什么用-UDP"><a href="#19-DNS-为什么用-UDP" class="headerlink" title="19. DNS 为什么用 UDP"></a>19. DNS 为什么用 UDP</h3><p>DNS 既使用 TCP 又使用 UDP。</p>
<p>当进行区域传送（主域名服务器向辅助域名服务器传送变化的那部分数据）时会使用 TCP，因为数据同步传送的数据量比一个请求和应答的数据量要多，而 TCP 允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的 TCP。</p>
<p>当客户端向 DNS 服务器查询域名 ( 域名解析) 的时候，一般返回的内容不会超过 UDP 报文的最大长度，即 512 字节。用 UDP 传输时，不需要经过 TCP 三次握手的过程，从而大大提高了响应速度，但这要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。</p>
<h3 id="20-怎么实现-DNS-劫持"><a href="#20-怎么实现-DNS-劫持" class="headerlink" title="20. 怎么实现 DNS 劫持"></a>20. 怎么实现 DNS 劫持</h3><p>DNS 劫持即域名劫持，是通过将原域名对应的 IP 地址进行替换从而使得用户访问到错误的网站或者使得用户无法正常访问网站的一种攻击方式。域名劫持往往只能在特定的网络范围内进行，范围外的 DNS 服务器能够返回正常的 IP 地址。攻击者可以冒充原域名所属机构，通过电子邮件的方式修改组织机构的域名注册信息，或者将域名转让给其它组织，并将新的域名信息保存在所指定的 DNS 服务器中，从而使得用户无法通过对原域名进行解析来访问目的网址。</p>
<p>具体实施步骤如下：</p>
<p>① 获取要劫持的域名信息：攻击者首先会访问域名查询站点查询要劫持的域名信息。</p>
<p>② 控制域名相应的 E-MAIL 账号：在获取到域名信息后，攻击者通过暴力破解或者专门的方法破解公司注册域名时使用的 E-mail 账号所对应的密码。更高级的攻击者甚至能够直接对 E-mail 进行信息窃取。</p>
<p>③ 修改注册信息：当攻击者破解了 E-MAIL 后，会利用相关的更改功能修改该域名的注册信息，包括域名拥有者信息，DNS 服务器信息等。</p>
<p>④ 使用 E-MAIL 收发确认函：在修改完注册信息后，攻击者在 E-mail 真正拥有者之前收到修改域名注册信息的相关确认信息，并回复确认修改文件，待网络公司恢复已成功修改信件后，攻击者便成功完成 DNS 劫持。</p>
<p><strong>用户端的一些预防手段：</strong></p>
<p>直接通过 IP 地址访问网站，避开 DNS 劫持。 由于域名劫持往往只能在特定的网络范围内进行，因此一些高级用户可以通过网络设置让 DNS 指向正常的域名服务器以实现对目的网址的正常访问，例如将计算机首选 DNS 服务器的地址固定为 8.8.8.8。</p>
<h3 id="21-socket-套接字有哪些"><a href="#21-socket-套接字有哪些" class="headerlink" title="21. socket() 套接字有哪些"></a>21. socket() 套接字有哪些</h3><p>套接字（Socket）是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象，网络进程通信的一端就是一个套接字，不同主机上的进程便是通过套接字发送报文来进行通信。例如 TCP 用主机的 IP 地址 + 端口号作为 TCP 连接的端点，这个端点就叫做套接字。</p>
<p>套接字主要有以下三种类型：</p>
<ol>
<li>流套接字（SOCK_STREAM）：流套接字基于 TCP 传输协议，主要用于提供面向连接、可靠的数据传输服务。由于 TCP 协议的特点，使用流套接字进行通信时能够保证数据无差错、无重复传送，并按顺序接收，通信双方不需要在程序中进行相应的处理。</li>
<li>数据报套接字（SOCK_DGRAM）：和流套接字不同，数据报套接字基于 UDP 传输协议，对应于无连接的 UDP 服务应用。该服务并不能保证数据传输的可靠性，也无法保证对端能够顺序接收到数据。此外，通信两端不需建立长时间的连接关系，当 UDP 客户端发送一个数据给服务器后，其可以通过同一个套接字给另一个服务器发送数据。当用 UDP 套接字时，丢包等问题需要在程序中进行处理。</li>
<li>原始套接字（SOCK_RAW）：由于流套接字和数据报套接字只能读取 TCP 和 UDP 协议的数据，当需要传送非传输层数据包（例如 Ping 命令时用的 ICMP 协议数据包）或者遇到操作系统无法处理的数据包时，此时就需要建立原始套接字来发送。</li>
</ol>
<h3 id="22-URI（统一资源标识符）和-URL（统一资源定位符）之间的区别"><a href="#22-URI（统一资源标识符）和-URL（统一资源定位符）之间的区别" class="headerlink" title="22. URI（统一资源标识符）和 URL（统一资源定位符）之间的区别"></a>22. URI（统一资源标识符）和 URL（统一资源定位符）之间的区别</h3><p>URL，即统一资源定位符 (Uniform Resource Locator )，URL 其实就是我们平时上网时输入的网址，它标识一个互联网资源，并指定对其进行操作或获取该资源的方法。例如 <a href="https://link.juejin.cn/?target=https://leetcode-cn.com/problemset/all/">leetcode-cn.com&#x2F;problemset&#x2F;…</a> 这个 URL，标识一个特定资源并表示该资源的某种形式是可以通过 HTTP 协议从相应位置获得。</p>
<p>从定义即可看出，URL 是 URI 的一个子集，两者都定义了资源是什么，而 URL 还定义了如何能访问到该资源。URI 是一种语义上的抽象概念，可以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位，是绝对的。简单地说，只要能唯一标识资源的就是 URI，在 URI 的基础上给出其资源的访问方式的就是 URL。</p>
<h3 id="23-为什么-fidder，charles-能抓到你的包【抓取数据包的过程】"><a href="#23-为什么-fidder，charles-能抓到你的包【抓取数据包的过程】" class="headerlink" title="23. 为什么 fidder，charles 能抓到你的包【抓取数据包的过程】"></a>23. 为什么 fidder，charles 能抓到你的包【抓取数据包的过程】</h3><p>假如我们需要抓取客户端的数据包，需要监控客户端与服务器交互之间的网络节点，监控其中任意一个网络节点（网卡），获取所有经过网卡中的数据，对这些数据按照网络协议进行解析，这就是抓包的基本原理。而中间的网络节点不受我们控制，是基本无法实现抓包的，因此只能在客户端与服务器之间进行抓包。</p>
<p>① 当采用抓包工具抓取 HTTP 数据包时，过程较为简单：</p>
<p>首先抓包工具会提出代理服务，客户端需要连接该代理； 客户端发出 HTTP 请求时，会经过抓包工具的代理，抓包工具将请求的原文进行展示； 抓包工具使用该原文将请求发送给服务器； 服务器返回结果给抓包工具，抓包工具将返回结果进行展示； 抓包工具将服务器返回的结果原样返回给客户端。 这里抓包工具相当于透明人，数据经过的时候它一只手接到数据，然后另一只手把数据传出去。</p>
<p>② 当抓取 HTTPS 数据包时：</p>
<ul>
<li>客户端连接抓包工具提供的代理服务，并安装抓包工具的根证书；</li>
<li>客户端发出 HTTPS 请求，抓包工具模拟服务器与客户端进行 TLS 握手交换密钥等流程；</li>
<li>抓包工具发送一个 HTTPS 请求给客户端请求的目标服务器，并与目标服务器进行 TLS 握手交换密钥等流程；</li>
<li>客户端使用与抓包工具协定好的密钥加密数据后发送给抓包工具；</li>
<li>抓包工具使用与客户端协定好的密钥解密数据，并将结果进行展示；</li>
<li>抓包工具将解密后的客户端数据，使用与服务器协定好的密钥进行加密后发送给目标服务器；</li>
<li>服务器解密数据后，做对应的逻辑处理，然后将返回结果使用与抓包工具协定好的密钥进行加密发送给抓包工具；</li>
<li>抓包工具将服务器返回的结果，用与服务器协定好的密钥解密，并将结果进行展示；</li>
<li>抓包工具将解密后的服务器返回数据，使用与客户端协定好的密钥进行加密后发送给客户端；</li>
<li>客户端解密数据。</li>
</ul>
<p>这个时候抓包工具对客户端来说相当于服务器，对服务器来说相当于客户端。在这个传输过程中，客户端会以为它就是目标服务器，服务器也会以为它就是请求发起的客户端。</p>
<h3 id="24-如果你访问一个网站很慢，怎么排查和解决"><a href="#24-如果你访问一个网站很慢，怎么排查和解决" class="headerlink" title="24. 如果你访问一个网站很慢，怎么排查和解决"></a>24. 如果你访问一个网站很慢，怎么排查和解决</h3><p>网页打开速度慢的原因有很多，这里列举出一些较常出现的问题：</p>
<p>① 首先最直接的方法是查看本地网络是否正常，可以通过网络测速软件例如电脑管家等对电脑进行测速，若网速正常，我们查看网络带宽是否被占用，例如当你正在下载电影时并且没有限速，是会影响你打开网页的速度的，这种情况往往是处理器内存小导致的；</p>
<p>② 当网速测试正常时，我们对网站服务器速度进行排查，通过 ping 命令查看链接到服务器的时间和丢包等情况，一个速度好的机房，首先丢包率不能超过 1%，其次 ping 值要小，最后是 ping 值要稳定，如最大和最小差值过大说明路由不稳定。或者我们也可以查看同台服务器上其他网站的打开速度，看是否其他网站打开也慢。</p>
<p>③ 如果网页打开的速度时快时慢，甚至有时候打不开，有可能是空间不稳定的原因。当确定是该问题时，就要找你的空间商解决或换空间商了，如果购买空间的话，可选择购买购买双线空间或多线空间；如果是在有的地方打开速度快，有的地方打开速度慢，那应该是网络线路的问题。电信线路用户访问放在联通服务器的网站，联通线路用户访问放在电信服务器上的网站，相对来说打开速度肯定是比较慢。</p>
<p>④ 从网站本身找原因。网站的问题主要包括网站程序设计、网页设计结构和网页内容三个部分。</p>
<ul>
<li>网站程序设计：当访问网页中有拖慢网站打开速度的代码，会影响网页的打开速度，例如网页中的统计代码，我们最好将其放在网站的末尾。因此我们需要查看网页程序的设计结构是否合理；</li>
<li>网页设计结构：如果是 table 布局的网站，查看是否嵌套次数太多，或是一个大表格分成多个表格这样的网页布局，此时我们可以采用 div 布局并配合 css 进行优化。</li>
<li>网页内容：查看网页中是否有许多尺寸大的图片或者尺寸大的 flash 存在，我们可以通过降低图片质量，减小图片尺寸，少用大型 flash 加以解决。此外，有的网页可能过多地引用了其他网站的内容，若某些被引用的网站访问速度慢，或者一些页面已经不存在了，打开的速度也会变慢。一种直接的解决方法是去除不必要的加载项。</li>
</ul>
<h3 id="25-其他协议"><a href="#25-其他协议" class="headerlink" title="25. 其他协议"></a>25. 其他协议</h3><p>对于应用层来说，考察的重点集中在 HTTP 协议和 DNS 这两块，其他协议考察较少，我们仅加以了解即可。</p>
<p><strong>FTP</strong></p>
<ul>
<li>FTP（File Transfer Protocol，文件传输协议）是用于在网络上进行文件传输的一套标准协议，使用客户&#x2F;服务器模式，使用 TCP 数据报，提供交互式访问，双向传输。</li>
<li>TFTP（Trivial File Transfer Protocol，简单文件传输协议）一个小且易实现的文件传输协议，也使用客户&#x2F;服务器方式，使用 UDP 数据报，只支持文件传输而不支持交互，没有列目录，不能对用户进行身份鉴定。</li>
</ul>
<p><strong>SMTP</strong> SMTP（Simple Main Transfer Protocol，简单邮件传输协议）是在 Internet 传输 Email 的标准，是一个相对简单的基于文本的协议。在其之上指定了一条消息的一个或多个接收者（在大多数情况下被确认是存在的），然后消息文本会被传输。可以很简单地通过 Telnet 程序来测试一个 SMTP 服务器。SMTP 使用 TCP 端口 25。</p>
<p><strong>DHCP</strong></p>
<p>DHCP ( Dynamic Host Configuration Protocol，动态主机设置协议 ) 是一个局域网的网络协议，使用 UDP 协议工作，主要有两个用途：</p>
<p>用于内部网络或网络服务供应商自动分配 IP 地址给用户 用于内部网络管理员作为对所有电脑作中央管理的手段</p>
<p><strong>SNMP</strong></p>
<p>SNMP（Simple Network Management Protocol，简单网络管理协议）构成了互联网工程工作小组（IETF，Internet Engineering Task Force）定义的 Internet 协议族的一部分。该协议能够支持网络管理系统，用以监测连接到网络上的设备是否有任何引起管理上关注的情况。</p>
<h3 id="26-网页解析全过程【用户输入网址到显示对应页面的全过程】"><a href="#26-网页解析全过程【用户输入网址到显示对应页面的全过程】" class="headerlink" title="26. 网页解析全过程【用户输入网址到显示对应页面的全过程】"></a>26. 网页解析全过程【用户输入网址到显示对应页面的全过程】</h3><p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/13.png" alt="img"> ① DNS 解析：当用户输入一个网址并按下回车键的时候，浏览器获得一个域名，而在实际通信过程中，我们需要的是一个 IP 地址，因此我们需要先把域名转换成相应 IP 地址。【具体细节参看问题 16，17】</p>
<p>② TCP 连接：浏览器通过 DNS 获取到 Web 服务器真正的 IP 地址后，便向 Web 服务器发起 TCP 连接请求，通过 TCP 三次握手建立好连接后，浏览器便可以将 HTTP 请求数据发送给服务器了。【三次握手放在传输层详细讲解】</p>
<p>③ 发送 HTTP 请求：浏览器向 Web 服务器发起一个 HTTP 请求，HTTP 协议是建立在 TCP 协议之上的应用层协议，其本质是在建立起的TCP连接中，按照HTTP协议标准发送一个索要网页的请求。在这一过程中，会涉及到负载均衡等操作。</p>
<p><strong>拓展：什么是负载均衡？</strong></p>
<p>负载均衡，英文名为 Load Balance，其含义是指将负载（工作任务）进行平衡、分摊到多个操作单元上进行运行，例如 FTP 服务器、Web 服务器、企业核心服务器和其他主要任务服务器等，从而协同完成工作任务。负载均衡建立在现有的网络之上，它提供了一种透明且廉价有效的方法扩展服务器和网络设备的带宽、增加吞吐量、加强网络处理能力并提高网络的灵活性和可用性。</p>
<p>负载均衡是分布式系统架构设计中必须考虑的因素之一，例如天猫、京东等大型用户网站中为了处理海量用户发起的请求，其往往采用分布式服务器，并通过引入反向代理等方式将用户请求均匀分发到每个服务器上，而这一过程所实现的就是负载均衡。</p>
<p>④ 处理请求并返回：服务器获取到客户端的 HTTP 请求后，会根据 HTTP 请求中的内容来决定如何获取相应的文件，并将文件发送给浏览器。</p>
<p>⑤ 浏览器渲染：浏览器根据响应开始显示页面，首先解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。</p>
<p>⑥ 断开连接：客户端和服务器通过四次挥手终止 TCP 连接。【其中的细节放在传输层详细讲解】</p>
<h2 id="三：传输层"><a href="#三：传输层" class="headerlink" title="三：传输层"></a>三：传输层</h2><h3 id="1-三次握手和四次挥手机制"><a href="#1-三次握手和四次挥手机制" class="headerlink" title="1. 三次握手和四次挥手机制"></a>1. 三次握手和四次挥手机制</h3><p><strong>三次握手</strong> <img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/14.png" alt="img"> 三次握手是 TCP 连接的建立过程。在握手之前，主动打开连接的客户端结束 CLOSE 阶段，被动打开的服务器也结束 CLOSE 阶段，并进入 LISTEN 阶段。随后进入三次握手阶段：</p>
<p>① 首先客户端向服务器发送一个 SYN 包，并等待服务器确认，其中：</p>
<ul>
<li>标志位为 SYN，表示请求建立连接；</li>
<li>序号为 Seq &#x3D; x（x 一般为 1）；</li>
<li>随后客户端进入 SYN-SEND 阶段。</li>
</ul>
<p>② 服务器接收到客户端发来的 SYN 包后，对该包进行确认后结束 LISTEN 阶段，并返回一段 TCP 报文，其中：</p>
<ul>
<li>标志位为 SYN 和 ACK，表示确认客户端的报文 Seq 序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接；</li>
<li>序号为 Seq &#x3D; y；</li>
<li>确认号为 Ack &#x3D; x + 1，表示收到客户端的序号 Seq 并将其值加 1 作为自己确认号 Ack 的值，随后服务器端进入 SYN-RCVD 阶段。</li>
</ul>
<p>③ 客户端接收到发送的 SYN + ACK 包后，明确了从客户端到服务器的数据传输是正常的，从而结束 SYN-SENT 阶段。并返回最后一段报文。其中：</p>
<ul>
<li>标志位为 ACK，表示确认收到服务器端同意连接的信号；</li>
<li>序号为 Seq &#x3D; x + 1，表示收到服务器端的确认号 Ack，并将其值作为自己的序号值；</li>
<li>确认号为 Ack&#x3D; y + 1，表示收到服务器端序号 seq，并将其值加 1 作为自己的确认号 Ack 的值。</li>
<li>随后客户端进入 ESTABLISHED。</li>
</ul>
<p>当服务器端收到来自客户端确认收到服务器数据的报文后，得知从服务器到客户端的数据传输是正常的，从而结束 SYN-SEND 阶段，进入 ESTABLISHED 阶段，从而完成三次握手。</p>
<p><strong>四次挥手：</strong> <img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/15.png" alt="img"> 四次挥手即 TCP 连接的释放，这里假设客户端主动释放连接。在挥手之前主动释放连接的客户端结束 ESTABLISHED 阶段，随后开始四次挥手：</p>
<p>① 首先客户端向服务器发送一段 TCP 报文表明其想要释放 TCP 连接，其中：</p>
<ul>
<li>标记位为 FIN，表示请求释放连接；</li>
<li>序号为 Seq &#x3D; u；</li>
<li>随后客户端进入 FIN-WAIT-1 阶段，即半关闭阶段，并且停止向服务端发送通信数据。</li>
</ul>
<p>② 服务器接收到客户端请求断开连接的 FIN 报文后，结束 ESTABLISHED 阶段，进入 CLOSE-WAIT 阶段并返回一段 TCP 报文，其中：</p>
<ul>
<li>标记位为 ACK，表示接收到客户端释放连接的请求；</li>
<li>序号为 Seq &#x3D; v；</li>
<li>确认号为 Ack &#x3D; u + 1，表示是在收到客户端报文的基础上，将其序号值加 1 作为本段报文确认号 Ack 的值；</li>
<li>随后服务器开始准备释放服务器端到客户端方向上的连接。</li>
<li>客户端收到服务器发送过来的 TCP 报文后，确认服务器已经收到了客户端连接释放的请求，随后客户端结束 FIN-WAIT-1 阶段，进入 FIN– WAIT-2 阶段。</li>
</ul>
<p>③ 服务器端在发出 ACK 确认报文后，服务器端会将遗留的待传数据传送给客户端，待传输完成后即经过 CLOSE-WAIT 阶段，便做好了释放服务器端到客户端的连接准备，再次向客户端发出一段 TCP 报文，其中：</p>
<ul>
<li>标记位为 FIN 和 ACK，表示已经准备好释放连接了；</li>
<li>序号为 Seq &#x3D; w；</li>
<li>确认号 Ack &#x3D; u + 1，表示是在收到客户端报文的基础上，将其序号 Seq 的值加 1 作为本段报文确认号 Ack 的值。</li>
<li>随后服务器端结束 CLOSE-WAIT 阶段，进入 LAST-ACK 阶段。并且停止向客户端发送数据。</li>
</ul>
<p>④ 客户端收到从服务器发来的 TCP 报文，确认了服务器已经做好释放连接的准备，于是结束 FIN-WAIT-2 阶段，进入 TIME-WAIT 阶段，并向服务器发送一段报文，其中：</p>
<ul>
<li>标记位为 ACK，表示接收到服务器准备好释放连接的信号；</li>
<li>序号为 Seq&#x3D; u + 1，表示是在已收到服务器报文的基础上，将其确认号 Ack 值作为本段序号的值；</li>
<li>确认号为 Ack&#x3D; w + 1，表示是在收到了服务器报文的基础上，将其序号 Seq 的值作为本段报文确认号的值。</li>
</ul>
<p>随后客户端开始在 TIME-WAIT 阶段等待 2 MSL。服务器端收到从客户端发出的 TCP 报文之后结束 LAST-ACK 阶段，进入 CLOSED 阶段。由此正式确认关闭服务器端到客户端方向上的连接。客户端等待完 2 MSL 之后，结束 TIME-WAIT 阶段，进入 CLOSED 阶段，由此完成「四次挥手」。</p>
<h3 id="2-如果三次握手的时候每次握手信息对方没有收到会怎么样"><a href="#2-如果三次握手的时候每次握手信息对方没有收到会怎么样" class="headerlink" title="2. 如果三次握手的时候每次握手信息对方没有收到会怎么样"></a>2. 如果三次握手的时候每次握手信息对方没有收到会怎么样</h3><ul>
<li>若第一次握手服务器未接收到客户端请求建立连接的数据包时，服务器不会进行任何相应的动作，而客户端由于在一段时间内没有收到服务器发来的确认报文， 因此会等待一段时间后重新发送 SYN 同步报文，若仍然没有回应，则重复上述过程直到发送次数超过最大重传次数限制后，建立连接的系统调用会返回 -1。</li>
<li>若第二次握手客户端未接收到服务器回应的 ACK 报文时，客户端会采取第一次握手失败时的动作，这里不再重复，而服务器端此时将阻塞在 accept() 系统调用处等待 client 再次发送 ACK 报文。</li>
<li>若第三次握手服务器未接收到客户端发送过来的 ACK 报文，同样会采取类似于客户端的超时重传机制，若重传次数超过限制后仍然没有回应，则 accep() 系统调用返回 -1，服务器端连接建立失败。但此时客户端认为自己已经连接成功了，因此开始向服务器端发送数据，但是服务器端的 accept() 系统调用已返回，此时没有在监听状态。因此服务器端接收到来自客户端发送来的数据时会发送 RST 报文给 客户端，消除客户端单方面建立连接的状态。</li>
</ul>
<h3 id="3-为什么要进行三次握手？两次握手可以吗？"><a href="#3-为什么要进行三次握手？两次握手可以吗？" class="headerlink" title="3. 为什么要进行三次握手？两次握手可以吗？"></a>3. 为什么要进行三次握手？两次握手可以吗？</h3><p>三次握手的主要目的是确认自己和对方的发送和接收都是正常的，从而保证了双方能够进行可靠通信。若采用两次握手，当第二次握手后就建立连接的话，此时客户端知道服务器能够正常接收到自己发送的数据，而服务器并不知道客户端是否能够收到自己发送的数据。</p>
<p>我们知道网络往往是非理想状态的（存在丢包和延迟），当客户端发起创建连接的请求时，如果服务器直接创建了这个连接并返回包含 SYN、ACK 和 Seq 等内容的数据包给客户端，这个数据包因为网络传输的原因丢失了，丢失之后客户端就一直接收不到返回的数据包。由于客户端可能设置了一个超时时间，一段时间后就关闭了连接建立的请求，再重新发起新的请求，而服务器端是不知道的，如果没有第三次握手告诉服务器客户端能否收到服务器传输的数据的话，服务器端的端口就会一直开着，等到客户端因超时重新发出请求时，服务器就会重新开启一个端口连接。长此以往， 这样的端口越来越多，就会造成服务器开销的浪费。</p>
<h3 id="4-第-2-次握手传回了-ACK，为什么还要传回-SYN"><a href="#4-第-2-次握手传回了-ACK，为什么还要传回-SYN" class="headerlink" title="4. 第 2 次握手传回了 ACK，为什么还要传回 SYN"></a>4. 第 2 次握手传回了 ACK，为什么还要传回 SYN</h3><p>ACK 是为了告诉客户端发来的数据已经接收无误，而传回 SYN 是为了告诉客户端，服务端收到的消息确实是客户端发送的消息。</p>
<h3 id="5-为什么要四次挥手？"><a href="#5-为什么要四次挥手？" class="headerlink" title="5. 为什么要四次挥手？"></a>5. 为什么要四次挥手？</h3><p>释放 TCP 连接时之所以需要四次挥手，是因为 FIN 释放连接报文和 ACK 确认接收报文是分别在两次握手中传输的。 当主动方在数据传送结束后发出连接释放的通知，由于被动方可能还有必要的数据要处理，所以会先返回 ACK 确认收到报文。当被动方也没有数据再发送的时候，则发出连接释放通知，对方确认后才完全关闭TCP连接。</p>
<p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p>
<h3 id="6-CLOSE-WAIT-和-TIME-WAIT-的状态和意义"><a href="#6-CLOSE-WAIT-和-TIME-WAIT-的状态和意义" class="headerlink" title="6. CLOSE-WAIT 和 TIME-WAIT 的状态和意义"></a>6. CLOSE-WAIT 和 TIME-WAIT 的状态和意义</h3><p>在服务器收到客户端关闭连接的请求并告诉客户端自己已经成功收到了该请求之后，服务器进入了 CLOSE-WAIT 状态，然而此时有可能服务端还有一些数据没有传输完成，因此不能立即关闭连接，而 CLOSE-WAIT 状态就是为了保证服务器在关闭连接之前将待发送的数据发送完成。</p>
<p>TIME-WAIT 发生在第四次挥手，当客户端向服务端发送 ACK 确认报文后进入该状态，若取消该状态，即客户端在收到服务端的 FIN 报文后立即关闭连接，此时服务端相应的端口并没有关闭，若客户端在相同的端口立即建立新的连接，则有可能接收到上一次连接中残留的数据包，可能会导致不可预料的异常出现。除此之外，假设客户端最后一次发送的 ACK 包在传输的时候丢失了，由于 TCP 协议的超时重传机制，服务端将重发 FIN 报文，若客户端并没有维持 TIME-WAIT 状态而直接关闭的话，当收到服务端重新发送的 FIN 包时，客户端就会用 RST 包来响应服务端，这将会使得对方认为是有错误发生，然而其实只是正常的关闭连接过程，并没有出现异常情况。</p>
<h3 id="7-TIME-WAIT-状态会导致什么问题，怎么解决"><a href="#7-TIME-WAIT-状态会导致什么问题，怎么解决" class="headerlink" title="7. TIME_WAIT 状态会导致什么问题，怎么解决"></a>7. TIME_WAIT 状态会导致什么问题，怎么解决</h3><p>我们考虑高并发短连接的业务场景，在高并发短连接的 TCP 服务器上，当服务器处理完请求后主动请求关闭连接，这样服务器上会有大量的连接处于 TIME_WAIT 状态，服务器维护每一个连接需要一个 socket，也就是每个连接会占用一个文件描述符，而文件描述符的使用是有上限的，如果持续高并发，会导致一些正常的 连接失败。</p>
<p>解决方案：修改配置或设置 SO_REUSEADDR 套接字，使得服务器处于 TIME-WAIT 状态下的端口能够快速回收和重用。</p>
<h3 id="8-TIME-WAIT-为什么是-2MSL"><a href="#8-TIME-WAIT-为什么是-2MSL" class="headerlink" title="8. TIME-WAIT 为什么是 2MSL"></a>8. TIME-WAIT 为什么是 2MSL</h3><p>当客户端发出最后的 ACK 确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完 ACK 确认报文之后，会设置一个时长为 2 MSL 的计时器。MSL（Maximum Segment Lifetime），指一段 TCP 报文在传输过程中的最大生命周期。2 MSL 即是服务器端发出 FIN 报文和客户端发出的 ACK 确认报文所能保持有效的最大时长。</p>
<p>若服务器在 1 MSL 内没有收到客户端发出的 ACK 确认报文，再次向客户端发出 FIN 报文。如果客户端在 2 MSL 内收到了服务器再次发来的 FIN 报文，说明服务器由于一些原因并没有收到客户端发出的 ACK 确认报文。客户端将再次向服务器发出 ACK 确认报文，并重新开始 2 MSL 的计时。</p>
<p>若客户端在 2MSL 内没有再次收到服务器发送的 FIN 报文，则说明服务器正常接收到客户端 ACK 确认报文，客户端可以进入 CLOSE 阶段，即完成四次挥手。</p>
<p>所以客户端要经历 2 MSL 时长的 TIME-WAIT 阶段，为的是确认服务器能否接收到客户端发出的 ACK 确认报文。</p>
<h3 id="9-有很多-TIME-WAIT-状态如何解决"><a href="#9-有很多-TIME-WAIT-状态如何解决" class="headerlink" title="9. 有很多 TIME-WAIT 状态如何解决"></a>9. 有很多 TIME-WAIT 状态如何解决</h3><p>服务器可以设置 SO_REUSEADDR 套接字选项来通知内核，如果端口被占用，但 TCP 连接位于 TIME_WAIT 状态时可以重用端口。如果你的服务器程序停止后想立即重启，而新的套接字依旧希望使用同一端口，此时 SO_REUSEADDR 选项就可以避免 TIME-WAIT 状态。</p>
<p>也可以采用长连接的方式减少 TCP 的连接与断开，在长连接的业务中往往不需要考虑 TIME-WAIT 状态，但其实在长连接的业务中并发量一般不会太高。</p>
<h3 id="10-有很多-CLOSE-WAIT-怎么解决"><a href="#10-有很多-CLOSE-WAIT-怎么解决" class="headerlink" title="10. 有很多 CLOSE-WAIT 怎么解决"></a>10. 有很多 CLOSE-WAIT 怎么解决</h3><ul>
<li>首先检查是不是自己的代码问题（看是否服务端程序忘记关闭连接），如果是，则修改代码。</li>
<li>调整系统参数，包括句柄相关参数和 TCP&#x2F;IP 的参数，一般一个 CLOSE_WAIT 会维持至少 2 个小时的时间，我们可以通过调整参数来缩短这个时间。</li>
</ul>
<h3 id="11-TCP-和-UDP-的区别"><a href="#11-TCP-和-UDP-的区别" class="headerlink" title="11. TCP 和 UDP 的区别"></a>11. TCP 和 UDP 的区别</h3><p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/16.png" alt="img"></p>
<h3 id="12-TCP-协议中的定时器"><a href="#12-TCP-协议中的定时器" class="headerlink" title="12. TCP 协议中的定时器"></a>12. TCP 协议中的定时器</h3><p>TCP中有七种计时器，分别为：</p>
<ul>
<li>建立连接定时器：顾名思义，该定时器是在建立 TCP 连接的时候使用的，在 TCP 三次握手的过程中，发送方发送 SYN 时，会启动一个定时器（默认为 3 秒），若 SYN 包丢失了，那么 3 秒以后会重新发送 SYN 包，直到达到重传次数。</li>
<li>重传定时器：该计时器主要用于 TCP 超时重传机制中，当TCP 发送报文段时，就会创建特定报文的重传计时器，并可能出现两种情况：</li>
</ul>
<p>① 若在计时器截止之前发送方收到了接收方的 ACK 报文，则撤销该计时器；</p>
<p>② 若计时器截止时间内并没有收到接收方的 ACK 报文，则发送方重传报文，并将计时器复位。</p>
<ul>
<li>坚持计时器：我们知道 TCP 通过让接受方指明希望从发送方接收的数据字节数（窗口大小）来进行流量控制，当接收端的接收窗口满时，接收端会告诉发送端此时窗口已满，请停止发送数据。此时发送端和接收端的窗口大小均为0，直到窗口变为非0时，接收端将发送一个 确认 ACK 告诉发送端可以再次发送数据，但是该报文有可能在传输时丢失。若该 ACK 报文丢失，则双方可能会一直等待下去，为了避免这种死锁情况的发生，发送方使用一个坚持定时器来周期性地向接收方发送探测报文段，以查看接收方窗口是否变大。</li>
<li>延迟应答计时器：延迟应答也被称为捎带 ACK，这个定时器是在延迟应答的时候使用的，为了提高网络传输的效率，当服务器接收到客户端的数据后，不是立即回 ACK 给客户端，而是等一段时间，这样如果服务端有数据需要发送给客户端的话，就可以把数据和 ACK 一起发送给客户端了。</li>
<li>保活定时器：该定时器是在建立 TCP 连接时指定 SO_KEEPLIVE 时才会生效，当发送方和接收方长时间没有进行数据交互时，该定时器可以用于确定对端是否还活着。</li>
<li>FIN_WAIT_2 定时器：当主动请求关闭的一方发送 FIN 报文给接收端并且收到其对 FIN 的确认 ACK后进入 FIN_WAIT_2状态。如果这个时候因为网络突然断掉、被动关闭的一端宕机等原因，导致请求方没有收到接收方发来的 FIN，主动关闭的一方会一直等待。该定时器的作用就是为了避免这种情况的发生。当该定时器超时的时候，请求关闭方将不再等待，直接释放连接。</li>
<li>TIME_WAIT 定时器：我们知道在 TCP 四次挥手中，发送方在最后一次挥手之后会进入 TIME_WAIT 状态，不直接进入 CLOSE 状态的主要原因是被动关闭方万一在超时时间内没有收到最后一个 ACK，则会重发最后的 FIN，2 MSL（报文段最大生存时间）等待时间保证了重发的 FIN 会被主动关闭的一段收到且重新发送最后一个 ACK 。还有一个原因是在这 2 MSL 的时间段内任何迟到的报文段会被接收方丢弃，从而防止老的 TCP 连接的包在新的 TCP 连接里面出现。</li>
</ul>
<h3 id="13-TCP-是如何保证可靠性的"><a href="#13-TCP-是如何保证可靠性的" class="headerlink" title="13. TCP 是如何保证可靠性的"></a>13. TCP 是如何保证可靠性的</h3><p><strong>数据分块</strong>： 应用数据被分割成 TCP 认为最适合发送的数据块。</p>
<p><strong>序列号和确认应答</strong>：TCP 给发送的每一个包进行编号，在传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答，即发送 ACK 报文，这个 ACK 报文当中带有对应的确认序列号，告诉发送方成功接收了哪些数据以及下一次的数据从哪里开始发。除此之外，接收方可以根据序列号对数据包进行排序，把有序数据传送给应用层，并丢弃重复的数据。</p>
<p><strong>校验和</strong>： TCP 将保持它首部和数据部分的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到报文段的检验和有差错，TCP 将丢弃这个报文段并且不确认收到此报文段。</p>
<p><strong>流量控制</strong>： TCP 连接的双方都有一个固定大小的缓冲空间，发送方发送的数据量不能超过接收端缓冲区的大小。当接收方来不及处理发送方的数据，会提示发送方降低发送的速率，防止产生丢包。TCP 通过滑动窗口协议来支持流量控制机制。</p>
<p><strong>拥塞控制</strong>： 当网络某个节点发生拥塞时，减少数据的发送。</p>
<p><strong>ARQ协议</strong>： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</p>
<p><strong>超时重传</strong>： 当 TCP 发出一个报文段后，它启动一个定时器，等待目的端确认收到这个报文段。如果超过某个时间还没有收到确认，将重发这个报文段。</p>
<h3 id="14-UDP-为什么是不可靠的？bind-和-connect-对于-UDP-的作用是什么"><a href="#14-UDP-为什么是不可靠的？bind-和-connect-对于-UDP-的作用是什么" class="headerlink" title="14. UDP 为什么是不可靠的？bind 和 connect 对于 UDP 的作用是什么"></a>14. UDP 为什么是不可靠的？bind 和 connect 对于 UDP 的作用是什么</h3><p>UDP 只有一个 socket 接收缓冲区，没有 socket 发送缓冲区，即只要有数据就发，不管对方是否可以正确接收。而在对方的 socket 接收缓冲区满了之后，新来的数据报无法进入到 socket 接受缓冲区，此数据报就会被丢弃，因此 UDP 不能保证数据能够到达目的地，此外，UDP 也没有流量控制和重传机制，故UDP的数据传输是不可靠的。</p>
<p>和 TCP 建立连接时采用三次握手不同，UDP 中调用 connect 只是把对端的 IP 和 端口号记录下来，并且 UDP 可多多次调用 connect 来指定一个新的 IP 和端口号，或者断开旧的 IP 和端口号（通过设置 connect 函数的第二个参数）。和普通的 UDP 相比，调用 connect 的 UDP 会提升效率，并且在高并发服务中会增加系统稳定性。</p>
<p>当 UDP 的发送端调用 bind 函数时，就会将这个套接字指定一个端口，若不调用 bind 函数，系统内核会随机分配一个端口给该套接字。当手动绑定时，能够避免内核来执行这一操作，从而在一定程度上提高性能。</p>
<h3 id="15-TCP-超时重传的原理"><a href="#15-TCP-超时重传的原理" class="headerlink" title="15. TCP 超时重传的原理"></a>15. TCP 超时重传的原理</h3><p>发送方在发送一次数据后就开启一个定时器，在一定时间内如果没有得到发送数据包的 ACK 报文，那么就重新发送数据，在达到一定次数还没有成功的话就放弃重传并发送一个复位信号。其中超时时间的计算是超时的核心，而定时时间的确定往往需要进行适当的权衡，因为当定时时间过长会造成网络利用率不高，定时太短会造成多次重传，使得网络阻塞。在 TCP 连接过程中，会参考当前的网络状况从而找到一个合适的超时时间。</p>
<h3 id="16-TCP-的停止等待协议是什么"><a href="#16-TCP-的停止等待协议是什么" class="headerlink" title="16. TCP 的停止等待协议是什么"></a>16. TCP 的停止等待协议是什么</h3><p>停止等待协议是为了实现 TCP 可靠传输而提出的一种相对简单的协议，该协议指的是发送方每发完一组数据后，直到收到接收方的确认信号才继续发送下一组数据。我们通过四种情形来帮助理解停等协议是如何实现可靠传输的：</p>
<p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/17.png" alt="img"></p>
<p>① 无差错传输</p>
<p>如上述左图所示，A 发送分组 Msg 1，发完就暂停发送，直到收到接收方确认收到 Msg 1 的报文后，继续发送 Msg 2，以此类推，该情形是通信中的一种理想状态。</p>
<p>② 出现差错</p>
<p>如上述右图所示，发送方发送的报文出现差错导致接收方不能正确接收数据，出现差错的情况主要分为两种：</p>
<ul>
<li>发送方发送的 Msg 1 在中途丢失了，接收方完全没收到数据。</li>
<li>接收方收到 Msg 1 后检测出现了差错，直接丢弃 Msg 1。</li>
</ul>
<p>上面两种情形，接收方都不会回任何消息给发送方，此时就会触发超时传输机制，即发送方在等待一段时间后仍然没有收到接收方的确认，就认为刚才发送的数据丢失了，因此重传前面发送过的数据。</p>
<p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/18.png" alt="img"></p>
<p>③ 确认丢失</p>
<p>当接收方回应的 Msg 1 确认报文在传输过程中丢失，发送方无法接收到确认报文。于是发送方等待一段时间后重传 Msg 1，接收方将收到重复的 Msg1 数据包，此时接收方会丢弃掉这个重复报文并向发送方再次发送 Msg1 的确认报文。</p>
<p>④ 确认迟到</p>
<p>当接收方回应的 Msg 1 确认报文由于网络各种原因导致发送方没有及时收到，此时发送方在超时重传机制的作用下再次发送了 Msg 数据包，接收方此时进行和确认丢失情形下相同的动作（丢弃重复的数据包并再次发送 Msg 1 确认报文）。发送方此时收到了接收方的确认数据包，于是继续进行数据发送。过了一段时间后，发送方收到了迟到的 Msg 1 确认包会直接丢弃。</p>
<p>上述四种情形即停止等待协议中所出现的所有可能情况。</p>
<h3 id="17-TCP-最大连接数限制"><a href="#17-TCP-最大连接数限制" class="headerlink" title="17. TCP 最大连接数限制"></a>17. TCP 最大连接数限制</h3><ul>
<li><strong>Client 最大 TCP 连接数</strong></li>
</ul>
<p>client 在每次发起 TCP 连接请求时，如果自己并不指定端口的话，系统会随机选择一个本地端口（local port），该端口是独占的，不能和其他 TCP 连接共享。TCP 端口的数据类型是 unsigned short，因此本地端口个数最大只有 65536，除了端口 0不能使用外，其他端口在空闲时都可以正常使用，这样可用端口最多有 65535 个。</p>
<ul>
<li><strong>Server最大 TCP 连接数</strong></li>
</ul>
<p>server 通常固定在某个本地端口上监听，等待 client 的连接请求。不考虑地址重用（Unix 的 SO_REUSEADDR 选项）的情况下，即使 server 端有多个 IP，本地监听端口也是独占的，因此 server 端 TCP 连接 4 元组中只有客户端的 IP 地址和端口号是可变的，因此最大 TCP 连接为客户端 IP 数 × 客户端 port 数，对 IPV4，在不考虑 IP 地址分类的情况下，最大 TCP 连接数约为 2 的 32 次方（IP 数）× 2 的 16 次方（port 数），也就是 server 端单机最大 TCP 连接数约为 2 的 48 次方。</p>
<p>然而上面给出的是只是理论上的单机最大连接数，在实际环境中，受到明文规定（一些 IP 地址和端口具有特殊含义，没有对外开放）、机器资源、操作系统等的限制，特别是 sever 端，其最大并发 TCP 连接数远不能达到理论上限。对 server 端，通过增加内存、修改最大文件描述符个数等参数，单机最大并发 TCP 连接数超过 10 万 是没问题的。</p>
<h3 id="18-TCP-流量控制与拥塞控制"><a href="#18-TCP-流量控制与拥塞控制" class="headerlink" title="18. TCP 流量控制与拥塞控制"></a>18. TCP 流量控制与拥塞控制</h3><ul>
<li>流量控制</li>
</ul>
<p>所谓流量控制就是让发送方的发送速率不要太快，让接收方来得及接收。如果接收方来不及接收发送方发送的数据，那么就会有分组丢失。在 TCP 中利用可边长的滑动窗口机制可以很方便的在 TCP 连接上实现对发送方的流量控制。主要的方式是接收方返回的 ACK 中会包含自己的接收窗口大小，以控制发送方此次发送的数据量大小（发送窗口大小）。</p>
<ul>
<li>拥塞控制</li>
</ul>
<p>在实际的网络通信系统中，除了发送方和接收方外，还有路由器，交换机等复杂的网络传输线路，此时就需要拥塞控制。拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况。常用的解决方法有：慢开始和拥塞避免、快重传和快恢复。</p>
<ul>
<li>拥塞控制和流量控制的区别</li>
</ul>
<p>拥塞控制往往是一种全局的，防止过多的数据注入到网络之中，而TCP连接的端点只要不能收到对方的确认信息，猜想在网络中发生了拥塞，但并不知道发生在何处，因此，流量控制往往指点对点通信量的控制，是端到端的问题。</p>
<h3 id="19-如果接收方滑动窗口满了，发送方会怎么做"><a href="#19-如果接收方滑动窗口满了，发送方会怎么做" class="headerlink" title="19. 如果接收方滑动窗口满了，发送方会怎么做"></a>19. 如果接收方滑动窗口满了，发送方会怎么做</h3><p>基于 TCP 流量控制中的滑动窗口协议，我们知道接收方返回给发送方的 ACK 包中会包含自己的接收窗口大小，若接收窗口已满，此时接收方返回给发送方的接收窗口大小为 0，此时发送方会等待接收方发送的窗口大小直到变为非 0 为止，然而，接收方回应的 ACK 包是存在丢失的可能的，为了防止双方一直等待而出现死锁情况，此时就需要坚持计时器来辅助发送方周期性地向接收方查询，以便发现窗口是否变大【坚持计时器参考问题】，当发现窗口大小变为非零时，发送方便继续发送数据。</p>
<h3 id="20-TCP-拥塞控制采用的四种算法"><a href="#20-TCP-拥塞控制采用的四种算法" class="headerlink" title="20. TCP 拥塞控制采用的四种算法"></a>20. TCP 拥塞控制采用的四种算法</h3><ul>
<li>慢开始</li>
</ul>
<p>当发送方开始发送数据时，由于一开始不知道网络负荷情况，如果立即将大量的数据字节传输到网络中，那么就有可能引起网络拥塞。一个较好的方法是在一开始发送少量的数据先探测一下网络状况，即由小到大的增大发送窗口（拥塞窗口 cwnd）。慢开始的慢指的是初始时令 cwnd为 1，即一开始发送一个报文段。如果收到确认，则 cwnd &#x3D; 2，之后每收到一个确认报文，就令 cwnd &#x3D; cwnd* 2。</p>
<p>但是，为了防止拥塞窗口增长过大而引起网络拥塞，另外设置了一个慢开始门限 ssthresh。</p>
<p>① 当 cwnd &lt; ssthresh 时，使用上述的慢开始算法；</p>
<p>② 当 cwnd &gt; ssthresh 时，停止使用慢开始，转而使用拥塞避免算法；</p>
<p>③ 当 cwnd &#x3D;&#x3D; ssthresh 时，两者均可。</p>
<ul>
<li>拥塞避免</li>
</ul>
<p>拥塞控制是为了让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT （往返时间定义为发送方发送数据到收到确认报文所经历的时间）就把发送方的 cwnd 值加 1，通过让 cwnd 线性增长，防止很快就遇到网络拥塞状态。</p>
<p>当网络拥塞发生时，让新的慢开始门限值变为发生拥塞时候的值的一半,并将拥塞窗口置为 1 ,然后再次重复两种算法（慢开始和拥塞避免）,这时一瞬间会将网络中的数据量大量降低。</p>
<ul>
<li>快重传</li>
</ul>
<p>快重传算法要求接收方每收到一个失序的报文就立即发送重复确认，而不要等到自己发送数据时才捎带进行确认，假定发送方发送了 Msg 1 ~ Msg 4 这 4 个报文，已知接收方收到了 Msg 1，Msg 3 和 Msg 4 报文，此时因为接收到收到了失序的数据包，按照快重传的约定，接收方应立即向发送方发送 Msg 1 的重复确认。 于是在接收方收到 Msg 4 报文的时候，向发送方发送的仍然是 Msg 1 的重复确认。这样，发送方就收到了 3 次 Msg 1 的重复确认，于是立即重传对方未收到的 Msg 报文。由于发送方尽早重传未被确认的报文段，因此，快重传算法可以提高网络的吞吐量。</p>
<ul>
<li>快恢复</li>
</ul>
<p>快恢复算法是和快重传算法配合使用的，该算法主要有以下两个要点：</p>
<p>① 当发送方连续收到三个重复确认，执行乘法减小，慢开始门限 ssthresh 值减半；</p>
<p>② 由于发送方可能认为网络现在没有拥塞，因此与慢开始不同，把 cwnd 值设置为 ssthresh 减半之后的值，然后执行拥塞避免算法，线性增大 cwnd。</p>
<h3 id="21-TCP-粘包问题"><a href="#21-TCP-粘包问题" class="headerlink" title="21. TCP 粘包问题"></a>21. TCP 粘包问题</h3><p><strong>为什么会发生TCP粘包和拆包?</strong></p>
<p>① 发送方写入的数据大于套接字缓冲区的大小，此时将发生拆包。</p>
<p>② 发送方写入的数据小于套接字缓冲区大小，由于 TCP 默认使用 Nagle 算法，只有当收到一个确认后，才将分组发送给对端，当发送方收集了多个较小的分组，就会一起发送给对端，这将会发生粘包。</p>
<p>③ 进行 MSS （最大报文长度）大小的 TCP 分段，当 TCP 报文的数据部分大于 MSS 的时候将发生拆包。</p>
<p>④ 发送方发送的数据太快，接收方处理数据的速度赶不上发送端的速度，将发生粘包。</p>
<p><strong>常见解决方法</strong></p>
<p>① 在消息的头部添加消息长度字段，服务端获取消息头的时候解析消息长度，然后向后读取相应长度的内容。</p>
<p>② 固定消息数据的长度，服务端每次读取既定长度的内容作为一条完整消息，当消息不够长时，空位补上固定字符。但是该方法会浪费网络资源。</p>
<p>③ 设置消息边界，也可以理解为分隔符，服务端从数据流中按消息边界分离出消息内容，一般使用换行符。</p>
<p><strong>什么时候需要处理粘包问题？</strong></p>
<p>当接收端同时收到多个分组，并且这些分组之间毫无关系时，需要处理粘包；而当多个分组属于同一数据的不同部分时，并不需要处理粘包问题。</p>
<h3 id="22-TCP-报文包含哪些信息"><a href="#22-TCP-报文包含哪些信息" class="headerlink" title="22. TCP 报文包含哪些信息"></a>22. TCP 报文包含哪些信息</h3><p>TCP 报文是 TCP 传输的的数据单元，也叫做报文段，其报文格式如下图所示：</p>
<p><img src="/2022/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/19.png" alt="img"></p>
<ul>
<li>源端口和目的端口号：它用于多路复用&#x2F;分解来自或送往上层应用的数据，其和 IP 数据报中的源 IP 与目的 IP 地址一同确定一条 TCP 连接。</li>
<li>序号和确认号字段：序号是本报文段发送的数据部分中第一个字节的编号，在 TCP 传送的流中，每一个字节一个序号。例如一个报文段的序号为 100，此报文段数据部分共有 100 个字节，则下一个报文段的序号为 200。序号确保了 TCP 传输的有序性。确认号，即 ACK，指明下一个想要收到的字节序号，发送 ACK 时表明当前序号之前的所有数据已经正确接收。这两个字段的主要目的是保证数据可靠传输。</li>
<li>首部长度：该字段指示了以 32 比特的字为单位的 TCP 的首部长度。其中固定字段长度为 20 字节，由于首部长度可能含有可选项内容，因此 TCP 报头的长度是不确定的，20 字节是 TCP 首部的最小长度。</li>
<li>保留：为将来用于新的用途而保留。</li>
<li>控制位：URG 表示紧急指针标志，该位为 1 时表示紧急指针有效，为 0 则忽略；ACK 为确认序号标志，即相应报文段包括一个对已被成功接收报文段的确认；PSH 为 push 标志，当该位为 1 时，则指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队； RST 为重置连接标志，当出现错误连接时，使用此标志来拒绝非法的请求；SYN 为同步序号，在连接的建立过程中使用，例如三次握手时，发送方发送 SYN 包表示请求建立连接；FIN 为 finish 标志，用于释放连接，为 1 时表示发送方已经没有数据发送了，即关闭本方数据流。</li>
<li>接收窗口：主要用于 TCP 流量控制。该字段用来告诉发送方其窗口（缓冲区）大小，以此控制发送速率，从而达到流量控制的目的。</li>
<li>校验和：奇偶校验，此校验和是对整个 TCP 报文段，包括 TCP 头部和 数据部分。该校验和是一个端到端的校验和，由发送端计算和存储，并由接收端进行验证，主要目的是检验数据是否发生改动，若检测出差错，接收方会丢弃该 TCP 报文。</li>
<li>紧急数据指针：紧急数据用于告知紧急数据所在的位置，在URG标志位为 1 时才有效。当紧急数据存在时，TCP 必须通知接收方的上层实体，接收方会对紧急模式采取相应的处理。</li>
<li>选项：该字段一般为空，可根据首部长度进行推算。主要有以下作用：</li>
</ul>
<p>① TCP 连接初始化时，通信双方确认最大报文长度。</p>
<p>② 在高速数据传输时，可使用该选项协商窗口扩大因子。</p>
<p>③ 作为时间戳时，提供一个 较为精准的 RTT，主要为了更好的实现 TCP 流量控制协议。</p>
<ul>
<li>数据：TCP 报文中的数据部分也是可选的，例如在 TCP 三次握手和四次挥手过程中，通信双方交换的报文只包含头部信息，数据部分为空，只有当连接成功建立后，TCP 包才真正携带数据。</li>
</ul>
<h3 id="23-SYN-FLOOD-是什么"><a href="#23-SYN-FLOOD-是什么" class="headerlink" title="23. SYN FLOOD 是什么"></a>23. SYN FLOOD 是什么</h3><p>SYN Flood 是种典型的 DoS（拒绝服务）攻击，其目的是通过消耗服务器所有可用资源使服务器无法用于处理合法请求。通过重复发送初始连接请求（SYN）数据包，攻击者能够压倒目标服务器上的所有可用端口，导致目标设备根本不响应合法请求。</p>
<h3 id="24-为什么服务端易受到-SYN-攻击"><a href="#24-为什么服务端易受到-SYN-攻击" class="headerlink" title="24. 为什么服务端易受到 SYN 攻击"></a>24. 为什么服务端易受到 SYN 攻击</h3><p>在 TCP 建立连接的过程中，因为服务端不确定自己发给客户端的 SYN-ACK 消息或客户端反馈的 ACK 消息是否会丢在半路，所以会给每个待完成的半开连接状态设一个定时器，如果超过时间还没有收到客户端的 ACK 消息，则重新发送一次 SYN-ACK 消息给客户端，直到重试超过一定次数时才会放弃。</p>
<p>服务端为了维持半开连接状态，需要分配内核资源维护半开连接。当攻击者伪造海量的虚假 IP 向服务端发送 SYN 包时，就形成了 SYN FLOOD 攻击。攻击者故意不响应 ACK 消息，导致服务端被大量注定不能完成的半开连接占据，直到资源耗尽，停止响应正常的连接请求。</p>
<p><strong>解决方法：</strong></p>
<ul>
<li>直接的方法是提高 TCP 端口容量的同时减少半开连接的资源占用时间，然而该方法只是稍稍提高了防御能力；</li>
<li>部署能够辨别恶意 IP 的路由器，将伪造 IP 地址的发送方发送的 SYN 消息过滤掉，该方案作用一般不是太大；</li>
</ul>
<p>上述两种方法虽然在一定程度上能够提高服务器的防御能力，但是没有从根本上解决服务器资源消耗殆尽的问题，而以下几种方法的出发点都是在发送方发送确认回复后才开始分配传输资源，从而避免服务器资源消耗殆尽。</p>
<p><strong>SYN Cache</strong>：该方法首先构造一个全局 Hash Table，用来缓存系统当前所有的半开连接信息。在 Hash Table 中的每个桶的容量大小是有限制的，当桶满时，会主动丢掉早来的信息。当服务端收到一个 SYN 消息后，会通过一个映射函数生成一个相应的 Key 值，使得当前半连接信息存入相应的桶中。当收到客户端正确的确认报文后，服务端才开始分配传输资源块，并将相应的半开连接信息从表中删除。和服务器传输资源相比，维护表的开销要小得多。</p>
<p><strong>SYN Cookies</strong>：该方案原理和 HTTP Cookies 技术类似，服务端通过特定的算法将半开连接信息编码成序列号或者时间戳，用作服务端给客户端的消息编号，随 SYN-ACK 消息一同返回给连接发起方，这样在连接建立完成前服务端不保存任何信息，直到发送方发送 ACK 确认报文并且服务端成功验证编码信息后，服务端才开始分配传输资源。若请求方是攻击者，则不会向服务端会 ACK 消息，由于未成功建立连接，因此服务端并没有花费任何额外的开销。</p>
<p>然而该方案也存在一些缺点，由于服务端并不保存半开连接状态，因此也就丧失了超时重传的能力，这在一定程度上降低了正常用户的连接成功率。此外，客户端发送给服务端的确认报文存在传输丢失的可能，当 ACK 确认报文丢失时，服务端和客户端会对连接的成功与否产生歧义，此时就需要上层应用采取相应的策略进行处理了。</p>
<p><strong>SYN Proxy</strong>：在客户端和服务器之间部署一个代理服务器，类似于防火墙的作用。通过代理服务器与客户端进行建立连接的过程，之后代理服务器充当客户端将成功建立连接的客户端信息发送给服务器。这种方法基本不消耗服务器的资源，但是建立连接的时间变长了（总共需要 6 次握手）。</p>
<h3 id="25-高并发服务器客户端主动关闭连接和服务端主动关闭连接的区别"><a href="#25-高并发服务器客户端主动关闭连接和服务端主动关闭连接的区别" class="headerlink" title="25. 高并发服务器客户端主动关闭连接和服务端主动关闭连接的区别"></a>25. 高并发服务器客户端主动关闭连接和服务端主动关闭连接的区别</h3><p>以下是针对 TCP 服务来说的：</p>
<ul>
<li>服务端主动关闭连接</li>
</ul>
<p>在高并发场景下，当服务端主动关闭连接时，此时服务器上就会有大量的连接处于 TIME-WAIT 状态【详解见问题 7, 8, 9】</p>
<ul>
<li>客户端主动关闭连接</li>
</ul>
<p>当客户端主动关闭连接时，我们并不需要关心 TIME-WAIT 状态过多造成的问题，但是需要关注服务端保持大量的 CLOSE-WAIT 状态时会产生的问题【见问题 10 的解决方法】</p>
<p>无论是客户端还是服务器主动关闭连接，从本质上来说，在高并发场景下主要关心的就是服务端的资源占用问题，而这也是采用 TCP 传输协议必须要面对的问题，其问题解决的出发点也是如何处理好服务质量和资源消耗之间的关系。</p>
<h2 id="四：网络层"><a href="#四：网络层" class="headerlink" title="四：网络层"></a>四：网络层</h2><h3 id="1-IP-协议的定义和作用"><a href="#1-IP-协议的定义和作用" class="headerlink" title="1. IP 协议的定义和作用"></a>1. IP 协议的定义和作用</h3><p>IP 协议（Internet Protocol）又称互联网协议，是支持网间互联的数据包协议。该协议工作在网络层，主要目的就是为了提高网络的可扩展性，和传输层 TCP 相比，IP 协议提供一种无连接&#x2F;不可靠、尽力而为的数据包传输服务，其与TCP协议（传输控制协议）一起构成了TCP&#x2F;IP 协议族的核心。IP 协议主要有以下几个作用：</p>
<ul>
<li>寻址和路由：在IP 数据包中会携带源 IP 地址和目的 IP 地址来标识该数据包的源主机和目的主机。IP 数据报在传输过程中，每个中间节点（IP 网关、路由器）只根据网络地址进行转发，如果中间节点是路由器，则路由器会根据路由表选择合适的路径。IP 协议根据路由选择协议提供的路由信息对 IP 数据报进行转发，直至抵达目的主机。</li>
<li>分段与重组：IP 数据包在传输过程中可能会经过不同的网络，在不同的网络中数据包的最大长度限制是不同的，IP 协议通过给每个 IP 数据包分配一个标识符以及分段与组装的相关信息，使得数据包在不同的网络中能够传输，被分段后的 IP 数据报可以独立地在网络中进行转发，在到达目的主机后由目的主机完成重组工作，恢复出原来的 IP 数据包。</li>
</ul>
<h3 id="2-域名和-IP-的关系，一个-IP-可以对应多个域名吗"><a href="#2-域名和-IP-的关系，一个-IP-可以对应多个域名吗" class="headerlink" title="2. 域名和 IP 的关系，一个 IP 可以对应多个域名吗"></a>2. 域名和 IP 的关系，一个 IP 可以对应多个域名吗</h3><p>IP 在同一个网络中是唯一的，用来标识每一个网络上的设备，其相当于一个人的身份证号；域名在同一个网络中也是唯一的，就像一个人的名字，绰号。假如你有多个不同的绰号，你的朋友可以用其中任何一个绰号叫你，但你的身份证号码却是唯一的。由此我们可以看出一个域名只能对应一个 IP 地址，是一对一的关系；而一个 IP 却可以对应多个域名，是一对多的关系。</p>
<h3 id="3-IPV4-地址不够如何解决"><a href="#3-IPV4-地址不够如何解决" class="headerlink" title="3. IPV4 地址不够如何解决"></a>3. IPV4 地址不够如何解决</h3><ul>
<li>DHCP：动态主机配置协议。动态分配 IP 地址，只给接入网络的设备分配IP地址，因此同一个 MAC 地址的设备，每次接入互联网时，得到的IP地址不一定是相同的，该协议使得空闲的 IP 地址可以得到充分利用。</li>
<li>CIDR：无类别域间路由。CIDR 消除了传统的 A 类、B 类、C 类地址以及划分子网的概念，因而更加有效的分配 IPv4 的地址空间，但无法从根本上解决地址耗尽问题。</li>
<li>NAT：网络地址转换协议。我们知道属于不同局域网的主机可以使用相同的 IP 地址，从而一定程度上缓解了 IP 资源枯竭的问题。然而主机在局域网中使用的 IP 地址是不能在公网中使用的，当局域网主机想要与公网进行通信时， NAT 方法可以将该主机 IP 地址转换成全球 IP 地址。该协议能够有效解决 IP 地址不足的问题。</li>
<li>IPv6 ：作为接替 IPv4 的下一代互联网协议，其可以实现 2 的 128 次方个地址，而这个数量级，即使是给地球上每一颗沙子都分配一个IP地址，该协议能够从根本上解决 IPv4 地址不够用的问题。</li>
</ul>
<h3 id="4-路由器的分组转发流程"><a href="#4-路由器的分组转发流程" class="headerlink" title="4. 路由器的分组转发流程"></a>4. 路由器的分组转发流程</h3><p>① 从 IP 数据包中提取出目的主机的 IP 地址，找到其所在的网络；</p>
<p>② 判断目的 IP 地址所在的网络是否与本路由器直接相连，如果是，则不需要经过其它路由器直接交付，否则执行 ③；</p>
<p>③ 检查路由表中是否有目的 IP 地址的特定主机路由。如果有，则按照路由表传送到下一跳路由器中，否则执行 ④；</p>
<p>④ 逐条检查路由表，若找到匹配路由，则按照路由表转发到下一跳路由器中，否则执行步骤 ⑤；</p>
<p>⑤ 若路由表中设置有默认路由，则按照默认路由转发到默认路由器中，否则执行步骤 ⑥；</p>
<p>⑥ 无法找到合适路由，向源主机报错。</p>
<h3 id="5-路由器和交换机的区别"><a href="#5-路由器和交换机的区别" class="headerlink" title="5. 路由器和交换机的区别"></a>5. 路由器和交换机的区别</h3><ul>
<li>交换机：交换机用于局域网，利用主机的物理地址（MAC 地址）确定数据转发的目的地址，它工作与数据链路层。</li>
<li>路由器：路由器通过数据包中的目的 IP 地址识别不同的网络从而确定数据转发的目的地址，网络号是唯一的。路由器根据路由选择协议和路由表信息从而确定数据的转发路径，直到到达目的网络，它工作于网络层。</li>
</ul>
<h3 id="6-ICMP-协议概念-x2F-作用"><a href="#6-ICMP-协议概念-x2F-作用" class="headerlink" title="6. ICMP 协议概念&#x2F;作用"></a>6. ICMP 协议概念&#x2F;作用</h3><p>ICMP（Internet Control Message Protocol）是因特网控制报文协议，主要是实现 IP 协议中未实现的部分功能，是一种网络层协议。该协议并不传输数据，只传输控制信息来辅助网络层通信。其主要的功能是验证网络是否畅通（确认接收方是否成功接收到 IP 数据包）以及辅助 IP 协议实现可靠传输（若发生 IP 丢包，ICMP 会通知发送方 IP 数据包被丢弃的原因，之后发送方会进行相应的处理）。</p>
<h3 id="7-ICMP-的应用"><a href="#7-ICMP-的应用" class="headerlink" title="7. ICMP 的应用"></a>7. ICMP 的应用</h3><ul>
<li>Ping</li>
</ul>
<p>Ping（Packet Internet Groper），即因特网包探测器，是一种工作在网络层的服务命令，主要用于测试网络连接量。本地主机通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 响应报文，Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率从而推断网络是否通常、运行是否正常等。</p>
<ul>
<li>TraceRoute</li>
</ul>
<p>TraceRoute 是 ICMP 的另一个应用，其主要用来跟踪一个分组从源点耗费最少 TTL 到达目的地的路径。TraceRoute 通过逐渐增大 TTL 值并重复发送数据报来实现其功能，首先，TraceRoute 会发送一个 TTL 为 1 的 IP 数据报到目的地，当路径上的第一个路由器收到这个数据报时，它将 TTL 的值减 1，此时 TTL &#x3D; 0，所以路由器会将这个数据报丢掉，并返回一个差错报告报文，之后源主机会接着发送一个 TTL 为 2 的数据报，并重复此过程，直到数据报能够刚好到达目的主机。此时 TTL &#x3D; 0，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文，之后源主机便知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</p>
<h3 id="8-两台电脑连起来后-ping-不通，你觉得可能存在哪些问题？"><a href="#8-两台电脑连起来后-ping-不通，你觉得可能存在哪些问题？" class="headerlink" title="8. 两台电脑连起来后 ping 不通，你觉得可能存在哪些问题？"></a>8. 两台电脑连起来后 ping 不通，你觉得可能存在哪些问题？</h3><ol>
<li>首先看网络是否连接正常，检查网卡驱动是否正确安装。</li>
<li>局域网设置问题，检查 IP 地址是否设置正确。</li>
<li>看是否被防火墙阻拦（有些设置中防火墙会对 ICMP 报文进行过滤），如果是的话，尝试关闭防火墙 。</li>
<li>看是否被第三方软件拦截。</li>
<li>两台设备间的网络延迟是否过大（例如路由设置不合理），导致 ICMP 报文无法在规定的时间内收到。</li>
</ol>
<h3 id="9-ARP-地址解析协议的原理和地址解析过程"><a href="#9-ARP-地址解析协议的原理和地址解析过程" class="headerlink" title="9. ARP 地址解析协议的原理和地址解析过程"></a>9. ARP 地址解析协议的原理和地址解析过程</h3><p>ARP（Address Resolution Protocol）是地址解析协议的缩写，该协议提供根据 IP 地址获取物理地址的功能，它工作在第二层，是一个数据链路层协议，其在本层和物理层进行联系，同时向上层提供服务。当通过以太网发送 IP 数据包时，需要先封装 32 位的 IP 地址和 48位 MAC 地址。在局域网中两台主机进行通信时需要依靠各自的物理地址进行标识，但由于发送方只知道目标 IP 地址，不知道其 MAC 地址，因此需要使用地址解析协议。 ARP 协议的解析过程如下：</p>
<p>① 首先，每个主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址之间的对应关系；</p>
<p>② 当源主机要发送数据时，首先检查 ARP 列表中是否有 IP 地址对应的目的主机 MAC 地址，如果存在，则可以直接发送数据，否则就向同一子网的所有主机发送 ARP 数据包。该数据包包括的内容有源主机的 IP 地址和 MAC 地址，以及目的主机的 IP 地址。</p>
<p>③ 当本网络中的所有主机收到该 ARP 数据包时，首先检查数据包中的 目的 主机IP 地址是否是自己的 IP 地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的 IP 和 MAC 地址写入到 ARP 列表中，如果已经存在，则覆盖，然后将自己的 MAC 地址写入 ARP 响应包中，告诉源主机自己是它想要找的 MAC 地址。</p>
<p>④ 源主机收到 ARP 响应包后。将目的主机的 IP 和 MAC 地址写入 ARP 列表，并利用此信息发送数据。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。</p>
<h3 id="10-网络地址转换-NAT"><a href="#10-网络地址转换-NAT" class="headerlink" title="10. 网络地址转换 NAT"></a>10. 网络地址转换 NAT</h3><p>NAT（Network Address Translation），即网络地址转换，它是一种把内部私有网络地址翻译成公有网络 IP 地址的技术。该技术不仅能解决 IP 地址不足的问题，而且还能隐藏和保护网络内部主机，从而避免来自外部网络的攻击。</p>
<p>NAT 的实现方式主要有三种：</p>
<ul>
<li>静态转换：内部私有 IP 地址和公有 IP 地址是一对一的关系，并且不会发生改变。通过静态转换，可以实现外部网络对内部网络特定设备的访问，这种方式原理简单，但当某一共有 IP 地址被占用时，跟这个 IP 绑定的内部主机将无法访问 Internet。</li>
<li>动态转换：采用动态转换的方式时，私有 IP 地址每次转化成的公有 IP 地址是不唯一的。当私有 IP 地址被授权访问 Internet 时会被随机转换成一个合法的公有 IP 地址。当 ISP 通过的合法 IP 地址数量略少于网络内部计算机数量时，可以采用这种方式。</li>
<li>端口多路复用：该方式将外出数据包的源端口进行端口转换，通过端口多路复用的方式，实现内部网络所有主机共享一个合法的外部 IP 地址进行 Internet 访问，从而最大限度地节约 IP 地址资源。同时，该方案可以隐藏内部网络中的主机，从而有效避免来自 Internet 的攻击。</li>
</ul>
<h3 id="11-TTL-是什么？有什么作用"><a href="#11-TTL-是什么？有什么作用" class="headerlink" title="11. TTL 是什么？有什么作用"></a>11. TTL 是什么？有什么作用</h3><p>TTL 是指生存时间，简单来说，它表示了数据包在网络中的时间。每经过一个路由器后 TTL 就减一，这样 TTL 最终会减为 0 ，当 TTL 为 0 时，则将数据包丢弃。通过设置 TTL 可以避免这两个路由器之间形成环导致数据包在环路上死转的情况，由于有了 TTL ，当 TTL 为 0 时，数据包就会被抛弃。</p>
<h3 id="12-运输层协议和网络层协议的区别"><a href="#12-运输层协议和网络层协议的区别" class="headerlink" title="12. 运输层协议和网络层协议的区别"></a>12. 运输层协议和网络层协议的区别</h3><p>网络层协议负责提供主机间的逻辑通信；运输层协议负责提供进程间的逻辑通信。</p>
<h2 id="五：数据链路层"><a href="#五：数据链路层" class="headerlink" title="五：数据链路层"></a>五：数据链路层</h2><h3 id="1-MAC-地址和-IP-地址分别有什么作用"><a href="#1-MAC-地址和-IP-地址分别有什么作用" class="headerlink" title="1. MAC 地址和 IP 地址分别有什么作用"></a>1. MAC 地址和 IP 地址分别有什么作用</h3><ul>
<li>MAC 地址是数据链路层和物理层使用的地址，是写在网卡上的物理地址。MAC 地址用来定义网络设备的位置。</li>
<li>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。IP 地址用来区别网络上的计算机。</li>
</ul>
<h3 id="2-为什么有了-MAC-地址还需要-IP-地址"><a href="#2-为什么有了-MAC-地址还需要-IP-地址" class="headerlink" title="2. 为什么有了 MAC 地址还需要 IP 地址"></a>2. 为什么有了 MAC 地址还需要 IP 地址</h3><p>如果我们只使用 MAC 地址进行寻址的话，我们需要路由器记住每个 MAC 地址属于哪一个子网，不然每一次路由器收到数据包时都要满世界寻找目的 MAC 地址。而我们知道 MAC 地址的长度为 48 位，也就是说最多总共有 2 的 48 次方个 MAC 地址，这就意味着每个路由器需要 256 T 的内存，这显然是不现实的。</p>
<p>和 MAC 地址不同，IP 地址是和地域相关的，在一个子网中的设备，我们给其分配的 IP 地址前缀都是一样的，这样路由器就能根据 IP 地址的前缀知道这个设备属于哪个子网，剩下的寻址就交给子网内部实现，从而大大减少了路由器所需要的内存。</p>
<h3 id="3-为什么有了-IP-地址还需要-MAC-地址"><a href="#3-为什么有了-IP-地址还需要-MAC-地址" class="headerlink" title="3. 为什么有了 IP 地址还需要 MAC 地址"></a>3. 为什么有了 IP 地址还需要 MAC 地址</h3><p>只有当设备连入网络时，才能根据他进入了哪个子网来为其分配 IP 地址，在设备还没有 IP 地址的时候或者在分配 IP 地址的过程中，我们需要 MAC 地址来区分不同的设备。</p>
<h3 id="4-私网地址和公网地址之间进行转换：同一个局域网内的两个私网地址，经过转换之后外面看到的一样吗"><a href="#4-私网地址和公网地址之间进行转换：同一个局域网内的两个私网地址，经过转换之后外面看到的一样吗" class="headerlink" title="4. 私网地址和公网地址之间进行转换：同一个局域网内的两个私网地址，经过转换之后外面看到的一样吗"></a>4. 私网地址和公网地址之间进行转换：同一个局域网内的两个私网地址，经过转换之后外面看到的一样吗</h3><p>当采用静态或者动态转换时，由于一个私网 IP 地址对应一个公网地址，因此经过转换之后的公网 IP 地址是不同的；而采用端口复用方式的话，在一个子网中的所有地址都采用一个公网地址，但是使用的端口是不同的。</p>
<h3 id="5-以太网中的-CSMA-x2F-CD-协议"><a href="#5-以太网中的-CSMA-x2F-CD-协议" class="headerlink" title="5. 以太网中的 CSMA&#x2F;CD 协议"></a>5. 以太网中的 CSMA&#x2F;CD 协议</h3><p>CSMA&#x2F;CD 为载波侦听多路访问&#x2F;冲突检测，是像以太网这种广播网络采用的一种机制，我们知道在以太网中多台主机在同一个信道中进行数据传输，CSMA&#x2F;CD 很好的解决了共享信道通信中出现的问题，它的工作原理主要包括两个部分：</p>
<ul>
<li>载波监听：当使用 CSMA&#x2F;CD 协议时，总线上的各个节点都在监听信道上是否有信号在传输，如果有的话，表明信道处于忙碌状态，继续保持监听，直到信道空闲为止。如果发现信道是空闲的，就立即发送数据。</li>
<li>冲突检测：当两个或两个以上节点同时监听到信道空闲，便开始发送数据，此时就会发生碰撞（数据的传输延迟也可能引发碰撞）。当两个帧发生冲突时，数据帧就会破坏而失去了继续传输的意义。在数据的发送过程中，以太网是一直在监听信道的，当检测到当前信道冲突，就立即停止这次传输，避免造成网络资源浪费，同时向信道发送一个「冲突」信号，确保其它节点也发现该冲突。之后采用一种二进制退避策略让待发送数据的节点随机退避一段时间之后重新。</li>
</ul>
<h3 id="6-数据链路层上的三个基本问题"><a href="#6-数据链路层上的三个基本问题" class="headerlink" title="6. 数据链路层上的三个基本问题"></a>6. 数据链路层上的三个基本问题</h3><p><strong>封装成帧</strong>：将网络层传下来的分组前后分别添加首部和尾部，这样就构成了帧。首部和尾部的一个重要作用是帧定界，也携带了一些必要的控制信息，对于每种数据链路层协议都规定了帧的数据部分的最大长度。</p>
<p><strong>透明传输</strong>：帧使用首部和尾部进行定界，如果帧的数据部分含有和首部和尾部相同的内容， 那么帧的开始和结束的位置就会判断错，因此需要在数据部分中出现有歧义的内容前边插入转义字符，如果数据部分出现转义字符，则在该转义字符前再加一个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</p>
<p><strong>差错检测</strong>：目前数据链路层广泛使用循环冗余检验（CRC）来检查数据传输过程中是否产生比特差错。</p>
<h3 id="7-PPP-协议"><a href="#7-PPP-协议" class="headerlink" title="7. PPP 协议"></a>7. PPP 协议</h3><p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP（点对点）协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。点对点协议为点对点连接上传输多协议数据包提供了一个标准方法。该协议设计的目的主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种解决方案。</p>
<p>PPP 协议具有以下特点：</p>
<ul>
<li>PPP 协议具有动态分配 IP 地址的能力，其允许在连接时刻协商 IP 地址。</li>
<li>PPP 支持多种网络协议，例如 TCP&#x2F;IP、NETBEUI 等。</li>
<li>PPP 具有差错检测能力，但不具备纠错能力，所以 PPP 是不可靠传输协议。</li>
<li>无重传的机制，网络开销小，速度快。</li>
<li>PPP 具有身份验证的功能。</li>
</ul>
<h3 id="8-为什么-PPP-协议不使用序号和确认机制"><a href="#8-为什么-PPP-协议不使用序号和确认机制" class="headerlink" title="8. 为什么 PPP 协议不使用序号和确认机制"></a>8. 为什么 PPP 协议不使用序号和确认机制</h3><ul>
<li>IETF 在设计因特网体系结构时把齐总最复杂的部分放在 TCP 协议中，而网际协议 IP 则相对比较简单，它提供的是不可靠的数据包服务，在这种情况下，数据链路层没有必要提供比 IP 协议更多的功能。若使用能够实现可靠传输的数据链路层协议，则开销就要增大，这在数据链路层出现差错概率不大时是得不偿失的。</li>
<li>即使数据链路层实现了可靠传输，但其也不能保证网络层的传输也是可靠的，当数据帧在路由器中从数据链路层上升到网络层后，仍有可能因为网络层拥塞而被丢弃。</li>
<li>PPP 协议在帧格式中有帧检验序列，对每一个收到的帧，PPP 都会进行差错检测，若发现差错，则丢弃该帧。</li>
</ul>
<h3 id="9-物理层主要做什么事情"><a href="#9-物理层主要做什么事情" class="headerlink" title="9. 物理层主要做什么事情"></a>9. 物理层主要做什么事情</h3><p>作为 OSI 参考模型最低的一层，物理层是整个开放系统的基础，该层利用传输介质为通信的两端建立、管理和释放物理连接，实现比特流的透明传输。物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，其尽可能地屏蔽掉不同种类传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异，这样就可以使数据链路层只考虑完成本层的协议和服务，而不必考虑网络的具体传输媒体和通信手段是什么。</p>
<h3 id="10-主机之间的通信方式"><a href="#10-主机之间的通信方式" class="headerlink" title="10. 主机之间的通信方式"></a>10. 主机之间的通信方式</h3><p><strong>单工通信</strong>：也叫单向通信，发送方和接收方是固定的，消息只能单向传输。例如采集气象数据、家庭电费，网费等数据收集系统，或者打印机等应用主要采用单工通信。 <strong>半双工通信</strong>：也叫双向交替通信，通信双方都可以发送消息，但同一时刻同一信道只允许单方向发送数据。例如传统的对讲机使用的就是半双工通信。 <strong>全双工通信</strong>：也叫双向同时通信，全双工通信允许通信双方同时在两个方向是传输，其要求通信双方都具有独立的发送和接收数据的能力。例如平时我们打电话，自己说话的同时也能听到对面的声音。</p>
<h3 id="11-通道复用技术"><a href="#11-通道复用技术" class="headerlink" title="11. 通道复用技术"></a>11. 通道复用技术</h3><p><strong>频分复用（FDM，Frequency Division Multiplexing）</strong> 频分复用将传输信道的总带宽按频率划分为若干个子频带或子信道，每个子信道传输一路信号。用户分到一定的频带后，在数据传输的过程中自始至终地占用这个频带。由于每个用户所分到的频带不同，使得传输信道在同一时刻能够支持不同用户进行数据传输，从而实现复用。除了传统意义上的 FDM 外，目前正交频分复用（OFDM）已在高速通信系统中得到广泛应用。</p>
<p><strong>时分复用（TDM，Time Division Multiplexing）</strong> 顾名思义，时分复用将信道传输信息的时间划分为若干个时间片，每一个时分复用的用户在每一个 TDM 帧中占用固定时隙进行数据传输。用户所分配到的时隙是固定的，所以时分复用有时也叫做同步时分复用。这种分配方式能够便于调节控制，但是也存在缺点，当某个信道空闲时，其他繁忙的信道无法占用该空闲信道，因此会降低信道利用率。</p>
<p><strong>波分复用（WDM，Wavelength Division Multiplexing）</strong> 在光通信领域通常按照波长而不是频率来命名，因为光的频率和波长具有单一对应关系，因此 WDM 本质上也是 FDM，光通信系统中，通常由光来运载信号进行传输，WDM 是在一条光纤上传输多个波长光信号，其将 1 根光纤看做多条「虚拟」光纤，每条「虚拟」光纤工作在不同的波长上，从而极大地提高了光纤的传输容量。</p>
<p><strong>码分复用（CDM，Code Division Multiplexing）</strong> 码分复用是靠不同的编码来区分各路原始信号的一种复用方式，不同的用户使用相互正交的码字携带信息。由于码组相互正交，因此接收方能够有效区分不同的用户数据，从而实现每一个用户可以在同样的时间在同样的频带进行数据传输，频谱资源利用率高。其主要和各种多址接入技术相结合从而产生各种接入技术，包括无线和优先接入。</p>
<h3 id="12-几种常用的宽带接入技术"><a href="#12-几种常用的宽带接入技术" class="headerlink" title="12. 几种常用的宽带接入技术"></a>12. 几种常用的宽带接入技术</h3><p>我们一般将速率超过 1 Mbps 的接入称为宽带接入，目前常用的宽带接入技术主要包括：ADSL 和 FTTx + LAN。</p>
<ul>
<li>ADSL</li>
</ul>
<p>ADSL 全称为非对称用户数字环路，是铜线宽带接入技术的一种。其非对称体现在用户上行和下行的传输速率不相等，一般上行速率较低，下行速率高。这种接入技术适用于有宽带业务需求的家庭用户或者中小型商务用户等。</p>
<ul>
<li>FTTx + LAN</li>
</ul>
<p>其中 FTTx 英文翻译为 Fiber To The X，这里的 X 指任何地方，我们可以理解为光纤可以接入到任何地方，而 LAN 指的是局域网。FTTx + LAN 是一种在接入网全部或部分采用光纤传输介质，构成光纤用户线路，从而实现用户高速上网的接入技术，其中用户速率可达 20 Mbps。这种接入技术投资规模小，网络拓展性强，网络可靠稳定，使得其应用广泛，目前是城市汇总较为普及的一种宽带接入技术。</p>
<p>其它还有 光纤同轴混合网（HFC）、光接入技术（有源和无源光纤系统）和无线接入技术等等。</p>
<h2 id="六：物理层"><a href="#六：物理层" class="headerlink" title="六：物理层"></a>六：物理层</h2><h3 id="1-物理层主要做什么事情"><a href="#1-物理层主要做什么事情" class="headerlink" title="1. 物理层主要做什么事情"></a>1. 物理层主要做什么事情</h3><p>作为 OSI 参考模型最低的一层，物理层是整个开放系统的基础，该层利用传输介质为通信的两端建立、管理和释放物理连接，实现比特流的透明传输。物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，其尽可能地屏蔽掉不同种类传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异，这样就可以使数据链路层只考虑完成本层的协议和服务，而不必考虑网络的具体传输媒体和通信手段是什么。</p>
<h3 id="2-主机之间的通信方式"><a href="#2-主机之间的通信方式" class="headerlink" title="2. 主机之间的通信方式"></a>2. 主机之间的通信方式</h3><p><strong>单工通信</strong>：也叫单向通信，发送方和接收方是固定的，消息只能单向传输。例如采集气象数据、家庭电费，网费等数据收集系统，或者打印机等应用主要采用单工通信。 <strong>半双工通信</strong>：也叫双向交替通信，通信双方都可以发送消息，但同一时刻同一信道只允许单方向发送数据。例如传统的对讲机使用的就是半双工通信。 <strong>全双工通信</strong>：也叫双向同时通信，全双工通信允许通信双方同时在两个方向是传输，其要求通信双方都具有独立的发送和接收数据的能力。例如平时我们打电话，自己说话的同时也能听到对面的声音。</p>
<h3 id="3-通道复用技术"><a href="#3-通道复用技术" class="headerlink" title="3. 通道复用技术"></a>3. 通道复用技术</h3><p><strong>频分复用（FDM，Frequency Division Multiplexing）</strong> 频分复用将传输信道的总带宽按频率划分为若干个子频带或子信道，每个子信道传输一路信号。用户分到一定的频带后，在数据传输的过程中自始至终地占用这个频带。由于每个用户所分到的频带不同，使得传输信道在同一时刻能够支持不同用户进行数据传输，从而实现复用。除了传统意义上的 FDM 外，目前正交频分复用（OFDM）已在高速通信系统中得到广泛应用。</p>
<p><strong>时分复用（TDM，Time Division Multiplexing）</strong> 顾名思义，时分复用将信道传输信息的时间划分为若干个时间片，每一个时分复用的用户在每一个 TDM 帧中占用固定时隙进行数据传输。用户所分配到的时隙是固定的，所以时分复用有时也叫做同步时分复用。这种分配方式能够便于调节控制，但是也存在缺点，当某个信道空闲时，其他繁忙的信道无法占用该空闲信道，因此会降低信道利用率。</p>
<p><strong>波分复用（WDM，Wavelength Division Multiplexing）</strong> 在光通信领域通常按照波长而不是频率来命名，因为光的频率和波长具有单一对应关系，因此 WDM 本质上也是 FDM，光通信系统中，通常由光来运载信号进行传输，WDM 是在一条光纤上传输多个波长光信号，其将 1 根光纤看做多条「虚拟」光纤，每条「虚拟」光纤工作在不同的波长上，从而极大地提高了光纤的传输容量。</p>
<p><strong>码分复用（CDM，Code Division Multiplexing）</strong> 码分复用是靠不同的编码来区分各路原始信号的一种复用方式，不同的用户使用相互正交的码字携带信息。由于码组相互正交，因此接收方能够有效区分不同的用户数据，从而实现每一个用户可以在同样的时间在同样的频带进行数据传输，频谱资源利用率高。其主要和各种多址接入技术相结合从而产生各种接入技术，包括无线和优先接入。</p>
<h3 id="4-几种常用的宽带接入技术"><a href="#4-几种常用的宽带接入技术" class="headerlink" title="4. 几种常用的宽带接入技术"></a>4. 几种常用的宽带接入技术</h3><p>我们一般将速率超过 1 Mbps 的接入称为宽带接入，目前常用的宽带接入技术主要包括：ADSL 和 FTTx + LAN。</p>
<ul>
<li>ADSL</li>
</ul>
<p>ADSL 全称为非对称用户数字环路，是铜线宽带接入技术的一种。其非对称体现在用户上行和下行的传输速率不相等，一般上行速率较低，下行速率高。这种接入技术适用于有宽带业务需求的家庭用户或者中小型商务用户等。</p>
<ul>
<li>FTTx + LAN</li>
</ul>
<p>其中 FTTx 英文翻译为 Fiber To The X，这里的 X 指任何地方，我们可以理解为光纤可以接入到任何地方，而 LAN 指的是局域网。FTTx + LAN 是一种在接入网全部或部分采用光纤传输介质，构成光纤用户线路，从而实现用户高速上网的接入技术，其中用户速率可达 20 Mbps。这种接入技术投资规模小，网络拓展性强，网络可靠稳定，使得其应用广泛，目前是城市汇总较为普及的一种宽带接入技术。</p>
<p>其它还有 光纤同轴混合网（HFC）、光接入技术（有源和无源光纤系统）和无线接入技术等等。</p>
<h2 id="七：计算机网络中的安全问题"><a href="#七：计算机网络中的安全问题" class="headerlink" title="七：计算机网络中的安全问题"></a>七：计算机网络中的安全问题</h2><h3 id="1-安全攻击有哪些"><a href="#1-安全攻击有哪些" class="headerlink" title="1. 安全攻击有哪些"></a>1. 安全攻击有哪些</h3><p>网络安全攻击主要分为被动攻击和主动攻击两类：</p>
<ul>
<li>被动攻击：攻击者窃听和监听数据传输，从而获取到传输的数据信息，被动攻击主要有两种形式：消息内容泄露攻击和流量分析攻击。由于攻击者并没有修改数据，使得这种攻击类型是很难被检测到的。</li>
<li>主动攻击：攻击者修改传输的数据流或者故意添加错误的数据流，例如假冒用户身份从而得到一些权限，进行权限攻击，除此之外，还有重放、改写和拒绝服务等主动攻击的方式。</li>
</ul>
<h3 id="2-ARP-攻击"><a href="#2-ARP-攻击" class="headerlink" title="2. ARP 攻击"></a>2. ARP 攻击</h3><p>在 ARP 的解析过程中，局域网上的任何一台主机如果接收到一个 ARP 应答报文，并不会去检测这个报文的真实性，而是直接记入自己的 ARP 缓存表中。并且这个 ARP 表是可以被更改的，当表中的某一列长时间不适使用，就会被删除。ARP 攻击就是利用了这一点，攻击者疯狂发送 ARP 报文，其源 MAC 地址为攻击者的 MAC 地址，而源 IP 地址为被攻击者的 IP 地址。通过不断发送这些伪造的 ARP 报文，让网络内部的所有主机和网关的 ARP 表中被攻击者的 IP 地址所对应的 MAC 地址为攻击者的 MAC 地址。这样所有发送给被攻击者的信息都会发送到攻击者的主机上，从而产生 ARP 欺骗。通常可以把 ARP 欺骗分为以下几种：</p>
<ul>
<li>洪泛攻击</li>
</ul>
<p>攻击者恶意向局域网中的网关、路由器和交换机等发送大量 ARP 报文，设备的 CPU 忙于处理 ARP 协议，而导致难以响应正常的服务请求。其表现通常为：网络中断或者网速很慢。</p>
<ul>
<li>欺骗主机</li>
</ul>
<p>这种攻击方式也叫仿冒网关攻击。攻击者通过 ARP 欺骗使得网络内部被攻击主机发送给网关的信息实际上都发送给了攻击者，主机更新的 ARP 表中对应的 MAC 地址为攻击者的 MAC。当用户主机向网关发送重要信息使，该攻击方式使得用户的数据存在被窃取的风险。</p>
<ul>
<li>欺骗网关</li>
</ul>
<p>该攻击方式和欺骗主机的攻击方式类似，不过这种攻击的欺骗对象是局域网的网关，当局域网中的主机向网关发送数据时，网关会把数据发送给攻击者，这样攻击者就会源源不断地获得局域网中用户的信息。该攻击方式同样会造成用户数据外泄。</p>
<ul>
<li>中间人攻击</li>
</ul>
<p>攻击者同时欺骗网关和主机，局域网的网关和主机发送的数据最后都会到达攻击者这边。这样，网关和用户的数据就会泄露。</p>
<ul>
<li>IP 地址冲突</li>
</ul>
<p>攻击者对局域网中的主机进行扫描，然后根据物理主机的 MAC 地址进行攻击，导致局域网内的主机产生 IP 冲突，使得用户的网络无法正常使用。</p>
<h3 id="3-对称加密和非对称的区别，非对称加密有哪些"><a href="#3-对称加密和非对称的区别，非对称加密有哪些" class="headerlink" title="3. 对称加密和非对称的区别，非对称加密有哪些"></a>3. 对称加密和非对称的区别，非对称加密有哪些</h3><ul>
<li>加密和解密的过程不同：对称加密和解密过程使用同一个密钥；非对称加密中加密和解密采用公钥和私钥两个密钥，一般使用公钥进行加密，使用私钥进行解密。</li>
<li>加密和解密的速度不同：对称加密和解密速度较快，当数据量比较大时适合使用；非对称加密和解密时间较长，速度相对较慢，适合少量数据传输的场景。</li>
<li>传输的安全性不同：采用对称加密方式进行通信时，收发双方在数据传送前需要协定好密钥，而这个密钥还有可能被第三方窃听到的，一旦密钥泄漏，之后的通信就完全暴漏给攻击者了；非对称加密采用公钥加密和私钥解密的方式，其中私钥是基于不同的算法生成的随机数，公钥可以通过私钥通过一定的算法推导得出，并且私钥到公钥的推导过程是不可逆的，也就是说公钥无法反推导出私钥，即使攻击者窃听到传输的公钥，也无法正确解出数据，所以安全性较高。</li>
</ul>
<p>常见的非对称加密算法主要有：RSA、Elgamal、背包算法、Rabin、D-H 算法等等。</p>
<h3 id="4-AES-的过程"><a href="#4-AES-的过程" class="headerlink" title="4. AES 的过程"></a>4. AES 的过程</h3><p>AES（Advanced Encryption Standard）即密码学的高级加密标准，也叫做 Rijndeal 加密法，是为最为常见的一种对称加密算法，和传统的对称加密算法大致的流程类似，在发送端需要采用加密算法对明文进行加密，在接收端需要采用与加密算法相同的算法进行解密，不同的是， AES 采用分组加密的方式，将明文分成一组一组的，每组长度相等，每次加密一组数据，直到加密完整个明文。在 AES 标准中，分组长度固定为 128 位，即每个分组为 16 个字节（每个字节有 8 位）。而密钥的长度可以是 128 位，192 位或者 256 位。并且密钥的长度不同，推荐加密的轮数也不同。</p>
<p>我们以 128 位密钥为例（加密轮次为 10），已知明文首先需要分组，每一组大小为16个字节并形成 4 × 4 的状态矩阵（矩阵中的每一个元素代表一个字节）。类似地，128 位密钥同样用 4 × 4 的字节矩阵表示，矩阵中的每一列称为 1 个 32 位的比特字。通过密钥编排函数该密钥矩阵被扩展成一个由 44 个字组成的序列，该序列的前四个字是原始密钥，用于 AES 的初始密钥加过程，后面 40 个字分为 10 组，每组 4 个字分别用于 10 轮加密运算中的轮密钥加。在每轮加密过程中主要包括四个步骤：</p>
<p>① <strong>字节代换</strong>：AES 的字节代换其实是一个简易的查表操作，在 AES 中定义了一个 S-box 和一个逆 S-box，我们可以将其简单地理解为两个映射表，在做字节代换时，状态矩阵中的每一个元素（字节）的高四位作为行值，低四位作为列值，取出 S-box 或者逆 S-box 中对应的行或者列作为输出。</p>
<p>② <strong>行位移</strong>：顾名思义，就是对状态矩阵的每一行进行位移操作，其中状态矩阵的第 0 行左移 0 位，第 1 行左移 1 位，以此类推。</p>
<p>③ <strong>列混合</strong>：列混合变换是通过矩阵相乘来实现的，经唯一后的状态矩阵与固定的矩阵相乘，从而得到混淆后的状态矩阵。其中矩阵相乘中涉及到的加法等价于两个字节的异或运算，而乘法相对复杂一些，对于状态矩阵中的每一个 8 位二进制数来说，首先将其与 00000010 相乘，其等效为将 8 位二进制数左移一位，若原二进制数的最高位是 1 的话再将左移后的数与 00011011 进行异或运算。</p>
<p>④ <strong>轮密相加</strong>：在开始时我们提到，128 位密钥通过密钥编排函数被扩展成 44 个字组成的序列，其中前 4 个字用于加密过程开始时对原始明文矩阵进行异或运算，而后 40 个字中每四个一组在每一轮中与状态矩阵进行异或运算（共计 10 轮）。</p>
<p>上述过程即为 AES 加密算法的主要流程，在我们的例子中，上述过程需要经过 10 轮迭代。而 AES 的解密过程的各个步骤和加密过程是一样的，只是用逆变换取代原来的变换。</p>
<h3 id="5-RSA-和-AES-算法有什么区别"><a href="#5-RSA-和-AES-算法有什么区别" class="headerlink" title="5. RSA 和 AES 算法有什么区别"></a>5. RSA 和 AES 算法有什么区别</h3><ul>
<li>RSA</li>
</ul>
<p>采用非对称加密的方式，采用公钥进行加密，私钥解密的形式。其私钥长度一般较长，除此之外，由于需要大数的乘幂求模等运算，其运算速度较慢，不适合大量数据文件加密。</p>
<ul>
<li>AES</li>
</ul>
<p>采用对称加密的方式，其密钥长度最长只有 256 个比特，加密和解密速度较快，易于硬件实现。由于是对称加密，通信双方在进行数据传输前需要获知加密密钥。</p>
<p>基于上述两种算法的特点，一般使用 RSA 传输密钥给对方，之后使用 AES 进行加密通信。</p>
<h3 id="6-DDoS-有哪些，如何防范"><a href="#6-DDoS-有哪些，如何防范" class="headerlink" title="6. DDoS 有哪些，如何防范"></a>6. DDoS 有哪些，如何防范</h3><p>DDoS 为分布式拒绝服务攻击，是指处于不同位置的多个攻击者同时向一个或数个目标发动攻击，或者一个攻击者控制了不同位置上的多台机器并利用这些机器对受害者同时实施攻击。和单一的 DoS 攻击相比，DDoS 是借助数百台或者数千台已被入侵并添加了攻击进程的主机一起发起网络攻击。</p>
<p>DDoS 攻击主要有两种形式：流量攻击和资源耗尽攻击。前者主要针对网络带宽，攻击者和已受害主机同时发起大量攻击导致网络带宽被阻塞，从而淹没合法的网络数据包；后者主要针对服务器进行攻击，大量的攻击包会使得服务器资源耗尽或者 CPU 被内核应用程序占满从而无法提供网络服务。</p>
<p>常见的 DDos 攻击主要有：TCP 洪水攻击（SYN Flood）、放射性攻击（DrDos）、CC 攻击（HTTP Flood）等。</p>
<p>针对 DDoS 中的流量攻击，最直接的方法是增加带宽，理论上只要带宽大于攻击流量就可以了，但是这种方法成本非常高。在有充足网络带宽的前提下，我们应尽量提升路由器、网卡、交换机等硬件设施的配置。</p>
<p>针对资源耗尽攻击，我们可以升级主机服务器硬件，在网络带宽得到保证的前提下，使得服务器能有效对抗海量的 SYN 攻击包。我们也可以安装专业的抗 DDoS 防火墙，从而对抗 SYN Flood等流量型攻击。此外，负载均衡，CDN 等技术都能够有效对抗 DDoS 攻击</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>HTTP</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-策略模式I</title>
    <url>/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8FI/</url>
    <content><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8FI/1.png" alt="图片"></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>什么是策略模式？它的原理实现是怎么样的？</p>
<blockquote>
<p>定义一系列算法，封装每个算法，并使他们可以互换，不同的策略可以让算法独立于使用它们的客户而变化。以上定义来自设计模式之美</p>
</blockquote>
<p>感觉有点抽象？那就来看一张结构图吧</p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8FI/2.png" alt="图片"></p>
<blockquote>
<ul>
<li>Strategy（抽象策略）：抽象策略类，并且定义策略执行入口</li>
<li>ConcreteStrategy（具体策略）：实现抽象策略，实现algorithm方法</li>
<li>Context（环境）：运行特定的策略类。</li>
</ul>
</blockquote>
<p>这么看结构其实还是不复杂的，而且跟状态模式类似。</p>
<p>那么这个代码怎么实现？</p>
<p>举个例子，汽车大家肯定都不陌生，愿大家早日完成汽车梦，汽车的不同档(concreteStrategy）就好比不同的策略，驾驶者选择几档则汽车按几档的速度前进，整个选择权在驾驶者（context）手中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GearStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义策略执行方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">(String param)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先还是先定义抽象策略</p>
<blockquote>
<p>这里是用接口的形式，还有一种方式可以用抽象方法<strong>abstract</strong>来写也是一样的。具体就看大家自己选择了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">GearStrategyAbstract</span> &#123;</span><br><span class="line"><span class="comment">// 定义策略执行方法</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">(String param)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GearStrategyOne</span> <span class="keyword">implements</span> <span class="title class_">GearStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">(String param)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前档位&quot;</span> + param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次定义具体档位策略，实现algorithm方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">  <span class="comment">// 缓存所有的策略，当前是无状态的，可以共享策略类对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, GearStrategy&gt; strategies = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一种写法</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        strategies.put(<span class="string">&quot;one&quot;</span>, <span class="keyword">new</span> <span class="title class_">GearStrategyOne</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GearStrategy <span class="title function_">getStrategy</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="literal">null</span> || type.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;type should not be empty.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strategies.get(type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种写法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GearStrategy <span class="title function_">getStrategySecond</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="literal">null</span> || type.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;type should not be empty.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">&quot;one&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GearStrategyOne</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 测试结果</span></span><br><span class="line">        <span class="type">GearStrategy</span> <span class="variable">strategyOne</span> <span class="operator">=</span> Context.getStrategy(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">        strategyOne.algorithm(<span class="string">&quot;1档&quot;</span>);</span><br><span class="line">         <span class="comment">// 结果：当前档位1档</span></span><br><span class="line">        <span class="type">GearStrategy</span> <span class="variable">strategyTwo</span> <span class="operator">=</span> Context.getStrategySecond(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">        strategyTwo.algorithm(<span class="string">&quot;1档&quot;</span>);</span><br><span class="line">        <span class="comment">// 结果：当前档位1档</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后就是实现运行时环境（Context），你可以定义成StrategyFactory，但都是一个意思。</p>
<p>在main方法里面的测试demo，可以看到通过不同的type类型，可以实现不同的策略，这就是策略模式主要思想。</p>
<p>在Context里面定义了两种写法：</p>
<blockquote>
<ul>
<li>第一种是维护了一个strategies的Map容器。用这种方式就需要判断每种策略是否可以共享使用，它只是作为算法的实现。</li>
<li>第二种是直接通过有状态的类，每次根据类型new一个新的策略类对象。这个就需要根据实际业务场景去做的判断。</li>
</ul>
</blockquote>
<h3 id="框架的应用"><a href="#框架的应用" class="headerlink" title="框架的应用"></a>框架的应用</h3><p>策略模式在框架中也在一个很常见的地方体现出来了，而且大家肯定都有使用过。</p>
<p>那就是JDK中的线程池<strong>ThreadPoolExecutor</strong></p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8FI/3.png" alt="图片"></p>
<p>首先都是类似于这样定义一个线程池，里面实现线程池的异常策略。</p>
<p>这个线程池的异常策略就是用的策略模式的思想。</p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8FI/4.png" alt="图片"></p>
<p>在源码中有RejectedExecutionHandler这个抽象异常策略接口，同时它也有四种拒绝策略。关系图如下：</p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8FI/5.png" alt="图片"></p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8FI/6.png" alt="图片"></p>
<p>这就是在框架中的体现了，根据自己的业务场景，合理的选择线程池的异常策略。</p>
<h3 id="业务改造举例"><a href="#业务改造举例" class="headerlink" title="业务改造举例"></a>业务改造举例</h3><p>在真实的业务场景中策略模式也还是应用很多的。</p>
<p>在社交电商中分享商品是一个很重要的环节，假设现在要我们实现一个分享图片功能，比如当前有 单商品、多商品、下单、会场、邀请、小程序链接等等多种分享场景。</p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8FI/7.png" alt="图片"></p>
<p>针对上线这个流程图先用if else语句做一个普通业务代码判断，就像下面的这中方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleItemShare</span> &#123;</span><br><span class="line">    <span class="comment">// 单商品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">(String param)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前分享图片是&quot;</span> + param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiItemShare</span> &#123;</span><br><span class="line">    <span class="comment">// 多商品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">(String param)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前分享图片是&quot;</span> + param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderItemShare</span> &#123;</span><br><span class="line">    <span class="comment">// 下单</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">(String param)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前分享图片是&quot;</span> + param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShareFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">shareType</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">       <span class="comment">// 测试业务逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (shareType.equals(ShareType.SINGLE.getCode())) &#123;</span><br><span class="line">            <span class="type">SingleItemShare</span> <span class="variable">singleItemShare</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleItemShare</span>();</span><br><span class="line">            singleItemShare.algorithm(<span class="string">&quot;单商品&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shareType.equals(ShareType.MULTI.getCode())) &#123;</span><br><span class="line">            <span class="type">MultiItemShare</span> <span class="variable">multiItemShare</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MultiItemShare</span>();</span><br><span class="line">            multiItemShare.algorithm(<span class="string">&quot;多商品&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shareType.equals(ShareType.ORDER.getCode())) &#123;</span><br><span class="line">            <span class="type">OrderItemShare</span> <span class="variable">orderItemShare</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderItemShare</span>();</span><br><span class="line">            orderItemShare.algorithm(<span class="string">&quot;下单&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;未知分享类型&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// .....省略更多分享场景</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">ShareType</span> &#123;</span><br><span class="line">        SINGLE(<span class="number">1</span>, <span class="string">&quot;单商品&quot;</span>),</span><br><span class="line">        MULTI(<span class="number">2</span>, <span class="string">&quot;多商品&quot;</span>),</span><br><span class="line">        ORDER(<span class="number">3</span>, <span class="string">&quot;下单&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 场景对应的编码</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Integer code;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 业务场景描述</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> String desc;</span><br><span class="line">        ShareType(Integer code, String desc) &#123;</span><br><span class="line">            <span class="built_in">this</span>.code = code;</span><br><span class="line">            <span class="built_in">this</span>.desc = desc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> code;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 省略 get set 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里大家可以看到每新加一种分享类型，就需要加一次if else 判断，当如果有十几种场景的时候那代码整体就会非常的长，看起来给人的感觉也不是很舒服。</p>
<p>接下来就看看如何用策略模式进行重构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ShareStrategy</span> &#123;</span><br><span class="line">    <span class="comment">// 定义分享策略执行方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">shareAlgorithm</span><span class="params">(String param)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderItemShare</span> <span class="keyword">implements</span> <span class="title class_">ShareStrategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shareAlgorithm</span><span class="params">(String param)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前分享图片是&quot;</span> + param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略 MultiItemShare以及SingleItemShare策略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分享工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShareFactory</span> &#123;</span><br><span class="line">  <span class="comment">// 定义策略枚举</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">ShareType</span> &#123;</span><br><span class="line">        SINGLE(<span class="string">&quot;single&quot;</span>, <span class="string">&quot;单商品&quot;</span>),</span><br><span class="line">        MULTI(<span class="string">&quot;multi&quot;</span>, <span class="string">&quot;多商品&quot;</span>),</span><br><span class="line">        ORDER(<span class="string">&quot;order&quot;</span>, <span class="string">&quot;下单&quot;</span>);</span><br><span class="line">        <span class="comment">// 场景对应的编码</span></span><br><span class="line">        <span class="keyword">private</span> String code;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 业务场景描述</span></span><br><span class="line">        <span class="keyword">private</span> String desc;</span><br><span class="line">        ShareType(String code, String desc) &#123;</span><br><span class="line">            <span class="built_in">this</span>.code = code;</span><br><span class="line">            <span class="built_in">this</span>.desc = desc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> code;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 省略 get set 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 定义策略map缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, ShareStrategy&gt; shareStrategies = <span class="keyword">new</span>       <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        shareStrategies.put(<span class="string">&quot;order&quot;</span>, <span class="keyword">new</span> <span class="title class_">OrderItemShare</span>());</span><br><span class="line">        shareStrategies.put(<span class="string">&quot;single&quot;</span>, <span class="keyword">new</span> <span class="title class_">SingleItemShare</span>());</span><br><span class="line">        shareStrategies.put(<span class="string">&quot;multi&quot;</span>, <span class="keyword">new</span> <span class="title class_">MultiItemShare</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取指定策略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ShareStrategy <span class="title function_">getShareStrategy</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="literal">null</span> || type.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;type should not be empty.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shareStrategies.get(type);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 测试demo</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shareType</span> <span class="operator">=</span> <span class="string">&quot;order&quot;</span>;</span><br><span class="line">        <span class="type">ShareStrategy</span> <span class="variable">shareStrategy</span> <span class="operator">=</span> ShareFactory.getShareStrategy(shareType);</span><br><span class="line">        shareStrategy.shareAlgorithm(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        <span class="comment">// 输出结果：当前分享图片是order</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里策略模式就已经改造完了。在client请求端，根本看不到那么多的if else判断，只需要传入对应的策略方式即可，这里我们维护了一个策略缓存map，在直接调用的ShareFactory获取策略的时候就直接是从换种获取策略类对象。</p>
<p>这就已经达到了行为解偶的思想。同时也避免了长串的if else 判断。</p>
<p>优点：</p>
<blockquote>
<ul>
<li>算法策略可以自由实现切换</li>
<li>扩展性好，加一个策略，只需要增加一个类</li>
</ul>
</blockquote>
<p>缺点：</p>
<blockquote>
<ul>
<li>策略类数量多</li>
<li>需要维护一个策略枚举，让别人知道你当前具有哪些策略</li>
</ul>
</blockquote>
<p><strong>以上策略模式可以优化点：不需要枚举类，通过Spring IOC容器自动注入到map中：</strong></p>
<h4 id="Spring-Autowired-注入到List和Map"><a href="#Spring-Autowired-注入到List和Map" class="headerlink" title="Spring @Autowired 注入到List和Map"></a>Spring @Autowired 注入到List和Map</h4><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>BeanInterface只是一个接口无方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Autowired.ListMap;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * order：把实现类排序输出 只适合List </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liu </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="meta">@Order(2)</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanImplOne</span> <span class="keyword">implements</span> <span class="title class_">BeanInterface</span> &#123;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.Autowired.ListMap;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Order(1)</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanImplTwo</span> <span class="keyword">implements</span> <span class="title class_">BeanInterface</span> &#123;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Autowired.ListMap;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.util.List;  </span><br><span class="line"><span class="keyword">import</span> java.util.Map;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanInvoke</span> &#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> List&lt;BeanInterface&gt; list;  </span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,BeanInterface&gt; map;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** <span class="doctag">@Autowired</span>默认为byType的  所以有两个相同类型的bean   </span></span><br><span class="line"><span class="comment">     * 如果不使用 <span class="doctag">@Qualifier</span>指定具体的bean就会抛出异常 </span></span><br><span class="line"><span class="comment">     *  private BeanInterface beaninterface; </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    <span class="meta">@Qualifier(&quot;beanImplOne&quot;)</span>  </span><br><span class="line">    <span class="keyword">private</span> BeanInterface beaninterface;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;list...&quot;</span>);  </span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> !=list &amp;&amp;<span class="number">0</span>!=list.size())&#123;  </span><br><span class="line">            <span class="keyword">for</span>(BeanInterface bean :list)&#123;  </span><br><span class="line">                System.out.println(bean.getClass().getName());  </span><br><span class="line">            &#125;  </span><br><span class="line">              </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;List&lt;BeanInterface&gt; list is null !!!!&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println();  </span><br><span class="line">        System.out.println(<span class="string">&quot;map...&quot;</span>);  </span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> !=map &amp;&amp;<span class="number">0</span>!=map.size())&#123;  </span><br><span class="line">            <span class="keyword">for</span>(Map.Entry&lt;String, BeanInterface&gt; m:map.entrySet())&#123;  </span><br><span class="line">                  System.out.println(m.getKey()+<span class="string">&quot;    &quot;</span>+m.getValue().getClass().getName());  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;Map&lt;String,BeanInterface&gt; map is null !!!!&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------&quot;</span>);  </span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> !=beaninterface)&#123;  </span><br><span class="line">            System.out.println(beaninterface.getClass().getName());  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;beaninterface is null !!!&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.Autowired.ListMap;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> org.junit.Test;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.imooc.test.base.UnitTestBase;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestListMap</span>  <span class="keyword">extends</span> <span class="title class_">UnitTestBase</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestListMap</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;classpath*:spring-beanannotation3.xml&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Test</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;  </span><br><span class="line">        BeanInvoke  bean=<span class="built_in">super</span>.getBean(<span class="string">&quot;beanInvoke&quot;</span>);  </span><br><span class="line">        bean.say();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans  </span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd  </span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context  </span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span> &gt;</span>  </span><br><span class="line">          </span><br><span class="line">        <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;package com.Autowired.ListMap;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span>  </span><br><span class="line">          </span><br><span class="line"> <span class="tag">&lt;/<span class="name">beans</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2017</span>-<span class="number">6</span>-<span class="number">4</span> <span class="number">15</span>:<span class="number">38</span>:<span class="number">26</span> org.springframework.context.support.AbstractApplicationContext prepareRefresh  </span><br><span class="line">信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@58a17083: startup date [Sun Jun <span class="number">04</span> <span class="number">15</span>:<span class="number">38</span>:<span class="number">26</span> CST <span class="number">2017</span>]; root of context hierarchy  </span><br><span class="line"><span class="number">2017</span>-<span class="number">6</span>-<span class="number">4</span> <span class="number">15</span>:<span class="number">38</span>:<span class="number">26</span> org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions  </span><br><span class="line">信息: Loading XML bean definitions from URL [file:/E:/myeclipse/workspace/Spring2/bin/spring-beanannotation3.xml]  </span><br><span class="line"><span class="number">2017</span>-<span class="number">6</span>-<span class="number">4</span> <span class="number">15</span>:<span class="number">38</span>:<span class="number">27</span> org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor &lt;init&gt;  </span><br><span class="line">信息: JSR-<span class="number">330</span> <span class="string">&#x27;javax.inject.Inject&#x27;</span> annotation found and supported <span class="keyword">for</span> autowiring  </span><br><span class="line">list...  </span><br><span class="line"><span class="number">2017</span>-<span class="number">6</span>-<span class="number">4</span> <span class="number">15</span>:<span class="number">38</span>:<span class="number">27</span> org.springframework.context.support.AbstractApplicationContext doClose  </span><br><span class="line">信息: Closing org.springframework.context.support.ClassPathXmlApplicationContext@58a17083: startup date [Sun Jun <span class="number">04</span> <span class="number">15</span>:<span class="number">38</span>:<span class="number">26</span> CST <span class="number">2017</span>]; root of context hierarchy  </span><br><span class="line">com.Autowired.ListMap.BeanImplTwo  </span><br><span class="line">com.Autowired.ListMap.BeanImplOne  </span><br><span class="line">  </span><br><span class="line">map...  </span><br><span class="line">beanImplOne    com.Autowired.ListMap.BeanImplOne  </span><br><span class="line">beanImplTwo    com.Autowired.ListMap.BeanImplTwo  </span><br><span class="line">-------------------------  </span><br><span class="line">com.Autowired.ListMap.BeanImplOne  </span><br></pre></td></tr></table></figure>

<p>Spring吧bean放入了List中 那个这个顺序怎么控制呢</p>
<p>在实现类中加入@Order(value) 注解即可 ，值越小越先被初始化越先被放入List</p>
<h2 id="看下源码"><a href="#看下源码" class="headerlink" title="看下源码"></a>看下源码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DependencyDescriptor, String, Set&lt;String&gt;,TypeConverter)</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8FI/8.png" alt="img"> <strong>对于@Autowired声明的数组、集合类型，spring并不是根据beanName去找容器中对应的bean，而是把容器中所有类型与集合（数组)中元素类型相同的bean构造出一个对应集合，注入到目标bean中。对应到上问配置文件中，就是把容器中所有类型为java.lang.String的bean放到新建的Set中，然后注入到Managerbean中。也就是把resourcePackage和resourceLoaction这两个String注入了，导致上面的输出结果</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就讲完了策略模式，整体看上去其实还是比较简单的，还是那句话学习设计模式我们还是要学习每种设计模式的思想，任何一种设计模式存在即合理。当然也不要因为设计模式而设计代码，那样反而得不偿失。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-观察者模式</title>
    <url>/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>消息队列（MQ），一种能实现生产者到消费者单向通信的通信模型，这也是现在常用的主流中间件。</p>
<p>常见有 RabbitMQ、ActiveMQ、Kafka等  他们的特点也有很多 比如 <strong>解偶</strong>、<strong>异步</strong>、<strong>广播</strong>、<strong>削峰</strong> 等等多种优势特点。</p>
<p>在设计模式中也有一种模式能有效的达到<strong>解偶</strong>、<strong>异步</strong>的特点，那就是<strong>观察者模式</strong>又称为<strong>发布订阅模式</strong>。</p>
<p>今天阿丙就分享一下实际开发中比较常见的这种模式</p>
<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/55.png" alt="图片"></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>什么是观察者模式？他的目的是什么？</p>
<blockquote>
<p>当一个对象的状态发生改变时，已经登记的其他对象能够观察到这一改变从而作出自己相对应的改变。通过这种方式来达到减少依赖关系，解耦合的作用。</p>
</blockquote>
<p>举一个例子，就好比微信朋友圈，以当前个人作为订阅者，好友作为主题。一个人发一条动态朋友圈出去，他的好友都能看到这个朋友圈，并且可以在自主选择点赞或者评论。</p>
<p>感觉有点抽象，还是看看他有哪些主要角色：</p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/53.pmg" alt="图片"></p>
<blockquote>
<ul>
<li>Subject（主题）: 主要由类实现的可观察的接口，通知观察者使用attach方法，以及取消观察的detach方法。</li>
<li>ConcreteSubject（具体主题）: 是一个实现主题接口的类，处理观察者的变化</li>
<li>Observe（观察者）: 观察者是一个由对象水岸的接口，根据主题中的更改而进行更新。</li>
</ul>
</blockquote>
<p>这么看角色也不多，但是感觉还是有点抽象，我们还是用具体实例代码来走一遍吧，我们还是以上面的朋友圈为例看看代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">// 添加订阅关系</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    <span class="comment">// 移除订阅关系</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    <span class="comment">// 通知订阅者</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先创建一个主题定义，定义添加删除关系以及通知订阅者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅者容器</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        <span class="comment">// 添加订阅关系</span></span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        <span class="comment">// 移除订阅关系</span></span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="comment">// 通知订阅者们</span></span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次再创建的具体主题，并且构建一个容器来维护订阅关系，支持添加删除关系，以及通知订阅者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">// 处理业务逻辑</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个观察者接口，方便我们管理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriendOneObserver</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">   </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟处理业务逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;FriendOne 知道了你发动态了&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后就是创建具体的观察者类，实现观察者接口的update方法，处理本身的业务逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ConcreteSubject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteSubject</span>();</span><br><span class="line">        <span class="comment">// 这里假设是添加好友</span></span><br><span class="line">        subject.attach(<span class="keyword">new</span> <span class="title class_">FriendOneObserver</span>());</span><br><span class="line">        <span class="type">FriendTwoObserver</span> <span class="variable">twoObserver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriendTwoObserver</span>();</span><br><span class="line">        subject.attach(twoObserver);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送朋友圈动态</span></span><br><span class="line">        subject.notifyObservers(<span class="string">&quot;第一个朋友圈消息&quot;</span>);</span><br><span class="line">        <span class="comment">// 输出结果：FriendOne 知道了你发动态了第一个朋友圈消息</span></span><br><span class="line">        <span class="comment">//          FriendTwo 知道了你发动态了第一个朋友圈消息</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里发现 twoObserver 是个推荐卖茶叶的，删除好友</span></span><br><span class="line">        subject.detach(twoObserver);</span><br><span class="line">        subject.notifyObservers(<span class="string">&quot;第二个朋友圈消息&quot;</span>);</span><br><span class="line">        <span class="comment">// 输出结果：FriendOne 知道了你发动态了第二个朋友圈消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后就是看测试结果了，通过ConcreteSubject 维护了一个订阅关系，在通过notifyObservers 方法通知订阅者之后，观察者都获取到消息从而处理自己的业务逻辑。</p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/52.pmg" alt="图片"></p>
<p>这里细心的朋友已经达到了解耦合的效果，同时也减少了依赖关系，每个观察者根本不要知道发布者处理了什么业务逻辑，也不用依赖发布者任何业务模型，只关心自己本身需要处理的逻辑就可以了。</p>
<p>如果有新的业务添加进来，我们也只需要创建一个新的订阅者，并且维护到observers 容器中即可，也符合我们的开闭原则。</p>
<p>这里只是一种同步的实现方式，我们还可以扩展更多其他的异步实现方式，或者采用多线程等实现方式。</p>
<h2 id="框架应用"><a href="#框架应用" class="headerlink" title="框架应用"></a>框架应用</h2><p>观察者模式在框架的中的应用也是应该很多</p>
<ul>
<li><p>第一种  熟悉JDK的人应该知道 在java.util 包下 除了常用的 集合 和map之外还有一个<strong>Observable</strong>类，他的实现方式其实就是观察者模式。里面也有<strong>添加、删除、通知</strong>等方法。</p>
<p>这里需要注意是的 他是用Vector 作为订阅关系的容器，同时在他的定义方法中都添加synchronized关键字修饰类，以达到线程安全的目的</p>
<p>这里我贴出了关键源码，感兴趣的同学可以自己打开并且观看每个方法的注释。</p>
</li>
</ul>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/51.pmg" alt="图片"></p>
<ul>
<li><p>第二种 在Spring中有一个ApplicationListener，也是采用观察者模式来处理的，ApplicationEventMulticaster作为主题，里面有添加，删除，通知等。</p>
<p>spring有一些内置的事件，当完成某种操作时会发出某些事件动作，他的处理方式也就上面的这种模式，当然这里面还有很多，我没有细讲，有兴趣的同学可以仔细了解下Spring的启动过程。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.EventListener;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Interface to be implemented by application event listeners.</span></span><br><span class="line"><span class="comment"> * Based on the standard &#123;<span class="doctag">@code</span> java.util.EventListener&#125; interface</span></span><br><span class="line"><span class="comment"> *  for the Observer design pattern. // 这里也已经说明是采用观察者模式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;As of Spring 3.0, an ApplicationListener can generically declare the event type</span></span><br><span class="line"><span class="comment"> * that it is interested in. When registered with a Spring ApplicationContext, events</span></span><br><span class="line"><span class="comment"> * will be filtered accordingly, with the listener getting invoked for matching event</span></span><br><span class="line"><span class="comment"> * objects only.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rod Johnson</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;E&gt; the specific ApplicationEvent subclass to listen to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.event.ApplicationEventMulticaster //主题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationListener</span>&lt;E <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span>&gt; <span class="keyword">extends</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Handle an application event.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> event the event to respond to</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(E event)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第三种  Google Guava的事件处理机制<strong>Guava EventBus</strong> 他的实现也是采用设计模式中的观察者设计模式。</p>
<blockquote>
<p>EventBus 当前实现有两种方式：</p>
</blockquote>
</li>
<li><ul>
<li>EventBus  &#x2F;&#x2F; 同步阻塞模式</li>
<li>AsyncEventBus &#x2F;&#x2F; &#x2F;&#x2F; 异步非阻塞模式</li>
</ul>
</li>
</ul>
<p>EventBus内部也提供来一系列的方法来供我们方便使用：</p>
<ul>
<li>register 方法作为添加观察者</li>
<li>unregister方法删除观察者</li>
<li>post 方法发送通知消息等</li>
</ul>
<p>使用起来非常方便。添加@Subscribe注解就可以创建一个订阅者了，具体的使用方式可以看看官网。</p>
<h2 id="现实业务改造举例"><a href="#现实业务改造举例" class="headerlink" title="现实业务改造举例"></a>现实业务改造举例</h2><p>框架应用的例子这么多，在业务场景中其实也有很多地方可以使用到，这里我还是给大家举一个例子。</p>
<p>在新用户注册成功之后我们需要给用户做两件事情，第一是发送注册成功短信，第二是给用发送新人优惠券。</p>
<p>看到这个问题 大家可能首先会想到用MQ消息处理呀，是的，用消息确实可以的，但是这里我们用观察者模式来实现这个问题，同时可以给大家演示一下，同步或者异步的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendNewPersonCouponObserver</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Future&lt;String&gt; future = pool.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                <span class="comment">// 处理响应的业务逻辑</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;调用发券服务，返回结果&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 假设等待200毫秒 没有获取到返回值结果则认为失败</span></span><br><span class="line">            System.out.println(future.get(<span class="number">4000</span>, TimeUnit.MILLISECONDS));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 执行异步获取失败</span></span><br><span class="line">            <span class="comment">// 记录日志，定时任务重试等</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一种不关心返回值结果</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@SneakyThrows</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟服务调用 线程睡3秒钟</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;发送新人优惠券&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行异步返回&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendSuccessMessageObserver</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理业务逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;注册成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 假设用户注册成功直接通知观察者，改干自己的事情了</span></span><br><span class="line">        <span class="type">ConcreteSubject</span> <span class="variable">subject</span> <span class="operator">=</span> buildSubject();</span><br><span class="line">        subject.notifyObservers(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ConcreteSubject <span class="title function_">buildSubject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ConcreteSubject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteSubject</span>();</span><br><span class="line">        subject.attach(<span class="keyword">new</span> <span class="title class_">SendSuccessMessageObserver</span>());</span><br><span class="line">        subject.attach(<span class="keyword">new</span> <span class="title class_">SendNewPersonCouponObserver</span>());</span><br><span class="line">        <span class="keyword">return</span> subject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/50.pmg" alt="图片"></p>
<p>这里我们新写了两个观察者，主要看第一个SendNewPersonCouponObserver，这里了异步开启新的线程去处理我们的业务逻辑，当我们关心返回值的时候可以用Future来获取返回结果，当不关心的返回值的化，直接开启普通线程就可以了。</p>
<p>这个举例整体其实还是比较简单的主要是为了说清楚异步线程处理，当然如果用Guava EventBus也可以实现。而且也不复杂，感兴趣的朋友可以自己去试试。</p>
<p>当前现在有更加好的中间件<strong>MQ消息队列</strong>来处理这个业务问题，使得我们更加从容的面对这类场景问题，但是一些资源不足，不想引入新的系统。还是可以用这种方式来处理问题的。</p>
<p>设计模式学习的不是代码，而是学习每种模式的思想，他们分别处理的是什么业务场景。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>大家看完本篇文章不知道有发现没有，其实整个内容都是围绕了<strong>解耦</strong>的思想来写的，观察者模式作为行为型设计模式，主要也是为了不同的业务行为的代码<strong>解耦</strong>。</p>
<p>合理的使用设计模式可以使代码结构更加清晰，同时还能满足不同的小模块符合单一职责，以及开闭原则，从而达到前面写工厂模式说的，提高代码的可扩展性，维护成本低的特点。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-责任链模式</title>
    <url>/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>前言</strong></p>
<p>面试经历大家肯定都有过，但是面试的流程其实跟一种设计模式很像，每一轮的面试官都有自己的职责，一个求职者面试经历的过程就好比一次客户端的请求过程。</p>
<p>在设计模式系列的文章中之前已经为大家分享了创建型设计模式，感兴趣的小伙伴们可以再去翻看之前的分享。接下来开始分享设计模式三大类型中的<strong>行为型模式</strong>了，今天要分享的是<strong>责任链模式</strong></p>
<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/40.png" alt="图片"></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>什么是责任链？它的原理是什么？</p>
<blockquote>
<p>将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。</p>
<p>以上定义来自《设计模式之美》</p>
</blockquote>
<p>再看看一张官方图解吧</p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/41.png" alt="图片"></p>
<blockquote>
<ul>
<li>Client(客户端)：实例化一个处理器的链，在第一个链对象中调用handleRequest 方法。</li>
<li>Handle(处理器)：抽象类，提供给实际处理器继承然后实现handleRequst方法，处理请求</li>
<li>ConcreteHandler(具体处理器)：继承了handler的类，同时实现handleRequst方法，负责处理业务逻辑类，不同业务模块有不同的ConcreteHandler。</li>
</ul>
</blockquote>
<p>这么看结构其实还是比较简单的，但是我们还是拿面试的流程来模拟一下责任链吧！</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>假设现在去一家公司面试，第一次去一面，第二次去二面，第三次去直接过了。那这个模拟面试代码怎么写呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Handler handler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHandler</span><span class="params">(Handler handler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(Integer times)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们还是定义一个抽象Handler处理器，同时添加一个抽象处理方法 handleRequest，后面我只需要编写具体的处理器来继承Handler类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstInterview</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(Integer times)</span> &#123;</span><br><span class="line">        <span class="comment">// 条件判断是否是属于当前Handler的处理范围之内，不是则向下传递Handler处理器</span></span><br><span class="line">        <span class="keyword">if</span>(times ==<span class="number">1</span>)&#123;</span><br><span class="line">          <span class="comment">// 假设这里是处理的业务逻辑代码</span></span><br><span class="line">            System.out.println(<span class="string">&quot;第一次面试&quot;</span>+times);</span><br><span class="line">        &#125;</span><br><span class="line">        handler.handleRequest(times);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次构建第一次面试Handler，内部实现handleRequest方法，判断一下是否是当前处理应该处理的业务逻辑，不是则向下传递。同样的第二次的SecondInterview和FirstInterview代码基本是一致的，我就不给大家贴出来了，直接看最后一个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreeInterview</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(Integer times)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (times == <span class="number">3</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第三次面试&quot;</span>+ times + <span class="string">&quot;，恭喜面试通过，HR会跟你联      系！！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Handler</span> <span class="variable">first</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FirstInterview</span>();</span><br><span class="line">        <span class="type">Handler</span> <span class="variable">second</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecondInterview</span>();</span><br><span class="line">        <span class="type">Handler</span> <span class="variable">three</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreeInterview</span>();</span><br><span class="line">        first.setHandler(second);</span><br><span class="line">        second.setHandler(three);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一次面试</span></span><br><span class="line">        first.handleRequest(<span class="number">1</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">// 第二次面试</span></span><br><span class="line">        first.handleRequest(<span class="number">2</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">// 第三次面试</span></span><br><span class="line">        first.handleRequest(<span class="number">3</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/42.png" alt="图片"></p>
<p>这个结果可以很明显的看出，根据我们传参，不同的Handler根据自己的职责处理着自己的业务，这就是责任链。</p>
<h2 id="框架的应用"><a href="#框架的应用" class="headerlink" title="框架的应用"></a>框架的应用</h2><p>责任链在很多框架源码中也有体现。比如开始学SpringMVC中的 <strong>ServletFilter</strong></p>
<p>以及Spring中的 <strong>SpringInterceptor</strong> 这里面其实都是运用了责任链模式的思想，达到框架的可扩展性的同时也遵循着开闭原则。</p>
<p>作为常见的RPC框架的DUBBO其实里面也同样有这个责任链的思想。</p>
<p>给大家一个思考问题？</p>
<blockquote>
<p>dubbo服务一旦暴露出去了，那么基本任何服务都能调用，但是在一些特殊的业务中需要我们暴露服务，但是又不希望被不了解业务的人随便调用。</p>
<p>比如：商品的库存修改的dubbo服务，我们只允许下单，购物车，添加修改商品等一些指定场景可以调用。</p>
<p>那么有什么办法，在Provider这端做好拦截，针对特定的服务才允许调用，否则拦截下来不允许执行？</p>
</blockquote>
<p>第一种方法，添加服务名称APP_NAME作为传参校验，这是很常见也最容易想到的办法。</p>
<p>第二种方法，实现一个DUBBO拦截器，对RPC调用进行选择性过滤。</p>
<p>针对上面的两种方法，给大家详细讲讲第二种方法具体怎么实现，每个公司都会基于现有的DUBBO源码做自己的特定化改动，那么第二种方式也是同样需要我们改动线有dubbo源码。</p>
<p>先修改ConsumerContextFilter消费者拦截器</p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/43.png" alt="图片"></p>
<p>这里我们以dubbo的2.7.19版本为例。在ConsumerContextFilter中添加APP_NAME至Attachments中，那么作为本次的RPC调用都能从Attachments中获取到我们塞入的值。</p>
<p>至于这个APP_NAME的获取 可以通过 System.getProperty(“project.name”, “”) 来获取服务名</p>
<blockquote>
<p>这里我就不对DUBBO做过多的展开，大家如果有强烈建议讲解。那么在结束设计模式再跟大家详细剖析一下dubbo，以及zookeeper里面的ZAB，一致性选举算法等等。</p>
</blockquote>
<p>CONSUMER既然已经填充了服务名称，那么在Provider同样的也就只需要写一个ProviderFilter 就可以了</p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/44.png" alt="图片"></p>
<p>这里就基本实现怎么处理每一次RPC调用的拦截了，然后想要那个服务拦截，在provider里面的filter里面指定一下这个DubboProviderFilter就可以了，也可以全局都实现。</p>
<p>注意 ：这个Filter 要是用DUBBO包里面的，不要搞错了。</p>
<h2 id="现实业务改造举例"><a href="#现实业务改造举例" class="headerlink" title="现实业务改造举例"></a>现实业务改造举例</h2><p>框架中既然都有这种思想，那么怎么运用到业务代码中呢？</p>
<p>还是给大家举一个例子：</p>
<p>商品详情展示我们可以是分模块展示的，比如头图，商品信息，sku信息，配送地址，分期付费等等。</p>
<p><strong>那么怎么进行组装到商品详情的展示呢？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractDataHandler</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理模块化数据</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title function_">doRequest</span><span class="params">(String query)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们还是定一个抽象数据Handler，然后分别建立ItemInfoHandler 和SkuInfoHandler 来继承抽象处理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemInfoHandler</span> <span class="keyword">extends</span> <span class="title class_">AbstractDataHandler</span>&lt;ItemInfoHandler.ItemInfo&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> ItemInfoHandler.ItemInfo <span class="title function_">doRequest</span><span class="params">(String query)</span> &#123;</span><br><span class="line">        ItemInfoHandler.<span class="type">ItemInfo</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ItemInfo</span>();</span><br><span class="line">        info.setItemId(<span class="number">123456L</span>);</span><br><span class="line">        info.setItemName(<span class="string">&quot;测试商品&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ItemInfo</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Long itemId;</span><br><span class="line">        <span class="keyword">private</span> String itemName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样SkuInfoHandler类也是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SkuInfoHandler</span> <span class="keyword">extends</span> <span class="title class_">AbstractDataHandler</span>&lt;SkuInfoHandler.SkuInfo&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> SkuInfoHandler.SkuInfo <span class="title function_">doRequest</span><span class="params">(String query)</span> &#123;</span><br><span class="line">        SkuInfoHandler.<span class="type">SkuInfo</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SkuInfoHandler</span>.SkuInfo();</span><br><span class="line">        info.setSkuId(<span class="number">78910L</span>);</span><br><span class="line">        info.setSkuName(<span class="string">&quot;测试SKU&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SkuInfo</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Long skuId;</span><br><span class="line">        <span class="keyword">private</span> String skuName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后就是我们的测试代码了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataAggregation</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SkuInfoHandler skuInfoHandler;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ItemInfoHandler itemInfoHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map <span class="title function_">convertItemDetail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="type">Map</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">       result.put(<span class="string">&quot;skuInfoHandler&quot;</span>, skuInfoHandler.doRequest(<span class="string">&quot;模拟数据请求&quot;</span>));</span><br><span class="line">       result.put(<span class="string">&quot;itemInfoHandler&quot;</span>,itemInfoHandler.doRequest(<span class="string">&quot;模拟数据请求&quot;</span>));</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">DataAggregation</span> <span class="variable">dataAggregation</span> <span class="operator">=</span> (DataAggregation) applicationContext.getBean(<span class="string">&quot;dataAggregation&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> dataAggregation.convertItemDetail();</span><br><span class="line">        System.out.println(JSON.toJSONString(map));</span><br><span class="line">      <span class="comment">// 打印的结果数据</span></span><br><span class="line">      <span class="comment">// &#123;&quot;skuInfoHandler&quot;:&#123;&quot;skuId&quot;:78910,&quot;skuName&quot;:&quot;测试SKU&quot;&#125;,&quot;itemInfoHandler&quot;:&#123;&quot;itemId&quot;:123456,&quot;itemName&quot;:&quot;测试商品&quot;&#125;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子其实是经过一点小小的改动的，我们没有通过向下传递处理器的方式，而是通过实际业务逻辑在 convertItemDetail 的方法中去构建每个模块的数据，最后返回出一个Map结构数据。</p>
<p>这里其实还有另外的一种写法，把每一个需要处理的Handler 可以加载到一个List容器中，然后循环调用每个Handler中的doRequest方法，当然这是针对一些其他的业务场景这么写。</p>
<p>看完大家也能发现其实每个Handler是可以共用的，每一块业务的代码逻辑非常的清晰，这样的代码写出来就感觉很舒服了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>设计模式不是一成不变的，只有适合自己当前业务的模式才是最好的模式。理解前辈的思想，组合我们自己需要的模式。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-装饰者模式</title>
    <url>/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h3><p>装饰模式的设计理念主要是以对客户端透明的方式动态扩展对象的功能，是继承关系的一个替代（继承会产生大量的子类，而且代码有冗余）。装饰模式可以在不创造更多子类的情况下，将对象的功能加以扩展。装饰模式把客户端的调用委派到被装饰类。装饰模式的关键在于这种扩展完全是透明的（装饰模式的透明性要求客户端程序不应该将对象声明为具体构件类型或具体装饰类型，而应该全部声明为抽象构件类型），装饰模式的应用在java的I&#x2F;O流中最为显著。</p>
<h3 id="二、角色"><a href="#二、角色" class="headerlink" title="二、角色"></a>二、角色</h3><p><strong>抽象构件角色（Component）</strong>：通常是一个抽象类或者一个接口，定义了一系列方法，方法的实现可以由子类实现或者自己实现。通常不会直接使用该类，而是通过继承该类或者实现该接口来实现特定的功能。（例如，对于动物类，有一个抽象方法输出所有的功能，基本功能包括：呼吸，觅食，睡觉等等）<br><strong>具体构件角色（Concrete Component）</strong>：是Component的子类，实现了对应的方法，它就是那个被装饰的类。（具体构建角色可以建立很多个，例如狗，猫，鸟等等，如果是狗，我们可以装饰一些吼叫的功能，吃肉的功能；鸟可以装饰一些飞行的功能，带有翅膀的功能等等。当然这些需要在具体装饰角色中去具体定义）<br><strong>装饰角色（Decorator）</strong>：是Component的子类，它是具体装饰角色共同实现的抽象类（也可以是接口），并且持有一个Component类型的对象引用，它的主要作用就是把客户端的调用委派到被装饰类。<br><strong>具体装饰角色（Concrete Decorator）</strong>：它是具体的装饰类，是Decorator的子类，当然也是Component的子类。它主要就是定义具体的装饰功能，例如上面说的，对于鸟这个具体构建角色而言，除了具备抽象构件角色基本的功能，它还具有一些飞行的功能，带翅膀的功能。那么我们可以把这两个功能定义成一个具体装饰角色1，对于狗这个具体构件角色而言，我们可以把吼叫，吃肉这两个功能定义成一个具体装饰角色2，这样，如果我们再定义一个狼这样的具体构件角色的时候，就可以直接用具体装饰角色2来进行装饰。</p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/70.png" alt="img"></p>
<h3 id="三、Example"><a href="#三、Example" class="headerlink" title="三、Example"></a>三、Example</h3><p>以上面所说的动物的例子来写代码演示。</p>
<p><strong>抽象构件角色（对应动物类）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">function</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>具体构件角色（对应狗）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;基本功能：呼吸+觅食+睡觉&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>装饰角色</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> Component component; <span class="comment">//持有一个Component类型的对象引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Decorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.component = component;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">	component.function(); <span class="comment">//客户端的调用委派给具体的子类</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>具体装饰角色（对应吼叫和吃肉这两个功能）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcreteDecorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">	<span class="built_in">super</span>(component);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">super</span>.function();</span><br><span class="line">	System.out.println(<span class="string">&quot;附加功能：&quot;</span>);</span><br><span class="line">	<span class="built_in">this</span>.eat();</span><br><span class="line">	<span class="built_in">this</span>.bellow();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;吃肉&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bellow</span><span class="params">()</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;吼叫&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端测试：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Component</span> <span class="variable">component</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteComponent</span>(); </span><br><span class="line">		System.out.println(<span class="string">&quot;------装饰前：-------&quot;</span>);</span><br><span class="line">		component.function();</span><br><span class="line">		<span class="type">Component</span> <span class="variable">newComponent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteDecorator</span>(component);</span><br><span class="line">		System.out.println(<span class="string">&quot;------装饰后：-------&quot;</span>);</span><br><span class="line">		newComponent.function();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">------装饰前：-------</span><br><span class="line">基本功能：呼吸+觅食+睡觉</span><br><span class="line">------装饰后：-------</span><br><span class="line">基本功能：呼吸+觅食+睡觉</span><br><span class="line">附加功能：吃肉+吼叫</span><br></pre></td></tr></table></figure>

<h3 id="四、应用"><a href="#四、应用" class="headerlink" title="四、应用"></a>四、应用</h3><p>装饰者模式主要应用在Java的I&#x2F;O流中，如果读者对I&#x2F;O流体系比较混乱的话，不妨利用装饰者模式去理理思路。<code>OutputStream</code>和<code>InputStream</code>就对应于抽象构件角色(Component)，<code>FileInputStream</code>和<code>FileOutputStream</code>就对应具体构件角色(ConcreteComponent)，<code>FilterOutputStream</code>和<code>FilterInputStream</code>就对应着装饰角色(Decorator)，而<code>BufferedOutputStream</code>，<code>DataOutputStream</code>等等就对应着具体装饰角色。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>负载均衡-I</title>
    <url>/2022/10/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-I/</url>
    <content><![CDATA[<p><strong>序言</strong></p>
<p> LB,SLB,ALB，GSLB,CDN，傻傻分不清楚，听风看雨。。。毒鸡汤看多了，我快掩饰不住我的悲伤了。。。</p>
<p> <a href="https://cloud.tencent.com/product/clb?from=10680">负载均衡</a>，碰到的太多，使用的场景也很多，无论你是传统行业，还是互联网行业，魂牵梦绕的技术，所以谈谈其发展。</p>
<p><strong>前世今生</strong></p>
<p> 当业务量小的时候，每天访问的人数就那么几个的时候，我们用一台服务器就够了，上面部署上开发写的应用，部署上<a href="https://cloud.tencent.com/solution/database?from=10680">数据库</a>服务，再加一个前端程序。</p>
<p>  随着业务量的增多，访问的并发越来越高，服务器的负载加大，可能首先进行垂直增加服务器的性能，也就是原来是4C8G，现在增加到32C156G。</p>
<p> 随着业务量的进一步增多，服务器的响应时间越来越长，垂直增加性能，一个是成本太高，另外一个是可用性不高，从而需要拆分，并使用集群的方式，也就是应用程序划分多个服务器，进行水平扩容，那么在用户访问的时候，访问那个应用服务器呢？从而就有了负载均衡。</p>
<p>​    负载均衡，load balance，简称为LB，也可以写成service load balance，从而称之为SLB，也可以写成Application load balance，从而称之为ALB，进一步的负载均衡就是全局负载均衡，就可以写成Global service load balance，当发现性能还是不够的时候，就是CDN，也就是<a href="https://cloud.tencent.com/product/cdn?from=10680">内容分发网络</a>，称之为content delivery network。</p>
<p>​    可能我们在平时不知不觉中已经接触到了负载均衡，例如常见的LVS四层负载均衡，nginx&#x2F;httpd&#x2F;haproxy七层负载均衡，四层和七层有啥区别，区别在于协议不同，七层是应用层协议，一般指的是http和https协议，四层指的是网络层协议，一般指的是tcp&#x2F;udp协议，当然也可以代理mysql协议</p>
<p>​    负载均衡根据类型划分，主要划分为三种类型：第一种类型为DNS负载均衡（软硬结合的方式），主要是使用DNS解析出IP的方式，来进行业务流量的分发，并发无上限；第二种类型为硬件负载均衡，例如那些贵的离谱的硬件设备，F5，A10，并发百万级别；第三种类型为软件负载均衡，就是我们常见的负载均衡软件，例如nginx，lvs，并发几万到百万级别</p>
<p>​    权衡？是不是这三种我们只能选一种，是不是选择最好的哪种？不是的，这三种的使用范围和场景不一样，从而我们可以使用组合的方式来使用。</p>
<p>​    DNS负载均衡主要适用于的场景是多地集群的方式，也就是可能北京有一个数据中心，在其中部署了一整套的集群提供服务，在上海有一个数据中心，也部署了同样的一套的集群来提供服务，用于预防地震，水灾，整个机房断电的故障，这种可以将请求发送给不同的数据中心，从而可以使用户更加快速的访问到服务，异地恋了解一下。。。数据中心级别的负载均衡</p>
<p>​    硬件负载均衡，硬件厂商一般能提供强力的服务，稳定性较高，性能较好，能支持百万级别的并发量，缺点就是太贵了，在一个数据中心，一般买俩就够了，做成主备的形式，提供高可靠，高可用。。。集群之间的负载均衡</p>
<p>​    软件负载均衡，一般就是在前端创建一个SLB，然后在后端挂上真正的物理服务器，成为多个应用服务器的控制器，可以用各种调度算法来进行调度。。。服务器之间的负载均衡</p>
<p>​    三种的选择，可以是随着业务的发展递增式的使用，先是使用SLB，然后扛不住，上硬件，再扛不住上DNS，再扛不住用GSLB，还不行，上CDN。</p>
<p>​    权衡，那么在软件负载均衡之中怎么选？建议的类型就是四层SLB使用LVS，性能高，可靠性强，能做健康检查，能做会话同步；七层使用nginx，模块多，扩展性好，当然没有最好，选择你熟悉的，根据业务定制也不错。</p>
<p><img src="/2022/10/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-I/1.png" alt="img"></p>
<p><strong>分配算法</strong></p>
<p>   在SLB选择后端的rs也就是real server真正的服务器处理请求的时候，有多种类型的算法可以选择。</p>
<p>​    最常用的方式就是RR（round robin）轮询的方式，不管你后端的服务器是什么样的，不管你后端服务器的压力如何都会发送请求过去，这种的优点是简单，但是不能感知到服务器的状态。</p>
<p>​    改进的方式就是使用WRR（weight round robin）加权轮询的方式，这种会考虑后端的服务器的性能，例如一台服务器的配置是2C4G，一台服务器的配置是4C8G，那么在设置权重的时候，就可以将第一台配置为1，第二台配置为2，从而如果客户端发送了6个请求过来，第一台会处理2个请求，而第二台会处理4个请求， 这种方式只是考虑到了服务器本身的物理配置，而没有考虑到服务器本身的性能。。。这种方式是最常见的使用方式，及时所有的服务器配置一样，也要使用WRR的方式，也就是权重一样，这种便于切流，也就是可以动态的将一台服务器的权重设置为0，从而不会影响业务，而使用RR的方式的时候，有服务器下线会报错，当然，在其中也可以配置相关的如果发现一个请求不通，跳转到另外的机器，但是增加了配置配置文件的复杂度，相对来说WRR更加简单。</p>
<p> 再使用的方式就是使用WLC（weighted least connection）最少连接数的方式，在此种情况下，判断服务器的性能主要靠检测后端服务器的连接数量，如果连接过多，就认为你的负载很大，如果连接很少，那么可以理解为分配给这台服务器处理，性能会更高。这种方式主要是从服务器端来考虑，也就是考虑服务器的性能，在此处可以定义不同的检测方式，例如如果是CPU密集型，那么可以使用CPU的负载来进行衡量，如果是IO密集型，那么可以使用IO的负载来进行衡量。在LVS中就是通过连接数来进行衡量，而在nginx中，可以使用http连接数来进行衡量。</p>
<p>​    还有使用的方式就是站在客户端角度来考虑服务器的性能，主要就是统计和分析客户端到服务端的请求响应时间来判断性能好坏，如果一台服务器的RTT（round trip time） 往返时间很短，可以理解为性能很好，从而可以将请求发送给这台服务器进行处理。</p>
<p>​    在以上的分配算法当中，没有考虑会话的情况，在很多的应用场景下都需要考虑会话需要保持在同一台服务器中，最简单的例子就是你登录一个网站的时候，刷新一下不需要重新登录，说明你的请求发送给了同一台服务器进行处理，在保持会话的时候，可以根据源ip进行hash，也可以对目标ip进行hash，或者是通过session id或者user id进行hash分配到同一台服务器进行处理，在LVS中是通过IP hash进行会话同步，在nginx中可以通过session id进行会话同步。</p>
<p> 分配算法，站在不同的角度考虑问题，站在服务端，你需要考虑服务器的cpu负载，io负载，网卡的吞吐，网络连接数；站在客户端，我主要关注的是请求和响应的时间。。。</p>
<p>​    一个人的压力大小和负载其实是一样的，负载来源于哪里，让你去做事，你不做，你说你压力大。。。团队中分配任务也是一样的，你是采用轮询？还是采用加权轮询？还是采用任务数量？还是采用做任务的速度？。。种种策略和工作一样一样的</p>
<p> 站在不同的角度，其实就是第一个指你本身解决问题的能力；第二个客户需要你的什么能力。。。合理的运用你的能力，这个本身也是一种能力。。。珍珑棋局了解一下。。。</p>
<p><strong>GSLB和CDN了解一下</strong></p>
<p> GSLB其实是DNS轮询方式的一种改进，因为DNS轮询的时候比较傻，它不能对后端的服务进行健康检查，没准有一个机房挂了，但是。。。。它依旧把请求发送给那个机房，从而就有了GSLB。</p>
<p> DNS还有一个缺点就是在DNS解析的时候，一般会先向本地的DNS服务器进行解析，但是这并不是客户端的真实的IP地址，从而有可能分配的时候，并不是距离上最近的或者是性能最好的，从而也就有GSLB。</p>
<p> DNS的轮询其实是GSLB的一种实现方式，所以这种也能称之为GSLB，而DNS轮询这种说法比较少，而GSLB的实现方式中，还有一种方式就是HTTP 302跳转，将GSLB的IP地址作为域名的A记录，然后访问GSLB的时候，会将请求返回给客户端，然后给一个302响应，让客户端跳转到真正的地址（此种方式GSLB能看到客户端的真实的IP地址，从而给出距离跟进的服务器ip地址）。</p>
<p><img src="/2022/10/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-I/2.png" alt="img"></p>
<p> 在上面一种实现中，只能代理http的请求，而其他的请求不能代理，从而就有了ip欺骗的方式，我不怕你骗我，我就怕。。。你骗不到我。。如下：</p>
<p><img src="/2022/10/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-I/3.png" alt="img"></p>
<p> 在这种时候，zone1的位置的服务器会修改源ip地址，修改为GSLB的ip，从而直接发送给客户端。但是这种本身上会有部分性能和响应的损耗。</p>
<p>​    当使用GSLB的时候，性能不能满足怎么办。。。欲求不满啊。。。</p>
<p>  CDN，内容分发网络，其实好像也没啥神奇的，就是使用缓存，你请求web页面慢，我缓存你，你请求图片慢，我缓存你，你请求视频慢，我缓存你。。。没有缓存不能解决的事。。。cpu的L1 cache和L2 cache，还有L3 cache了解一下</p>
<p><img src="/2022/10/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-I/4.png" alt="img"></p>
<p> 在CDN中，GSLB变成了其中的一部分，指向的地址修改为各大缓存的地址，可以是squid，或者是varnish，或者是nginx的缓存，缓存。。。缓存热点数据，有就直接返回，没有就到源里面去取，然后再缓存，再返回给客户端。</p>
<p><img src="/2022/10/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-I/5.png" alt="img"></p>
]]></content>
      <categories>
        <category>负载均衡</category>
      </categories>
      <tags>
        <tag>负载均衡</tag>
        <tag>Load Balance</tag>
        <tag>LB</tag>
        <tag>SLB</tag>
      </tags>
  </entry>
  <entry>
    <title>负载均衡-II</title>
    <url>/2022/10/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-II/</url>
    <content><![CDATA[<p><img src="/2022/10/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-II/1.png" alt="图片"></p>
<h2 id="1写在前面"><a href="#1写在前面" class="headerlink" title="1写在前面"></a>1写在前面</h2><p>写本文的目的：</p>
<ul>
<li>对负载均衡的理解零零散散，不成体系。</li>
</ul>
<p>阅读这篇文章需要的条件：</p>
<ul>
<li>对OSI模型有些许了解</li>
<li>有耐心。本文涉及大量的知识点，且只能用文字才能讲清楚，所以文字比较多。</li>
</ul>
<p>收获：</p>
<ul>
<li>读完此篇文章，从宏观的角度理解了负载均衡的原理以及实现机制。加深对分布式架构的了解</li>
</ul>
<p>主要内容：</p>
<ul>
<li>本文首先从概念开始，讲解什么是负载均衡，以及负载均衡在分布式系统中所承担的角色以及提供的功能。</li>
<li>讲解负载均衡的分类。分别从 <em><strong>软硬件角度</strong></em>、<em><strong>地域范围角度</strong></em> 以及 <em><strong>OSI模型角度</strong></em> 进行分类讲解负载均衡的实现方案。</li>
<li>从负载均衡的策略角度来分析目前业界的负载均衡算法以及其优缺点</li>
</ul>
<p>好了，准备好了么，让我们开始这次愉快之旅。</p>
<p><img src="/2022/10/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-II/2.png" alt="图片"></p>
<h2 id="2引言"><a href="#2引言" class="headerlink" title="2引言"></a>2引言</h2><p>首先 <em><strong>撇开对线上的影响</strong></em>，如果线上突发来了流量,后端服务扛不住，我们会怎么做呢？无非两种方式：</p>
<ul>
<li>提升机器配置(CPU、内存、硬盘、带宽等)</li>
<li>加机器</li>
</ul>
<p>上面两种方式，我们称之为纵向扩展和横向扩展。</p>
<p>纵向扩展，是从单机的角度通过增加硬件处理能力，比如CPU处理能力，内存容量，磁盘等方面，实现服务器处理能力的提升，不能满足大型分布式系统（网站），大流量，高并发，海量数据的问题。</p>
<p>横向扩展，通过添加机器来满足大型网站服务的处理能力。比如：一台机器不能满足，则增加两台或者多台机器，共同承担访问压力。</p>
<h2 id="3概念"><a href="#3概念" class="headerlink" title="3概念"></a>3概念</h2><blockquote>
<p>负载均衡，英文名称为Load Balance，其含义就是指将负载（工作任务或者网络请求）进行平衡，分摊到多个操作单元(服务器或者组件)上进行运行。目的是尽量将网络流量 <em><strong>平均</strong></em> 发送到多个服务器上，以保证整个业务系统的高可用。</p>
</blockquote>
<p><img src="/2022/10/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-II/3.png" alt="图片">负载均衡</p>
<p>在互联网的早期，网络还不是很发达，流量相对较小，业务也比较简单，单台服务器或者实例就有可能满足访问需要。但如今在互联网发达的今天，流量请求动辄百亿、甚至上千亿，单台服务器或者实例已完全不能满足需求，这就有了集群。不论是为了实现高可用还是高性能，都需要用到多台机器来扩展服务能力，用户的请求不管连接到哪台服务器，都能得到相同的相应处理。</p>
<p>另一方面，如何构建和调度服务集群这事情，又必须对用户一侧保持足够的透明，即使请求背后是由一千台、一万台机器来共同响应的，也绝非用户所关心的事情，用户需记住的只有一个域名地址而已。调度后方的多台机器，以统一的接口对外提供服务，承担此职责的技术组件被称为 <em><strong>负载均衡</strong></em>。</p>
<p>负载均衡主要有以下作用：</p>
<ul>
<li>高并发。通过采取一定的算法策略，将流量尽可能的均匀发送给后端的实例，以此提高集群的并发处理能力。</li>
<li>伸缩性。根据网络流量的大小，增加或者减少后端服务器实例，由负载均衡设备进行控制，这样使得集群具有伸缩性。</li>
<li>高可用。负载均衡器通过算法或者其他性能数据来监控候选实例，当实例负载过高或者异常时，减少其流量请求或者直接跳过该实例，将请求发送个其他可用实例，这使得集群具有高可用的特性。</li>
<li>安全防护。有些负载均衡器提供了安全防护功能。如：黑白名单处理、防火墙等。</li>
</ul>
<h2 id="4分类"><a href="#4分类" class="headerlink" title="4分类"></a>4分类</h2><h4 id="根据载体类型分类"><a href="#根据载体类型分类" class="headerlink" title="根据载体类型分类"></a>根据载体类型分类</h4><p>从支持负载均衡的载体来看，可以将负载均衡分为两类：</p>
<ul>
<li>硬件负载均衡</li>
<li>软件负载均衡</li>
</ul>
<h6 id="硬件负载均衡"><a href="#硬件负载均衡" class="headerlink" title="硬件负载均衡"></a>硬件负载均衡</h6><p>硬件负载平衡器是一种硬件设备，具有专门的操作系统。硬件负载平衡器位于传入流量和内部服务器之间，本质上充当“流量警察”。当用户访问网站或者使用app某个功能时，它们首先被发送到负载均衡器，然后负载均衡器根据一定的策略，将流量转发到后端不同的服务器。为确保最佳性能，硬件负载均衡器根据自定义规则分配流量，以免后端实例不堪重负。</p>
<p>传统上，硬件负载平衡器和应用服务器部署在本地数据中心，负载平衡器的数量取决于预期的峰值流量。负载均衡器通常成对部署，以防其中一个失败。</p>
<p>目前业界领先的两款硬件负载均衡器：F5和A10</p>
<p><img src="/2022/10/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-II/4.png" alt="图片">硬件负载均衡</p>
<p><strong>优点</strong>：</p>
<blockquote>
<p>功能强大：支持全局负载均衡并提供较全面的、复杂的负载均衡算法。</p>
<p>性能强悍：硬件负载均衡由于是在专用处理器上运行，因此吞吐量大，可支持单机百万以上的并发。</p>
<p>安全性高：往往具备防火墙，防 DDos 攻击等安全功能。</p>
</blockquote>
<p><strong>缺点</strong></p>
<blockquote>
<p>成本昂贵：购买和维护硬件负载均衡的成本都很高(：F5价格在15w~55w不等，A10价格在55w-100w不等)。</p>
<p>扩展性差：当访问量突增时，超过限度不能动态扩容。</p>
</blockquote>
<h6 id="软件负载均衡"><a href="#软件负载均衡" class="headerlink" title="软件负载均衡"></a>软件负载均衡</h6><p>软件负载均衡指的是在服务器的操作系统上安装负载均衡软件，从此服务器发出的请求经软件负载均衡算法路由到后端集群的某一台机器上。</p>
<p>常见负载均衡软件有：LVS、Nginx、Haproxy。</p>
<p><img src="/2022/10/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-II/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">软件负载均衡</p>
<p><strong>优点</strong></p>
<blockquote>
<p>扩展性好：适应动态变化，可以通过添加软件负载均衡实例，动态扩展到超出初始容量的能力。</p>
<p>成本低廉：软件负载均衡可以在任何标准物理设备上运行，降低了购买和运维的成本。</p>
</blockquote>
<p><strong>缺点</strong></p>
<blockquote>
<p>性能略差：相比于硬件负载均衡，软件负载均衡的性能要略低一些。</p>
</blockquote>
<p><strong>软硬件负载均衡器的区别</strong></p>
<ul>
<li>硬件负载平衡器与软件负载平衡器之间最明显的区别在于，硬件负载平衡器需要专有的机架堆叠硬件设备，而软件负载平衡器只需安装在标准 x86 服务器或虚拟机上。网络负载平衡器硬件通常是过度配置的——换句话说，它们的大小能够处理偶尔的高峰流量负载。此外，每个硬件设备都必须与一个额外的设备配对以获得高可用性，以防其他负载均衡器出现故障。</li>
<li>硬件和软件负载平衡器之间的另一个关键区别在于扩展能力。随着网络流量的增长，数据中心必须提供足够的负载均衡器以满足峰值需求。对于许多企业来说，这意味着大多数负载均衡器在高峰流量时间（例如黑色星期五）之前一直处于空闲状态。</li>
<li>如果流量意外超出容量，最终用户体验会受到显着影响。另一方面，软件负载平衡器能够弹性扩展以满足需求。无论网络流量是低还是高，软件负载平衡器都可以简单地实时自动扩展，消除过度配置成本和对意外流量激增的担忧。</li>
<li>此外，硬件负载平衡器配置可能很复杂。基于软件定义原则构建的软件负载平衡器跨多个数据中心和混合&#x2F;多云环境。事实上，硬件设备与云环境不兼容，而软件负载均衡器与裸机、虚拟、容器和云平台兼容。</li>
</ul>
<h4 id="根据地域范围分类"><a href="#根据地域范围分类" class="headerlink" title="根据地域范围分类"></a>根据地域范围分类</h4><p>负载均衡从其应用的地理结构上分为本地负载均衡(Local Load Balance)和全局负载均衡(Global Load Balance，也叫地域负载均衡)。</p>
<p><img src="/2022/10/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-II/5.png" alt="图片">地域负载均衡</p>
<h6 id="本地负载均衡"><a href="#本地负载均衡" class="headerlink" title="本地负载均衡"></a>本地负载均衡</h6><blockquote>
<p>本地负载均衡是指对本地的服务器群做负载均衡。</p>
</blockquote>
<p>本地负载均衡针对本地范围的服务器群做负载均衡，本地负载均衡不需要花费高额成本购置高性能服务器，只需利用现有设备资源,就可有效避免服务器单点故障造成数据流量的损失，通常用来解决数据流量过大、网络负荷过重的问题。同时它拥有形式多样的均衡策略把数据流量合理均衡的分配到各台服务器。如果需要在现在服务器上升级扩充，不需改变现有网络结构、停止现有服务，仅需要在服务群中简单地添加一台新服务器。</p>
<p>本地负载均衡能有效地解决数据流量过大、网络负荷过重的问题，并且不需花费昂贵开支购置性能卓越的服务器，充分利用现有设备，避免服务器单点故障造成数据流量的损失。</p>
<p>其有灵活多样的均衡策略把数据流量合理地分配给服务器群内的服务器共同负担。即使是再给现有服务器扩充升级，也只是简单地增加一个新的服务器到服务群中，而不需改变现有网络结构、停止现有的服务。</p>
<h6 id="全局负载均衡"><a href="#全局负载均衡" class="headerlink" title="全局负载均衡"></a>全局负载均衡</h6><blockquote>
<p>全局负载均衡是指对分别放置在不同的地理位置、有不同网络结构的服务器群间作负载均衡。</p>
</blockquote>
<p>全局负载均衡主要用于在一个多区域拥有自己服务器的站点，为了使全球用户只以一个IP地址或域名就能访问到离自己最近的服务器，从而获得最快的访问速度，也可用于子公司分散站点分布广的大公司通过Intranet(企业内部互联网)来达到资源统一合理分配的目的。</p>
<p>全局负载均衡，目前实现方式有以下几种：</p>
<ul>
<li><p>通过运营商线路调度：这个主要是指国内，由于特殊原因国内不同运营商互联互通存在很大问题，比如联通用户访问电信机房服务器延迟很大，甚至有可能无法访问的情况。假如您的业务部署在不同运营商机房，可以通过运营商线路解析来实现调度，联通线路用户域名解析到联通机房IP，电信线路用户域名解析电信机房IP，这样保证不同用户访问最佳的服务器。</p>
</li>
<li><p>通过地域线路调度：</p>
</li>
<li><ul>
<li>我们都知道，网站服务器越近，访问速度越快，比如天津用户访问北京服务器会比广州服务器快很多。假如您的业务部署在华北，华南两个Region，可以通过地域线路解析，设置华北，东北，西北，华中用户访问域名解析到北京服务器IP，华东，华南，西南用户访问域名解析到广州服务器IP，这样用户访问离自己最近的服务器可以提升访问体验。</li>
<li>假如您的业务是面向全球的，国内部署有业务，海外也部署有业务，可以选择中国用户访问域名解析到国内服务器，海外用户访问域名解析到海外服务器。当然海外的还可以细分，比如选择亚太–新加坡的用户等，可以具体到洲，国家。</li>
</ul>
</li>
<li><p>权重轮询：比如一个域名解析到多个IP，可以根据不同IP服务器的配置，业务情况设置解析比重，比如2:1或者1:1等等。</p>
</li>
<li><p>健康检查，故障转移：可以创建监控任务实时监控后端服务器IP的健康状态，如果发现后端服务器异常，可以把解析流量切换到其他正常的服务器或者备用服务器，保证业务不会中断。</p>
</li>
</ul>
<p>CDN的全称是Content Delivery Network，即内容分发网络。其就是采用的全局负载均衡。假如我们将图片存储在CDN上，且该CDN所在厂家在北京、杭州均有服务器。那么：</p>
<ul>
<li>当天津的用户需要下载该图片的时候，会自动将流量请求转发至距离其最近的CDN服务器，也就是北京</li>
<li>当安徽的用户需要下载图片的时候，就会将流量请求转发至杭州。</li>
</ul>
<h4 id="根据OSI网络模型分类"><a href="#根据OSI网络模型分类" class="headerlink" title="根据OSI网络模型分类"></a>根据OSI网络模型分类</h4><p><img src="/2022/10/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-II/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">OSI是一个开放性的通信系统互连参考模型，如上图所示。在OSI参考模型中，分别有：</p>
<ul>
<li>应用层</li>
<li>表示层</li>
<li>会话层</li>
<li>传输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层</li>
</ul>
<p>从上图可以看出：</p>
<blockquote>
<p>TELNET、HTTP、FTP、NFS、SMTP、DNS等属于第七层应用层的概念。</p>
<p>TCP、UDP、SPX等属于第四层传输层的概念。</p>
<p>IP、IPX等属于第三层网络层的概念。</p>
<p>ATM、FDDI等属于第二层数据链路层的概念。</p>
</blockquote>
<p>根据负载均衡技术实现在OSI七层模型的不同层次，我们给负载均衡分类：</p>
<ul>
<li>七层负载均衡：工作在应用层的负载均衡称</li>
<li>四层负载均衡：工作在传输层的负载均衡称</li>
<li>三层负载均衡：工作在网络层的负载均衡，</li>
<li>二层负载均衡：工作在数据链路层的负载均衡。</li>
</ul>
<p><img src="/2022/10/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-II/6.png" alt="图片"></p>
<p><em><strong>其中最常用的是四层和七层负载均衡</strong></em>。</p>
<p>下面我们将从OSI模型从下往上的顺序，来详细讲解上述几种负载均衡。</p>
<h6 id="二层负载均衡"><a href="#二层负载均衡" class="headerlink" title="二层负载均衡"></a>二层负载均衡</h6><blockquote>
<p>工作在数据链路层的负载均衡称之为二层负载均衡(又称为数据链路层负载均衡)，通过在通信协议的数据链路层修改mac地址进行负载均衡。</p>
</blockquote>
<p>二层负载均衡是基于数据链路层的负载均衡，即让负载均衡服务器和业务服务器绑定同一个虚拟IP（即VIP），客户端直接通过这个VIP进行请求集群。集群中不同的机器采用相同IP地址，但是机器的MAC地址不一样。当负载均衡服务器接受到请求之后，通过改写报文的目标MAC地址的方式将请求转发到目标机器实现负载均衡。</p>
<p>数据链路层负载均衡所做的工作，是修改请求的数据帧中的 MAC 目标地址，让用户原本是发送给负载均衡器的请求的数据帧，被二层交换机根据新的 MAC 目标地址转发到服务器集群中对应的服务器（真实服务器）的网卡上，这样真实服务器就获得了一个原本目标并不是发送给它的数据帧。</p>
<p>为了便于理解，我们假设负载均衡器所在的ip地址为192.168.1.1，后端服务实例的mac地址分别为52:54:00:A1:CB:F7，61:52:00:A2:BD, 71:63:52:A3:CA。如下图所示：</p>
<p><img src="/2022/10/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-II/7.png" alt="图片">二层负载均衡</p>
<p>在上图中，用户的请求首先到达ip为192.168.1.1的二层负载均衡器，然后二层负载均衡器通过采取一定的策略，选中了mac地址为71:63:52:A3:CA，然后将流量转发至该服务实例。</p>
<p>需要注意的是,上述只有请求经过负载均衡器，而服务的响应无须从负载均衡器原路返回的工作模式，整个请求、转发、响应的链路形成一个“三角关系”，所以这种负载均衡模式也常被很形象地称为“三角传输模式”，也有叫“单臂模式”或者“直接路由”。</p>
<p><em>二层负载均衡器直接改写目标 MAC 地址的工作原理决定了它与真实的服务器的通信必须是二层可达的，通俗地说就是必须位于同一个子网当中，无法跨 VLAN。优势（效率高）和劣势（不能跨子网）共同决定了数据链路层负载均衡最适合用来做数据中心的第一级均衡设备，用来连接其他的下级负载均衡器。</em></p>
<h6 id="三层负载均衡"><a href="#三层负载均衡" class="headerlink" title="三层负载均衡"></a>三层负载均衡</h6><blockquote>
<p>三层负载均衡是基于网络层的负载均衡，因此又叫网络层负载均衡。通俗的说就是按照不同机器不同IP地址进行转发请求到不同的机器上。</p>
</blockquote>
<p>根据 OSI 七层模型，在第三层网络层传输的单位是分组数据包，这是一种在分组交换网络中传输的结构化数据单位。以IP协议为例，一个IP 数据包由 Headers 和 Payload 两部分组成， Headers 长度最大为60Bytes，其中包括了20Bytes的固定数据和最长不超过40Bytes 的可选的额外设置组成。</p>
<p>三层负载均衡服务器对外依然提供一个VIP（虚IP），但是集群中不同的机器采用不同的IP地址。当负载均衡服务器接受到请求之后，根据不同的负载均衡算法，通过IP将请求转发至不同的真实服务器。</p>
<p>学过计算机网络的都知道，在IP分组的数据报header中有 <em>源IP</em> 和 <em>目标IP</em>。源IP和目标IP代表分组交换中数据是从哪台机器到哪台机器的，那么，我们可以采用跟修改二层负载均衡中MAC地址的方式一样，直接修改目标IP，以达到数据转发的目的。</p>
<p>修改目标IP的方式有两种：1、原有的数据包保持不变，生成一个新的数据包，原数据包的Header和Payload作为新数据包的Payload，在这个新数据包的 Headers 中写入真实服务器的 IP 作为目标地址，然后把它发送出去。</p>
<p>真实服务器收到数据包后，必须在接收入口处设计一个针对性的拆包机制，把由负载均衡器自动添加的那层 Headers 扔掉，还原出原来的数据包来进行使用。这样，真实服务器就同样拿到了一个原本不是发给它（目标 IP 不是它）的数据包，达到了流量转发的目的。这种数据传输方式叫做 <em>IP隧道</em> 传输。</p>
<p>尽管因为要封装新的数据包，IP 隧道的转发模式比起直接路由模式效率会有所下降，但由于并没有修改原有数据包中的任何信息，所以 IP 隧道的转发模式仍然具备三角传输的特性，即负载均衡器转发来的请求，可以由真实服务器去直接应答，无须在经过均衡器原路返回。而且由于 IP 隧道工作在网络层，所以可以跨越 VLAN，因此摆脱了直接路由模式中网络侧的约束。</p>
<p>此模式从请求到响应如下图所示：</p>
<p><img src="/2022/10/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-II/8.png" alt="图片">IP隧道模式负载均衡</p>
<p>优点：</p>
<ul>
<li>可以跨越 VLAN 缺点：</li>
<li>要求真实服务器必须支持IP隧道协议，也就是说服务器需要自己会拆包</li>
<li>必须通过专门的配置，必须保证所有的真实服务器与均衡器有着相同的虚拟 IP 地址，因为回复该数据包时，需要使用这个虚拟 IP 作为响应数据包的源地址，这样客户端收到这个数据包时才能正确解析。</li>
</ul>
<p>基于以上原因，就有了第二种修改方式。2、改变目标数据包。</p>
<p>直接把数据包 Headers 中的目标地址改为真实服务器地址，修改后原本由用户发给均衡器的数据包，也会被三层交换机转发送到真实服务器的网卡上，而且因为没有经过 IP 隧道的额外包装，也就无须再拆包了。</p>
<p>因为这种模式是通过修改目标 IP 地址才到达真实服务器的，如果真实服务器直接将应答包返回客户端的话，这个应答数据包的源 IP 是真实服务器的 IP，也即均衡器修改以后的 IP 地址，客户端不可能认识该 IP，自然就无法再正常处理这个应答了。因此，只能让应答流量继续回到负载均衡，由负载均衡把应答包的源 IP 改回自己的 IP，再发给客户端，这样才能保证客户端与真实服务器之间的正常通信。</p>
<p>这种修改目标IP的方式叫NAT模式，这种通过修改目标IP的方式达到负载均衡目的的方式叫做NAT负载均衡。如下图所示：</p>
<p><img src="/2022/10/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-II/9.png" alt="图片">NAT模式负载均衡</p>
<h6 id="四层负载均衡"><a href="#四层负载均衡" class="headerlink" title="四层负载均衡"></a>四层负载均衡</h6><blockquote>
<p>所谓四层负载均衡，也就是主要通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</p>
</blockquote>
<p>由于四层负载均衡是作用在传输层，因此，我们就以常见的TCP进行举例。</p>
<p>负载均衡设备在接收到第一个来自客户端的SYN 请求时，即通过上述方式选择一个最佳的服务器，并对报文中目标IP地址进行修改(改为后端服务器IP），直接转发给该服务器。TCP的连接建立，即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作。在某些部署情况下，为保证服务器回包可以正确返回给负载均衡设备，在转发报文的同时可能还会对报文原来的源地址进行修改。</p>
<p><img src="/2022/10/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-II/10.png" alt="图片">四层负载均衡</p>
<p>四层负载均衡主要是基于tcp协议报文，可以做任何基于tcp&#x2F;ip协议的软件的负载均衡，比如Haproxy、LVS等。</p>
<h6 id="七层负载均衡"><a href="#七层负载均衡" class="headerlink" title="七层负载均衡"></a>七层负载均衡</h6><blockquote>
<p>所谓七层负载均衡，也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</p>
</blockquote>
<p>应用层协议较多，常用http、radius、dns等。七层负载就可以基于这些协议来负载。</p>
<p>我们仍然以TCP为例。负载均衡设备如果要根据真正的应用层内容再选择服务器，只能先代理最终的服务器和客户端建立连接(三次握手)后，才可能接受到客户端发送的真正应用层内容的报文，然后再根据该报文中的特定字段，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。负载均衡设备在这种情况下，更类似于一个代理服务器。负载均衡和前端的客户端以及后端的服务器会分别建立TCP连接。所以从这个技术原理上来看，七层负载均衡明显的对负载均衡设备的要求更高，处理七层的能力也必然会低于四层模式的部署方式。</p>
<blockquote>
<p>七层负载均衡器会与客户端 以及 后端的服务实例分别建立连接</p>
</blockquote>
<p><img src="/2022/10/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-II/11.png" alt="图片">七层负载均衡</p>
<p>七层负载均衡基本都是基于http协议的，适用于web服务器的负载均衡，比如Nginx等。</p>
<h4 id="对比-四层和七层"><a href="#对比-四层和七层" class="headerlink" title="对比(四层和七层)"></a>对比(四层和七层)</h4><ul>
<li><p>智能性</p>
</li>
<li><ul>
<li>七层负载均衡由于具备OIS七层的所有功能，所以在处理用户需求上能更加灵活，从理论上讲，七层模型能对用户的所有跟服务端的请求进行修改。例如对文件header添加信息，根据不同的文件类型进行分类转发。</li>
<li>四层模型仅支持基于网络层的需求转发，不能修改用户请求的内容。</li>
</ul>
</li>
<li><p>安全性</p>
</li>
<li><ul>
<li>七层负载均衡由于具有OSI模型的全部功能，能更容易抵御来自网络的攻击</li>
<li>四层模型从原理上讲，会直接将用户的请求转发给后端节点，无法直接抵御网络攻击。</li>
</ul>
</li>
<li><p>复杂度</p>
</li>
<li><ul>
<li>四层模型一般比较简单的架构，容易管理，容易定位问题</li>
<li>七层模型架构比较复杂，通常也需要考虑结合四层模型的混用情况，出现问题定位比较复杂。</li>
</ul>
</li>
<li><p>效率比</p>
</li>
<li><ul>
<li>四层模型基于更底层的设置，通常效率更高，但应用范围有限</li>
<li>七层模型需要更多的资源损耗，在理论上讲比四层模型有更强的功能，现在的实现更多是基于http应用。</li>
</ul>
</li>
</ul>
<h2 id="6算法与实现"><a href="#6算法与实现" class="headerlink" title="6算法与实现"></a>6算法与实现</h2><p>常用的负载均衡算法分为以下两类：</p>
<ul>
<li>静态负载均衡</li>
<li>动态负载均衡</li>
</ul>
<p>常见的静态均衡算法：轮询法、随机法、源地址哈希法、一致性哈希法、加权轮询法、加权随机法。</p>
<p>常见的动态负载均衡算法：最小连接数法、最快响应速度法。</p>
<h4 id="随机法-Random"><a href="#随机法-Random" class="headerlink" title="随机法(Random)"></a>随机法(Random)</h4><blockquote>
<p>将请求随机分配到各个节点。由概率统计理论得知，随着客户端调用服务端的次数增多，其实际效果越来越接近于平均分配，也就是轮询的结果。</p>
</blockquote>
<p>随机策略会导致配置较低的机器Down机，从而可能引起雪崩，一般采用随机算法时建议后端集群机器配置最好同等的，随机策略的性能取决于随机算法的性能。</p>
<ul>
<li>优点：简单高效，易于水平扩展，每个节点满足字面意义上的均衡；</li>
<li>缺点：没有考虑机器的性能问题，根据木桶最短木板理论，集群性能瓶颈更多的会受性能差的服务器影响。</li>
</ul>
<p><img src="/2022/10/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-II/12.png" alt="图片">随机法</p>
<p>实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::string Select(const std::vector&lt;int&gt; &amp;ips) &#123;</span><br><span class="line">  size_t size = ips.size();</span><br><span class="line">  if (size == 0) &#123;</span><br><span class="line">    return &quot;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return ips[random() % size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="轮询法-Round-Robin"><a href="#轮询法-Round-Robin" class="headerlink" title="轮询法(Round Robin)"></a>轮询法(Round Robin)</h4><blockquote>
<p>每一次来自网络的请求轮流分配给内部中的服务器，从1至N然后重新开始。此种均衡算法适合于服务器组中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况。</p>
</blockquote>
<p>假设10台机器，从0-9，请求来临时从0号机器开始，后续每来一次请求对编号加1，这样一直循环，上面的随机策略其实最后就变成轮询了，这两种策略都不关心机器的负载和运行情况，而且对变量操作会引入锁操作，性能也会下会下降。</p>
<ul>
<li>优点：简单高效，易于水平扩展，每个节点满足字面意义上的均衡；</li>
<li>缺点：没有考虑机器的性能问题，根据木桶最短木板理论，集群性能瓶颈更多的会受性能差的服务器影响。</li>
</ul>
<p><img src="/2022/10/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-II/13.png" alt="图片">轮询法</p>
<p>代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int idx = 0;</span><br><span class="line">std::string Select(const std::vector&lt;int&gt; &amp;ips) &#123;</span><br><span class="line">  size_t size = ips.size();</span><br><span class="line">  if (size == 0) &#123;</span><br><span class="line">    return &quot;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  if (idx == ips.size()) &#123;</span><br><span class="line">    idx = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return ips[idx++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="加权轮询法-Weighted-Round-Robin"><a href="#加权轮询法-Weighted-Round-Robin" class="headerlink" title="加权轮询法(Weighted Round Robin)"></a>加权轮询法(Weighted Round Robin)</h4><blockquote>
<p>不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请求；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</p>
</blockquote>
<p>假设后端有3台服务器，分别为a b c，现在在负载均衡器中配置a服务器的权重为7，b服务的权重为2，c服务的权重为1。当来了10次请求的时候，其中有7次请求a，2次请求b，1次请求c。即最终结果是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aaaaaaabbc</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：可以将不同机器的性能问题纳入到考量范围，集群性能最优最大化；</li>
<li>缺点：生产环境复杂多变，服务器抗压能力也无法精确估算，静态算法导致无法实时动态调整节点权重，只能粗糙优化。</li>
</ul>
<p><img src="/2022/10/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-II/14.png" alt="图片">加权轮询</p>
<h4 id="加权随机法-Weighted-Random"><a href="#加权随机法-Weighted-Random" class="headerlink" title="加权随机法(Weighted Random)"></a>加权随机法(Weighted Random)</h4><blockquote>
<p>与加权轮询法一样，加权随机法也根据服务器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。</p>
</blockquote>
<p>在之前的文章<a href="https://mp.weixin.qq.com/s?__biz=Mzk0MzI4OTI1Ng==&mid=2247484656&idx=1&sn=aae935199378a31296bd28ec6c9c97c4&scene=21#wechat_redirect">权重随机分配器</a>我们有详细讲过各种实现方案，此处我们不再赘述，从里面摘抄了一种实现方案作为本方案的实现。</p>
<p><img src="/2022/10/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-II/15.png" alt="图片">加权随机</p>
<ul>
<li>优点：可以将不同机器的性能问题纳入到考量范围，集群性能最优最大化；</li>
<li>缺点：生产环境复杂多变，服务器抗压能力也无法精确估算，静态算法导致无法实时动态调整节点权重，只能粗糙优化。</li>
</ul>
<p>代码实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">srtuct Item &#123;</span><br><span class="line">  std::string ip;</span><br><span class="line">  int weight;</span><br><span class="line">&#125;;</span><br><span class="line">std::string select(const std::vector&lt;Item&gt; &amp;items) &#123;</span><br><span class="line">  int sum = 0;</span><br><span class="line">  for (auto elem : items) &#123;</span><br><span class="line">    sum += elem.weight;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  int rd = rand() % sum;</span><br><span class="line">  int s = 0;</span><br><span class="line">  std::string res;</span><br><span class="line">  for (auto elem : items) &#123;</span><br><span class="line">    s += elem.weight;</span><br><span class="line">    if (s &gt;= rd) &#123;</span><br><span class="line">      res = elem.ip;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最快响应速度法-Response-Time"><a href="#最快响应速度法-Response-Time" class="headerlink" title="最快响应速度法(Response Time)"></a>最快响应速度法(Response Time)</h4><blockquote>
<p>根据请求的响应时间，来动态调整每个节点的权重，将响应速度快的服务节点分配更多的请求，响应速度慢的服务节点分配更少的请求</p>
</blockquote>
<p>负载均衡设备对内部各服务器发出一个探测请求（例如Ping），然后根据内部中各服务器对探测请求的最快响应时间来决定哪一台服务器来响应客户端的服务请求。此种均衡算法能较好的反映服务器的当前运行状态，但这最快响应时间仅仅指的是负载均衡设备与服务器间的最快响应时间，而不是客户端与服务器间的最快响应时间。</p>
<ul>
<li>优点：动态，实时变化，控制的粒度更细，更灵敏；</li>
<li>缺点：复杂度更高，每次需要计算请求的响应速度；</li>
</ul>
<p><img src="/2022/10/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-II/16.png" alt="图片">最快响应速度</p>
<h4 id="最少连接数法-Least-Connections"><a href="#最少连接数法-Least-Connections" class="headerlink" title="最少连接数法(Least Connections)"></a>最少连接数法(Least Connections)</h4><blockquote>
<p>将请求分发到连接数&#x2F;请求数最少的候选服务器，已达到负载均衡的目的</p>
</blockquote>
<p>客户端的每一次请求服务在服务器停留的时间可能会有较大的差异，随着工作时间加长，如果采用简单的轮循或随机均衡算法，每一台服务器上的连接进程可能会产生极大的不同，并没有达到真正的负载均衡。最少连接数均衡算法对内部中需负载的每一台服务器都有一个数据记录，记录当前该服务器正在处理的连接数量，当有新的服务连接请求时，将把当前请求分配给连接数最少的服务器，使均衡更加符合实际情况，负载更加均衡。此种均衡算法适合长时处理的请求服务，如FTP。</p>
<ul>
<li>优点：动态，根据节点状况实时变化</li>
<li>缺点：提高了复杂度，每次连接断开需要进行计数</li>
</ul>
<p><img src="/2022/10/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-II/17.png" alt="图片">最少连接数</p>
<h4 id="源地址哈希法-Source-Hashing"><a href="#源地址哈希法-Source-Hashing" class="headerlink" title="源地址哈希法(Source Hashing)"></a>源地址哈希法(Source Hashing)</h4><blockquote>
<p>根据请求源 IP，通过哈希计算得到一个数值，用该数值在候选服务器列表的进行取模运算，得到的结果便是选中的服务器。</p>
</blockquote>
<p>能够让同一客户端的请求或者同一用户的请求总是请求在后端同一台机器上，这种算法根据客户端IP求出Hash值然后对端集群总数求余得到值就是服务器集合的下标，一般这种算法用于缓存命中，或者同一会话请求等，但这种算法也有一定的缺点，某一用户访问量(黑产)非常高时可能造成服务端压力过大或者后端服务Down掉，那么客户端就会无法访问，所以也需要一定的降级策略。</p>
<ul>
<li>优点：将来自同一IP地址的请求，同一会话期内，转发到相同的服务器；实现会话粘滞</li>
<li>缺点：目标服务器宕机后，会话会丢失</li>
</ul>
<p><img src="/2022/10/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-II/18.png" alt="图片">源地址哈希</p>
<h4 id="一致性哈希-Consistency-hash"><a href="#一致性哈希-Consistency-hash" class="headerlink" title="一致性哈希(Consistency hash)"></a>一致性哈希(Consistency hash)</h4><p>一些场景希望同样的请求尽量落到一台机器上，比如访问缓存集群时，我们往往希望同一种请求能落到同一个后端上，以充分利用其上已有的缓存，不同的机器承载不同的稳定请求量（也可以理解为固定批用户的请求）。而不是随机地散落到所有机器上，那样的话会迫使所有机器缓存所有的内容，最终由于存不下形成颠簸而表现糟糕。我们都知道hash能满足这个要求，比如当有n台服务器时，输入x总是会发送到第hash(x) % n台服务器上。但当服务器变为m台时，hash(x) % n和hash(x) % m很可能都不相等，这会使得几乎所有请求的发送目的地都发生变化，如果目的地是缓存服务，所有缓存将失效，继而对原本被缓存遮挡的数据库或计算服务造成请求风暴，触发雪崩。一致性哈希是一种特殊的哈希算法，在增加服务器时，发向每个老节点的请求中只会有一部分转向新节点，从而实现平滑的迁移。</p>
<p><img src="/2022/10/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-II/19.png" alt="图片">一致性哈希</p>
<p>优点：</p>
<ul>
<li>平衡性: 每个节点被选到的概率是O(1&#x2F;n)。</li>
<li>单调性: 当新节点加入时， 不会有请求在老节点间移动， 只会从老节点移动到新节点。当有节点被删除时，也不会影响落在别的节点上的请求。</li>
<li>分散性: 当上游的机器看到不同的下游列表时(在上线时及不稳定的网络中比较常见), 同一个请求尽量映射到少量的节点中。</li>
<li>负载: 当上游的机器看到不同的下游列表的时候， 保证每台下游分到的请求数量尽量一致。</li>
</ul>
<p>缺点：</p>
<ul>
<li>在机器数量较少的时候，区间大小会不平衡。</li>
<li>当一台机器故障的时候，它的压力会完全转移到另外一台机器， 可能无法承载。</li>
</ul>
<h2 id="7结语"><a href="#7结语" class="headerlink" title="7结语"></a>7结语</h2><p>负载均衡并不是真正确保网络流量能够”均匀”的分配到后端服务实例。它只是抱着在意外情况发生时候，也能保证用户体验。良好的架构设计和弹性扩容，能够使得负载均衡的功能 <em><strong>事半功倍</strong></em>。</p>
]]></content>
      <categories>
        <category>负载均衡</category>
      </categories>
      <tags>
        <tag>负载均衡</tag>
        <tag>Load Balance</tag>
        <tag>LB</tag>
        <tag>SLB</tag>
      </tags>
  </entry>
  <entry>
    <title>走进DDD</title>
    <url>/2022/10/25/%E8%B5%B0%E8%BF%9BDDD/</url>
    <content><![CDATA[<p>p1-走进DDD</p>
<div class="pdf-container" data-target="./p1-走入DDD.pdf" data-height="1000px"></div>]]></content>
      <categories>
        <category>DDD领域驱动设计</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>去哪儿网DDD系列公开课</tag>
      </tags>
  </entry>
  <entry>
    <title>酒店报价DDD实战</title>
    <url>/2022/10/25/%E9%85%92%E5%BA%97%E6%8A%A5%E4%BB%B7DDD%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<p>p7-酒店报价DDD实战</p>
<div class="pdf-container" data-target="./p7-酒店报价DDD实战.pdf" data-height="1000px"></div>]]></content>
      <categories>
        <category>DDD领域驱动设计</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>去哪儿网DDD系列公开课</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发实践文章-携程1分钟售票8万张</title>
    <url>/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E6%90%BA%E7%A8%8B1%E5%88%86%E9%92%9F%E5%94%AE%E7%A5%A88%E4%B8%87%E5%BC%A0/</url>
    <content><![CDATA[<p><strong>一、背景</strong></p>
<p>去年疫情后，为了加速启动旅游市场，湖北在全域范围内开展“与爱同行 惠游湖北”活动——全省所有A级旅游景区向全国游客免门票，敞开怀抱欢迎全国人民。本文将介绍在这一活动期间，线上预约抢票系统遇到的核心问题，系统的改造过程以及实施的一些经验。这是高并发、高可用场景下，提升系统稳定性的一次实战优化，希望能给面对同样问题的同学提供一些借鉴思路。</p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E6%90%BA%E7%A8%8B1%E5%88%86%E9%92%9F%E5%94%AE%E7%A5%A88%E4%B8%87%E5%BC%A0/1.png" alt="img"></p>
<p>活动页面</p>
<p><strong>二、风险与挑战</strong></p>
<p>在活动初期，系统面临以下四类风险：</p>
<ul>
<li>流量大，入口流量瞬间增长100倍，远超系统承载能力；</li>
<li>高并发下，服务稳定性降低；</li>
<li>限购错误；</li>
<li>热门门票、热门出行日期扣库存热点；</li>
</ul>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E6%90%BA%E7%A8%8B1%E5%88%86%E9%92%9F%E5%94%AE%E7%A5%A88%E4%B8%87%E5%BC%A0/2.png" alt="img"></p>
<p>高并发下系统的挑战</p>
<p>下面我们一起来看下每个问题的影响和解决策略。</p>
<p><strong>2.1 入口流量增长100倍</strong></p>
<p><strong>问题</strong></p>
<p>活动开始时入口流量增长100倍，当前系统无法通过水平扩展解决问题。</p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E6%90%BA%E7%A8%8B1%E5%88%86%E9%92%9F%E5%94%AE%E7%A5%A88%E4%B8%87%E5%BC%A0/3.png" alt="img"></p>
<p>请求量监控</p>
<p><strong>目标</strong></p>
<p>提升入口应用吞吐能力，降低下游调用量。</p>
<p><strong>策略</strong></p>
<p><strong>减少依赖</strong></p>
<p>1）去除0元票场景不需要的依赖。例如：优惠、立减；</p>
<p>2）合并重复的 IO(SOA&#x2F; Redis&#x2F;DB)，减少一次请求中相同数据的重复访问。</p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E6%90%BA%E7%A8%8B1%E5%88%86%E9%92%9F%E5%94%AE%E7%A5%A88%E4%B8%87%E5%BC%A0/4.png" alt="img"></p>
<p>上下文传递对象减少重复IO</p>
<p><strong>提升缓存命中率</strong></p>
<p>这里说的是接口级缓存，数据源依赖的是下游接口，如下图所示：</p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E6%90%BA%E7%A8%8B1%E5%88%86%E9%92%9F%E5%94%AE%E7%A5%A88%E4%B8%87%E5%BC%A0/5.png" alt="img"></p>
<p>服务层-接口级缓存-固定过期</p>
<p>接口级缓存一般使用固定过期+懒加载方式来缓存下游接口返回对象或者自定义的DO对象。当一个请求进来，先从缓存中取数据，若命中缓存则返回数据，若没命中则从下游获取数据重新构建缓存，由于是接口级的缓存，一般过期时间设置都比较短，流程如下图：</p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E6%90%BA%E7%A8%8B1%E5%88%86%E9%92%9F%E5%94%AE%E7%A5%A88%E4%B8%87%E5%BC%A0/6.png" alt="img"></p>
<p>固定过期+懒加载缓存</p>
<p>这种缓存方案存在击穿和穿透的风险，在高并发场景下缓存击穿和缓存穿透问题会被放大，下面会分别介绍一下这几类常见问题在系统中是如何解决的。</p>
<p><strong>1）缓存击穿</strong></p>
<p>描述：缓存击穿是指数据库中有，缓存中没有。例如：某个 key访问量非常高，属于集中式高并发访问，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求到下游（接口&#x2F;数据库），造成下游压力过大。</p>
<p>解决方案：对缓存增加被动刷新机制，在缓存实体对象中增加上一次刷新时间，请求进来后从缓存获取数据返回，后续判断缓存是否满刷新条件，若满足则异步获取数据重新构建缓存，若不满足，本次不更新缓存。通过用户请求异步刷新的方式，续租过期时间，避免缓存固定过期。</p>
<p>例如：商品描述信息，以前缓存过期时间为5min，现在缓存过期时间为24H，被动刷新时间为1min，用户每次请求都返回上一次的缓存，但每1min都会异步构建一次缓存。</p>
<p><strong>2）缓存穿透</strong></p>
<p>描述：缓存穿透是指数据库和缓存中都没有的数据，当用户不断发起请求，比如获取id不存在的数据，导致缓存无法命中，造成下游压力过大。</p>
<p>解决方案：当缓存未命中，在下游也没有取到数据时，缓存实体内容为空对象，缓存实体增加穿透状态标识，这类缓存过期时间设置比较短，默认30s过期，10s刷新，防止不存在的id反复访问下游，大部分场景穿透是少量的，但是有些场景刚好相反。例如：某一类规则配置，只有少量商品有，这种情况下我们对穿透类型的缓存过期时间和刷新时间设置同正常的过期和刷新时间一样，防止下游无数据一直频繁请求。</p>
<p><strong>3）异常降级</strong></p>
<p>当下游出现异常的时候，缓存更新策略如下：</p>
<p>缓存更新：</p>
<ul>
<li>下游是非核心：超时异常写一个短暂的空缓存（例如：30s 过期，10s刷新），防止下游超时，影响上游服务的稳定性。</li>
<li>下游是核心：异常时不更新缓存，下次请求再更新，防止写入空缓存，阻断了核心流程。</li>
</ul>
<p><strong>4）缓存模块化管理</strong></p>
<p>将缓存key按照数据源做分类，每一类key对应一个缓存模块名， 每个缓存模块可以动态设置版本号、过期时间和刷新时间，并统一埋点与监控。模块化管理后，缓存过期时间粒度更为细致，通过分析缓存模块命中率监控，可以反推过期和刷新时间是否合理，最终通过动态调整缓存过期时间与刷新时间，让命中率达到最佳。</p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E6%90%BA%E7%A8%8B1%E5%88%86%E9%92%9F%E5%94%AE%E7%A5%A88%E4%B8%87%E5%BC%A0/7.png" alt="img"></p>
<p>缓存模块命中率可视化埋点</p>
<p>我们将以上功能封装为了缓存组件，在使用的时只需要关心数据访问实现，既解决了使用缓存本身的一些共性问题，也降低了业务代码与缓存读写的耦合度。</p>
<p>下图为优化前后缓存使用流程对比：</p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E6%90%BA%E7%A8%8B1%E5%88%86%E9%92%9F%E5%94%AE%E7%A5%A88%E4%B8%87%E5%BC%A0/8.png" alt="img"></p>
<p>缓存使用对比</p>
<p><strong>效果</strong></p>
<p>通过解决缓存穿透与击穿、异常降级、缓存模块化管理，最终缓存命中率提升到98%以上，接口性能 (RT) 提升50% 以上，上下游调用量比例从1 : 3.9 降低为 1 : 1.3，下游接口调用量降低70%。</p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E6%90%BA%E7%A8%8B1%E5%88%86%E9%92%9F%E5%94%AE%E7%A5%A88%E4%B8%87%E5%BC%A0/9.png" alt="img"></p>
<p>处理性能提升50%</p>
<p><strong>2.2 高并发下服务稳定性低</strong></p>
<p><strong>问题</strong></p>
<p>在每天上午8:00抢票活动开始时，DB连接池被打满，线程波动大，商品服务超时。</p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E6%90%BA%E7%A8%8B1%E5%88%86%E9%92%9F%E5%94%AE%E7%A5%A88%E4%B8%87%E5%BC%A0/10.png" alt="img"></p>
<p>数据库线程波动</p>
<p><strong>思考</strong></p>
<ul>
<li>DB 连接池为什么会被打满？</li>
<li>API为什么会超时？</li>
<li>是DB不稳定影响了API，还是API流量过大影响了DB？</li>
</ul>
<p><strong>问题分析</strong></p>
<p>1）DB 连接池为什么会被打满？分析三类SQL日志。</p>
<ul>
<li>Insert 语句过多 – 场景：限购记录提交，将限购表单独拆库隔离后，商品API依然超时（排除） </li>
<li>Update 语句耗时过长 – 场景：扣减库存热点引起（重点排查）</li>
<li>Select 高频查询 – 场景：商品信息查询</li>
</ul>
<p>2）API为什么会超时？</p>
<p>排查日志可以看到，8:00活动开始后，大量热门商品信息查询到DB与Select高频查询一致。</p>
<p>3）是DB不稳定影响了API，还是API流量过大影响了DB？</p>
<p>根据#2初步判断是由于缓存击穿，导致大量流量穿透到DB。</p>
<p><strong>为什么缓存会被击穿？</strong></p>
<p>梳理系统架构后发现，由于8:00定时可售通过离线Job控制，8:00商品上线引发数据变更，数据变更导致缓存被刷新（先删后增），在缓存失效瞬间，服务端流量击穿到DB，导致服务端数据库连接池被打满，也就是上文所说的缓存击穿的现象。</p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E6%90%BA%E7%A8%8B1%E5%88%86%E9%92%9F%E5%94%AE%E7%A5%A88%E4%B8%87%E5%BC%A0/11.png" alt="img"></p>
<p>数据访问层-表级缓存-主动刷新</p>
<p>如下图所示，商品信息变更后主动让缓存过期，用户访问时重新加载缓存：</p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E6%90%BA%E7%A8%8B1%E5%88%86%E9%92%9F%E5%94%AE%E7%A5%A88%E4%B8%87%E5%BC%A0/12.png" alt="img"></p>
<p>数据访问层缓存刷新架构（旧）- 消息变更删除缓存Key</p>
<p><strong>目标</strong></p>
<p>为了防止活动时缓存被删除导致缓存击穿，流量穿透到DB，采用了以下2种策略：</p>
<p>1）避开活动时数据更新导致缓存失效</p>
<p>我们将商品可售状态拆分商品可见、可售状态。</p>
<ul>
<li>可见状态：7:00提前上线对外可见，避开高峰；</li>
<li>可售状态：逻辑判断定时售卖，既解决定时上线修改数据后，导致缓存被刷新的问题，也解决了Job上线后，商品可售状态延迟的问题。</li>
</ul>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E6%90%BA%E7%A8%8B1%E5%88%86%E9%92%9F%E5%94%AE%E7%A5%A88%E4%B8%87%E5%BC%A0/13.png" alt="img"></p>
<p>逻辑判断定时可售避开高峰缓存击穿</p>
<p>2）调整缓存刷新策略</p>
<p>原缓存刷新方案（先删后增）存在缓存击穿的风险，所以后面缓存刷新策略调整为覆盖更新，避免缓存失效导致缓存击穿。新缓存刷新架构，通过Canal监听 MySQL binlog 发送的MQ消息，在消费端聚合后，重新构建缓存。</p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E6%90%BA%E7%A8%8B1%E5%88%86%E9%92%9F%E5%94%AE%E7%A5%A88%E4%B8%87%E5%BC%A0/14.png" alt="img"></p>
<p>数据访问层缓存刷新架构（新）- 消息变更重新构建缓存</p>
<p><strong>效果</strong></p>
<p>服务(RT)正常，QPS提升至21w。</p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E6%90%BA%E7%A8%8B1%E5%88%86%E9%92%9F%E5%94%AE%E7%A5%A88%E4%B8%87%E5%BC%A0/15.png" alt="img"></p>
<p>上面两类问题与具体业务无关，下面我们介绍一下两个业务痛点：</p>
<ul>
<li>如何防止恶意购买（限购）</li>
<li>如何防止库存少买&#x2F;超买（扣库存）</li>
</ul>
<p><strong>2.3 限购</strong></p>
<p><strong>什么是限购？</strong></p>
<p>限购就是限制购买，规定购买的数量，往往是一些特价和降价的产品，为了防止恶意抢购所采取的一种商业手段。</p>
<p>限购规则（多达几十种组合）例如：</p>
<p>1）同一出行日期同一景区每张身份证只能预订1张；</p>
<p>2）7天内（预订日期）某地区只能预约3个景区且最多限购20份；</p>
<p>3）活动期间，预约超过5次，没有去游玩noshow限购；</p>
<p><strong>问题</strong></p>
<p>扣库存失败，限购取消成功（实际数据不一致），再次预订被限购了。</p>
<p><strong>原因</strong></p>
<p>限购提交是Redis和DB双写操作，Redis是同步写，DB是线程池异步写，当请求量过大时，线程队列会出现积压，最终导致Redis写成功，DB延时写入。在提交限购记录成功，扣库存失败后，需要执行取消限购记录。</p>
<p>如下图所示：</p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E6%90%BA%E7%A8%8B1%E5%88%86%E9%92%9F%E5%94%AE%E7%A5%A88%E4%B8%87%E5%BC%A0/16.png" alt="img"></p>
<p>限购检查-提交限购-取消限购</p>
<p>在高并发的场景下，提交限购记录在线程池队列中出现积压，Redis写入成功后，DB并未写入完成，此时取消限购Redis删除成功，DB删除未查到记录，最终提交限购记录后被写入，再次预订时，又被限购。</p>
<p>如下图：</p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E6%90%BA%E7%A8%8B1%E5%88%86%E9%92%9F%E5%94%AE%E7%A5%A88%E4%B8%87%E5%BC%A0/17.png" alt="img"></p>
<p>线程队列积压，先提交的“提交限购”请求晚于“取消限购”</p>
<p><strong>目标</strong></p>
<p>服务稳定，限购准确。</p>
<p><strong>策略</strong></p>
<p>确保取消限购操作Redis&#x2F;DB最终一致。</p>
<p>由于提交限购记录可能会出现积压，取消限购时提交限购记录还未写入，导致取消限购时未能删除对应的提交记录。我们通过延迟消息补偿重试，确保取消限购操作(Redis&#x2F;DB)最终一致。在取消限购的时候，删除限购记录影响行数为0时，发送MQ延迟消息，在Consumer端消费消息，重试取消限购，并通过埋点与监控检测核心指标是否有异常。</p>
<p>如下图所示：</p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E6%90%BA%E7%A8%8B1%E5%88%86%E9%92%9F%E5%94%AE%E7%A5%A88%E4%B8%87%E5%BC%A0/18.png" alt="img"></p>
<p>下单-提交限购与取消限购</p>
<p><strong>效果</strong></p>
<p>限购准确，没有误拦截投诉。</p>
<p><strong>2.4 扣减库存</strong></p>
<p><strong>问题</strong></p>
<ul>
<li>商品后台显示1w已售完，实际卖出5000，导致库存未售完。</li>
<li>MySQL出现热点行级别锁，影响扣减性能。</li>
</ul>
<p><strong>原因</strong></p>
<ul>
<li>扣库存与库存明细SQL不在一个事务里面，大量扣减时容易出现部分失败的情况，导致库存记录和明细不一致的情况。</li>
<li>热门景点热门出行日期被集中预订，导致MySQL出现扣减库存热点。</li>
</ul>
<p><strong>目标</strong></p>
<p>库存扣减准确，提升处理能力。</p>
<p><strong>策略</strong></p>
<p><strong>1）将扣减库存记录和扣减明细放在一个事务里面，保证数据一致性。</strong></p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E6%90%BA%E7%A8%8B1%E5%88%86%E9%92%9F%E5%94%AE%E7%A5%A88%E4%B8%87%E5%BC%A0/19.png" alt="img"></p>
<p>DB事务扣减库存</p>
<p><strong>效果</strong></p>
<p>优点：数据一致。</p>
<p>缺点：热点资源，热门日期，扣减库存行级锁时间变长，接口RT变长，处理能力下降。</p>
<p><strong>2）使用分布式缓存，在分布式缓存中预减库存，减少数据库访问。</strong></p>
<p>秒杀商品异步扣减，消除DB峰值，非秒杀走正常流程。</p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E6%90%BA%E7%A8%8B1%E5%88%86%E9%92%9F%E5%94%AE%E7%A5%A88%E4%B8%87%E5%BC%A0/20.png" alt="img"></p>
<p>商品上线的时候将库存写入Redis，在活动扣减库存时，使用incrby原子扣减成功后将扣减消息MQ发出，在Consumer端消费消息执行DB扣减库存，若下单失败，执行还库存操作，也是先操作Redis，再发MQ，在Consumer端，执行DB还库存，如果未查询到扣减记录（可能扣库存MQ有延迟），则延时重试，并通过埋点与监控检测核心指标是否有异常。</p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E6%90%BA%E7%A8%8B1%E5%88%86%E9%92%9F%E5%94%AE%E7%A5%A88%E4%B8%87%E5%BC%A0/21.png" alt="img"></p>
<p>异步扣减库存</p>
<p><strong>效果</strong></p>
<ul>
<li>服务RT平稳，数据库IO平稳</li>
<li>Redis 扣减有热点迹象</li>
</ul>
<p><strong>3）缓存热点分桶扣减库存</strong></p>
<p>当单个Key流量达到Redis单实例承载能力时，需要对单key做拆分，解决单实例热点问题。由于热点门票热门日期产生热点Key问题，观察监控后发现并不是特别严重，临时采用拆分Redis集群，减少单实例流量，缓解热点问题，所以缓存热点分桶扣减库存本次暂未实现，这里简单描述一下当时讨论的思路。</p>
<p>如下图所示：</p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E6%90%BA%E7%A8%8B1%E5%88%86%E9%92%9F%E5%94%AE%E7%A5%A88%E4%B8%87%E5%BC%A0/22.png" alt="img"></p>
<p>缓存热点分桶扣减</p>
<p>分桶分库存：</p>
<p>秒杀开始前提前锁定库存修改，并执行分桶策略，按照库存Id取模分为N个桶, 每个分桶对应缓存的Key为Key [0~ N-1]，每个分桶保存m个库存初始化到Redis，秒杀时根据 Hash(Uid)%N 路由到不同的桶进行扣减，解决所有流量访问单个Key对单个Redis实例造成压力。</p>
<p>桶缩容：</p>
<p>正常情况下，热门活动每个桶中的库存经过几轮扣减都会扣减为0。</p>
<p>特殊场景下，可能存在每个桶只剩下个位数库存，预订时候份数大于剩余库存，导致扣减不成功。例如：分桶数量为100个，每个桶有1~2个库存，用户预订3份时扣减失败。当库存小于十位数时，缩容桶的数量，防止用户看到有库存，扣减一直失败。</p>
<p><strong>优化前后对比</strong></p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E6%90%BA%E7%A8%8B1%E5%88%86%E9%92%9F%E5%94%AE%E7%A5%A88%E4%B8%87%E5%BC%A0/23.png" alt="img"></p>
<p> 扣减库存方案对比</p>
<p><strong>三、回顾总结</strong></p>
<p>回顾“与爱同行 惠游湖北”整个活动，我们整体是这样备战的：</p>
<ul>
<li>梳理风险点：包括系统架构、核心流程，识别出来后制定应对策略；</li>
<li>流量预估：根据票量、历史PV、节假日峰值预估活动峰值QPS；</li>
<li>全链路压测：对系统进行全链路压测，对峰值 QPS进行压测，找出问题点，优化改进；</li>
<li>限流配置：为系统配置安全的、符合业务需求的限流阀值；</li>
<li>应急预案：收集各个域的可能风险点，制作应急处理方案；</li>
<li>监控：活动时观察各项监控指标，如有异常，按预案处理；</li>
<li>复盘：活动后分析日志，监控指标，故障分析，持续改进；</li>
</ul>
<p>本文阐述了在抢票活动中遇到的四个具有代表性的问题，在优化过程中，不断地思考和落地技术细节，沉淀核心技术，以最终达到让用户预订及入园顺畅，体验良好的目标。</p>
]]></content>
      <categories>
        <category>架构设计</category>
      </categories>
      <tags>
        <tag>高并发</tag>
        <tag>架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-策略模式II</title>
    <url>/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8FII/</url>
    <content><![CDATA[<p>那么工厂模式和策略模式有什么区别呢？</p>
<blockquote>
<ul>
<li>工厂模式是属于创建型设计模式，主要用来针对不同类型创建不同的对象，达到解偶类对象。</li>
<li>策略模式是属于行为型设计模式，主要是针对不同的策略做出对应行为，达到行为解偶</li>
</ul>
</blockquote>
<p>本次就来具体聊聊<strong>策略模式</strong>它是如何做到行为解耦</p>
<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8FII/60.png" alt="图片"></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>什么是策略模式？它的原理实现是怎么样的？</p>
<blockquote>
<p>定义一系列算法，封装每个算法，并使他们可以互换，不同的策略可以让算法独立于使用它们的客户而变化。以上定义来自设计模式之美</p>
</blockquote>
<p>感觉有点抽象？那就来看一张结构图吧</p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8FII/61.png" alt="图片"></p>
<blockquote>
<ul>
<li>Strategy（抽象策略）：抽象策略类，并且定义策略执行入口</li>
<li>ConcreteStrategy（具体策略）：实现抽象策略，实现algorithm方法</li>
<li>Context（环境）：运行特定的策略类。</li>
</ul>
</blockquote>
<p>这么看结构其实还是不复杂的，而且跟状态模式类似。</p>
<p>那么这个代码怎么实现？</p>
<p>举个例子，汽车大家肯定都不陌生，愿大家早日完成汽车梦，汽车的不同档(concreteStrategy）就好比不同的策略，驾驶者选择几档则汽车按几档的速度前进，整个选择权在驾驶者（context）手中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GearStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义策略执行方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">(String param)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先还是先定义抽象策略</p>
<blockquote>
<p>这里是用接口的形式，还有一种方式可以用抽象方法<strong>abstract</strong>来写也是一样的。具体就看大家自己选择了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public abstract <span class="keyword">class</span> <span class="title class_">GearStrategyAbstract</span> &#123;</span><br><span class="line"><span class="comment">// 定义策略执行方法</span></span><br><span class="line">abstract <span class="keyword">void</span> <span class="title function_">algorithm</span>(<span class="title class_">String</span> param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GearStrategyOne</span> <span class="keyword">implements</span> <span class="title class_">GearStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">(String param)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前档位&quot;</span> + param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次定义具体档位策略，实现algorithm方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">  <span class="comment">// 缓存所有的策略，当前是无状态的，可以共享策略类对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, GearStrategy&gt; strategies = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一种写法</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        strategies.put(<span class="string">&quot;one&quot;</span>, <span class="keyword">new</span> <span class="title class_">GearStrategyOne</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GearStrategy <span class="title function_">getStrategy</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="literal">null</span> || type.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;type should not be empty.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strategies.get(type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种写法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GearStrategy <span class="title function_">getStrategySecond</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="literal">null</span> || type.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;type should not be empty.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">&quot;one&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GearStrategyOne</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 测试结果</span></span><br><span class="line">        <span class="type">GearStrategy</span> <span class="variable">strategyOne</span> <span class="operator">=</span> Context.getStrategy(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">        strategyOne.algorithm(<span class="string">&quot;1档&quot;</span>);</span><br><span class="line">         <span class="comment">// 结果：当前档位1档</span></span><br><span class="line">        <span class="type">GearStrategy</span> <span class="variable">strategyTwo</span> <span class="operator">=</span> Context.getStrategySecond(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">        strategyTwo.algorithm(<span class="string">&quot;1档&quot;</span>);</span><br><span class="line">        <span class="comment">// 结果：当前档位1档</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后就是实现运行时环境（Context），你可以定义成StrategyFactory，但都是一个意思。</p>
<p>在main方法里面的测试demo，可以看到通过不同的type类型，可以实现不同的策略，这就是策略模式主要思想。</p>
<p>在Context里面定义了两种写法：</p>
<blockquote>
<ul>
<li>第一种是维护了一个strategies的Map容器。用这种方式就需要判断每种策略是否可以共享使用，它只是作为算法的实现。</li>
<li>第二种是直接通过有状态的类，每次根据类型new一个新的策略类对象。这个就需要根据实际业务场景去做的判断。</li>
</ul>
</blockquote>
<h3 id="框架的应用"><a href="#框架的应用" class="headerlink" title="框架的应用"></a>框架的应用</h3><p>策略模式在框架中也在一个很常见的地方体现出来了，而且大家肯定都有使用过。</p>
<p>那就是JDK中的线程池<strong>ThreadPoolExecutor</strong></p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8FII/62.png" alt="图片"></p>
<p>首先都是类似于这样定义一个线程池，里面实现线程池的异常策略。</p>
<p>这个线程池的异常策略就是用的策略模式的思想。</p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8FII/63.png" alt="图片"></p>
<p>在源码中有RejectedExecutionHandler这个抽象异常策略接口，同时它也有四种拒绝策略。关系图如下：</p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8FII/64.png" alt="图片"></p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8FII/65.png" alt="图片"></p>
<p>这就是在框架中的体现了，根据自己的业务场景，合理的选择线程池的异常策略。</p>
<h3 id="业务改造举例"><a href="#业务改造举例" class="headerlink" title="业务改造举例"></a>业务改造举例</h3><p>在真实的业务场景中策略模式也还是应用很多的。</p>
<p>在社交电商中分享商品是一个很重要的环节，假设现在要我们实现一个分享图片功能，比如当前有 单商品、多商品、下单、会场、邀请、小程序链接等等多种分享场景。</p>
<p><img src="/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8FII/66.png" alt="图片"></p>
<p>针对上线这个流程图先用if else语句做一个普通业务代码判断，就像下面的这中方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleItemShare</span> &#123;</span><br><span class="line">    <span class="comment">// 单商品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">(String param)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前分享图片是&quot;</span> + param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiItemShare</span> &#123;</span><br><span class="line">    <span class="comment">// 多商品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">(String param)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前分享图片是&quot;</span> + param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderItemShare</span> &#123;</span><br><span class="line">    <span class="comment">// 下单</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">(String param)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前分享图片是&quot;</span> + param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShareFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">shareType</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">       <span class="comment">// 测试业务逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (shareType.equals(ShareType.SINGLE.getCode())) &#123;</span><br><span class="line">            <span class="type">SingleItemShare</span> <span class="variable">singleItemShare</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleItemShare</span>();</span><br><span class="line">            singleItemShare.algorithm(<span class="string">&quot;单商品&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shareType.equals(ShareType.MULTI.getCode())) &#123;</span><br><span class="line">            <span class="type">MultiItemShare</span> <span class="variable">multiItemShare</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MultiItemShare</span>();</span><br><span class="line">            multiItemShare.algorithm(<span class="string">&quot;多商品&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shareType.equals(ShareType.ORDER.getCode())) &#123;</span><br><span class="line">            <span class="type">OrderItemShare</span> <span class="variable">orderItemShare</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderItemShare</span>();</span><br><span class="line">            orderItemShare.algorithm(<span class="string">&quot;下单&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;未知分享类型&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// .....省略更多分享场景</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">ShareType</span> &#123;</span><br><span class="line">        SINGLE(<span class="number">1</span>, <span class="string">&quot;单商品&quot;</span>),</span><br><span class="line">        MULTI(<span class="number">2</span>, <span class="string">&quot;多商品&quot;</span>),</span><br><span class="line">        ORDER(<span class="number">3</span>, <span class="string">&quot;下单&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 场景对应的编码</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Integer code;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 业务场景描述</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> String desc;</span><br><span class="line">        ShareType(Integer code, String desc) &#123;</span><br><span class="line">            <span class="built_in">this</span>.code = code;</span><br><span class="line">            <span class="built_in">this</span>.desc = desc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> code;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 省略 get set 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里大家可以看到每新加一种分享类型，就需要加一次if else 判断，当如果有十几种场景的时候那代码整体就会非常的长，看起来给人的感觉也不是很舒服。</p>
<p>接下来就看看如何用策略模式进行重构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ShareStrategy</span> &#123;</span><br><span class="line">    <span class="comment">// 定义分享策略执行方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">shareAlgorithm</span><span class="params">(String param)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderItemShare</span> <span class="keyword">implements</span> <span class="title class_">ShareStrategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shareAlgorithm</span><span class="params">(String param)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前分享图片是&quot;</span> + param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略 MultiItemShare以及SingleItemShare策略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分享工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShareFactory</span> &#123;</span><br><span class="line">  <span class="comment">// 定义策略枚举</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">ShareType</span> &#123;</span><br><span class="line">        SINGLE(<span class="string">&quot;single&quot;</span>, <span class="string">&quot;单商品&quot;</span>),</span><br><span class="line">        MULTI(<span class="string">&quot;multi&quot;</span>, <span class="string">&quot;多商品&quot;</span>),</span><br><span class="line">        ORDER(<span class="string">&quot;order&quot;</span>, <span class="string">&quot;下单&quot;</span>);</span><br><span class="line">        <span class="comment">// 场景对应的编码</span></span><br><span class="line">        <span class="keyword">private</span> String code;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 业务场景描述</span></span><br><span class="line">        <span class="keyword">private</span> String desc;</span><br><span class="line">        ShareType(String code, String desc) &#123;</span><br><span class="line">            <span class="built_in">this</span>.code = code;</span><br><span class="line">            <span class="built_in">this</span>.desc = desc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> code;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 省略 get set 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 定义策略map缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, ShareStrategy&gt; shareStrategies = <span class="keyword">new</span>       <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        shareStrategies.put(<span class="string">&quot;order&quot;</span>, <span class="keyword">new</span> <span class="title class_">OrderItemShare</span>());</span><br><span class="line">        shareStrategies.put(<span class="string">&quot;single&quot;</span>, <span class="keyword">new</span> <span class="title class_">SingleItemShare</span>());</span><br><span class="line">        shareStrategies.put(<span class="string">&quot;multi&quot;</span>, <span class="keyword">new</span> <span class="title class_">MultiItemShare</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取指定策略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ShareStrategy <span class="title function_">getShareStrategy</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="literal">null</span> || type.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;type should not be empty.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shareStrategies.get(type);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 测试demo</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shareType</span> <span class="operator">=</span> <span class="string">&quot;order&quot;</span>;</span><br><span class="line">        <span class="type">ShareStrategy</span> <span class="variable">shareStrategy</span> <span class="operator">=</span> ShareFactory.getShareStrategy(shareType);</span><br><span class="line">        shareStrategy.shareAlgorithm(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        <span class="comment">// 输出结果：当前分享图片是order</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里策略模式就已经改造完了。在client请求端，根本看不到那么多的if else判断，只需要传入对应的策略方式即可，这里我们维护了一个策略缓存map，在直接调用的ShareFactory获取策略的时候就直接是从换种获取策略类对象。</p>
<p>这就已经达到了行为解偶的思想。同时也避免了长串的if else 判断。</p>
<p>优点：</p>
<blockquote>
<ul>
<li>算法策略可以自由实现切换</li>
<li>扩展性好，加一个策略，只需要增加一个类</li>
</ul>
</blockquote>
<p>缺点：</p>
<blockquote>
<ul>
<li>策略类数量多</li>
<li>需要维护一个策略枚举，让别人知道你当前具有哪些策略</li>
</ul>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就讲完了策略模式，整体看上去其实还是比较简单的，还是那句话学习设计模式我们还是要学习每种设计模式的思想，任何一种设计模式存在即合理。当然也不要因为设计模式而设计代码，那样反而得不偿失。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发实践文章-高可用系统架构设计简述</title>
    <url>/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>高可用（High availability，即 HA）的主要目的是为了保障「业务的连续性」，即在用户眼里，业务永远是正常（或者说基本正常）对外提供服务的。高可用主要是针对架构而言，那么要做好高可用，就要首先设计好架构，第一步我们一般会采用分层的思想将一个庞大的 IT 系统拆分成为应用层，中间件，数据存储层等独立的层，每一层再拆分成为更细粒度的组件，第二步就是让每个组件对外提供服务，毕竟每个组件都不是孤立存在的，都需要互相协作，对外提供服务才有意义。</p>
<p>要保证架构的高可用，就要保证架构中所有组件以及其对外暴露服务都要做高可用设计，任何一个组件或其服务没做高可用，都意味着系统存在风险。</p>
<p>那么这么多组件该怎么做高可用设计呢，其实任何组件要做高可用，都离不开「冗余」和「自动故障转移」，众所周知单点是高可用的大敌，所以组件一般是以集群（至少两台机器）的形式存在的，这样只要某台机器出现问题，集群中的其他机器就可以随时顶替，这就是「冗余」。简单计算一下，假设一台机器的可用性为 90%，则两台机器组成的集群可用性为 1-0.1*0.1 &#x3D; 99%，所以显然冗余的机器越多，可用性越高。</p>
<p>但光有冗余还不够，如果机器出现问题，需要人工切换的话也是费时费力，而且容易出错，所以我们还需要借助第三方工具（即仲裁者）的力量来实现「自动」的故障转移，以达到实现<strong>近实时</strong>的故障转移的目的，<strong>近实时的故障转移才是高可用的主要意义</strong></p>
<p>怎样的系统可以称之为高可用呢，业界一般用几个九来衡量系统的可用性，如下</p>
<table>
<thead>
<tr>
<th>可用性级别</th>
<th>系统可用性%</th>
<th>宕机时间&#x2F;年</th>
<th>宕机时间&#x2F;月</th>
<th>宕机时间&#x2F;周</th>
<th>宕机时间&#x2F;天</th>
</tr>
</thead>
<tbody><tr>
<td>不可用</td>
<td>90%</td>
<td>36.5 天</td>
<td>73 小时</td>
<td>16.8 小时</td>
<td>144 分钟</td>
</tr>
<tr>
<td>基本可用</td>
<td>99%</td>
<td>87.6 小时</td>
<td>7.3 小时</td>
<td>1.68 小时</td>
<td>14.4 分钟</td>
</tr>
<tr>
<td>较高可用</td>
<td>99.9%</td>
<td>8.76 小时</td>
<td>43.8 分钟</td>
<td>10.1 分钟</td>
<td>1.44 分钟</td>
</tr>
<tr>
<td>高可用</td>
<td>99.99%</td>
<td>52.56 分钟</td>
<td>4.38 分钟</td>
<td>1.01 秒</td>
<td>8.64 秒</td>
</tr>
<tr>
<td>极高可用</td>
<td>99.999%</td>
<td>5.26 分钟</td>
<td>26.28 秒</td>
<td>6.06 秒</td>
<td>0.86 秒</td>
</tr>
</tbody></table>
<p>一般实现两个 9 很简单，毕竟每天宕机 14 分钟已经严重影响业务了，这样的公司迟早歇菜，大厂一般要求 4 个 9，其他要求严苛的业务要达到五个九以上，比如如果因为一个电脑的故障导致所有列车停驶，那么就会有数以万计的人正常生活受到阻碍，这种情况就要求五个九以上</p>
<p>接下来我们就来一起看看架构中的各个组件如何借助「冗余」和「自动故障转移」来实现高可用。</p>
<h3 id="互联网架构剖析"><a href="#互联网架构剖析" class="headerlink" title="互联网架构剖析"></a>互联网架构剖析</h3><p>目前多数互联网都会采用微服务架构，常见架构如下:</p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%AE%80%E8%BF%B0/1.png" alt="图片"></p>
<p>可以看到架构主要分以下几层</p>
<ol>
<li>接入层：主要由 F5 硬件或 LVS 软件来承载所有的流量入口</li>
<li>反向代理层：Nginx，主要负责根据 url 来分发流量，限流等</li>
<li>网关：主要负责流控，风控，协议转换等</li>
<li>站点层：主要负责调用会员，促销等基本服务来装配 json 等数据并返回给客户端</li>
<li>基础 service：其实与站点层都属于微服务，是平级关系，只不过基础 service 属于基础设施，能被上层的各个业务层 server 调用而已</li>
<li>存储层：也就是 DB，如 MySQL，Oracle 等，一般由基础 service 调用返回给站点层</li>
<li>中间件：ZK，ES，Redis，MQ 等，主要起到加速访问数据等功能，在下文中我们会简单介绍下各个组件的作用</li>
</ol>
<p>如前所述，要实现整体架构的高可用，必须要实现每一层组件的高可用，接下来我们就来分别看一下每一层的组件都是如何实现高可用的</p>
<h3 id="接入层-amp-反向代理层"><a href="#接入层-amp-反向代理层" class="headerlink" title="接入层&amp;反向代理层"></a>接入层&amp;反向代理层</h3><p>这两层的高可用都和 keepalived 有关，所以我们结合起来一起看</p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%AE%80%E8%BF%B0/2.png" alt="图片"></p>
<p>对外，两个 LVS 以主备的形式对外提供服务，注意只有 master 在工作（即此时的 VIP 在 master 上生效），另外一个 backup 在 master 宕机之后会接管 master 的工作，那么 backup 怎么知道 master 是否正常呢，答案是通过 keepalived，在主备机器上都装上 keepalived 软件，启动后就会通过心跳检测彼此的健康状况，一旦 master 宕机，keepalived 会检测到，从而 backup 自动转成 master 对外提供服务，此时 VIP 地址（即图中的 115.204.94.139）即在 backup 上生效，也就是我们常说的「IP漂移」，通过这样的方式即解决了 LVS 的高可用。</p>
<p>keepalived 的心跳检测主要通过发送 ICMP 报文，或者利用 TCP 的端口连接和扫描检测来检测的，同样的，它也可以用来检测 Nginx 暴露的端口，这样的话如果某些 Nginx 不正常 Keepalived 也能检测到并将其从 LVS 能转发的服务列表中剔出。</p>
<p>借用 keepalived 这个第三方工具，同时实现了 LVS 和 Nginx 的高可用，同时在出现故障时也可以将宕机情况发送到对应开发人员的邮箱以让他们及时收到通知处理，确实很方便，Keepalived 应用广泛，下文我们会看到它也可以用在 MySQL 上来实现 MySQL 的高可用。</p>
<h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>接下来我们再来看一下「网关」，「站点层」,「基础服务层」，这三者一般就是我们所说的微服务架构组件，当然这些微服务组件还需要通过一些 RPC 框架如 Dubbo 来支撑才能通信，所以微服务要实现高可用，就意味着 dubbo 这些 RPC 框架也要提供支撑微服务高可用的能力，我们就以 dubbo 为例来看下它是如何实现高可用的</p>
<p>我们先来简单地看下 dubbo 的基本架构</p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%AE%80%E8%BF%B0/3.png" alt="图片"></p>
<p>思路也很简单，首先是 Provider（服务提供者）向 Registry（注册中心，如 ZK 或 Nacos 等）注册服务，然后 Consumer（服务消费者）向注册中心订阅和拉取 Provider 服务列表，获取服务列表后，Consumer 就可以根据其负载均衡策略选择其中一个  Provider 来向其发出请求，当其中某个 Provider 不可用（下线或者因为 GC 阻塞等）时，会被注册中心及时监听（通过心跳机制）到，也会及时推送给 Consumer，这样 Consumer 就能将其从可用的 Provider 列表中剔除，也就实现了故障的自动转移，不难看出，注册中心就起到了类似 keepalived 的作用</p>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>我们再来看下这些中间件如 ZK，Redis 等是如何实现高可用的呢</p>
<h4 id="ZK"><a href="#ZK" class="headerlink" title="ZK"></a>ZK</h4><p>上一节微服务中我们提到了注册中心，那我们就以 ZK（ZooKeeper）为例来看看它的高可用是如何实现的，先来看下它的整体架构图如下</p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%AE%80%E8%BF%B0/4.png" alt="图片"></p>
<p>Zookeeper 中的主要角色如下</p>
<ul>
<li>Leader: 即领导者，在集群中只有一个 Leader，主要承担了以下的功能</li>
</ul>
<ol>
<li>事务请求的唯一调度和处理者，保证集群事务处理的顺序性，所有 Follower 的写请求都会转给 Leader 执行，用来保证事务的一致性</li>
<li>集群内部各服务器的调度者：处理好事务请求后，会将数据广播同步到各个 Follower，统计 Follower 写入成功的数量，超过半数 Follower 写入成功，Leader 就会认为写请求提交成功，通知所有的 Follower commit 这个写操作，保证事后哪怕是集群崩溃恢复或者重启，这个写操作也不会丢失。</li>
</ol>
<ul>
<li>Follower:</li>
</ul>
<ol>
<li>处理客户端非事务请求、转发事务请求给 leader 服务器</li>
<li>参与事物请求 Proposal 的投票（需要半数以上服务器通过才能通知 leader commit 数据; Leader 发起的提案，要求 Follower 投票）</li>
<li>参与 Leader 选举的投票</li>
</ol>
<p><strong>画外音</strong>：Zookeeper 3.0 之后新增了一种 Observer 的角色，不过与此处讨论的 ZK 高可用关系不是很大，为了简化问题，所以省略</p>
<p>可以看到由于只有一个 Leader，很显然，此 Leader 存在单点隐患，那么 ZK 是怎么解决此问题的呢，首先 Follower 与 Leader 会用心跳机制保持连接，如果 Leader 出现问题了（宕机或者因为 FullGC 等原因无法响应），Follower 就无法感知到 Leader 的心跳，就会认为 Leader 出问题了，于是它们就会发起投票选举，最终在多个 Follower 中选出一个 Leader 来（这里主要用到了 Zookeeper Atomic Broadcast，即 ZAB 协议，它是为 ZK 专门设计的一种支持崩溃恢复的一致性协议），选举的细节不是本文重点，就不在此详述了。</p>
<p>除了 ZAB 协议，业界上常用的还有 Paxos，Raft 等协议算法，也可以用在 Leader 选举上，也就是是在分布式架构中，这些协议算法承担了“第三者”也就是仲裁者的作用，以承担故障的自动转移</p>
<h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><p>Redis 的高可用需要根据它的部署模式来看看，主要分为「主从模式」和「Cluster 分片模式」两种</p>
<h5 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h5><p>先来看一下主从模式，架构如下</p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%AE%80%E8%BF%B0/5.png" alt="图片">主从模式</p>
<p>主从模式即一主多从（一个或者多个从节点），其中主节点主要负责读和写，然后会将数据同步到多个从节点上，Client 也可以对多个从节点发起读请求，这样可以减轻主节点的压力，但和 ZK 一样，由于只有一个主节点，存在单点隐患，所以必须引入第三方仲裁者的机制来判定主节点是否宕机以及在判定主节点宕机后快速选出某个从节点来充当主节点的角色，这个第三方仲裁者在 Redis 中我们一般称其为「哨兵」（sentinel），当然哨兵进程本身也有可能挂掉，所以为了安全起见，需要部署多个哨兵（即哨兵集群）</p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%AE%80%E8%BF%B0/6.png" alt="图片">哨兵集群</p>
<p>这些哨兵通过 gossip（流言） 协议来接收关于主服务器是否下线的信息，并在判定主节点宕机后使用 Raft 协议来选举出新的主节点</p>
<h5 id="Cluster-分片集群"><a href="#Cluster-分片集群" class="headerlink" title="Cluster 分片集群"></a>Cluster 分片集群</h5><p>主从模式看似完美，但存在以下几个问题</p>
<ol>
<li>主节点写的压力难以降低：因为只有一个主节点能接收写请求，如果在高并发的情况下，写请求如果很高的话可能会把主节点的网卡打满，造成主节点对外无法服务</li>
<li>主节点的存储能力受到单机存储容量的限制：因为不管是主节点还是从节点，存储的都是<strong>全量</strong>缓存数据，那么随着业务量的增长，缓存数据很可能直线上升，直到达到存储瓶颈</li>
<li>同步风暴：因为数据都是从 master 同步到 slave 的，如果有多个从节点的话，master 节点的压力会很大</li>
</ol>
<p>为了解决主从模式的以上问题，分片集群应运而生，所谓分片集群即将数据分片，每一个分片数据由相应的主节点负责读写，这样的话就有多个主节点来分担写的压力，并且每个节点只存储<strong>部分数据</strong>，也就解决了单机存储瓶颈的问题，但需要注意的是每个主节点都存在单点问题，所以需要针对每个主节点做高可用，整体架构如下</p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%AE%80%E8%BF%B0/7.png" alt="图片"></p>
<p>原理也很简单，在 Proxy 收到 client 执行的 redis 的读写命令后，首先会对 key 进行计算得出一个值，如果这个值落在相应 master 负责的数值范围（一般将每个数字称为槽，Redis 一共有 16384 个槽）之内，那就把这条 redis 命令发给对应的 master 去执行，可以看到每个 master 节点只负责处理一部分的 redis 数据，同时为了避免每个 master 的单点问题，也为其配备了多个从节点以组成集群，当主节点宕机时，集群会通过 Raft 算法来从从节点中选举出一个主节点</p>
<h4 id="ES"><a href="#ES" class="headerlink" title="ES"></a>ES</h4><p>再来看一下 ES 是如何实现高可用的，在 ES 中，数据是以分片（Shard）的形式存在的，如下图所示，一个节点中索引数据共分为三个分片存储</p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%AE%80%E8%BF%B0/8.png" alt="图片"></p>
<p>但只有一个节点的话，显然存在和 Redis 的主从架构一样的单点问题，这个节点挂了，ES 也就挂了，所以显然需要创建多个节点</p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%AE%80%E8%BF%B0/9.png" alt="图片"></p>
<p>一旦创建了多个节点，分片（图中 P 为主分片，R 为副本分片）的优势就体现出来了，可以将分片数据分布式存储到其它节点上，极大提升了数据的水平扩展能力，同时每个节点都能承担读写请求，采用负载均衡的形式避免了单点的读写压力</p>
<blockquote>
<p>ES 的写机制与 Redis 和 MySQL 的主从架构有些差别（后两者的写都是直接向 master 节点发起写请求，而 ES 则不是），所以这里稍微解释一下 ES 的工作原理</p>
<p>首先说下节点的工作机制，节点（Node）分为主节点（Master Node）和从结点（Slave Node），主节点的主要职责是负责集群层面的相关操作，管理集群变更，如创建或删除索引，跟踪哪些节点是集群的一部分，并决定哪些分片分配给相关的节点，主节点也只有一个，一般通过类 Bully 算法来选举出来，如果主节点不可用了，则其他从节点也可以通过此算法来选举以实现集群的高可用，任何节点都可以接收读写请求以达到负载均衡的目的</p>
<p>再说一下分片的工作原理，分片分为主分片（Primary Shard，即图中 P0，P1，P2）和副本分片（Replica Shard，即图中 R0，R1，R2），主分片负责数据的写操作，所以虽然任何节点可以接收读写请求，但如果此节点接收的是写请求并且没有写数据所在的主分片话，此节点会将写请求调度到主分片所在的节点上，写入主分片后，主分片再把数据复制到其他节点的副本分片上，以有两个副本的集群为例，写操作如下</p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%AE%80%E8%BF%B0/10.png" alt="图片"></p>
</blockquote>
<h4 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h4><p>ES 利用数据分片来提升高可用和水平扩展能力的思想也应用在其他组件的架构设计上，我们以 MQ 中的 Kafka 为例再来看下数据分片的应用</p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%AE%80%E8%BF%B0/11.png" alt="图片">Kafka 高可用设计，图片来自《武哥漫谈IT》</p>
<p>如上是 Kafka 集群，可以看到每个 Topic 的 Partition 都分布式存储在其它消息服务器上，这样一旦某个 Partition 不可用，可以从 follower 中选举出 leader 继续服务，不过与 ES 中的数据分片不同的是，follower Partition 属于<strong>冷备</strong>，也就是说在正常情况下不会对外服务，只有在 leader 挂掉之后从 follower 中选举出 leader 后它才能对外提供服务</p>
<h3 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a>存储层</h3><p>接下来我们再来看一下最后一层，存储层（DB），这里我们以 MySQL 为例来简单地讨论一下其高可用设计，其实大家如果看完了以上的高可用设计，会发现 MySQL 的高可用也不过如此，思想都是类似的，与 Redis 类似，它也分主从和分片（即我们常说的分库分表）两种架构</p>
<p>主从的话与 LVS 类似，一般使用 keepalived 的形式来实现高可用，如下所示</p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%AE%80%E8%BF%B0/12.png" alt="图片"></p>
<p>如果 master 宕机了，Keepalived 也会及时发现，于是从库会升级主库，并且 VIP 也会“漂移”到原从库上生效，所以说大家在工程配置的 MySQL 地址一般是 VIP 以保证高可用</p>
<p>数据量大了之后就要分库分表了，于是就有了多主，就像 Redis 的分片集群一样，需要针对每个主配备多个从，如下</p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%AE%80%E8%BF%B0/13.png" alt="图片"></p>
<p>之前有读者问分库分表之后为啥还要做主从，现在我想大家应该都明白了，不是为了解决读写性能问题，主要是为了实现高可用</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>看完了架构层面的高可用设计，相信大家对高可用的核心思想「冗余」和「自动故障转移」会有更深刻的体会，观察以上架构中的组件你会发现冗余的主要原因是因为只有一主，为什么不能有多主呢，也不是不可以，但这样在分布式系统下要保证数据的一致性是非常困难的，尤其是节点多了的话，数据之间的同步更是一大难题，所以多数组件采用一主的形式，然后再在主和多从之间同步，多数组件之所以选择一主本质上是技术上的 tradeoff</p>
<p>那么做好每个组件的高可用之后是否整个架构就真的可用了呢，非也，这只能说迈出了第一步，在生产上还有很多突发情况会让我们的系统面临挑战，比如</p>
<ol>
<li>瞬时流量问题：比如我们可能会面临秒杀带来的瞬时流量激增导致系统的承载能力被压垮，这种情况可能影响日常交易等核心链路，所以需要做到系统之间的隔离，如单独为秒杀部署一套独立的集群</li>
<li>安全问题：比如 DDOS 攻击，爬虫频繁请求甚至删库跑路等导致系统拒绝服务</li>
<li>代码问题：比如代码 bug 引起内存泄露导致 FullGC 导致系统无法响应等</li>
<li>部署问题：在发布过程中如果贸然中止当前正在运行的服务也是不行的，需要做到优雅停机，平滑发布</li>
<li>第三方问题：比如我们之前的服务依赖第三方系统，第三方可能出问题导致影响我们的核心业务</li>
<li>不可抗力：如机房断电，所以需要做好容灾，异地多活，之前我司业务就由于机房故障导致服务四小时不可用，损失惨重</li>
</ol>
<p>所以除了做好架构的高可用之外，我们还需要在做好系统隔离，限流，熔断，风控，降级，对关键操作限制操作人权限等措施以保证系统的可用。</p>
<p>这里特别提一下降级，这是为了保证系统可用性采取的常用的措施，简单举几个例子</p>
<ol>
<li>我们之前对接过一个第三方资金方由于自身原因借款功能出了问题导致无法借款，这种情况为了避免引起用户恐慌，于是我们在用户申请第三方借款的时候返回了一个类似「为了提升你的额度，资金方正在系统升级」这样的文案，避免了客诉</li>
<li>在流媒体领域，当用户观看直播出现严重卡顿时，很多企业的第一选择不是查 log 排查问题，而是为用户自动降码率。因为比起画质降低，卡得看不了显然会让用户更痛苦</li>
<li>双十一零点高峰期，我们把用户的注册登录等非核心功能给停掉了，以保证下单等核心流程的顺利</li>
</ol>
<p>另外我们最好能做到事前防御，在系统出问题前把它扼杀在摇篮里，所以我们需要做单元测试，做全链路压测等来发现问题，还需要针对 CPU，线程数等做好<strong>监控</strong>，当其达到我们设定的域值时就触发告警以让我们及时发现修复问题（我司之前就碰到过一个类似的<a href="https://mp.weixin.qq.com/s?__biz=MzI5MTU1MzM3MQ==&mid=2247483844&idx=1&sn=549aabbf5ba5e5f03a634411c630a6da&scene=21#wechat_redirect">生产事故复盘</a>大家可以看一下），此外在做好单元测试的前提下，依然有可能因为代码的潜在 bug 引起线上问题，所以我们需要在关键时间（比如双十一期间）封网（也就是不让发布代码）</p>
<p>此外我们还需要在出事后能快速定位问题，快速回滚，这就需要记录每一次的发布时间，发布人等，这里的发布不仅包括工程的发布，还包括配置中心等的发布</p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%AE%80%E8%BF%B0/14.png" alt="图片"></p>
<p><strong>画外音</strong>：上图是我司的发布记录，可以看到有代码变更，回滚等，这样如果发现有问题的话可以一键回滚</p>
<p>最后我们以一张图来总结一下高可用的常见手段</p>
<p><img src="/2022/10/25/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%96%87%E7%AB%A0-%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%AE%80%E8%BF%B0/15.png" alt="图片"></p>
]]></content>
      <categories>
        <category>架构设计</category>
      </categories>
      <tags>
        <tag>高并发</tag>
        <tag>架构设计</tag>
      </tags>
  </entry>
</search>
