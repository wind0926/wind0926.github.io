<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-fill-left.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"wind0926.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"livere","storage":true,"lazyload":false,"nav":null,"activeClass":"livere"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="1.简介在上一篇文章中，我详细分析了 MyBatis 配置文件的解析过程。由于上一篇文章的篇幅比较大，加之映射文件解析过程也比较复杂的原因。所以我将映射文件解析过程的分析内容从上一篇文章中抽取出来，独立成文，于是就有了本篇文章。在本篇文章中，我将分析映射文件中出现的一些及节点，比如 ，，, &lt;select | insert | update | delete&gt; 等。除了分析常规的 XM">
<meta property="og:type" content="article">
<meta property="og:title" content="MyBatis源码分析-映射文件解析过程">
<meta property="og:url" content="https://wind0926.github.io/2022/10/25/MyBatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/index.html">
<meta property="og:site_name" content="默默的小磊磊技术博客">
<meta property="og:description" content="1.简介在上一篇文章中，我详细分析了 MyBatis 配置文件的解析过程。由于上一篇文章的篇幅比较大，加之映射文件解析过程也比较复杂的原因。所以我将映射文件解析过程的分析内容从上一篇文章中抽取出来，独立成文，于是就有了本篇文章。在本篇文章中，我将分析映射文件中出现的一些及节点，比如 ，，, &lt;select | insert | update | delete&gt; 等。除了分析常规的 XM">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15326221002503.jpg">
<meta property="og:image" content="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15326238856556.jpg">
<meta property="og:image" content="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15328770996894.jpg">
<meta property="og:image" content="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15328770012708.jpg">
<meta property="og:image" content="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15328288854753.jpg">
<meta property="og:image" content="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15328318597125.jpg">
<meta property="article:published_time" content="2022-10-25T07:38:41.000Z">
<meta property="article:modified_time" content="2022-10-25T07:41:50.747Z">
<meta property="article:author" content="磐石">
<meta property="article:tag" content="Mybatis">
<meta property="article:tag" content="ORM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15326221002503.jpg">


<link rel="canonical" href="https://wind0926.github.io/2022/10/25/MyBatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://wind0926.github.io/2022/10/25/MyBatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/","path":"2022/10/25/MyBatis源码分析-映射文件解析过程/","title":"MyBatis源码分析-映射文件解析过程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>MyBatis源码分析-映射文件解析过程 | 默默的小磊磊技术博客</title>
  




<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><style>
#needsharebutton-postbottom {
  cursor: pointer;
  height: 26px;
  margin-top: 10px;
  position: relative;
}
#needsharebutton-postbottom .btn {
  border: 1px solid $btn-default-border-color;
  border-radius: 3px;
  display: initial;
  padding: 1px 4px;
}
</style>
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">默默的小磊磊技术博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">1.简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="nav-number">2.</span> <span class="nav-text">2.映射文件解析过程分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E8%A7%A3%E6%9E%90%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 解析映射文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-%E8%A7%A3%E6%9E%90-%E8%8A%82%E7%82%B9"><span class="nav-number">2.1.1.</span> <span class="nav-text">2.1.1 解析  节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-%E8%A7%A3%E6%9E%90-%E8%8A%82%E7%82%B9"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.1.2 解析  节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-%E8%A7%A3%E6%9E%90-%E8%8A%82%E7%82%B9"><span class="nav-number">2.1.3.</span> <span class="nav-text">2.1.3 解析  节点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-3-1-%E8%A7%A3%E6%9E%90-%E5%92%8C-%E8%8A%82%E7%82%B9"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">2.1.3.1 解析  和  节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-3-2-%E8%A7%A3%E6%9E%90-%E8%8A%82%E7%82%B9"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">2.1.3.2 解析  节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-3-3-ResultMap-%E5%AF%B9%E8%B1%A1%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="nav-number">2.1.3.3.</span> <span class="nav-text">2.1.3.3 ResultMap 对象构建过程分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-4-%E8%A7%A3%E6%9E%90-%E8%8A%82%E7%82%B9"><span class="nav-number">2.1.4.</span> <span class="nav-text">2.1.4 解析  节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-5-%E8%A7%A3%E6%9E%90-SQL-%E8%AF%AD%E5%8F%A5%E8%8A%82%E7%82%B9"><span class="nav-number">2.1.5.</span> <span class="nav-text">2.1.5 解析 SQL 语句节点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-5-1-%E8%A7%A3%E6%9E%90-%E8%8A%82%E7%82%B9"><span class="nav-number">2.1.5.1.</span> <span class="nav-text">2.1.5.1 解析  节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-5-2-%E8%A7%A3%E6%9E%90-%E8%8A%82%E7%82%B9"><span class="nav-number">2.1.5.2.</span> <span class="nav-text">2.1.5.2 解析  节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-5-3-%E8%A7%A3%E6%9E%90-SQL-%E8%AF%AD%E5%8F%A5"><span class="nav-number">2.1.5.3.</span> <span class="nav-text">2.1.5.3 解析 SQL 语句</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-5-4-%E6%9E%84%E5%BB%BA-MappedStatement"><span class="nav-number">2.1.5.4.</span> <span class="nav-text">2.1.5.4 构建 MappedStatement</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-6-%E5%B0%8F%E8%8A%82"><span class="nav-number">2.1.6.</span> <span class="nav-text">2.1.6 小节</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Mapper-%E6%8E%A5%E5%8F%A3%E7%BB%91%E5%AE%9A%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 Mapper 接口绑定过程分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%A4%84%E7%90%86%E6%9C%AA%E5%AE%8C%E6%88%90%E8%A7%A3%E6%9E%90%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 处理未完成解析的节点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%80%BB%E7%BB%93"><span class="nav-number">3.</span> <span class="nav-text">3.总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">4.</span> <span class="nav-text">参考</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="磐石"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">磐石</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">92</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">71</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/wind0926" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wind0926" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:984564235@qq.com" title="E-Mail → mailto:984564235@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wind0926.github.io/2022/10/25/MyBatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="磐石">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="默默的小磊磊技术博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="MyBatis源码分析-映射文件解析过程 | 默默的小磊磊技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MyBatis源码分析-映射文件解析过程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-10-25 15:38:41 / 修改时间：15:41:50" itemprop="dateCreated datePublished" datetime="2022-10-25T15:38:41+08:00">2022-10-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Mybatis/" itemprop="url" rel="index"><span itemprop="name">Mybatis</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>63k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>57 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>在上一篇文章中，我详细分析了 MyBatis 配置文件的解析过程。由于上一篇文章的篇幅比较大，加之映射文件解析过程也比较复杂的原因。所以我将映射文件解析过程的分析内容从上一篇文章中抽取出来，独立成文，于是就有了本篇文章。在本篇文章中，我将分析映射文件中出现的一些及节点，比如 <cache>，<cache-ref>，<resultMap>, &lt;select | insert | update | delete&gt; 等。除了分析常规的 XML 解析过程外，我还会向大家介绍 Mapper 接口的绑定过程等。综上所述，本篇文章内容会比较丰富，如果大家对此感兴趣，不妨花点时间读一读，会有新的收获。当然，本篇文章通篇是关于源码分析的，所以阅读本文需要大家对 MyBatis 有一定的了解。如果大家对 MyBatis 还不是很了解，建议阅读一下 MyBatis 的<a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/index.html">官方文档</a>。</resultMap></cache-ref></cache></p>
<p>其他的就不多说了，下面开始我们的 MyBatis 源码之旅。</p>
<h2 id="2-映射文件解析过程分析"><a href="#2-映射文件解析过程分析" class="headerlink" title="2.映射文件解析过程分析"></a>2.映射文件解析过程分析</h2><p>我在前面说过，映射文件的解析过程是 MyBatis 配置文件解析过程的一部分。MyBatis 的配置文件由 XMLConfigBuilder 的 parseConfiguration 进行解析，该方法依次解析了 <properties>、<settings>、<typeAliases> 等节点。至于 <mappers> 节点，parseConfiguration 则是在方法的结尾对其进行了解析。该部分的解析逻辑封装在 mapperElement 方法中，下面来看一下。</mappers></typeAliases></settings></properties></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// -☆- XMLConfigBuilder</span><br><span class="line">private void mapperElement(XNode parent) throws Exception &#123;</span><br><span class="line">    if (parent != null) &#123;</span><br><span class="line">        for (XNode child : parent.getChildren()) &#123;</span><br><span class="line">            if (&quot;package&quot;.equals(child.getName())) &#123;</span><br><span class="line">                // 获取 &lt;package&gt; 节点中的 name 属性</span><br><span class="line">                String mapperPackage = child.getStringAttribute(&quot;name&quot;);</span><br><span class="line">                // 从指定包中查找 mapper 接口，并根据 mapper 接口解析映射配置</span><br><span class="line">                configuration.addMappers(mapperPackage);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 获取 resource/url/class 等属性</span><br><span class="line">                String resource = child.getStringAttribute(&quot;resource&quot;);</span><br><span class="line">                String url = child.getStringAttribute(&quot;url&quot;);</span><br><span class="line">                String mapperClass = child.getStringAttribute(&quot;class&quot;);</span><br><span class="line"></span><br><span class="line">                // resource 不为空，且其他两者为空，则从指定路径中加载配置</span><br><span class="line">                if (resource != null &amp;&amp; url == null &amp;&amp; mapperClass == null) &#123;</span><br><span class="line">                    ErrorContext.instance().resource(resource);</span><br><span class="line">                    InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">                    XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">                    // 解析映射文件</span><br><span class="line">                    mapperParser.parse();</span><br><span class="line"></span><br><span class="line">                // url 不为空，且其他两者为空，则通过 url 加载配置</span><br><span class="line">                &#125; else if (resource == null &amp;&amp; url != null &amp;&amp; mapperClass == null) &#123;</span><br><span class="line">                    ErrorContext.instance().resource(url);</span><br><span class="line">                    InputStream inputStream = Resources.getUrlAsStream(url);</span><br><span class="line">                    XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">                    // 解析映射文件</span><br><span class="line">                    mapperParser.parse();</span><br><span class="line"></span><br><span class="line">                // mapperClass 不为空，且其他两者为空，则通过 mapperClass 解析映射配置</span><br><span class="line">                &#125; else if (resource == null &amp;&amp; url == null &amp;&amp; mapperClass != null) &#123;</span><br><span class="line">                    Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">                    configuration.addMapper(mapperInterface);</span><br><span class="line"></span><br><span class="line">                // 以上条件不满足，则抛出异常</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    throw new BuilderException(&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码比较简单，主要逻辑是遍历 mappers 的子节点，并根据节点属性值判断通过什么方式加载映射文件或映射信息。这里，我把配置在注解中的内容称为<code>映射信息</code>，以 XML 为载体的配置称为<code>映射文件</code>。在 MyBatis 中，共有四种加载映射文件或信息的方式。第一种是从文件系统中加载映射文件；第二种是通过 URL 的方式加载和解析映射文件；第三种是通过 mapper 接口加载映射信息，映射信息可以配置在注解中，也可以配置在映射文件中。最后一种是通过包扫描的方式获取到某个包下的所有类，并使用第三种方式为每个类解析映射信息。</p>
<p>以上简单介绍了 MyBatis 加载映射文件或信息的几种方式。需要注意的是，在 MyBatis 中，通过注解配置映射信息的方式是有一定局限性的，这一点 MyBatis 官方文档中描述的比较清楚。这里引用一下：</p>
<blockquote>
<p>因为最初设计时，MyBatis 是一个 XML 驱动的框架。配置信息是基于 XML 的，而且映射语句也是定义在 XML 中的。而到了 MyBatis 3，就有新选择了。MyBatis 3 构建在全面且强大的基于 Java 语言的配置 API 之上。这个配置 API 是基于 XML 的 MyBatis 配置的基础，也是新的基于注解配置的基础。注解提供了一种简单的方式来实现<strong>简单映射语句</strong>，而不会引入大量的开销。</p>
</blockquote>
<blockquote>
<p><strong>注意：</strong> 不幸的是，<strong>Java 注解的的表达力和灵活性十分有限</strong>。尽管很多时间都花在调查、设计和试验上，<strong>最强大的 MyBatis 映射并不能用注解来构建</strong>——并不是在开玩笑，的确是这样。</p>
</blockquote>
<p>如上所示，重点语句我用黑体标注了出来。限于 Java 注解的表达力和灵活性，通过注解的方式并不能完全发挥 MyBatis 的能力。所以，对于一些较为复杂的配置信息，我们还是应该通过 XML 的方式进行配置。正因此，在接下的章节中，我会重点分析基于 XML 的映射文件的解析过程。如果能弄懂此种配置方式的解析过程，那么基于注解的解析过程也不在话下。</p>
<p>下面开始分析映射文件的解析过程，在展开分析之前，先来看一下映射文件解析入口。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// -☆- XMLMapperBuilder</span><br><span class="line">public void parse() &#123;</span><br><span class="line">    // 检测映射文件是否已经被解析过</span><br><span class="line">    if (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">        // 解析 mapper 节点</span><br><span class="line">        configurationElement(parser.evalNode(&quot;/mapper&quot;));</span><br><span class="line">        // 添加资源路径到“已解析资源集合”中</span><br><span class="line">        configuration.addLoadedResource(resource);</span><br><span class="line">        // 通过命名空间绑定 Mapper 接口</span><br><span class="line">        bindMapperForNamespace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 处理未完成解析的节点</span><br><span class="line">    parsePendingResultMaps();</span><br><span class="line">    parsePendingCacheRefs();</span><br><span class="line">    parsePendingStatements();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，映射文件解析入口逻辑包含三个核心操作，分别如下：</p>
<ol>
<li>解析 mapper 节点</li>
<li>通过命名空间绑定 Mapper 接口</li>
<li>处理未完成解析的节点</li>
</ol>
<p>这三个操作对应的逻辑，我将会在随后的章节中依次进行分析。下面，先来分析第一个操作对应的逻辑。</p>
<h3 id="2-1-解析映射文件"><a href="#2-1-解析映射文件" class="headerlink" title="2.1 解析映射文件"></a>2.1 解析映射文件</h3><p>在 MyBatis 映射文件中，可以配置多种节点。比如 <cache>，<resultMap>，<sql> 以及 &lt;select | insert | update | delete&gt; 等。下面我们来看一个映射文件配置示例。</sql></resultMap></cache></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace=&quot;xyz.coolblog.dao.AuthorDao&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;cache/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;resultMap id=&quot;authorResult&quot; type=&quot;Author&quot;&gt;</span><br><span class="line">        &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;</span><br><span class="line">        &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;</span><br><span class="line">        &lt;!-- ... --&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    &lt;sql id=&quot;table&quot;&gt;</span><br><span class="line">        author</span><br><span class="line">    &lt;/sql&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=&quot;findOne&quot; resultMap=&quot;authorResult&quot;&gt;</span><br><span class="line">        SELECT</span><br><span class="line">            id, name, age, sex, email</span><br><span class="line">        FROM</span><br><span class="line">            &lt;include refid=&quot;table&quot;/&gt;</span><br><span class="line">        WHERE</span><br><span class="line">            id = #&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- &lt;insert|update|delete/&gt; --&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>上面是一个比较简单的映射文件，还有一些的节点没有出现在上面。以上每种配置中的每种节点的解析逻辑都封装在了相应的方法中，这些方法由 XMLMapperBuilder 类的 configurationElement 方法统一调用。该方法的逻辑如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private void configurationElement(XNode context) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 获取 mapper 命名空间</span><br><span class="line">        String namespace = context.getStringAttribute(&quot;namespace&quot;);</span><br><span class="line">        if (namespace == null || namespace.equals(&quot;&quot;)) &#123;</span><br><span class="line">            throw new BuilderException(&quot;Mapper&#x27;s namespace cannot be empty&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 设置命名空间到 builderAssistant 中</span><br><span class="line">        builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line"></span><br><span class="line">        // 解析 &lt;cache-ref&gt; 节点</span><br><span class="line">        cacheRefElement(context.evalNode(&quot;cache-ref&quot;));</span><br><span class="line"></span><br><span class="line">        // 解析 &lt;cache&gt; 节点</span><br><span class="line">        cacheElement(context.evalNode(&quot;cache&quot;));</span><br><span class="line"></span><br><span class="line">        // 已废弃配置，这里不做分析</span><br><span class="line">        parameterMapElement(context.evalNodes(&quot;/mapper/parameterMap&quot;));</span><br><span class="line"></span><br><span class="line">        // 解析 &lt;resultMap&gt; 节点</span><br><span class="line">        resultMapElements(context.evalNodes(&quot;/mapper/resultMap&quot;));</span><br><span class="line"></span><br><span class="line">        // 解析 &lt;sql&gt; 节点</span><br><span class="line">        sqlElement(context.evalNodes(&quot;/mapper/sql&quot;));</span><br><span class="line"></span><br><span class="line">        // 解析 &lt;select&gt;、...、&lt;delete&gt; 等节点</span><br><span class="line">        buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new BuilderException(&quot;Error parsing Mapper XML. The XML location is &#x27;&quot; + resource + &quot;&#x27;. Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码的执行流程清晰明了。在阅读源码时，我们可以按部就班的分析每个方法调用即可。不过在写文章进行叙述时，需要做一些调整。下面我将会先分析 <cache> 节点的解析过程，然后再分析 <cache-ref> 节点，之后会按照顺序分析其他节点的解析过程。接下来，我们来看看 <cache> 节点的解析过程。</cache></cache-ref></cache></p>
<h4 id="2-1-1-解析-节点"><a href="#2-1-1-解析-节点" class="headerlink" title="2.1.1 解析  节点"></a>2.1.1 解析 <cache> 节点</cache></h4><p>MyBatis 提供了一、二级缓存，其中一级缓存是 SqlSession 级别的，默认为开启状态。二级缓存配置在映射文件中，使用者需要显示配置才能开启。如果没有特殊要求，二级缓存的配置很容易。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;cache/&gt;</span><br></pre></td></tr></table></figure>

<p>如果我们想修改缓存的一些属性，可以像下面这样配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;cache</span><br><span class="line">  eviction=&quot;FIFO&quot;</span><br><span class="line">  flushInterval=&quot;60000&quot;</span><br><span class="line">  size=&quot;512&quot;</span><br><span class="line">  readOnly=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>根据上面的配置创建出的缓存有以下特点：</p>
<ol>
<li>按先进先出的策略淘汰缓存项</li>
<li>缓存的容量为 512 个对象引用</li>
<li>缓存每隔60秒刷新一次</li>
<li>缓存返回的对象是写安全的，即在外部修改对象不会影响到缓存内部存储对象</li>
</ol>
<p>除了上面两种配置方式，我们还可以给 MyBatis 配置第三方缓存或者自己实现的缓存等。比如，我们将 Ehcache 缓存整合到 MyBatis 中，可以这样配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;timeToIdleSeconds&quot; value=&quot;3600&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;timeToLiveSeconds&quot; value=&quot;3600&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;maxEntriesLocalHeap&quot; value=&quot;1000&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;maxEntriesLocalDisk&quot; value=&quot;10000000&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;memoryStoreEvictionPolicy&quot; value=&quot;LRU&quot;/&gt;</span><br><span class="line">&lt;/cache&gt;</span><br></pre></td></tr></table></figure>

<p>以上简单介绍了几种缓存配置方式，关于 MyBatis 缓存更多的知识，后面我会独立成文进行分析，这里就不深入说明了。下面我们来分析一下缓存配置的解析逻辑，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void cacheElement(XNode context) throws Exception &#123;</span><br><span class="line">    if (context != null) &#123;</span><br><span class="line">        // 获取各种属性</span><br><span class="line">        String type = context.getStringAttribute(&quot;type&quot;, &quot;PERPETUAL&quot;);</span><br><span class="line">        Class&lt;? extends Cache&gt; typeClass = typeAliasRegistry.resolveAlias(type);</span><br><span class="line">        String eviction = context.getStringAttribute(&quot;eviction&quot;, &quot;LRU&quot;);</span><br><span class="line">        Class&lt;? extends Cache&gt; evictionClass = typeAliasRegistry.resolveAlias(eviction);</span><br><span class="line">        Long flushInterval = context.getLongAttribute(&quot;flushInterval&quot;);</span><br><span class="line">        Integer size = context.getIntAttribute(&quot;size&quot;);</span><br><span class="line">        boolean readWrite = !context.getBooleanAttribute(&quot;readOnly&quot;, false);</span><br><span class="line">        boolean blocking = context.getBooleanAttribute(&quot;blocking&quot;, false);</span><br><span class="line"></span><br><span class="line">        // 获取子节点配置</span><br><span class="line">        Properties props = context.getChildrenAsProperties();</span><br><span class="line"></span><br><span class="line">        // 构建缓存对象</span><br><span class="line">        builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, blocking, props);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，大段代码用来解析 <cache> 节点的属性和子节点，这些代码没什么好说的。缓存的构建逻辑封装在 BuilderAssistant 类的 useNewCache 方法中，下面我们来看一下该方法的逻辑。</cache></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// -☆- MapperBuilderAssistant</span><br><span class="line">public Cache useNewCache(Class&lt;? extends Cache&gt; typeClass,</span><br><span class="line">    Class&lt;? extends Cache&gt; evictionClass,Long flushInterval,</span><br><span class="line">    Integer size,boolean readWrite,boolean blocking,Properties props) &#123;</span><br><span class="line"></span><br><span class="line">    // 使用建造模式构建缓存实例</span><br><span class="line">    Cache cache = new CacheBuilder(currentNamespace)</span><br><span class="line">        .implementation(valueOrDefault(typeClass, PerpetualCache.class))</span><br><span class="line">        .addDecorator(valueOrDefault(evictionClass, LruCache.class))</span><br><span class="line">        .clearInterval(flushInterval)</span><br><span class="line">        .size(size)</span><br><span class="line">        .readWrite(readWrite)</span><br><span class="line">        .blocking(blocking)</span><br><span class="line">        .properties(props)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    // 添加缓存到 Configuration 对象中</span><br><span class="line">    configuration.addCache(cache);</span><br><span class="line"></span><br><span class="line">    // 设置 currentCache 遍历，即当前使用的缓存</span><br><span class="line">    currentCache = cache;</span><br><span class="line">    return cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面使用了建造模式构建 Cache 实例，Cache 实例的构建过程略为复杂，我们跟下去看看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// -☆- CacheBuilder</span><br><span class="line">public Cache build() &#123;</span><br><span class="line">    // 设置默认的缓存类型（PerpetualCache）和缓存装饰器（LruCache）</span><br><span class="line">    setDefaultImplementations();</span><br><span class="line"></span><br><span class="line">    // 通过反射创建缓存</span><br><span class="line">    Cache cache = newBaseCacheInstance(implementation, id);</span><br><span class="line">    setCacheProperties(cache);</span><br><span class="line">    // 仅对内置缓存 PerpetualCache 应用装饰器</span><br><span class="line">    if (PerpetualCache.class.equals(cache.getClass())) &#123;</span><br><span class="line">        // 遍历装饰器集合，应用装饰器</span><br><span class="line">        for (Class&lt;? extends Cache&gt; decorator : decorators) &#123;</span><br><span class="line">        	// 通过反射创建装饰器实例</span><br><span class="line">            cache = newCacheDecoratorInstance(decorator, cache);</span><br><span class="line">            // 设置属性值到缓存实例中</span><br><span class="line">            setCacheProperties(cache);</span><br><span class="line">        &#125;</span><br><span class="line">        // 应用标准的装饰器，比如 LoggingCache、SynchronizedCache</span><br><span class="line">        cache = setStandardDecorators(cache);</span><br><span class="line">    &#125; else if (!LoggingCache.class.isAssignableFrom(cache.getClass())) &#123;</span><br><span class="line">        // 应用具有日志功能的缓存装饰器</span><br><span class="line">        cache = new LoggingCache(cache);</span><br><span class="line">    &#125;</span><br><span class="line">    return cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的构建过程流程较为复杂，这里总结一下。如下：</p>
<ol>
<li>设置默认的缓存类型及装饰器</li>
<li>应用装饰器到 PerpetualCache 对象上<ul>
<li>遍历装饰器类型集合，并通过反射创建装饰器实例</li>
<li>将属性设置到实例中</li>
</ul>
</li>
<li>应用一些标准的装饰器</li>
<li>对非 LoggingCache 类型的缓存应用 LoggingCache 装饰器</li>
</ol>
<p>在以上4个步骤中，最后一步的逻辑很简单，无需多说。下面按顺序分析前3个步骤对应的逻辑，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void setDefaultImplementations() &#123;</span><br><span class="line">    if (implementation == null) &#123;</span><br><span class="line">        // 设置默认的缓存实现类</span><br><span class="line">        implementation = PerpetualCache.class;</span><br><span class="line">        if (decorators.isEmpty()) &#123;</span><br><span class="line">            // 添加 LruCache 装饰器</span><br><span class="line">            decorators.add(LruCache.class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上逻辑比较简单，主要做的事情是在 implementation 为空的情况下，为它设置一个默认值。如果大家仔细看前面的方法，会发现 MyBatis 做了不少判空的操作。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 判空操作1，若用户未设置 cache 节点的 type 和 eviction 属性，这里设置默认值 PERPETUAL</span><br><span class="line">String type = context.getStringAttribute(&quot;type&quot;, &quot;PERPETUAL&quot;);</span><br><span class="line">String eviction = context.getStringAttribute(&quot;eviction&quot;, &quot;LRU&quot;);</span><br><span class="line"></span><br><span class="line">// 判空操作2，若 typeClass 或 evictionClass 为空，valueOrDefault 方法会为它们设置默认值</span><br><span class="line">Cache cache = new CacheBuilder(currentNamespace)</span><br><span class="line">            .implementation(valueOrDefault(typeClass, PerpetualCache.class))</span><br><span class="line">            .addDecorator(valueOrDefault(evictionClass, LruCache.class))</span><br><span class="line">            // 省略部分代码</span><br><span class="line">            .build();</span><br></pre></td></tr></table></figure>

<p>既然前面已经做了两次判空操作，implementation 不可能为空，那么 setDefaultImplementations 方法似乎没有存在的必要了。其实不然，如果有人不按套路写代码。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cache cache = new CacheBuilder(currentNamespace)</span><br><span class="line">            // 忘记设置 implementation</span><br><span class="line">            .build();</span><br></pre></td></tr></table></figure>

<p>这里忘记设置 implementation，或人为的将 implementation 设为空。如果不对 implementation 进行判空，会导致 build 方法在构建实例时触发空指针异常，对于框架来说，出现空指针异常是很尴尬的，这是一个低级错误。这里以及之前做了这么多判空，就是为了避免出现空指针的情况，以提高框架的健壮性。好了，关于 setDefaultImplementations 方法的分析先到这，继续往下分析。</p>
<p>我们在使用 MyBatis 内置缓存时，一般不用为它们配置自定义属性。但使用第三方缓存时，则应按需进行配置。比如前面演示 MyBatis 整合 Ehcache 时，就为 Ehcache 配置了一些必要的属性。下面我们来看一下这部分配置是如何设置到缓存实例中的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">private void setCacheProperties(Cache cache) &#123;</span><br><span class="line">    if (properties != null) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * 为缓存实例生成一个“元信息”实例，forObject 方法调用层次比较深，但最终调用了 </span><br><span class="line">         * MetaClass 的 forClass 方法。关于 MetaClass 的源码，我在上一篇文章中已经</span><br><span class="line">         * 详细分析过了，这里不再赘述。</span><br><span class="line">         */</span><br><span class="line">        MetaObject metaCache = SystemMetaObject.forObject(cache);</span><br><span class="line">        for (Map.Entry&lt;Object, Object&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">            String name = (String) entry.getKey();</span><br><span class="line">            String value = (String) entry.getValue();</span><br><span class="line">            if (metaCache.hasSetter(name)) &#123;</span><br><span class="line">                // 获取 setter 方法的参数类型</span><br><span class="line">                Class&lt;?&gt; type = metaCache.getSetterType(name);</span><br><span class="line">                /*</span><br><span class="line">                 * 根据参数类型对属性值进行转换，并将转换后的值</span><br><span class="line">                 * 通过 setter 方法设置到 Cache 实例中</span><br><span class="line">                 */</span><br><span class="line">                if (String.class == type) &#123;</span><br><span class="line">                    metaCache.setValue(name, value);</span><br><span class="line">                &#125; else if (int.class == type || Integer.class == type) &#123;</span><br><span class="line">                	/*</span><br><span class="line">                	 * 此处及以下分支包含两个步骤：</span><br><span class="line">                	 *   1.类型转换 → Integer.valueOf(value)</span><br><span class="line">                	 *   2.将转换后的值设置到缓存实例中 → metaCache.setValue(name, value)</span><br><span class="line">                	 */ </span><br><span class="line">                    metaCache.setValue(name, Integer.valueOf(value));</span><br><span class="line">                &#125; else if (long.class == type || Long.class == type) &#123;</span><br><span class="line">                    metaCache.setValue(name, Long.valueOf(value));</span><br><span class="line">                &#125; </span><br><span class="line">                else if (short.class == type || Short.class == type) &#123;...&#125; </span><br><span class="line">                else if (byte.class == type || Byte.class == type) &#123;...&#125; </span><br><span class="line">                else if (float.class == type || Float.class == type) &#123;...&#125; </span><br><span class="line">                else if (boolean.class == type || Boolean.class == type) &#123;...&#125; </span><br><span class="line">                else if (double.class == type || Double.class == type) &#123;...&#125; </span><br><span class="line">                else &#123;</span><br><span class="line">                    throw new CacheException(&quot;Unsupported property type for cache: &#x27;&quot; + name + &quot;&#x27; of type &quot; + type);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果缓存类实现了 InitializingObject 接口，则调用 initialize 方法执行初始化逻辑</span><br><span class="line">    if (InitializingObject.class.isAssignableFrom(cache.getClass())) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ((InitializingObject) cache).initialize();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new CacheException(&quot;Failed cache initialization for &#x27;&quot; +</span><br><span class="line">                cache.getId() + &quot;&#x27; on &#x27;&quot; + cache.getClass().getName() + &quot;&#x27;&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的大段代码用于对属性值进行类型转换，和设置转换后的值到 Cache 实例中。关于上面代码中出现的 MetaObject，大家可以自己尝试分析一下。最后，我们来看一下设置标准装饰器的过程。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private Cache setStandardDecorators(Cache cache) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 创建“元信息”对象</span><br><span class="line">        MetaObject metaCache = SystemMetaObject.forObject(cache);</span><br><span class="line">        if (size != null &amp;&amp; metaCache.hasSetter(&quot;size&quot;)) &#123;</span><br><span class="line">            // 设置 size 属性，</span><br><span class="line">            metaCache.setValue(&quot;size&quot;, size);</span><br><span class="line">        &#125;</span><br><span class="line">        if (clearInterval != null) &#123;</span><br><span class="line">            // clearInterval 不为空，应用 ScheduledCache 装饰器</span><br><span class="line">            cache = new ScheduledCache(cache);</span><br><span class="line">            ((ScheduledCache) cache).setClearInterval(clearInterval);</span><br><span class="line">        &#125;</span><br><span class="line">        if (readWrite) &#123;</span><br><span class="line">            // readWrite 为 true，应用 SerializedCache 装饰器</span><br><span class="line">            cache = new SerializedCache(cache);</span><br><span class="line">        &#125;</span><br><span class="line">        /*</span><br><span class="line">         * 应用 LoggingCache，SynchronizedCache 装饰器，</span><br><span class="line">         * 使原缓存具备打印日志和线程同步的能力</span><br><span class="line">         */</span><br><span class="line">        cache = new LoggingCache(cache);</span><br><span class="line">        cache = new SynchronizedCache(cache);</span><br><span class="line">        if (blocking) &#123;</span><br><span class="line">            // blocking 为 true，应用 BlockingCache 装饰器</span><br><span class="line">            cache = new BlockingCache(cache);</span><br><span class="line">        &#125;</span><br><span class="line">        return cache;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new CacheException(&quot;Error building standard cache decorators.  Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码用于为缓存应用一些基本的装饰器，除了 LoggingCache 和 SynchronizedCache 这两个是必要的装饰器，其他的装饰器应用与否，取决于用户的配置。</p>
<p>到此，关于缓存的解析过程就分析完了。这一块的内容比较多，不过好在代码逻辑不是很复杂，耐心看还是可以弄懂的。其他的就不多说了，进入下一节的分析。</p>
<h4 id="2-1-2-解析-节点"><a href="#2-1-2-解析-节点" class="headerlink" title="2.1.2 解析  节点"></a>2.1.2 解析 <cache-ref> 节点</cache-ref></h4><p>在 MyBatis 中，二级缓存是可以共用的。这需要使用 <cache-ref> 节点配置参照缓存，比如像下面这样。</cache-ref></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Mapper1.xml --&gt;</span><br><span class="line">&lt;mapper namespace=&quot;xyz.coolblog.dao.Mapper1&quot;&gt;</span><br><span class="line">    &lt;!-- Mapper1 与 Mapper2 共用一个二级缓存 --&gt;</span><br><span class="line">    &lt;cache-ref namespace=&quot;xyz.coolblog.dao.Mapper2&quot;/&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Mapper2.xml --&gt;</span><br><span class="line">&lt;mapper namespace=&quot;xyz.coolblog.dao.Mapper2&quot;&gt;</span><br><span class="line">    &lt;cache/&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>接下来，我们对照上面的配置分析 cache-ref 的解析过程。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void cacheRefElement(XNode context) &#123;</span><br><span class="line">    if (context != null) &#123;</span><br><span class="line">        configuration.addCacheRef(builderAssistant.getCurrentNamespace(), context.getStringAttribute(&quot;namespace&quot;));</span><br><span class="line">        // 创建 CacheRefResolver 实例</span><br><span class="line">        CacheRefResolver cacheRefResolver = new CacheRefResolver(builderAssistant, context.getStringAttribute(&quot;namespace&quot;));</span><br><span class="line">        try &#123;</span><br><span class="line">            // 解析参照缓存</span><br><span class="line">            cacheRefResolver.resolveCacheRef();</span><br><span class="line">        &#125; catch (IncompleteElementException e) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * 这里对 IncompleteElementException 异常进行捕捉，并将 cacheRefResolver </span><br><span class="line">             * 存入到 Configuration 的 incompleteCacheRefs 集合中</span><br><span class="line">             */</span><br><span class="line">            configuration.addIncompleteCacheRef(cacheRefResolver);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，<cache-ref> 节点的解析逻辑封装在了 CacheRefResolver 的 resolveCacheRef 方法中。下面，我们一起看一下这个方法的逻辑。</cache-ref></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// -☆- CacheRefResolver</span><br><span class="line">public Cache resolveCacheRef() &#123;</span><br><span class="line">    // 调用 builderAssistant 的 useNewCache(namespace) 方法</span><br><span class="line">    return assistant.useCacheRef(cacheRefNamespace);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// -☆- MapperBuilderAssistant</span><br><span class="line">public Cache useCacheRef(String namespace) &#123;</span><br><span class="line">    if (namespace == null) &#123;</span><br><span class="line">        throw new BuilderException(&quot;cache-ref element requires a namespace attribute.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        unresolvedCacheRef = true;</span><br><span class="line">        // 根据命名空间从全局配置对象（Configuration）中查找相应的缓存实例</span><br><span class="line">        Cache cache = configuration.getCache(namespace);</span><br><span class="line">        </span><br><span class="line">        /*</span><br><span class="line">         * 若未查找到缓存实例，此处抛出异常。这里存在两种情况导致未查找到 cache 实例，</span><br><span class="line">         * 分别如下：</span><br><span class="line">         *     1.使用者在 &lt;cache-ref&gt; 中配置了一个不存在的命名空间，</span><br><span class="line">         *       导致无法找到 cache 实例</span><br><span class="line">         *     2.使用者所引用的缓存实例还未创建</span><br><span class="line">         */</span><br><span class="line">        if (cache == null) &#123;</span><br><span class="line">            throw new IncompleteElementException(&quot;No cache for namespace &#x27;&quot; + namespace + &quot;&#x27; could be found.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 设置 cache 为当前使用缓存</span><br><span class="line">        currentCache = cache;</span><br><span class="line">        unresolvedCacheRef = false;</span><br><span class="line">        return cache;</span><br><span class="line">    &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">        throw new IncompleteElementException(&quot;No cache for namespace &#x27;&quot; + namespace + &quot;&#x27; could be found.&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是 cache-ref 的解析过程，逻辑并不复杂。不过这里要注意 cache 为空的情况，我在代码中已经注释了可能导致 cache 为空的两种情况。第一种情况比较好理解，第二种情况稍微复杂点，但是也不难理解。我会在 2.3 节进行解释说明，这里先不说。</p>
<p>到此，关于 <cache-ref> 节点的解析过程就分析完了。本节的内容不是很难理解，就不多说了。</cache-ref></p>
<h4 id="2-1-3-解析-节点"><a href="#2-1-3-解析-节点" class="headerlink" title="2.1.3 解析  节点"></a>2.1.3 解析 <resultMap> 节点</resultMap></h4><p>resultMap 是 MyBatis 框架中常用的特性，主要用于映射结果。resultMap 是 MyBatis 提供的一个强力武器，这一点官方文档中有所描述，这里引用一下。</p>
<blockquote>
<p>resultMap 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC ResultSets 数据提取代码中解放出来, 并在一些情形下允许你做一些 JDBC 不支持的事情。 实际上，在对复杂语句进行联合映射的时候，它很可能可以代替数千行的同等功能的代码。 ResultMap 的设计思想是，简单的语句不需要明确的结果映射，而复杂一点的语句只需要描述它们的关系就行了。</p>
</blockquote>
<p>如上描述，resultMap 元素是 MyBatis 中最重要最强大的元素，它可以把大家从 JDBC ResultSets 数据提取的工作中解放出来。通过 resultMap 和自动映射，可以让 MyBatis 帮助我们完成 ResultSet → Object 的映射，这将会大大提高了开发效率。关于 resultMap 的用法，我相信大家都比较熟悉了，所以这里我就不介绍了。当然，如果大家不熟悉也没关系，MyBatis 的<a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html">官方文档</a>上对此进行了详细的介绍，大家不妨去看看。</p>
<p>好了，其他的就不多说了，下面开始分析 resultMap 配置的解析过程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">// -☆- XMLMapperBuilder</span><br><span class="line">private void resultMapElements(List&lt;XNode&gt; list) throws Exception &#123;</span><br><span class="line">    // 遍历 &lt;resultMap&gt; 节点列表</span><br><span class="line">    for (XNode resultMapNode : list) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 解析 resultMap 节点</span><br><span class="line">            resultMapElement(resultMapNode);</span><br><span class="line">        &#125; catch (IncompleteElementException e) &#123;</span><br><span class="line">            // ignore, it will be retried</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private ResultMap resultMapElement(XNode resultMapNode) throws Exception &#123;</span><br><span class="line">    // 调用重载方法</span><br><span class="line">    return resultMapElement(resultMapNode, Collections.&lt;ResultMapping&gt;emptyList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private ResultMap resultMapElement(XNode resultMapNode, List&lt;ResultMapping&gt; additionalResultMappings) throws Exception &#123;</span><br><span class="line">    ErrorContext.instance().activity(&quot;processing &quot; + resultMapNode.getValueBasedIdentifier());</span><br><span class="line"></span><br><span class="line">    // 获取 id 和 type 属性</span><br><span class="line">    String id = resultMapNode.getStringAttribute(&quot;id&quot;, resultMapNode.getValueBasedIdentifier());</span><br><span class="line">    String type = resultMapNode.getStringAttribute(&quot;type&quot;,</span><br><span class="line">        resultMapNode.getStringAttribute(&quot;ofType&quot;,</span><br><span class="line">            resultMapNode.getStringAttribute(&quot;resultType&quot;,</span><br><span class="line">                resultMapNode.getStringAttribute(&quot;javaType&quot;))));</span><br><span class="line">    // 获取 extends 和 autoMapping</span><br><span class="line">    String extend = resultMapNode.getStringAttribute(&quot;extends&quot;);</span><br><span class="line">    Boolean autoMapping = resultMapNode.getBooleanAttribute(&quot;autoMapping&quot;);</span><br><span class="line"></span><br><span class="line">    // 解析 type 属性对应的类型</span><br><span class="line">    Class&lt;?&gt; typeClass = resolveClass(type);</span><br><span class="line">    Discriminator discriminator = null;</span><br><span class="line">    List&lt;ResultMapping&gt; resultMappings = new ArrayList&lt;ResultMapping&gt;();</span><br><span class="line">    resultMappings.addAll(additionalResultMappings);</span><br><span class="line"></span><br><span class="line">    // 获取并遍历 &lt;resultMap&gt; 的子节点列表</span><br><span class="line">    List&lt;XNode&gt; resultChildren = resultMapNode.getChildren();</span><br><span class="line">    for (XNode resultChild : resultChildren) &#123;</span><br><span class="line">        if (&quot;constructor&quot;.equals(resultChild.getName())) &#123;</span><br><span class="line">            // 解析 constructor 节点，并生成相应的 ResultMapping</span><br><span class="line">            processConstructorElement(resultChild, typeClass, resultMappings);</span><br><span class="line">        &#125; else if (&quot;discriminator&quot;.equals(resultChild.getName())) &#123;</span><br><span class="line">            // 解析 discriminator 节点</span><br><span class="line">            discriminator = processDiscriminatorElement(resultChild, typeClass, resultMappings);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">            List&lt;ResultFlag&gt; flags = new ArrayList&lt;ResultFlag&gt;();</span><br><span class="line">            if (&quot;id&quot;.equals(resultChild.getName())) &#123;</span><br><span class="line">                // 添加 ID 到 flags 集合中</span><br><span class="line">                flags.add(ResultFlag.ID);</span><br><span class="line">            &#125;</span><br><span class="line">            // 解析 id 和 property 节点，并生成相应的 ResultMapping</span><br><span class="line">            resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ResultMapResolver resultMapResolver = new ResultMapResolver(builderAssistant, id, typeClass, extend,</span><br><span class="line">        discriminator, resultMappings, autoMapping);</span><br><span class="line">    try &#123;</span><br><span class="line">        // 根据前面获取到的信息构建 ResultMap 对象</span><br><span class="line">        return resultMapResolver.resolve();</span><br><span class="line">    &#125; catch (IncompleteElementException e) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * 如果发生 IncompleteElementException 异常，</span><br><span class="line">         * 这里将 resultMapResolver 添加到 incompleteResultMaps 集合中</span><br><span class="line">         */ </span><br><span class="line">        configuration.addIncompleteResultMap(resultMapResolver);</span><br><span class="line">        throw e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码比较多，看起来有点复杂，这里总结一下：</p>
<ol>
<li>获取 <resultMap> 节点的各种属性</resultMap></li>
<li>遍历 <resultMap> 的子节点，并根据子节点名称执行相应的解析逻辑</resultMap></li>
<li>构建 ResultMap 对象</li>
<li>若构建过程中发生异常，则将 resultMapResolver 添加到 incompleteResultMaps 集合中</li>
</ol>
<p>如上流程，第1步和最后一步都是一些常规操作，无需过多解释。第2步和第3步则是接下来需要重点分析的操作，这其中，鉴别器 discriminator 不是很常用的特性，我觉得大家知道它有什么用就行了，所以就不分析了。下面先来分析 <id> 和 <result> 节点的解析逻辑。</result></id></p>
<h5 id="2-1-3-1-解析-和-节点"><a href="#2-1-3-1-解析-和-节点" class="headerlink" title="2.1.3.1 解析  和  节点"></a>2.1.3.1 解析 <id> 和 <result> 节点</result></id></h5><p>在 <resultMap> 节点中，子节点 <id> 和 <result> 都是常规配置，比较常见。相信大家对此也比较熟悉了，我就不多说了。下面我们直接分析这两个节点的解析过程。如下：</result></id></resultMap></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private ResultMapping buildResultMappingFromContext(XNode context, Class&lt;?&gt; resultType, List&lt;ResultFlag&gt; flags) throws Exception &#123;</span><br><span class="line">    String property;</span><br><span class="line">    // 根据节点类型获取 name 或 property 属性</span><br><span class="line">    if (flags.contains(ResultFlag.CONSTRUCTOR)) &#123;</span><br><span class="line">        property = context.getStringAttribute(&quot;name&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        property = context.getStringAttribute(&quot;property&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取其他各种属性</span><br><span class="line">    String column = context.getStringAttribute(&quot;column&quot;);</span><br><span class="line">    String javaType = context.getStringAttribute(&quot;javaType&quot;);</span><br><span class="line">    String jdbcType = context.getStringAttribute(&quot;jdbcType&quot;);</span><br><span class="line">    String nestedSelect = context.getStringAttribute(&quot;select&quot;);</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     * 解析 resultMap 属性，该属性出现在 &lt;association&gt; 和 &lt;collection&gt; 节点中。</span><br><span class="line">     * 若这两个节点不包含 resultMap 属性，则调用 processNestedResultMappings 方法</span><br><span class="line">     * 解析嵌套 resultMap。</span><br><span class="line">     */</span><br><span class="line">    String nestedResultMap = context.getStringAttribute(&quot;resultMap&quot;, processNestedResultMappings(context, Collections.&lt;ResultMapping&gt;emptyList()));</span><br><span class="line">    </span><br><span class="line">    String notNullColumn = context.getStringAttribute(&quot;notNullColumn&quot;);</span><br><span class="line">    String columnPrefix = context.getStringAttribute(&quot;columnPrefix&quot;);</span><br><span class="line">    String typeHandler = context.getStringAttribute(&quot;typeHandler&quot;);</span><br><span class="line">    String resultSet = context.getStringAttribute(&quot;resultSet&quot;);</span><br><span class="line">    String foreignColumn = context.getStringAttribute(&quot;foreignColumn&quot;);</span><br><span class="line">    boolean lazy = &quot;lazy&quot;.equals(context.getStringAttribute(&quot;fetchType&quot;, configuration.isLazyLoadingEnabled() ? &quot;lazy&quot; : &quot;eager&quot;));</span><br><span class="line"></span><br><span class="line">    // 解析 javaType、typeHandler 的类型以及枚举类型 JdbcType</span><br><span class="line">    Class&lt;?&gt; javaTypeClass = resolveClass(javaType);</span><br><span class="line">    Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandlerClass = (Class&lt;? extends TypeHandler&lt;?&gt;&gt;) resolveClass(typeHandler);</span><br><span class="line">    JdbcType jdbcTypeEnum = resolveJdbcType(jdbcType);</span><br><span class="line"></span><br><span class="line">    // 构建 ResultMapping 对象</span><br><span class="line">    return builderAssistant.buildResultMapping(resultType, property, column, javaTypeClass, jdbcTypeEnum, nestedSelect,</span><br><span class="line">        nestedResultMap, notNullColumn, columnPrefix, typeHandlerClass, flags, resultSet, foreignColumn, lazy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法主要用于获取 <id> 和 <result> 节点的属性，其中，resultMap 属性的解析过程要相对复杂一些。该属性存在于 <association> 和 <collection> 节点中。下面以 <association> 节点为例，演示该节点的两种配置方式，分别如下：</association></collection></association></result></id></p>
<p>第一种配置方式是通过 resultMap 属性引用其他的 <resultMap> 节点，配置如下：</resultMap></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap id=&quot;articleResult&quot; type=&quot;Article&quot;&gt;</span><br><span class="line">    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;</span><br><span class="line">    &lt;result property=&quot;title&quot; column=&quot;article_title&quot;/&gt;</span><br><span class="line">    &lt;!-- 引用 authorResult --&gt;</span><br><span class="line">    &lt;association property=&quot;article_author&quot; column=&quot;article_author_id&quot; javaType=&quot;Author&quot; resultMap=&quot;authorResult&quot;/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">&lt;resultMap id=&quot;authorResult&quot; type=&quot;Author&quot;&gt;</span><br><span class="line">    &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt;</span><br><span class="line">    &lt;result property=&quot;name&quot; column=&quot;author_name&quot;/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure>

<p>第二种配置方式是采取 resultMap 嵌套的方式进行配置，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap id=&quot;articleResult&quot; type=&quot;Article&quot;&gt;</span><br><span class="line">    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;</span><br><span class="line">    &lt;result property=&quot;title&quot; column=&quot;article_title&quot;/&gt;</span><br><span class="line">    &lt;!-- resultMap 嵌套 --&gt;</span><br><span class="line">    &lt;association property=&quot;article_author&quot; javaType=&quot;Author&quot;&gt;</span><br><span class="line">        &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt;</span><br><span class="line">        &lt;result property=&quot;name&quot; column=&quot;author_name&quot;/&gt;</span><br><span class="line">    &lt;/association&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure>

<p>如上配置，<association> 的子节点是一些结果映射配置，这些结果配置最终也会被解析成 ResultMap。我们可以看看解析过程是怎样的，如下：</association></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private String processNestedResultMappings(XNode context, List&lt;ResultMapping&gt; resultMappings) throws Exception &#123;</span><br><span class="line">    // 判断节点名称</span><br><span class="line">    if (&quot;association&quot;.equals(context.getName())</span><br><span class="line">        || &quot;collection&quot;.equals(context.getName())</span><br><span class="line">        || &quot;case&quot;.equals(context.getName())) &#123;</span><br><span class="line">        if (context.getStringAttribute(&quot;select&quot;) == null) &#123;</span><br><span class="line">            // resultMapElement 是解析 ResultMap 入口方法</span><br><span class="line">            ResultMap resultMap = resultMapElement(context, resultMappings);</span><br><span class="line">            // 返回 resultMap id</span><br><span class="line">            return resultMap.getId();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，<association> 的子节点由 resultMapElement 方法解析成 ResultMap，并在最后返回 <a target="_blank" rel="noopener" href="http://resultmap.id/">resultMap.id</a>。对于 <resultMap> 节点，id 的值配置在该节点的 id 属性中。但 <association> 节点无法配置 id 属性，那么该 id 如何产生的呢？答案在 XNode 类的 getValueBasedIdentifier 方法中，这个方法具体逻辑我就不分析了。下面直接看一下以上配置中的 <association> 节点解析成 ResultMap 后的 id 值，如下：</association></association></resultMap></association></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id = mapper_resultMap[articleResult]_association[article_author]</span><br></pre></td></tr></table></figure>

<p>关于嵌套 resultMap 的解析逻辑就先分析到这，下面分析 ResultMapping 的构建过程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public ResultMapping buildResultMapping(Class&lt;?&gt; resultType, String property, String column, Class&lt;?&gt; javaType,JdbcType jdbcType, </span><br><span class="line">    String nestedSelect, String nestedResultMap, String notNullColumn, String columnPrefix,Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandler, </span><br><span class="line">    List&lt;ResultFlag&gt; flags, String resultSet, String foreignColumn, boolean lazy) &#123;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 若 javaType 为空，这里根据 property 的属性进行解析。关于下面方法中的参数，</span><br><span class="line">     * 这里说明一下：</span><br><span class="line">     *   - resultType：即 &lt;resultMap type=&quot;xxx&quot;/&gt; 中的 type 属性</span><br><span class="line">     *   - property：即 &lt;result property=&quot;xxx&quot;/&gt; 中的 property 属性</span><br><span class="line">     */</span><br><span class="line">    Class&lt;?&gt; javaTypeClass = resolveResultJavaType(resultType, property, javaType);</span><br><span class="line"></span><br><span class="line">    // 解析 TypeHandler</span><br><span class="line">    TypeHandler&lt;?&gt; typeHandlerInstance = resolveTypeHandler(javaTypeClass, typeHandler);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 解析 column = &#123;property1=column1, property2=column2&#125; 的情况，</span><br><span class="line">     * 这里会将 column 拆分成多个 ResultMapping</span><br><span class="line">     */</span><br><span class="line">    List&lt;ResultMapping&gt; composites = parseCompositeColumnName(column);</span><br><span class="line"></span><br><span class="line">    // 通过建造模式构建 ResultMapping</span><br><span class="line">    return new ResultMapping.Builder(configuration, property, column, javaTypeClass)</span><br><span class="line">        .jdbcType(jdbcType)</span><br><span class="line">        .nestedQueryId(applyCurrentNamespace(nestedSelect, true))</span><br><span class="line">        .nestedResultMapId(applyCurrentNamespace(nestedResultMap, true))</span><br><span class="line">        .resultSet(resultSet)</span><br><span class="line">        .typeHandler(typeHandlerInstance)</span><br><span class="line">        .flags(flags == null ? new ArrayList&lt;ResultFlag&gt;() : flags)</span><br><span class="line">        .composites(composites)</span><br><span class="line">        .notNullColumns(parseMultipleColumnNames(notNullColumn))</span><br><span class="line">        .columnPrefix(columnPrefix)</span><br><span class="line">        .foreignColumn(foreignColumn)</span><br><span class="line">        .lazy(lazy)</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// -☆- ResultMapping.Builder</span><br><span class="line">public ResultMapping build() &#123;</span><br><span class="line">    // 将 flags 和 composites 两个集合变为不可修改集合</span><br><span class="line">    resultMapping.flags = Collections.unmodifiableList(resultMapping.flags);</span><br><span class="line">    resultMapping.composites = Collections.unmodifiableList(resultMapping.composites);</span><br><span class="line">    // 从 TypeHandlerRegistry 中获取相应 TypeHandler</span><br><span class="line">    resolveTypeHandler();</span><br><span class="line">    validate();</span><br><span class="line">    return resultMapping;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ResultMapping 的构建过程不是很复杂，首先是解析 javaType 类型，并创建 typeHandler 实例。然后处理复合 column。最后通过建造器构建 ResultMapping 实例。关于上面方法中出现的一些方法调用，这里接不跟下去分析了，大家可以自己看看。</p>
<p>到此关于 ResultMapping 的解析和构建过程就分析完了，总的来说，还是比较复杂的。不过再难也是人写的，静下心都可以看懂。好了，其他就不多说了，继续往下分析。</p>
<h5 id="2-1-3-2-解析-节点"><a href="#2-1-3-2-解析-节点" class="headerlink" title="2.1.3.2 解析  节点"></a>2.1.3.2 解析 <constructor> 节点</constructor></h5><p>一般情况下，我们所定义的实体类都是简单的 Java 对象，即 POJO。这种对象包含一些私有属性和相应的 getter&#x2F;setter 方法，通常这种 POJO 可以满足大部分需求。但如果你想使用<code>不可变类</code>存储查询结果，则就需要做一些改动。比如把 POJO 的 setter 方法移除，增加构造方法用于初始化成员变量。对于这种不可变的 Java 类，需要通过带有参数的构造方法进行初始化（反射也可以达到同样目的）。下面举个例子说明一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ArticleDO &#123;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    public ArticleDO(Integer id, String title, String content) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.title = title;</span><br><span class="line">        this.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，ArticleDO 的构造方法对应的配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;constructor&gt;</span><br><span class="line">    &lt;idArg column=&quot;id&quot; name=&quot;id&quot;/&gt;</span><br><span class="line">    &lt;arg column=&quot;title&quot; name=&quot;title&quot;/&gt;</span><br><span class="line">    &lt;arg column=&quot;content&quot; name=&quot;content&quot;/&gt;</span><br><span class="line">&lt;/constructor&gt;</span><br></pre></td></tr></table></figure>

<p>下面，分析 constructor 节点的解析过程。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void processConstructorElement(XNode resultChild, Class&lt;?&gt; resultType, List&lt;ResultMapping&gt; resultMappings) throws Exception &#123;</span><br><span class="line">    // 获取子节点列表</span><br><span class="line">    List&lt;XNode&gt; argChildren = resultChild.getChildren();</span><br><span class="line">    for (XNode argChild : argChildren) &#123;</span><br><span class="line">        List&lt;ResultFlag&gt; flags = new ArrayList&lt;ResultFlag&gt;();</span><br><span class="line">        // 向 flags 中添加 CONSTRUCTOR 标志</span><br><span class="line">        flags.add(ResultFlag.CONSTRUCTOR);</span><br><span class="line">        if (&quot;idArg&quot;.equals(argChild.getName())) &#123;</span><br><span class="line">            // 向 flags 中添加 ID 标志</span><br><span class="line">            flags.add(ResultFlag.ID);</span><br><span class="line">        &#125;</span><br><span class="line">        // 构建 ResultMapping，上一节已经分析过</span><br><span class="line">        resultMappings.add(buildResultMappingFromContext(argChild, resultType, flags));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，上面方法的逻辑并不复杂。首先是获取并遍历子节点列表，然后为每个子节点创建 flags 集合，并添加 CONSTRUCTOR 标志。对于 idArg 节点，额外添加 ID 标志。最后一步则是构建 ResultMapping，该步逻辑前面已经分析过，这里就不多说了。</p>
<p>分析完 <resultMap> 的子节点 <id>，<result> 以及 <constructor> 的解析过程，下面来看看 ResultMap 实例的构建过程。</constructor></result></id></resultMap></p>
<h5 id="2-1-3-3-ResultMap-对象构建过程分析"><a href="#2-1-3-3-ResultMap-对象构建过程分析" class="headerlink" title="2.1.3.3 ResultMap 对象构建过程分析"></a>2.1.3.3 ResultMap 对象构建过程分析</h5><p>前面用了不少的篇幅来分析 <resultMap> 子节点的解析过程。通过前面的分析，我们可知 <id>，<result> 等节点最终都被解析成了 ResultMapping。在得到这些 ResultMapping 后，紧接着要做的事情是构建 ResultMap。如果说 ResultMapping 与单条结果映射相对应，那 ResultMap 与什么对应呢？答案是…。答案暂时还不能说，我们到源码中去找寻吧。下面，让我们带着这个疑问开始本节的源码分析。</result></id></resultMap></p>
<p>前面分析了很多源码，大家可能都忘了 ResultMap 构建的入口了。这里再贴一下，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private ResultMap resultMapElement(XNode resultMapNode, List&lt;ResultMapping&gt; additionalResultMappings) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    // 获取 resultMap 节点中的属性</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    // 解析 resultMap 对应的类型</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    // 遍历 resultMap 节点的子节点，构建 ResultMapping 对象</span><br><span class="line">    // ...</span><br><span class="line">    </span><br><span class="line">    // 创建 ResultMap 解析器</span><br><span class="line">    ResultMapResolver resultMapResolver = new ResultMapResolver(builderAssistant, id, typeClass, extend,</span><br><span class="line">        discriminator, resultMappings, autoMapping);</span><br><span class="line">    try &#123;</span><br><span class="line">        // 根据前面获取到的信息构建 ResultMap 对象</span><br><span class="line">        return resultMapResolver.resolve();</span><br><span class="line">    &#125; catch (IncompleteElementException e) &#123;</span><br><span class="line">        configuration.addIncompleteResultMap(resultMapResolver);</span><br><span class="line">        throw e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，ResultMap 的构建逻辑分装在 ResultMapResolver 的 resolve 方法中，下面我从该方法进行分析。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// -☆- ResultMapResolver</span><br><span class="line">public ResultMap resolve() &#123;</span><br><span class="line">    return assistant.addResultMap(this.id, this.type, this.extend, this.discriminator, this.resultMappings, this.autoMapping);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法将构建 ResultMap 实例的任务委托给了 MapperBuilderAssistant 的 addResultMap，我们跟进到这个方法中看看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// -☆- MapperBuilderAssistant</span><br><span class="line">public ResultMap addResultMap(</span><br><span class="line">    String id, Class&lt;?&gt; type, String extend, Discriminator discriminator,</span><br><span class="line">    List&lt;ResultMapping&gt; resultMappings, Boolean autoMapping) &#123;</span><br><span class="line">    </span><br><span class="line">    // 为 ResultMap 的 id 和 extend 属性值拼接命名空间</span><br><span class="line">    id = applyCurrentNamespace(id, false);</span><br><span class="line">    extend = applyCurrentNamespace(extend, true);</span><br><span class="line"></span><br><span class="line">    if (extend != null) &#123;</span><br><span class="line">        if (!configuration.hasResultMap(extend)) &#123;</span><br><span class="line">            throw new IncompleteElementException(&quot;Could not find a parent resultmap with id &#x27;&quot; + extend + &quot;&#x27;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        ResultMap resultMap = configuration.getResultMap(extend);</span><br><span class="line">        List&lt;ResultMapping&gt; extendedResultMappings = new ArrayList&lt;ResultMapping&gt;(resultMap.getResultMappings());</span><br><span class="line">        // 为拓展 ResultMappings 取出重复项</span><br><span class="line">        extendedResultMappings.removeAll(resultMappings);</span><br><span class="line">        </span><br><span class="line">        boolean declaresConstructor = false;</span><br><span class="line">        // 检测当前 resultMappings 集合中是否包含 CONSTRUCTOR 标志的元素</span><br><span class="line">        for (ResultMapping resultMapping : resultMappings) &#123;</span><br><span class="line">            if (resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR)) &#123;</span><br><span class="line">                declaresConstructor = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * 如果当前 &lt;resultMap&gt; 节点中包含 &lt;constructor&gt; 子节点，</span><br><span class="line">         * 则将拓展 ResultMapping 集合中的包含 CONSTRUCTOR 标志的元素移除</span><br><span class="line">         */</span><br><span class="line">        if (declaresConstructor) &#123;</span><br><span class="line">            Iterator&lt;ResultMapping&gt; extendedResultMappingsIter = extendedResultMappings.iterator();</span><br><span class="line">            while (extendedResultMappingsIter.hasNext()) &#123;</span><br><span class="line">                if (extendedResultMappingsIter.next().getFlags().contains(ResultFlag.CONSTRUCTOR)) &#123;</span><br><span class="line">                    extendedResultMappingsIter.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 将扩展 resultMappings 集合合并到当前 resultMappings 集合中</span><br><span class="line">        resultMappings.addAll(extendedResultMappings);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 构建 ResultMap</span><br><span class="line">    ResultMap resultMap = new ResultMap.Builder(configuration, id, type, resultMappings, autoMapping)</span><br><span class="line">        .discriminator(discriminator)</span><br><span class="line">        .build();</span><br><span class="line">    configuration.addResultMap(resultMap);</span><br><span class="line">    return resultMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法主要用于处理 resultMap 节点的 extend 属性，extend 不为空的话，这里将当前 resultMappings 集合和扩展 resultMappings 集合合二为一。随后，通过建造模式构建 ResultMap 实例。过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">// -☆- ResultMap</span><br><span class="line">public ResultMap build() &#123;</span><br><span class="line">    if (resultMap.id == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;ResultMaps must have an id&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    resultMap.mappedColumns = new HashSet&lt;String&gt;();</span><br><span class="line">    resultMap.mappedProperties = new HashSet&lt;String&gt;();</span><br><span class="line">    resultMap.idResultMappings = new ArrayList&lt;ResultMapping&gt;();</span><br><span class="line">    resultMap.constructorResultMappings = new ArrayList&lt;ResultMapping&gt;();</span><br><span class="line">    resultMap.propertyResultMappings = new ArrayList&lt;ResultMapping&gt;();</span><br><span class="line">    final List&lt;String&gt; constructorArgNames = new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    for (ResultMapping resultMapping : resultMap.resultMappings) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * 检测 &lt;association&gt; 或 &lt;collection&gt; 节点</span><br><span class="line">         * 是否包含 select 和 resultMap 属性</span><br><span class="line">         */</span><br><span class="line">        resultMap.hasNestedQueries = resultMap.hasNestedQueries || resultMapping.getNestedQueryId() != null;</span><br><span class="line">        resultMap.hasNestedResultMaps =</span><br><span class="line">            resultMap.hasNestedResultMaps || (resultMapping.getNestedResultMapId() != null &amp;&amp; resultMapping.getResultSet() == null);</span><br><span class="line"></span><br><span class="line">        final String column = resultMapping.getColumn();</span><br><span class="line">        if (column != null) &#123;</span><br><span class="line">            // 将 colum 转换成大写，并添加到 mappedColumns 集合中</span><br><span class="line">            resultMap.mappedColumns.add(column.toUpperCase(Locale.ENGLISH));</span><br><span class="line">        &#125; else if (resultMapping.isCompositeResult()) &#123;</span><br><span class="line">            for (ResultMapping compositeResultMapping : resultMapping.getComposites()) &#123;</span><br><span class="line">                final String compositeColumn = compositeResultMapping.getColumn();</span><br><span class="line">                if (compositeColumn != null) &#123;</span><br><span class="line">                    resultMap.mappedColumns.add(compositeColumn.toUpperCase(Locale.ENGLISH));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 添加属性 property 到 mappedProperties 集合中</span><br><span class="line">        final String property = resultMapping.getProperty();</span><br><span class="line">        if (property != null) &#123;</span><br><span class="line">            resultMap.mappedProperties.add(property);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 检测当前 resultMapping 是否包含 CONSTRUCTOR 标志</span><br><span class="line">        if (resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR)) &#123;</span><br><span class="line">            // 添加 resultMapping 到 constructorResultMappings 中</span><br><span class="line">            resultMap.constructorResultMappings.add(resultMapping);</span><br><span class="line">            // 添加属性（constructor 节点的 name 属性）到 constructorArgNames 中</span><br><span class="line">            if (resultMapping.getProperty() != null) &#123;</span><br><span class="line">                constructorArgNames.add(resultMapping.getProperty());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 添加 resultMapping 到 propertyResultMappings 中</span><br><span class="line">            resultMap.propertyResultMappings.add(resultMapping);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (resultMapping.getFlags().contains(ResultFlag.ID)) &#123;</span><br><span class="line">            // 添加 resultMapping 到 idResultMappings 中</span><br><span class="line">            resultMap.idResultMappings.add(resultMapping);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (resultMap.idResultMappings.isEmpty()) &#123;</span><br><span class="line">        resultMap.idResultMappings.addAll(resultMap.resultMappings);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!constructorArgNames.isEmpty()) &#123;</span><br><span class="line">        // 获取构造方法参数列表，篇幅原因，这个方法不分析了</span><br><span class="line">        final List&lt;String&gt; actualArgNames = argNamesOfMatchingConstructor(constructorArgNames);</span><br><span class="line">        if (actualArgNames == null) &#123;</span><br><span class="line">            throw new BuilderException(&quot;Error in result map &#x27;&quot; + resultMap.id</span><br><span class="line">                + &quot;&#x27;. Failed to find a constructor in &#x27;&quot;</span><br><span class="line">                + resultMap.getType().getName() + &quot;&#x27; by arg names &quot; + constructorArgNames</span><br><span class="line">                + &quot;. There might be more info in debug log.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 对 constructorResultMappings 按照构造方法参数列表的顺序进行排序</span><br><span class="line">        Collections.sort(resultMap.constructorResultMappings, new Comparator&lt;ResultMapping&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(ResultMapping o1, ResultMapping o2) &#123;</span><br><span class="line">                int paramIdx1 = actualArgNames.indexOf(o1.getProperty());</span><br><span class="line">                int paramIdx2 = actualArgNames.indexOf(o2.getProperty());</span><br><span class="line">                return paramIdx1 - paramIdx2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将以下这些集合变为不可修改集合</span><br><span class="line">    resultMap.resultMappings = Collections.unmodifiableList(resultMap.resultMappings);</span><br><span class="line">    resultMap.idResultMappings = Collections.unmodifiableList(resultMap.idResultMappings);</span><br><span class="line">    resultMap.constructorResultMappings = Collections.unmodifiableList(resultMap.constructorResultMappings);</span><br><span class="line">    resultMap.propertyResultMappings = Collections.unmodifiableList(resultMap.propertyResultMappings);</span><br><span class="line">    resultMap.mappedColumns = Collections.unmodifiableSet(resultMap.mappedColumns);</span><br><span class="line">    return resultMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码看起来很复杂，实际上这是假象。以上代码主要做的事情就是将 ResultMapping 实例及属性分别存储到不同的集合中，仅此而已。ResultMap 中定义了五种不同的集合，下面分别介绍一下这几种集合。</p>
<table>
<thead>
<tr>
<th>集合名称</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>mappedColumns</td>
<td>用于存储 <id>、<result>、<idArg>、<arg> 节点 column 属性</arg></idArg></result></id></td>
</tr>
<tr>
<td>mappedProperties</td>
<td>用于存储 <id> 和 <result> 节点的 property 属性，或 <idArgs> 和 <arg> 节点的 name 属性</arg></idArgs></result></id></td>
</tr>
<tr>
<td>idResultMappings</td>
<td>用于存储 <id> 和 <idArg> 节点对应的 ResultMapping 对象</idArg></id></td>
</tr>
<tr>
<td>propertyResultMappings</td>
<td>用于存储 <id> 和 <result> 节点对应的 ResultMapping 对象</result></id></td>
</tr>
<tr>
<td>constructorResultMappings</td>
<td>用于存储 <idArgs> 和 <arg> 节点对应的 ResultMapping 对象</arg></idArgs></td>
</tr>
</tbody></table>
<p>上面干巴巴的描述不够直观。下面我们写点代码测试一下，并把这些集合的内容打印到控制台上，大家直观感受一下。先定义一个映射文件，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace=&quot;xyz.coolblog.dao.ArticleDao&quot;&gt;</span><br><span class="line">    &lt;resultMap id=&quot;articleResult&quot; type=&quot;xyz.coolblog.model.Article&quot;&gt;</span><br><span class="line">        &lt;constructor&gt;</span><br><span class="line">            &lt;idArg column=&quot;id&quot; name=&quot;id&quot;/&gt;</span><br><span class="line">            &lt;arg column=&quot;title&quot; name=&quot;title&quot;/&gt;</span><br><span class="line">            &lt;arg column=&quot;content&quot; name=&quot;content&quot;/&gt;</span><br><span class="line">        &lt;/constructor&gt;</span><br><span class="line">        &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;</span><br><span class="line">        &lt;result property=&quot;author&quot; column=&quot;author&quot;/&gt;</span><br><span class="line">        &lt;result property=&quot;createTime&quot; column=&quot;create_time&quot;/&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>测试代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class ResultMapTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void printResultMapInfo() throws Exception &#123;</span><br><span class="line">        Configuration configuration = new Configuration();</span><br><span class="line">        String resource = &quot;mapper/ArticleMapper.xml&quot;;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        XMLMapperBuilder builder = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">        builder.parse();</span><br><span class="line"></span><br><span class="line">        ResultMap resultMap = configuration.getResultMap(&quot;articleResult&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;\n-------------------+✨ mappedColumns ✨+--------------------&quot;);</span><br><span class="line">        System.out.println(resultMap.getMappedColumns());</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;\n------------------+✨ mappedProperties ✨+------------------&quot;);</span><br><span class="line">        System.out.println(resultMap.getMappedProperties());</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;\n------------------+✨ idResultMappings ✨+------------------&quot;);</span><br><span class="line">        resultMap.getIdResultMappings().forEach(rm -&gt; System.out.println(simplify(rm)));</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;\n---------------+✨ propertyResultMappings ✨+---------------&quot;);</span><br><span class="line">        resultMap.getPropertyResultMappings().forEach(rm -&gt; System.out.println(simplify(rm)));</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;\n-------------+✨ constructorResultMappings ✨+--------------&quot;);</span><br><span class="line">        resultMap.getConstructorResultMappings().forEach(rm -&gt; System.out.println(simplify(rm)));</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;\n-------------------+✨ resultMappings ✨+-------------------&quot;);</span><br><span class="line">        resultMap.getResultMappings().forEach(rm -&gt; System.out.println(simplify(rm)));</span><br><span class="line"></span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** 简化 ResultMapping 输出结果 */</span><br><span class="line">    private String simplify(ResultMapping resultMapping) &#123;</span><br><span class="line">        return String.format(&quot;ResultMapping&#123;column=&#x27;%s&#x27;, property=&#x27;%s&#x27;, flags=%s, ...&#125;&quot;,</span><br><span class="line">            resultMapping.getColumn(), resultMapping.getProperty(), resultMapping.getFlags());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，我们把5个集合转给你的内容都打印出来，结果如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15326221002503.jpg" alt="img"></p>
<p>如上，结果比较清晰明了，不需要过多解释了。我们参照上面配置文件及输出的结果，把 ResultMap 的大致轮廓画出来。如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15326238856556.jpg" alt="img"></p>
<p>到这里，<resultMap> 节点的解析过程就分析完了。总的来说，该节点的解析过程还是比较复杂的。好了，其他的就不多说了，继续后面的分析。</resultMap></p>
<h4 id="2-1-4-解析-节点"><a href="#2-1-4-解析-节点" class="headerlink" title="2.1.4 解析  节点"></a>2.1.4 解析 <sql> 节点</sql></h4><p><sql> 节点用来定义一些可重用的 SQL 语句片段，比如表名，或表的列名等。在映射文件中，我们可以通过 <include> 节点引用 <sql> 节点定义的内容。下面我来演示一下 <sql> 节点的使用方式，如下：</sql></sql></include></sql></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;sql id=&quot;table&quot;&gt;</span><br><span class="line">    article</span><br><span class="line">&lt;/sql&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;findOne&quot; resultType=&quot;Article&quot;&gt;</span><br><span class="line">    SELECT id, title FROM &lt;include refid=&quot;table&quot;/&gt; WHERE id = #&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;update id=&quot;update&quot; parameterType=&quot;Article&quot;&gt;</span><br><span class="line">    UPDATE &lt;include refid=&quot;table&quot;/&gt; SET title = #&#123;title&#125; WHERE id = #&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure>

<p>如上，上面配置中，<select> 和 <update> 节点通过 <include> 引入定义在 <sql> 节点中的表名。上面的配置比较常规，除了静态文本，<sql> 节点还支持属性占位符 ${}。比如：</sql></sql></include></update></select></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;sql id=&quot;table&quot;&gt;</span><br><span class="line">    $&#123;table_prefix&#125;_article</span><br><span class="line">&lt;/sql&gt;</span><br></pre></td></tr></table></figure>

<p>如果属性 table_prefix &#x3D; blog，那么 <sql> 节点中的内容最终为 blog_article。</sql></p>
<p>上面介绍了 <sql> 节点的用法，比较容易。下面分析一下 sql 节点的解析过程，如下：</sql></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void sqlElement(List&lt;XNode&gt; list) throws Exception &#123;</span><br><span class="line">    if (configuration.getDatabaseId() != null) &#123;</span><br><span class="line">        // 调用 sqlElement 解析 &lt;sql&gt; 节点</span><br><span class="line">        sqlElement(list, configuration.getDatabaseId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 再次调用 sqlElement，不同的是，这次调用，该方法的第二个参数为 null</span><br><span class="line">    sqlElement(list, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法需要大家注意一下，如果 Configuration 的 databaseId 不为空，sqlElement 方法会被调用了两次。第一次传入具体的 databaseId，用于解析带有 databaseId 属性，且属性值与此相等的 <sql> 节点。第二次传入的 databaseId 为空，用于解析未配置 databaseId 属性的 <sql> 节点。这里是个小细节，大家注意一下就好。我们继续往下分析。</sql></sql></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void sqlElement(List&lt;XNode&gt; list, String requiredDatabaseId) throws Exception &#123;</span><br><span class="line">    for (XNode context : list) &#123;</span><br><span class="line">        // 获取 id 和 databaseId 属性</span><br><span class="line">        String databaseId = context.getStringAttribute(&quot;databaseId&quot;);</span><br><span class="line">        String id = context.getStringAttribute(&quot;id&quot;);</span><br><span class="line"></span><br><span class="line">        // id = currentNamespace + &quot;.&quot; + id</span><br><span class="line">        id = builderAssistant.applyCurrentNamespace(id, false);</span><br><span class="line"></span><br><span class="line">        // 检测当前 databaseId 和 requiredDatabaseId 是否一致</span><br><span class="line">        if (databaseIdMatchesCurrent(id, databaseId, requiredDatabaseId)) &#123;</span><br><span class="line">            // 将 &lt;id, XNode&gt; 键值对缓存到 sqlFragments 中</span><br><span class="line">            sqlFragments.put(id, context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法逻辑比较简单，首先是获取 <sql> 节点的 id 和 databaseId 属性，然后为 id 属性值拼接命名空间。最后，通过检测当前 databaseId 和 requiredDatabaseId 是否一致，来决定保存还是忽略当前的 <sql> 节点。下面，我们来看一下 databaseId 的匹配逻辑是怎样的。</sql></sql></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private boolean databaseIdMatchesCurrent(String id, String databaseId, String requiredDatabaseId) &#123;</span><br><span class="line">    if (requiredDatabaseId != null) &#123;</span><br><span class="line">        // 当前 databaseId 和目标 databaseId 不一致时，返回 false</span><br><span class="line">        if (!requiredDatabaseId.equals(databaseId)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 如果目标 databaseId 为空，但当前 databaseId 不为空。两者不一致，返回 false</span><br><span class="line">        if (databaseId != null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        /*</span><br><span class="line">         * 如果当前 &lt;sql&gt; 节点的 id 与之前的 &lt;sql&gt; 节点重复，且先前节点 </span><br><span class="line">         * databaseId 不为空。则忽略当前节点，并返回 false</span><br><span class="line">         */</span><br><span class="line">        if (this.sqlFragments.containsKey(id)) &#123;</span><br><span class="line">            XNode context = this.sqlFragments.get(id);</span><br><span class="line">            if (context.getStringAttribute(&quot;databaseId&quot;) != null) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面总结一下 databaseId 的匹配规则。</p>
<ol>
<li>databaseId 与 requiredDatabaseId 不一致，即失配，返回 false</li>
<li>当前节点与之前的节点出现 id 重复的情况，若之前的 <sql> 节点 databaseId 属性不为空，返回 false</sql></li>
<li>若以上两条规则均匹配失败，此时返回 true</li>
</ol>
<p>在上面三条匹配规则中，第二条规则稍微难理解一点。这里简单分析一下，考虑下面这种配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- databaseId 不为空 --&gt;</span><br><span class="line">&lt;sql id=&quot;table&quot; databaseId=&quot;mysql&quot;&gt;</span><br><span class="line">    article</span><br><span class="line">&lt;/sql&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- databaseId 为空 --&gt;</span><br><span class="line">&lt;sql id=&quot;table&quot;&gt;</span><br><span class="line">    article</span><br><span class="line">&lt;/sql&gt;</span><br></pre></td></tr></table></figure>

<p>在上面配置中，两个 <sql> 节点的 id 属性值相同，databaseId 属性不一致。假设 configuration.databaseId &#x3D; mysql，第一次调用 sqlElement 方法，第一个 <sql> 节点对应的 XNode 会被放入到 sqlFragments 中。第二次调用 sqlElement 方法时，requiredDatabaseId 参数为空。由于 sqlFragments 中已包含了一个 id 节点，且该节点的 databaseId 不为空，此时匹配逻辑返回 false，第二个节点不会被保存到 sqlFragments。</sql></sql></p>
<p>上面的分析内容涉及到了 databaseId，关于 databaseId 的用途，这里简单介绍一下。databaseId 用于标明数据库厂商的身份，不同厂商有自己的 SQL 方言，MyBatis 可以根据 databaseId 执行不同 SQL 语句。databaseId 在 <sql> 节点中有什么用呢？这个问题也不难回答。<sql> 节点用于保存 SQL 语句片段，如果 SQL 语句片段中包含方言的话，那么该 <sql> 节点只能被同一 databaseId 的查询语句或更新语句引用。关于 databaseId，这里就介绍这么多。</sql></sql></sql></p>
<p>好了，本节内容先到这里。继续往下分析。</p>
<h4 id="2-1-5-解析-SQL-语句节点"><a href="#2-1-5-解析-SQL-语句节点" class="headerlink" title="2.1.5 解析 SQL 语句节点"></a>2.1.5 解析 SQL 语句节点</h4><p>前面分析了 <cache>、<cache-ref>、<resultMap> 以及 <sql> 节点，从这一节开始，我们要分析映射文件中剩余的几个节点，分别是 <select>、<insert>、<update> 以及 <delete> 等。这几个节点中存储的是相同的内容，都是 SQL 语句，所以这几个节点的解析过程也是相同的。在进行代码分析之前，这里需要特别说明一下：为了避免和 <sql> 节点混淆，同时也为了描述方便，这里把 <select>、<insert>、<update> 以及 <delete> 等节点统称为 SQL 语句节点。好了，下面开始本节的分析。</delete></update></insert></select></sql></delete></update></insert></select></sql></resultMap></cache-ref></cache></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void buildStatementFromContext(List&lt;XNode&gt; list) &#123;</span><br><span class="line">    if (configuration.getDatabaseId() != null) &#123;</span><br><span class="line">        // 调用重载方法构建 Statement</span><br><span class="line">        buildStatementFromContext(list, configuration.getDatabaseId());</span><br><span class="line">    &#125;</span><br><span class="line">    // 调用重载方法构建 Statement，requiredDatabaseId 参数为空</span><br><span class="line">    buildStatementFromContext(list, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void buildStatementFromContext(List&lt;XNode&gt; list, String requiredDatabaseId) &#123;</span><br><span class="line">    for (XNode context : list) &#123;</span><br><span class="line">        // 创建 Statement 建造类</span><br><span class="line">        final XMLStatementBuilder statementParser = new XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);</span><br><span class="line">        try &#123;</span><br><span class="line">            /*</span><br><span class="line">             * 解析 Statement 节点，并将解析结果存储到 </span><br><span class="line">             * configuration 的 mappedStatements 集合中</span><br><span class="line">             */</span><br><span class="line">            statementParser.parseStatementNode();</span><br><span class="line">        &#125; catch (IncompleteElementException e) &#123;</span><br><span class="line">            // 解析失败，将解析器放入 configuration 的 incompleteStatements 集合中</span><br><span class="line">            configuration.addIncompleteStatement(statementParser);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的解析方法没有什么实质性的解析逻辑，我们继续往下分析。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">public void parseStatementNode() &#123;</span><br><span class="line">    // 获取 id 和 databaseId 属性</span><br><span class="line">    String id = context.getStringAttribute(&quot;id&quot;);</span><br><span class="line">    String databaseId = context.getStringAttribute(&quot;databaseId&quot;);</span><br><span class="line"></span><br><span class="line">    // 根据 databaseId 进行检测，检测逻辑和上一节基本一致，这里不再赘述</span><br><span class="line">    if (!databaseIdMatchesCurrent(id, databaseId, this.requiredDatabaseId)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取各种属性</span><br><span class="line">    Integer fetchSize = context.getIntAttribute(&quot;fetchSize&quot;);</span><br><span class="line">    Integer timeout = context.getIntAttribute(&quot;timeout&quot;);</span><br><span class="line">    String parameterMap = context.getStringAttribute(&quot;parameterMap&quot;);</span><br><span class="line">    String parameterType = context.getStringAttribute(&quot;parameterType&quot;);</span><br><span class="line">    Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType);</span><br><span class="line">    String resultMap = context.getStringAttribute(&quot;resultMap&quot;);</span><br><span class="line">    String resultType = context.getStringAttribute(&quot;resultType&quot;);</span><br><span class="line">    String lang = context.getStringAttribute(&quot;lang&quot;);</span><br><span class="line">    LanguageDriver langDriver = getLanguageDriver(lang);</span><br><span class="line"></span><br><span class="line">    // 通过别名解析 resultType 对应的类型</span><br><span class="line">    Class&lt;?&gt; resultTypeClass = resolveClass(resultType);</span><br><span class="line">    String resultSetType = context.getStringAttribute(&quot;resultSetType&quot;);</span><br><span class="line">    </span><br><span class="line">    // 解析 Statement 类型，默认为 PREPARED</span><br><span class="line">    StatementType statementType = StatementType.valueOf(context.getStringAttribute(&quot;statementType&quot;, StatementType.PREPARED.toString()));</span><br><span class="line">    </span><br><span class="line">    // 解析 ResultSetType</span><br><span class="line">    ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType);</span><br><span class="line"></span><br><span class="line">    // 获取节点的名称，比如 &lt;select&gt; 节点名称为 select</span><br><span class="line">    String nodeName = context.getNode().getNodeName();</span><br><span class="line">    // 根据节点名称解析 SqlCommandType</span><br><span class="line">    SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));</span><br><span class="line">    boolean isSelect = sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line">    boolean flushCache = context.getBooleanAttribute(&quot;flushCache&quot;, !isSelect);</span><br><span class="line">    boolean useCache = context.getBooleanAttribute(&quot;useCache&quot;, isSelect);</span><br><span class="line">    boolean resultOrdered = context.getBooleanAttribute(&quot;resultOrdered&quot;, false);</span><br><span class="line"></span><br><span class="line">    // 解析 &lt;include&gt; 节点</span><br><span class="line">    XMLIncludeTransformer includeParser = new XMLIncludeTransformer(configuration, builderAssistant);</span><br><span class="line">    includeParser.applyIncludes(context.getNode());</span><br><span class="line"></span><br><span class="line">    // 解析 &lt;selectKey&gt; 节点</span><br><span class="line">    processSelectKeyNodes(id, parameterTypeClass, langDriver);</span><br><span class="line"></span><br><span class="line">    // 解析 SQL 语句</span><br><span class="line">    SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);</span><br><span class="line">    String resultSets = context.getStringAttribute(&quot;resultSets&quot;);</span><br><span class="line">    String keyProperty = context.getStringAttribute(&quot;keyProperty&quot;);</span><br><span class="line">    String keyColumn = context.getStringAttribute(&quot;keyColumn&quot;);</span><br><span class="line"></span><br><span class="line">    KeyGenerator keyGenerator;</span><br><span class="line">    String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">    keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, true);</span><br><span class="line">    if (configuration.hasKeyGenerator(keyStatementId)) &#123;</span><br><span class="line">        // 获取 KeyGenerator 实例</span><br><span class="line">        keyGenerator = configuration.getKeyGenerator(keyStatementId);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 创建 KeyGenerator 实例</span><br><span class="line">        keyGenerator = context.getBooleanAttribute(&quot;useGeneratedKeys&quot;,</span><br><span class="line">            configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType)) ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 构建 MappedStatement 对象，并将该对象存储到 </span><br><span class="line">     * Configuration 的 mappedStatements 集合中</span><br><span class="line">     */</span><br><span class="line">    builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,</span><br><span class="line">        fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,</span><br><span class="line">        resultSetTypeEnum, flushCache, useCache, resultOrdered,</span><br><span class="line">        keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码比较长，看起来有点复杂。不过如果大家耐心看一下源码，会发现，上面的代码中起码有一般的代码都是用来获取节点属性，以及解析部分属性等。抛去这部分代码，以上代码做的事情如下。</p>
<ol>
<li>解析 <include> 节点</include></li>
<li>解析 <selectKey> 节点</selectKey></li>
<li>解析 SQL，获取 SqlSource</li>
<li>构建 MappedStatement 实例</li>
</ol>
<p>以上流程对应的代码比较复杂，每个步骤都能分析出一些东西来。下面我会每个步骤都进行分析，首先来分析 <include> 节点的解析过程。</include></p>
<h5 id="2-1-5-1-解析-节点"><a href="#2-1-5-1-解析-节点" class="headerlink" title="2.1.5.1 解析  节点"></a>2.1.5.1 解析 <include> 节点</include></h5><p><include> 节点的解析逻辑封装在 applyIncludes 中，该方法的代码如下：</include></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void applyIncludes(Node source) &#123;</span><br><span class="line">    Properties variablesContext = new Properties();</span><br><span class="line">    Properties configurationVariables = configuration.getVariables();</span><br><span class="line">    if (configurationVariables != null) &#123;</span><br><span class="line">        // 将 configurationVariables 中的数据添加到 variablesContext 中</span><br><span class="line">        variablesContext.putAll(configurationVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 调用重载方法处理 &lt;include&gt; 节点</span><br><span class="line">    applyIncludes(source, variablesContext, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码创建了一个新的 Properties 对象，并将全局 Properties 添加到其中。这样做的原因是 applyIncludes 的重载方法会向 Properties 中添加新的元素，如果直接将全局 Properties 传给重载方法，会造成全局 Properties 被污染。这是个小细节，一般容易被忽视掉。其他没什么需要注意的了，我们继续往下看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">private void applyIncludes(Node source, final Properties variablesContext, boolean included) &#123;</span><br><span class="line"></span><br><span class="line">    // ⭐️ 第一个条件分支</span><br><span class="line">    if (source.getNodeName().equals(&quot;include&quot;)) &#123;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * 获取 &lt;sql&gt; 节点。若 refid 中包含属性占位符 $&#123;&#125;，</span><br><span class="line">         * 则需先将属性占位符替换为对应的属性值</span><br><span class="line">         */</span><br><span class="line">        Node toInclude = findSqlFragment(getStringAttribute(source, &quot;refid&quot;), variablesContext);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * 解析 &lt;include&gt; 的子节点 &lt;property&gt;，并将解析结果与 variablesContext 融合，</span><br><span class="line">         * 然后返回融合后的 Properties。若 &lt;property&gt; 节点的 value 属性中存在占位符 $&#123;&#125;，</span><br><span class="line">         * 则将占位符替换为对应的属性值</span><br><span class="line">         */</span><br><span class="line">        Properties toIncludeContext = getVariablesContext(source, variablesContext);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * 这里是一个递归调用，用于将 &lt;sql&gt; 节点内容中出现的属性占位符 $&#123;&#125; 替换为对应的</span><br><span class="line">         * 属性值。这里要注意一下递归调用的参数：</span><br><span class="line">         * </span><br><span class="line">         *  - toInclude：&lt;sql&gt; 节点对象</span><br><span class="line">         *  - toIncludeContext：&lt;include&gt; 子节点 &lt;property&gt; 的解析结果与</span><br><span class="line">         *                      全局变量融合后的结果 </span><br><span class="line">         */</span><br><span class="line">        applyIncludes(toInclude, toIncludeContext, true);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * 如果 &lt;sql&gt; 和 &lt;include&gt; 节点不在一个文档中，</span><br><span class="line">         * 则从其他文档中将 &lt;sql&gt; 节点引入到 &lt;include&gt; 所在文档中</span><br><span class="line">         */</span><br><span class="line">        if (toInclude.getOwnerDocument() != source.getOwnerDocument()) &#123;</span><br><span class="line">            toInclude = source.getOwnerDocument().importNode(toInclude, true);</span><br><span class="line">        &#125;</span><br><span class="line">        // 将 &lt;include&gt; 节点替换为 &lt;sql&gt; 节点</span><br><span class="line">        source.getParentNode().replaceChild(toInclude, source);</span><br><span class="line">        while (toInclude.hasChildNodes()) &#123;</span><br><span class="line">            // 将 &lt;sql&gt; 中的内容插入到 &lt;sql&gt; 节点之前</span><br><span class="line">            toInclude.getParentNode().insertBefore(toInclude.getFirstChild(), toInclude);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * 前面已经将 &lt;sql&gt; 节点的内容插入到 dom 中了，</span><br><span class="line">         * 现在不需要 &lt;sql&gt; 节点了，这里将该节点从 dom 中移除</span><br><span class="line">         */</span><br><span class="line">        toInclude.getParentNode().removeChild(toInclude);</span><br><span class="line"></span><br><span class="line">    // ⭐️ 第二个条件分支</span><br><span class="line">    &#125; else if (source.getNodeType() == Node.ELEMENT_NODE) &#123;</span><br><span class="line">        if (included &amp;&amp; !variablesContext.isEmpty()) &#123;</span><br><span class="line">            NamedNodeMap attributes = source.getAttributes();</span><br><span class="line">            for (int i = 0; i &lt; attributes.getLength(); i++) &#123;</span><br><span class="line">                Node attr = attributes.item(i);</span><br><span class="line">                // 将 source 节点属性中的占位符 $&#123;&#125; 替换成具体的属性值</span><br><span class="line">                attr.setNodeValue(PropertyParser.parse(attr.getNodeValue(), variablesContext));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        NodeList children = source.getChildNodes();</span><br><span class="line">        for (int i = 0; i &lt; children.getLength(); i++) &#123;</span><br><span class="line">            // 递归调用</span><br><span class="line">            applyIncludes(children.item(i), variablesContext, included);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    // ⭐️ 第三个条件分支</span><br><span class="line">    &#125; else if (included &amp;&amp; source.getNodeType() == Node.TEXT_NODE &amp;&amp; !variablesContext.isEmpty()) &#123;</span><br><span class="line">        // 将文本（text）节点中的属性占位符 $&#123;&#125; 替换成具体的属性值</span><br><span class="line">        source.setNodeValue(PropertyParser.parse(source.getNodeValue(), variablesContext));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码如果从上往下读，不太容易看懂。因为上面的方法由三个条件分支，外加两个递归调用组成，代码的执行顺序并不是由上而下。要理解上面的代码，我们需要定义一些配置，并将配置带入到具体代码中，逐行进行演绎。不过，更推荐的方式是使用 IDE 进行单步调试。为了便于讲解，我把上面代码中的三个分支都用 ⭐️ 标记了出来，这个大家注意一下。好了，必要的准备工作做好了，下面开始演绎代码的执行过程。演绎所用的测试配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace=&quot;xyz.coolblog.dao.ArticleDao&quot;&gt;</span><br><span class="line">    &lt;sql id=&quot;table&quot;&gt;</span><br><span class="line">        $&#123;table_name&#125;</span><br><span class="line">    &lt;/sql&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=&quot;findOne&quot; resultType=&quot;xyz.coolblog.dao.ArticleDO&quot;&gt;</span><br><span class="line">        SELECT</span><br><span class="line">            id, title</span><br><span class="line">        FROM</span><br><span class="line">            &lt;include refid=&quot;table&quot;&gt;</span><br><span class="line">                &lt;property name=&quot;table_name&quot; value=&quot;article&quot;/&gt;</span><br><span class="line">            &lt;/include&gt;</span><br><span class="line">        WHERE id = #&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>我们先来看一下 applyIncludes 方法第一次被调用时的状态，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">参数值：</span><br><span class="line">source = &lt;select&gt; 节点</span><br><span class="line">节点类型：ELEMENT_NODE</span><br><span class="line">variablesContext = [ ]  // 无内容 </span><br><span class="line">included = false</span><br><span class="line"></span><br><span class="line">执行流程：</span><br><span class="line">1. 进入条件分支2</span><br><span class="line">2. 获取 &lt;select&gt; 子节点列表</span><br><span class="line">3. 遍历子节点列表，将子节点作为参数，进行递归调用</span><br></pre></td></tr></table></figure>

<p>第一次调用 applyIncludes 方法，source &#x3D; <select>，代码进入条件分支2。在该分支中，首先要获取 </select><select> 节点的子节点列表。可获取到的子节点如下：</select></p>
<table>
<thead>
<tr>
<th align="left">编号</th>
<th align="left">子节点</th>
<th align="left">类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">SELECT id, title FROM</td>
<td align="left">TEXT_NODE</td>
<td align="left">文本节点</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><include refid="table"></include></td>
<td align="left">ELEMENT_NODE</td>
<td align="left">普通节点</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">WHERE id &#x3D; #{id}</td>
<td align="left">TEXT_NODE</td>
<td align="left">文本节点</td>
</tr>
</tbody></table>
<p>在获取到子节点类列表后，接下来要做的事情是遍历列表，然后将子节点作为参数进行递归调用。在上面三个子节点中，子节点1和子节点3都是文本节点，调用过程一致。因此，下面我只会演示子节点1和子节点2的递归调用过程。先来演示子节点1的调用过程，如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15328770996894.jpg" alt="img"></p>
<p>节点1的调用过程比较简单，只有两层调用。然后我们在看一下子节点2的调用过程，如下：</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15328770012708.jpg" alt="img"></p>
<p>上面是子节点2的调用过程，共有四层调用，略为复杂。大家自己也对着配置，把源码走一遍，然后记录每一次调用的一些状态，这样才能更好的理解 applyIncludes 方法的逻辑。</p>
<p>好了，本节内容先到这里，继续往下分析。</p>
<h5 id="2-1-5-2-解析-节点"><a href="#2-1-5-2-解析-节点" class="headerlink" title="2.1.5.2 解析  节点"></a>2.1.5.2 解析 <selectKey> 节点</selectKey></h5><p>对于一些不支持自增主键的数据库来说，我们在插入数据时，需要明确指定主键数据。以 Oracle 数据库为例，Oracle 数据库不支持自增主键，但它提供了自增序列工具。我们每次向数据库中插入数据时，可以先通过自增序列获取主键数据，然后再进行插入。这里涉及到两次数据库查询操作，我们不能在一个 <select> 节点中同时定义两个 select 语句，否者会导致 SQL 语句出错。对于这个问题，MyBatis 的 <selectKey> 可以很好的解决。下面我们看一段配置：</selectKey></select></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;saveAuthor&quot;&gt;</span><br><span class="line">    &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;BEFORE&quot;&gt;</span><br><span class="line">        select author_seq.nextval from dual</span><br><span class="line">    &lt;/selectKey&gt;</span><br><span class="line">    insert into Author</span><br><span class="line">        (id, name, password)</span><br><span class="line">    values</span><br><span class="line">        (#&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<p>在上面的配置中，查询语句会先于插入语句执行，这样我们就可以在插入时获取到主键的值。关于 <selectKey> 的用法，这里不过多介绍了。下面我们来看一下 <selectKey> 节点的解析过程。</selectKey></selectKey></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void processSelectKeyNodes(String id, Class&lt;?&gt; parameterTypeClass, LanguageDriver langDriver) &#123;</span><br><span class="line">    List&lt;XNode&gt; selectKeyNodes = context.evalNodes(&quot;selectKey&quot;);</span><br><span class="line">    if (configuration.getDatabaseId() != null) &#123;</span><br><span class="line">        // 解析 &lt;selectKey&gt; 节点，databaseId 不为空</span><br><span class="line">        parseSelectKeyNodes(id, selectKeyNodes, parameterTypeClass, langDriver, configuration.getDatabaseId());</span><br><span class="line">    &#125;</span><br><span class="line">    // 解析 &lt;selectKey&gt; 节点，databaseId 为空</span><br><span class="line">    parseSelectKeyNodes(id, selectKeyNodes, parameterTypeClass, langDriver, null);</span><br><span class="line">    // 将 &lt;selectKey&gt; 节点从 dom 树中移除</span><br><span class="line">    removeSelectKeyNodes(selectKeyNodes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中可以看出，<selectKey> 节点在解析完成后，会被从 dom 树中移除。这样后续可以更专注的解析 <insert> 或 <update> 节点中的 SQL，无需再额外处理 <selectKey> 节点。继续往下看。</selectKey></update></insert></selectKey></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">private void parseSelectKeyNodes(String parentId, List&lt;XNode&gt; list, Class&lt;?&gt; parameterTypeClass,</span><br><span class="line">    LanguageDriver langDriver, String skRequiredDatabaseId) &#123;</span><br><span class="line">    for (XNode nodeToHandle : list) &#123;</span><br><span class="line">        // id = parentId + !selectKey，比如 saveUser!selectKey</span><br><span class="line">        String id = parentId + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">        // 获取 &lt;selectKey&gt; 节点的 databaseId 属性</span><br><span class="line">        String databaseId = nodeToHandle.getStringAttribute(&quot;databaseId&quot;);</span><br><span class="line">        // 匹配 databaseId</span><br><span class="line">        if (databaseIdMatchesCurrent(id, databaseId, skRequiredDatabaseId)) &#123;</span><br><span class="line">            // 解析 &lt;selectKey&gt; 节点</span><br><span class="line">            parseSelectKeyNode(id, nodeToHandle, parameterTypeClass, langDriver, databaseId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void parseSelectKeyNode(String id, XNode nodeToHandle, Class&lt;?&gt; parameterTypeClass,</span><br><span class="line">    LanguageDriver langDriver, String databaseId) &#123;</span><br><span class="line"></span><br><span class="line">    // 获取各种属性</span><br><span class="line">    String resultType = nodeToHandle.getStringAttribute(&quot;resultType&quot;);</span><br><span class="line">    Class&lt;?&gt; resultTypeClass = resolveClass(resultType);</span><br><span class="line">    StatementType statementType = StatementType.valueOf(nodeToHandle.getStringAttribute(&quot;statementType&quot;, StatementType.PREPARED.toString()));</span><br><span class="line">    String keyProperty = nodeToHandle.getStringAttribute(&quot;keyProperty&quot;);</span><br><span class="line">    String keyColumn = nodeToHandle.getStringAttribute(&quot;keyColumn&quot;);</span><br><span class="line">    boolean executeBefore = &quot;BEFORE&quot;.equals(nodeToHandle.getStringAttribute(&quot;order&quot;, &quot;AFTER&quot;));</span><br><span class="line"></span><br><span class="line">    // 设置默认值</span><br><span class="line">    boolean useCache = false;</span><br><span class="line">    boolean resultOrdered = false;</span><br><span class="line">    KeyGenerator keyGenerator = NoKeyGenerator.INSTANCE;</span><br><span class="line">    Integer fetchSize = null;</span><br><span class="line">    Integer timeout = null;</span><br><span class="line">    boolean flushCache = false;</span><br><span class="line">    String parameterMap = null;</span><br><span class="line">    String resultMap = null;</span><br><span class="line">    ResultSetType resultSetTypeEnum = null;</span><br><span class="line"></span><br><span class="line">    // 创建 SqlSource</span><br><span class="line">    SqlSource sqlSource = langDriver.createSqlSource(configuration, nodeToHandle, parameterTypeClass);</span><br><span class="line">    /*</span><br><span class="line">     * &lt;selectKey&gt; 节点中只能配置 SELECT 查询语句，</span><br><span class="line">     * 因此 sqlCommandType 为 SqlCommandType.SELECT</span><br><span class="line">     */</span><br><span class="line">    SqlCommandType sqlCommandType = SqlCommandType.SELECT;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 构建 MappedStatement，并将 MappedStatement </span><br><span class="line">     * 添加到 Configuration 的 mappedStatements map 中</span><br><span class="line">     */</span><br><span class="line">    builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,</span><br><span class="line">        fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,</span><br><span class="line">        resultSetTypeEnum, flushCache, useCache, resultOrdered,</span><br><span class="line">        keyGenerator, keyProperty, keyColumn, databaseId, langDriver, null);</span><br><span class="line"></span><br><span class="line">    // id = namespace + &quot;.&quot; + id</span><br><span class="line">    id = builderAssistant.applyCurrentNamespace(id, false);</span><br><span class="line">    MappedStatement keyStatement = configuration.getMappedStatement(id, false);</span><br><span class="line">    // 创建 SelectKeyGenerator，并添加到 keyGenerators map 中</span><br><span class="line">    configuration.addKeyGenerator(id, new SelectKeyGenerator(keyStatement, executeBefore));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的源码比较长，但大部分代码都是一些基础代码，不是很难理解。以上代码比较重要的步骤如下：</p>
<ol>
<li>创建 SqlSource 实例</li>
<li>构建并缓存 MappedStatement 实例</li>
<li>构建并缓存 SelectKeyGenerator 实例</li>
</ol>
<p>在这三步中，第1步和第2步调用的是公共逻辑，其他地方也会调用，这两步对应的源码后续会分两节进行讲解。第3步则是创建一个 SelectKeyGenerator 实例，SelectKeyGenerator 创建的过程本身没什么好说的，所以就不多说了。下面分析一下 SqlSource 和 MappedStatement 实例的创建过程。</p>
<h5 id="2-1-5-3-解析-SQL-语句"><a href="#2-1-5-3-解析-SQL-语句" class="headerlink" title="2.1.5.3 解析 SQL 语句"></a>2.1.5.3 解析 SQL 语句</h5><p>前面分析了 <include> 和 <selectKey> 节点的解析过程，这两个节点解析完成后，都会以不同的方式从 dom 树中消失。所以目前的 SQL 语句节点由一些文本节点和普通节点组成，比如 <if>、<where> 等。那下面我们来看一下移除掉 <include> 和 <selectKey> 节点后的 SQL 语句节点是如何解析的。</selectKey></include></where></if></selectKey></include></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// -☆- XMLLanguageDriver</span><br><span class="line">public SqlSource createSqlSource(Configuration configuration, XNode script, Class&lt;?&gt; parameterType) &#123;</span><br><span class="line">    XMLScriptBuilder builder = new XMLScriptBuilder(configuration, script, parameterType);</span><br><span class="line">    return builder.parseScriptNode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// -☆- XMLScriptBuilder</span><br><span class="line">public SqlSource parseScriptNode() &#123;</span><br><span class="line">    // 解析 SQL 语句节点</span><br><span class="line">    MixedSqlNode rootSqlNode = parseDynamicTags(context);</span><br><span class="line">    SqlSource sqlSource = null;</span><br><span class="line">    // 根据 isDynamic 状态创建不同的 SqlSource</span><br><span class="line">    if (isDynamic) &#123;</span><br><span class="line">        sqlSource = new DynamicSqlSource(configuration, rootSqlNode);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        sqlSource = new RawSqlSource(configuration, rootSqlNode, parameterType);</span><br><span class="line">    &#125;</span><br><span class="line">    return sqlSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，SQL 语句的解析逻辑被封装在了 XMLScriptBuilder 类的 parseScriptNode 方法中。该方法首先会调用 parseDynamicTags 解析 SQL 语句节点，在解析过程中，会判断节点是是否包含一些动态标记，比如 ${} 占位符以及动态 SQL 节点等。若包含动态标记，则会将 isDynamic 设为 true。后续可根据 isDynamic 创建不同的 SqlSource。下面，我们来看一下 parseDynamicTags 方法的逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/** 该方法用于初始化 nodeHandlerMap 集合，该集合后面会用到 */</span><br><span class="line">private void initNodeHandlerMap() &#123;</span><br><span class="line">    nodeHandlerMap.put(&quot;trim&quot;, new TrimHandler());</span><br><span class="line">    nodeHandlerMap.put(&quot;where&quot;, new WhereHandler());</span><br><span class="line">    nodeHandlerMap.put(&quot;set&quot;, new SetHandler());</span><br><span class="line">    nodeHandlerMap.put(&quot;foreach&quot;, new ForEachHandler());</span><br><span class="line">    nodeHandlerMap.put(&quot;if&quot;, new IfHandler());</span><br><span class="line">    nodeHandlerMap.put(&quot;choose&quot;, new ChooseHandler());</span><br><span class="line">    nodeHandlerMap.put(&quot;when&quot;, new IfHandler());</span><br><span class="line">    nodeHandlerMap.put(&quot;otherwise&quot;, new OtherwiseHandler());</span><br><span class="line">    nodeHandlerMap.put(&quot;bind&quot;, new BindHandler());</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">protected MixedSqlNode parseDynamicTags(XNode node) &#123;</span><br><span class="line">    List&lt;SqlNode&gt; contents = new ArrayList&lt;SqlNode&gt;();</span><br><span class="line">    NodeList children = node.getNode().getChildNodes();</span><br><span class="line">    // 遍历子节点</span><br><span class="line">    for (int i = 0; i &lt; children.getLength(); i++) &#123;</span><br><span class="line">        XNode child = node.newXNode(children.item(i));</span><br><span class="line">        if (child.getNode().getNodeType() == Node.CDATA_SECTION_NODE || child.getNode().getNodeType() == Node.TEXT_NODE) &#123;</span><br><span class="line">            // 获取文本内容</span><br><span class="line">            String data = child.getStringBody(&quot;&quot;);</span><br><span class="line">            TextSqlNode textSqlNode = new TextSqlNode(data);</span><br><span class="line">            // 若文本中包含 $&#123;&#125; 占位符，也被认为是动态节点</span><br><span class="line">            if (textSqlNode.isDynamic()) &#123;</span><br><span class="line">                contents.add(textSqlNode);</span><br><span class="line">                // 设置 isDynamic 为 true</span><br><span class="line">                isDynamic = true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 创建 StaticTextSqlNode</span><br><span class="line">                contents.add(new StaticTextSqlNode(data));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        // child 节点是 ELEMENT_NODE 类型，比如 &lt;if&gt;、&lt;where&gt; 等</span><br><span class="line">        &#125; else if (child.getNode().getNodeType() == Node.ELEMENT_NODE) &#123;</span><br><span class="line">            // 获取节点名称，比如 if、where、trim 等</span><br><span class="line">            String nodeName = child.getNode().getNodeName();</span><br><span class="line">            // 根据节点名称获取 NodeHandler</span><br><span class="line">            NodeHandler handler = nodeHandlerMap.get(nodeName);</span><br><span class="line">            /*</span><br><span class="line">             * 如果 handler 为空，表明当前节点对与 MyBatis 来说，是未知节点。</span><br><span class="line">             * MyBatis 无法处理这种节点，故抛出异常</span><br><span class="line">             */ </span><br><span class="line">            if (handler == null) &#123;</span><br><span class="line">                throw new BuilderException(&quot;Unknown element &lt;&quot; + nodeName + &quot;&gt; in SQL statement.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            // 处理 child 节点，生成相应的 SqlNode</span><br><span class="line">            handler.handleNode(child, contents);</span><br><span class="line"></span><br><span class="line">            // 设置 isDynamic 为 true</span><br><span class="line">            isDynamic = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new MixedSqlNode(contents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面方法的逻辑我前面已经说过，主要是用来判断节点是否包含一些动态标记，比如 ${} 占位符以及动态 SQL 节点等。这里，不管是动态 SQL 节点还是静态 SQL 节点，我们都可以把它们看成是 SQL 片段，一个 SQL 语句由多个 SQL 片段组成。在解析过程中，这些 SQL 片段被存储在 contents 集合中。最后，该集合会被传给 MixedSqlNode 构造方法，用于创建 MixedSqlNode 实例。从 MixedSqlNode 类名上可知，它会存储多种类型的 SqlNode。除了上面代码中已出现的几种 SqlNode 实现类，还有一些 SqlNode 实现类未出现在上面的代码中。但它们也参与了 SQL 语句节点的解析过程，这里我们来看一下这些幕后的 SqlNode 类。</p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15328288854753.jpg" alt="img"></p>
<p>上面的 SqlNode 实现类用于处理不同的动态 SQL 逻辑，这些 SqlNode 是如何生成的呢？答案是由各种 NodeHandler 生成。我们再回到上面的代码中，可以看到这样一句代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handler.handleNode(child, contents);</span><br></pre></td></tr></table></figure>

<p>该代码用于处理动态 SQL 节点，并生成相应的 SqlNode。下面来简单分析一下 WhereHandler 的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/** 定义在 XMLScriptBuilder 中 */</span><br><span class="line">private class WhereHandler implements NodeHandler &#123;</span><br><span class="line"></span><br><span class="line">    public WhereHandler() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleNode(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents) &#123;</span><br><span class="line">        // 调用 parseDynamicTags 解析 &lt;where&gt; 节点</span><br><span class="line">        MixedSqlNode mixedSqlNode = parseDynamicTags(nodeToHandle);</span><br><span class="line">        // 创建 WhereSqlNode</span><br><span class="line">        WhereSqlNode where = new WhereSqlNode(configuration, mixedSqlNode);</span><br><span class="line">        // 添加到 targetContents</span><br><span class="line">        targetContents.add(where);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，handleNode 方法内部会再次调用 parseDynamicTags 解析 <where> 节点中的内容，这样又会生成一个 MixedSqlNode 对象。最终，整个 SQL 语句节点会生成一个具有树状结构的 MixedSqlNode。如下图：</where></p>
<p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15328318597125.jpg" alt="img"></p>
<p>到此，SQL 语句的解析过程就分析完了。现在，我们已经将 XML 配置解析了 SqlSource，但这还没有结束。SqlSource 中只能记录 SQL 语句信息，除此之外，这里还有一些额外的信息需要记录。因此，我们需要一个类能够同时存储 SqlSource 和其他的信息。这个类就是 MappedStatement。下面我们来看一下它的构建过程。</p>
<h5 id="2-1-5-4-构建-MappedStatement"><a href="#2-1-5-4-构建-MappedStatement" class="headerlink" title="2.1.5.4 构建 MappedStatement"></a>2.1.5.4 构建 MappedStatement</h5><p>SQL 语句节点可以定义很多属性，这些属性和属性值最终存储在 MappedStatement 中。下面我们看一下 MappedStatement 的构建过程是怎样的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public MappedStatement addMappedStatement(</span><br><span class="line">    String id, SqlSource sqlSource, StatementType statementType, </span><br><span class="line">    SqlCommandType sqlCommandType,Integer fetchSize, Integer timeout, </span><br><span class="line">    String parameterMap, Class&lt;?&gt; parameterType,String resultMap, </span><br><span class="line">    Class&lt;?&gt; resultType, ResultSetType resultSetType, boolean flushCache,</span><br><span class="line">    boolean useCache, boolean resultOrdered, KeyGenerator keyGenerator, </span><br><span class="line">    String keyProperty,String keyColumn, String databaseId, </span><br><span class="line">    LanguageDriver lang, String resultSets) &#123;</span><br><span class="line"></span><br><span class="line">    if (unresolvedCacheRef) &#123;</span><br><span class="line">        throw new IncompleteElementException(&quot;Cache-ref not yet resolved&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    id = applyCurrentNamespace(id, false);</span><br><span class="line">    boolean isSelect = sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line"></span><br><span class="line">    // 创建建造器，设置各种属性</span><br><span class="line">    MappedStatement.Builder statementBuilder = new MappedStatement.Builder(configuration, id, sqlSource, sqlCommandType)</span><br><span class="line">        .resource(resource).fetchSize(fetchSize).timeout(timeout)</span><br><span class="line">        .statementType(statementType).keyGenerator(keyGenerator)</span><br><span class="line">        .keyProperty(keyProperty).keyColumn(keyColumn).databaseId(databaseId)</span><br><span class="line">        .lang(lang).resultOrdered(resultOrdered).resultSets(resultSets)</span><br><span class="line">        .resultMaps(getStatementResultMaps(resultMap, resultType, id))</span><br><span class="line">        .flushCacheRequired(valueOrDefault(flushCache, !isSelect))</span><br><span class="line">        .resultSetType(resultSetType).useCache(valueOrDefault(useCache, isSelect))</span><br><span class="line">        .cache(currentCache);</span><br><span class="line"></span><br><span class="line">    // 获取或创建 ParameterMap</span><br><span class="line">    ParameterMap statementParameterMap = getStatementParameterMap(parameterMap, parameterType, id);</span><br><span class="line">    if (statementParameterMap != null) &#123;</span><br><span class="line">        statementBuilder.parameterMap(statementParameterMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 构建 MappedStatement，没有什么复杂逻辑，不跟下去了</span><br><span class="line">    MappedStatement statement = statementBuilder.build();</span><br><span class="line">    // 添加 MappedStatement 到 configuration 的 mappedStatements 集合中</span><br><span class="line">    configuration.addMappedStatement(statement);</span><br><span class="line">    return statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是 MappedStatement，没什么复杂的地方，就不多说了。</p>
<h4 id="2-1-6-小节"><a href="#2-1-6-小节" class="headerlink" title="2.1.6 小节"></a>2.1.6 小节</h4><p>本章分析了映射文件的解析过程，总的来说，本章的内容还是比较复杂的，逻辑太多。不过如果大家自己也能把映射文件的解析过程认真分析一遍，会对 MyBatis 有更深入的理解。分析过程很累，但是在此过程中会收获了很多东西，还是很开心的。好了，本章内容先到这里。后面还有一些代码需要分析，我们继续往后看。</p>
<h3 id="2-2-Mapper-接口绑定过程分析"><a href="#2-2-Mapper-接口绑定过程分析" class="headerlink" title="2.2 Mapper 接口绑定过程分析"></a>2.2 Mapper 接口绑定过程分析</h3><p>映射文件解析完成后，并不意味着整个解析过程就结束了。此时还需要通过命名空间绑定 mapper 接口，这样才能将映射文件中的 SQL 语句和 mapper 接口中的方法绑定在一起，后续即可通过调用 mapper 接口方法执行与之对应的 SQL 语句。下面我们来分析一下 mapper 接口的绑定过程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// -☆- XMLMapperBuilder</span><br><span class="line">private void bindMapperForNamespace() &#123;</span><br><span class="line">    // 获取映射文件的命名空间</span><br><span class="line">    String namespace = builderAssistant.getCurrentNamespace();</span><br><span class="line">    if (namespace != null) &#123;</span><br><span class="line">        Class&lt;?&gt; boundType = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 根据命名空间解析 mapper 类型</span><br><span class="line">            boundType = Resources.classForName(namespace);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        if (boundType != null) &#123;</span><br><span class="line">            // 检测当前 mapper 类是否被绑定过</span><br><span class="line">            if (!configuration.hasMapper(boundType)) &#123;</span><br><span class="line">                configuration.addLoadedResource(&quot;namespace:&quot; + namespace);</span><br><span class="line">                // 绑定 mapper 类</span><br><span class="line">                configuration.addMapper(boundType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// -☆- Configuration</span><br><span class="line">public &lt;T&gt; void addMapper(Class&lt;T&gt; type) &#123;</span><br><span class="line">    // 通过 MapperRegistry 绑定 mapper 类</span><br><span class="line">    mapperRegistry.addMapper(type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// -☆- MapperRegistry</span><br><span class="line">public &lt;T&gt; void addMapper(Class&lt;T&gt; type) &#123;</span><br><span class="line">    if (type.isInterface()) &#123;</span><br><span class="line">        if (hasMapper(type)) &#123;</span><br><span class="line">            throw new BindingException(&quot;Type &quot; + type + &quot; is already known to the MapperRegistry.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        boolean loadCompleted = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            /*</span><br><span class="line">             * 将 type 和 MapperProxyFactory 进行绑定，</span><br><span class="line">             * MapperProxyFactory 可为 mapper 接口生成代理类</span><br><span class="line">             */</span><br><span class="line">            knownMappers.put(type, new MapperProxyFactory&lt;T&gt;(type));</span><br><span class="line">            </span><br><span class="line">            // 创建注解解析器。在 MyBatis 中，有 XML 和 注解两种配置方式可选</span><br><span class="line">            MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);</span><br><span class="line">            // 解析注解中的信息</span><br><span class="line">            parser.parse();</span><br><span class="line">            loadCompleted = true;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (!loadCompleted) &#123;</span><br><span class="line">                knownMappers.remove(type);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是 Mapper 接口的绑定过程。这里简单一下：</p>
<ol>
<li>获取命名空间，并根据命名空间解析 mapper 类型</li>
<li>将 type 和 MapperProxyFactory 实例存入 knownMappers 中</li>
<li>解析注解中的信息</li>
</ol>
<p>以上步骤中，第3步的逻辑较多。如果大家看懂了映射文件的解析过程，那么注解的解析过程也就不难理解了，这里就不深入分析了。好了，Mapper 接口的绑定过程就先分析到这。</p>
<h3 id="2-3-处理未完成解析的节点"><a href="#2-3-处理未完成解析的节点" class="headerlink" title="2.3 处理未完成解析的节点"></a>2.3 处理未完成解析的节点</h3><p>在解析某些节点的过程中，如果这些节点引用了其他一些未被解析的配置，会导致当前节点解析工作无法进行下去。对于这种情况，MyBatis 的做法是抛出 IncompleteElementException 异常。外部逻辑会捕捉这个异常，并将节点对应的解析器放入 incomplet* 集合中。这个我在分析映射文件解析的过程中进行过相应注释，不知道大家有没有注意到。没注意到也没关系，待会我会举例说明。下面我们来看一下 MyBatis 是如何处理未完成解析的节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// -☆- XMLMapperBuilder</span><br><span class="line">public void parse() &#123;</span><br><span class="line">    // 省略部分代码</span><br><span class="line">    </span><br><span class="line">    // 解析 mapper 节点</span><br><span class="line">    configurationElement(parser.evalNode(&quot;/mapper&quot;));</span><br><span class="line"></span><br><span class="line">    // 处理未完成解析的节点</span><br><span class="line">    parsePendingResultMaps();</span><br><span class="line">    parsePendingCacheRefs();</span><br><span class="line">    parsePendingStatements();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，parse 方法是映射文件的解析入口。在本章的开始，我贴过这个源码。从上面的源码中可以知道有三种节点在解析过程中可能会出现不能完成解析的情况。由于上面三个以 parsePending 开头的方法逻辑一致，所以下面我只会分析其中一个方法的源码。简单起见，这里选择分析 parsePendingCacheRefs 的源码。下面看一下如何配置映射文件会导致 <cache-ref> 节点无法完成解析。</cache-ref></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 映射文件1 --&gt;</span><br><span class="line">&lt;mapper namespace=&quot;xyz.coolblog.dao.Mapper1&quot;&gt;</span><br><span class="line">    &lt;!-- 引用映射文件2中配置的缓存 --&gt;</span><br><span class="line">    &lt;cache-ref namespace=&quot;xyz.coolblog.dao.Mapper2&quot;/&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 映射文件2 --&gt;</span><br><span class="line">&lt;mapper namespace=&quot;xyz.coolblog.dao.Mapper2&quot;&gt;</span><br><span class="line">    &lt;cache/&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>如上，假设 MyBatis 先解析映射文件1，然后再解析映射文件2。按照这样的解析顺序，映射文件1中的 <cache-ref> 节点就无法完成解析，因为它所引用的缓存还未被解析。当映射文件2解析完成后，MyBatis 会调用 parsePendingCacheRefs 方法处理在此之前未完成解析的 <cache-ref> 节点。具体的逻辑如下：</cache-ref></cache-ref></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void parsePendingCacheRefs() &#123;</span><br><span class="line">    // 获取 CacheRefResolver 列表</span><br><span class="line">    Collection&lt;CacheRefResolver&gt; incompleteCacheRefs = configuration.getIncompleteCacheRefs();</span><br><span class="line">    synchronized (incompleteCacheRefs) &#123;</span><br><span class="line">        Iterator&lt;CacheRefResolver&gt; iter = incompleteCacheRefs.iterator();</span><br><span class="line">        // 通过迭代器遍历列表</span><br><span class="line">        while (iter.hasNext()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                /*</span><br><span class="line">                 * 尝试解析 &lt;cache-ref&gt; 节点，若解析失败，则抛出 IncompleteElementException，</span><br><span class="line">                 * 此时下面的删除操作不会被执行</span><br><span class="line">                 */</span><br><span class="line">                iter.next().resolveCacheRef();</span><br><span class="line">                /*</span><br><span class="line">                 * 移除 CacheRefResolver 对象。如果代码能执行到此处，</span><br><span class="line">                 * 表明已成功解析了 &lt;cache-ref&gt; 节点</span><br><span class="line">                 */</span><br><span class="line">                iter.remove();</span><br><span class="line">            &#125; catch (IncompleteElementException e) &#123;</span><br><span class="line">                /*</span><br><span class="line">                 * 如果再次发生 IncompleteElementException 异常，表明当前映射文件中并没有 </span><br><span class="line">                 * &lt;cache-ref&gt; 所引用的缓存。有可能所引用的缓存在后面的映射文件中，所以这里</span><br><span class="line">                 * 不能将解析失败的 CacheRefResolver 从集合中删除</span><br><span class="line">                 */</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码不是很长，我也做了比较多的注释，应该不难理解。好了，关于未完成解析节点的解析过程就分析到这。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>本篇文章对映射文件的解析过程进行了较为详细的分析，全文篇幅比较大，写的也比较辛苦。本篇文章耗时7天完成，在这7天中，基本上一有空闲时间，就会用来写作。虽然很累，但是收获也很多。我目前正在努力的构建自己的知识体系，我觉得对于常用的技术，还是应该花一些时间和精力，去弄懂它的原理。这样以后才能走的更远，才能成为你想成为的样子。</p>
<p>好了，其他的就不多说了，本篇文章就到这吧。谢谢大家的阅读。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/27087564/">《MyBatis 技术内幕》- 徐郡明</a></li>
<li><a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/index.html">MyBatis 官方文档</a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer"><div class="post-widgets">
      <div id="needsharebutton-postbottom">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    </div>
          <div class="reward-container">
  <div>Buy me a coffee</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/alipay.png" alt="磐石 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
        <a target="_blank" class="social-link" href="/images/qrcode_for_gh_08ce048a33bc_258.jpg">
          <span class="icon">
            <i class="fab fa-weixin"></i>
          </span>

          <span class="label">微信公众号</span>
        </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/Mybatis/" rel="tag"># Mybatis</a>
              <a href="/tags/ORM/" rel="tag"># ORM</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/10/25/MyBatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/" rel="prev" title="MyBatis源码分析-配置文件解析过程">
                  <i class="fa fa-chevron-left"></i> MyBatis源码分析-配置文件解析过程
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/10/25/MyBatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E5%AF%BC%E8%AF%BB/" rel="next" title="MyBatis源码分析系列文章导读">
                  MyBatis源码分析系列文章导读 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC81NzQ3NS8zMzk0MA=="></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">磐石</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">1.1m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">16:13</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.2.8/pdfobject.min.js","integrity":"sha256-tu9j5pBilBQrWSDePOOajCUdz6hWsid/lBNzK4KgEPM="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>



  <script src="/js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script>
  <script>
      pbOptions = {};
        pbOptions.iconStyle = "box";
        pbOptions.boxForm = "horizontal";
        pbOptions.position = "bottomCenter";
        pbOptions.networks = "Wechat,QQZone,Weibo,Douban,Twitter,Facebook";
      new needShareButton('#needsharebutton-postbottom', pbOptions);
  </script><script src="/js/third-party/comments/livere.js"></script>

</body>
</html>
